
//=================================================================
// consqlole.cs
//=================================================================
// PowerSDR is a C# implementation of a Software Defined Radio. 
// Copyright (C) 2003-2013  FlexRadio Systems.  
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
//
// You may contact us via email at: gpl@flexradio.com.
// Paper mail may be sent to: 
//    FlexRadio Systems
//    4616 W. Howard Lane  Suite 1-150
//    Austin, TX 78728
//    USA
//=================================================================

// ke9ns things to remember:
//PA has 6 LPF for transmit that switch at the following Frequencies:
//K1K2 160m :0-2.099, K13K14 80M:2.1-4.099, K5K6 60-40M 4.1-7.399, K9K10 30-20m7.4- 14.449, K11K12 17-15M 14.450-21.549,K3K4 12-10m 21.550-29.799, K7K8 6m 29.8- ? mhz
// 160m LPF = 4uH/220pf (1200pf) 3 pole filter design
// ke9ns 630m LPF (external) 16uH (5600pf) 3 pole


//  0 through 41 and 13 values per key
// ORIGINAL KEY: FIRST=-1,
// ORIGINAL KEYS: GEN=0,B160M=1,B80M,B60M,B40M,B30M,B20M,B17M,B15M,B12M,B10M,B6M,B2M,WWV=13,VHF0,VHF1,VHF2=16,VHF3,VHF4,VHF5,VHF6,VHF7,VHF8,VHF9,VHF10,VHF11,VHF12,VHF13=27,
// KE9NS keys added: BLMF=28,B120M,B90M,B61M,B49M,B41M,B31M,B25M,B22M,B19M,B16M,B14M,B13M,B11M=41
// ORIGINAL key: LAST=42

//< State >
//    < Key > power_table[41] </ Key >  with 13 values each 1=160m , 8= 15m
//    < Value > 0.0168 | 0.0222 | 0.0326 | 0.0437 | 0.0579 | 0.0700 | 0.0810 | 0.0925 | 0.1080 | 0.1365 | 0.1764 | 0.2226 | 0.2826 </ Value >
//  </ State >                     represent int[] powers = { 1, 2, 5, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100 };
// <Key> rx1_level_table[41] </Key> 3 values
// <Key> rx2_level_table[41] </Key> 3  values
// <Key> pa_bridge_table[41] </Key> 6 values for TX LPF   able = { 1.0, 2.0, 5.0, 10.0, 20.0, 90.0 };
// <Key> swr_table[41 </Key> 1 value
// <Key> atu_swr_table[41] </Key> 1 value
// <Key> SLowScan[41] </Key>
// <Key> SHighScan[41] </Key>

// < Key > pa_bias_table[3] </ Key > 4keys with 8 values each
//    < Value > 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 </ Value >

// <Key>rx1_preamp_offset[3]</Key> 4 keys


// FWCEEPROM.RX2OK
// if (FWCEEPROM.VUOK)

// Invoke(new MethodInvoker(radRX2ModeCWU.Select)); // switch RX2 to CWU mode  

//  if ((Display.CurrentDisplayModeBottom != DisplayMode.OFF) && (rx2_enabled) && (e.Y > H7)) to check if your clicked inside RX2 pan area

// skin is in

// this.txtMultiText.SetStyle(ControlStyles.SupportsTransparentBackColor, true);
// CONDITIONALS   NO_WIDETX;NO_MCL_PM;NO_KE9NS;NO_DJ
// btnhidden.focus  for items that steal focus away from the display.

// AutoClosingMessageBox.Show("Database Updated\nPowerSDR now Closed.", "PowerSDR Closed.", 2000);   this allows for a messagebox that automatically closes after a specified amount of 
// Messagebox(new Form { TopMost = true },"message");
// g.TextRenderingHint = TextRenderingHint.ClearTypeGridFit;
// g.CompositingMode = CompositingMode.SourceOver;
// g.CompositingQuality = CompositingQuality.HighQuality;
// g.InterpolationMode = InterpolationMode.HighQualityBicubic;
// g.SmoothingMode = SmoothingMode.HighQuality;
// g.PixelOffsetMode = PixelOffsetMode.HighQuality;

// System.Globalization.CultureInfo.CurrentCulture.NumberFormat.NumberDecimalSeparator;
//  t.CurrentCulture = System.Globalization.CultureInfo.CreateSpecificCulture("en-US");
//  t.CurrentUICulture = System.Globalization.CultureInfo.CreateSpecificCulture("en-US");
//  CultureInfo.InvariantCulture
//
// .net 4.6 and above require this (below) in the app.config file to force 4.5.2 behavior for currentculture
//< configuration >
//    < runtime >
 //       < AppContextSwitchOverrides value = "Switch.System.Globalization.NoAsyncCurrentCulture=true" />
//    </ runtime >
//</ configuration >


// example of how to disable and EVENT
//setupForm.gridBoxTS.CheckedChanged -= setupForm.gridBoxTS_CheckedChanged;  // ke9ns turn off checkchanged temporarily   
// 
// setupForm.gridBoxTS.CheckedChanged += setupForm.gridBoxTS_CheckedChanged;

//  txtVFOAFreq_LostFocus(this, EventArgs.Empty);    (ke9ns this is how to generate an event programatically)
//
// ke9ns console_closing(), then Dispose(), then ExitConsole(), then back to Displose() to finish
//
// console.Console_Resize(this, e);
// Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData)  ==   %userprofile%\AppData\Roaming
//
// string master_path = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) + "\\FlexRadio Systems\\";  // %userprofile%\AppData\Roaming\FlexRadio Systems\
//
// File.Exists(app_data_path + "wisdom"))  // look for %userprofile%\AppData\Roaming\FlexRadio Systems\PowerSDR v2.8.0\wisdom
// File.Exists(master_path + "production")    production = true;   // this allows PA calibration
// File.Exists(master_path + "test_equip")    test_equip = true;   // this allows ?
// File.Exists(master_path + "master.xml");                        // this is list of your PowerSDR radios
//
// path = Environment.GetFolderPath(Environment.SpecialFolder.CommonApplicationData) + "\\FlexRadio Systems\\PowerSDR";  // ke9ns this is the ProgramData folder
// Application.StartupPath  = \Program Files (x86)\FlexRadio Systems\PowerSDR v2.8.0
//   string pm_file_path = Path.Combine(common_data_path, "powermaster.txt");  // programData\flexradio systems\powersdr folder

//  current_region = FWCEEPROM.Region; or //  current_region = HIDEEPROM.Region;
//
//  extended = FWC.GetStatus(); or  extended = USBHID.GetStatus(); or (File.Exists("extended.edf")		// Check for extended capabilities file
//
//  a.Add("Version/"+this.Text);		    // save the current title bar string
//  a.Add("VersionNumber/" + ver_num);      // PowerSDR version number in a.b.c format
//  a.Add("RadioType/" + CurrentModel);     // radio model string (ex. FLEX1500)
//  a.Add("BandTextID/" + current_region);  // TURF Region
//  a.Add("Opened/" + extended);            // has the radio been opened?

/*
         if (!this.InvokeRequired)
         {
            txtVFOAFreq.Text = value.ToString("f6" );
            txtVFOAFreq_LostFocus(this, EventArgs.Empty);
         }
         else
         {
            VFOUpdateDel del = new VFOUpdateDel(VFOAUpdate);
            Invoke(del, new object[] { value });
         }

*/
/*
Class Console
{
   import gdi32.dll here

   public Console
   {
       InitializeComponents();
       InitConsole();

   } // public console

   Dispose()
   {
   }
   InitializeComponents
   {
      select property info for console items here
   }
   Main
   {
      embed fonts here
   }
   InitConsole
   {

   } 
   Flexcontrolscan
   {
   }
   Flexcontrolscan_threadfunction
   {
   }
   SyncDsp
   {
   }
   Exitconsole
   {
   }
   SaveState
   {
   }
   Getstate
   {
   } 






} // class console



*/

//
// SoftRock Modifications Copyright (C) 2005, 2006, 2007 Bill Tracey (kd5tfd)
//

//#define INTERLEAVED
//#define SPLIT_INTERLEAVED
//#define SDRX
#define FLEX1500_BUFFER_MUTE                             // Enables muting audio as buffers switch in RX/TX transitions
//#define WRITE_FFT_TEST

using System;

using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Drawing.Imaging;
using System.Drawing.Text;
using System.Globalization;
using System.IO;
using System.IO.Ports;
using System.Net;
using System.Net.Sockets; // ke9ns add
using System.Reflection;
using System.Runtime.InteropServices;
using System.Management;
using System.Threading;
using System.Text;
using System.Xml.Linq;

//using System.Text.Json; // ke9ns add
//using System.Text.Json.Serialization; // ke9ns add

//System.Windows.Media.Effects; // ke9ns add

using System.Windows.Forms;

//using System.Threading.Tasks; // ke9ns add net 4.5

using System.Speech.Synthesis; // ke9ns add
//using System.Object;
//using System.Windows.Threading.DispatcherObject;
using FlexCW; // .250
using System.Linq; // ke9ns add
using NAudio.Wave; // ke9ns add
using NAudio.Lame; // ke9ns add

//using MahApps.Metro.Controls; // ke9ns add


#if (!NO_TNF)
using Flex.TNF;
#endif

using Flex.Control; //.250

//using CefSharp;            // ke9ns add to allow embedded chrome browser (for help videos)
//using CefSharp.WinForms;

//using Syncfusion.Windows.Forms.Tools; // ke9ns add
//using Syncfusion.Windows.Forms.HTMLUI; // ke9ns add


namespace PowerSDR
{

    #region Enums

    public enum FWCATUMode
    {
        FIRST = -1,
        Bypass,
        SemiAutomatic,
        Automatic,
        LAST,
    }

    public enum AntMode
    {
        Simple = 0,
        Expert,
    }

    public enum Window
    {
        FIRST = -1,
        RECTANGULAR,
        HANNING,
        WELCH,
        PARZEN,
        BARTLETT,
        HAMMING,
        BLACKMAN2,
        BLACKMAN3,
        BLACKMAN4,
        EXPONENTIAL,
        RIEMANN,
        BLKHARRIS,
        LAST,
    }

    public enum FWCAnt
    {
        NC = 0,
        ANT1,
        ANT2,
        ANT3,
        RX1IN,
        RX2IN,
        RX1TAP,
        SIG_GEN,
        VHF,
        UHF,  // 9      
    }

    public enum HIDAnt
    {
        PA = 0,
        XVTX_COM,
        XVRX,
        BITE,
    }

    public enum RenderType
    {
        HARDWARE = 0,
        SOFTWARE,
        NONE,
    }

    public enum MultiMeterDisplayMode // means 0=first item, 1=second item, 3= thrid item
    {
        Original = 0,    // was a bargraph now ke9ns added tr7
        Edge,            // analog meter with straight needle
        Analog,          // ke9ns added
        Bar,             // ke9ns add back bar graph

    }

    public enum FilterWidthMode
    {
        Linear = 0,
        Log,
        Log10,
    }

    public enum DisplayEngine
    {
        GDI_PLUS = 0,
        DIRECT_X,
    }

    public enum Model
    {
        SDR1000 = 0,
        SOFTROCK40,
        DEMO,
        FLEX5000,
        SDRX,
        FLEX3000,
        FLEX1500,
    }

    public enum BPFBand
    {
        NONE = -1,
        B160,
        B60,
        B20,
        B40,
        B10,
        B6,
    }

    public enum RFELPFBand
    {
        NONE = -1,
        AUX,
        B6,
        B60,
        B20,
        B30,
        B40,
        B1210,
        B80,
        B1715,
        B160,
    }

    public enum PAFBand
    {
        NONE = 0,
        B1210,
        B1715,
        B3020,
        B6040,
        B80,
        B160,
    }

    public enum XVTRTRMode
    {
        NEGATIVE = 0,   // DEMI144-28FRS
        POSITIVE,       // 25W DEMI
        NONE,           // For Elecraft or similar XVTR
    }

    public enum SoundCard
    {
        FIRST = -1,
        UNSUPPORTED_CARD,
        DELTA_44,
        FIREBOX,
        EDIROL_FA_66,
        AUDIGY,
        AUDIGY_2,
        AUDIGY_2_ZS,
        EXTIGY,
        MP3_PLUS,
        SANTA_CRUZ,
        LAST,
    }

    public enum DisplayMode  // ke9ns  rearrange order of display modes
    {
        FIRST = -1,
        PANADAPTER,
        PANAFALL,
        PANAFALL8020,
        WATERFALL,
        PANASCOPE,
        SPECTRUM,
        SCOPE,
        PHASE,
        PHASE2,
        HISTOGRAM,
        OFF,
        CONTINUUM,
        LAST,
    }
    /*
    FIRST = -1,
		SPECTRUM,
		PANADAPTER,
		SCOPE,
		PHASE,
		PHASE2,
		WATERFALL,
		HISTOGRAM,
		PANAFALL,
		PANASCOPE,
		OFF,
		LAST,
      */
    public enum AGCMode
    {
        FIRST = -1,
        FIXD,
        LONG,
        SLOW,
        MED,
        FAST,
        CUSTOM,
        LAST,
    }

    public enum MeterRXMode
    {
        FIRST = -1,
        SIGNAL_STRENGTH,
        SIGNAL_AVERAGE,
        SIGNAL_PEAK,        // ke9ns ADD
        ADC_L,
        ADC_R,
        ADC2_L,
        ADC2_R,
        OFF,
        LAST,
    }

    public enum MeterTXMode
    {
        FIRST = -1,
        FORWARD_POWER,
        REVERSE_POWER,
        MIC,
        EQ,
        LEVELER,
        LVL_G,
        COMP,
        CPDR,
        ALC,
        ALC_G,
        SWR,
        Combo, // ke9ns add
        OFF,
        LAST,
    }

    public enum KeyerLine
    {
        None = 0,
        DTR,
        RTS,
    }

    public enum DateTimeMode
    {
        OFF = 0,
        LOCAL,
        UTC,
        LAST,
    }

    //================================================================================
    // w4tme modify Regions to match SmartSDR March 2017
    public enum FRSRegion
    {
        FIRST = -1,
        US = 0,           // USA  USA, CA, ROW 
        UK = 1,           // EU01 UK, Slovakia, France, Malta  
        Europe = 2,       // EU00 Germany, European Union, IARU1   (5351.5 - 5366.5 kHz)
        UK_Plus = 3,      // EU02 UK+ (adds 60m band)
        Italy = 4,        // EU10 
        Norway = 5,       // EU03 Norway, Czech Rep.
        Denmark = 6,      // EU03  Denmark, Czech Rep.
        Latvia = 7,       // EU08 
        Slovakia = 8,     // EU01 UK, Slovakia, France, Malta (UK,SK,FR,MT)
        Bulgaria = 9,     // EU07 
        Greece = 10,      // EU09 
        Hungary = 11,     // EU05 
        Belgium = 12,     // EU04
        France = 13,      // EU01 UK, Slovakia, France, Malta
        Russia = 14,      // RUSS  
        Sweden = 15,      // EU06 
        IARU3 = 16,       // IARU3 China, Australia, New Zealand
        Japan = 17,       // JPN  
        Italy_Plus = 18,  // EU11 Italy+ (40m band)
        ES_CH_FIN = 19,   // EU12 Spain, Switzerland, Finland (ES,CH,FIN)   5351.5 - 5366.5 kHz
        Netherlands = 20, // EU13 
        EU_Travel = 21,   // EU14 
        Luxembourg = 22,  // EU15
        IARU2 = 23,       // IARU2 (Central & South America)	 (NOTE: 4/17/18 Canada to get IARU1 60m band plan in addition to the 4 existing channels) 5351.5 - 5366.5 kHz
        Australia = 24,   // AUS
        China = 25,       // China (similar to IARU3 except for 60m)
        LAST,
    }


    /*  ke9ns  ORIGINAL 2.7.2 FRSRegion list
        US = 0,           // IARU 2
        Spain_UK = 1,     // now just UK
        Europe = 2,       // IARU 1  
        UK_Plus = 3,      //  
        Italy = 4,        // 
        Norway = 5,       // 
        Denmark = 6,      // 
        Latvia = 7,       // 
        Slovakia = 8,     // 
        Bulgaria = 9,     // 
        Greece = 10,      // 
        Hungary = 11,     // 
        Netherlands = 12, //  now belgium
        France = 13,      // 
        Russia = 14,      // 
        Sweden = 15,      // 
        Region_3 = 16,    // IARU 3
        Japan = 17,       // 
        Italy_Plus = 18,  // 
                         

     */

    public enum PreampMode
    {
        FIRST = -1,
        OFF,
        LOW,
        MED,
        HIGH,
        LAST,
    }

    public enum FLEX1500PreampMode
    {
        FIRST = -1,
        MINUS_10,
        ZERO,
        PLUS_10,
        PLUS_20,
        PLUS_30,
        LAST,
    }

    public enum StatusPin
    {
        PIN_12 = 0x08,      //S3
        Dash = 0x10,        //S4
        Dot = 0x20,     //S5
        PA_DATA = 0x40,     //S6
        PIN_11 = 0x80,      //S7\
    }

    public enum ATUTuneMode
    {
        FIRST = -1,
        BYPASS,
        MEMORY,
        FULL,
        LAST,
    }

    public enum DSPISB // ke9ns add for LSB-AM, USB-AM
    {
        FIRST = -1,
        AML,
        AMU,
        LAST,

    } // DSPISB


    public enum DSPMode
    {
        FIRST = -1,
        LSB, // 0
        USB, // 1
        DSB,
        CWL,
        CWU,
        FM,
        AM,
        DIGU,
        SPEC,
        DIGL,
        SAM, // = 10
        DRM,

        LAST,
    } // DSPMODE

    public enum Band
    {
        FIRST = -1,
        GEN, // 0
        B160M, // 1
        B80M,
        B60M,
        B40M,
        B30M,
        B20M,
        B17M,
        B15M,
        B12M,
        B10M,
        B6M,
        B2M,
        WWV, // 13

        VHF0,
        VHF1,

        VHF2, //16
        VHF3,
        VHF4,
        VHF5,
        VHF6,
        VHF7,
        VHF8,
        VHF9,
        VHF10,
        VHF11,
        VHF12,
        VHF13, // 27

        BLMF, // 28 ke9ns move down below vhf
        B120M,
        B90M,
        B61M,
        B49M,
        B41M,
        B31M,
        B25M,
        B22M,
        B19M,
        B16M,
        B14M,
        B13M,
        B11M, // 41

        LAST,
    }

    public enum Filter
    {
        FIRST = -1,
        F1,
        F2,
        F3,
        F4,
        F5,
        F6,
        F7,
        F8,
        F9,
        F10,
        VAR1,
        VAR2,
        NONE,
        LAST,
    }

    public enum PTTMode
    {
        FIRST = -1,
        NONE,
        MANUAL,
        MIC,
        CW,
        X2,
        CAT,
        VOX,
        LAST,
    }

    public enum DisplayLabelAlignment
    {
        FIRST = -1,
        LEFT,
        CENTER,
        RIGHT,
        AUTO,
        Sunit, // ke9ns add
        OFF,
        LAST,
    }

    public enum ClickTuneMode
    {
        Off = 0,
        VFOA,
        VFOB,
    }

    public enum FMTXMode
    {
        // Order is chosen carefully here for memory form -- take care before rearranging
        High = 0,   // +
        Simplex,    // S
        Low,        // -     
    }

    public enum FlexControlMode
    {
        Basic = 0,
        Advanced,
    }

    public enum FlexControlKnobFunction
    {
        TuneVFOA,
        TuneVFOB,
        TuneVFOASub,
        TuneRIT,
        TuneXIT,
        TuneAF,
        TuneAGCT,
        None,
    }

    #endregion

    // sealed unsafe public partial class Console : System.Windows.Forms.Form //.240 was this


    sealed unsafe public partial class Console : System.Windows.Forms.Form
    {

        //  public static event Microsoft.Win32.SessionEndingEventHandler SessionEnding; // ke9ns add


        //==================================================================================
        //==================================================================================
        // ke9ns add (copied from cwx precision multimedia msec timer)
        //       everything below

        #region Win32 Multimedia Timer Functions

        //  private int tel;            // time of one element in ms

        // Represents the method that is called by Windows when a timer event occurs.
        private delegate void TimeProc(int id, int msg, int user, int param1, int param2);

        // Specifies constants for multimedia timer event types.

        public enum TimerMode
        {
            OneShot,    // Timer event occurs once.w
            Periodic    // Timer event occurs periodically.
        };

        // Represents information about the timer's capabilities.
        [StructLayout(LayoutKind.Sequential)]
        public struct TimerCaps
        {
            public int periodMin;   // Minimum supported period in milliseconds.
            public int periodMax;   // Maximum supported period in milliseconds.
        }

        // ke9ns add wndProc
        [DllImport("user32.dll", SetLastError = true)]
        static extern bool ShutdownBlockReasonDestroy(IntPtr hWnd);

        [DllImport("user32.dll", SetLastError = true)]
        static extern bool ShutdownBlockReasonCreate(IntPtr hWnd, [MarshalAs(UnmanagedType.LPWStr)] string reason);

        [DllImport("kernel32.dll", SetLastError = true)]
        static extern bool SetProcessShutdownParameters(uint dwLevel, uint dwFlags);




        // Gets timer capabilities.
        [DllImport("winmm.dll")]
        private static extern int timeGetDevCaps(ref TimerCaps caps, int sizeOfTimerCaps);

        // Creates and starts the timer.
        [DllImport("winmm.dll")]
        private static extern int timeSetEvent(int delay, int resolution, TimeProc proc, int user, int mode);


        // Stops and destroys the timer.
        [DllImport("winmm.dll")]
        private static extern int timeKillEvent(int id);

        // Indicates that the operation was successful.
        private const int TIMERR_NOERROR = 0;

        // Timer identifier.
        private int timerID;

        private TimeProc timeProcPeriodic;   // ke9ns add to use windows based multimedia timer

        //   Stopwatch WATCH1 = new Stopwatch();
        //    Stopwatch WATCH2 = new Stopwatch();


        #endregion





        //============================================================================ ke9ns add
        //============================================================================ ke9ns add
        // ke9ns ADD font
        // import gdi32.dll because this allows you to embed fonts into PowerSDR
        //============================================================================ ke9ns add
        //============================================================================ ke9ns add
        [DllImport("gdi32.dll")]
        private static extern IntPtr AddFontMemResourceEx(IntPtr pbFont, uint cbFont,
               IntPtr pdv, [In] ref uint pcFonts); // this imports the addfont call

        private static FontFamily S1, S2, S3, S4;    // setup 3 font families
        private static Font ff, ff1, ff2, ff3, ff4, ff5, ff6, ff7, ff8, ff9, ff9a;  // 8 different font sizes and styles


        //============================================================================ ke9ns ad
        //============================================================================ ke9ns add
        // ke9nd ADD images
        // the purpose of this is to embed an image file into PowerSDR
        // make sure to put the jpg in powersdr.resources and set the properties of the jpg to "embed resource"
        //============================================================================ ke9ns add
        //============================================================================ ke9ns add
        private static System.Reflection.Assembly myAssembly = System.Reflection.Assembly.GetExecutingAssembly();
        // this code allows you to embed an image.

        public static Stream meter_image = myAssembly.GetManifestResourceStream("PowerSDR.Resources.met3.jpg"); // ke9ns add tr7 meter image
        public static Stream meter_image1 = myAssembly.GetManifestResourceStream("PowerSDR.Resources.meterback1.png"); // ke9ns add light color analog meter background
        public static Stream meter_image2 = myAssembly.GetManifestResourceStream("PowerSDR.Resources.meterback2.png");// ke9ns add dark color analog meter background

        //  public static Stream meter_image3 = myAssembly.GetManifestResourceStream("PowerSDR.Resources.Black_combo.png");// ke9ns add  meter 
        public static Stream meter_image4 = myAssembly.GetManifestResourceStream("PowerSDR.Resources.Black_TXonly.png");// ke9ns add  meter 

        public static Stream antpic = myAssembly.GetManifestResourceStream("PowerSDR.Resources.ant2.png");// ke9ns add clip art of antenna symbol
        public static Stream antpic3 = myAssembly.GetManifestResourceStream("PowerSDR.Resources.ant3.png");// ke9ns add clip art of antenna symbol

        public static Stream dialpic = myAssembly.GetManifestResourceStream("PowerSDR.Resources.disk3.png");// ke9ns add dial graphic
        public static Stream vfoApic = myAssembly.GetManifestResourceStream("PowerSDR.Resources.arrowA.png");// ke9ns add vfoA graphic
        public static Stream vfoBpic = myAssembly.GetManifestResourceStream("PowerSDR.Resources.arrowB.png");// ke9ns add vfoB graphic


        public static Stream Black_image = myAssembly.GetManifestResourceStream("PowerSDR.Resources.black2.png");// ke9ns add black needle analog meter
        public static Stream Red_image = myAssembly.GetManifestResourceStream("PowerSDR.Resources.red2.png");// ke9ns add red needle analog meter
        public static Stream Yellow_image = myAssembly.GetManifestResourceStream("PowerSDR.Resources.yell2.png");// ke9ns add yellow needle analog meter
        public static Stream White_image = myAssembly.GetManifestResourceStream("PowerSDR.Resources.white2.png");// ke9ns add yellow needle analog meter

        public static Stream Map_image2 = myAssembly.GetManifestResourceStream("PowerSDR.Resources.Wmap1.jpg");     // MAP with lat / long on it


        Image TR7 = new Bitmap(meter_image);         // pre-can the images 
        Image meterback1 = new Bitmap(meter_image1);
        Image meterback2 = new Bitmap(meter_image2);

        //   Image meterback3 = new Bitmap(meter_image3); // ke9ns combo meter
        Image meterback4 = new Bitmap(meter_image4);

        Image ant2 = new Bitmap(antpic); // image of antenna symbol
        Image ant3 = new Bitmap(antpic3); // image of antenna symbol

        Image dial = new Bitmap(dialpic); // image of vfo a
        Image dial1 = new Bitmap(dialpic); // image of vfo b
        Image vfoA = new Bitmap(vfoApic); // image of vfo a
        Image vfoB = new Bitmap(vfoBpic); // image of vfo b

        public Image Wmap1 = new Bitmap(Map_image2); // image of world map


        int yell = 1;
        int red = 3;
        int white = 0;
        int black = 2;

        Bitmap yell1 = new Bitmap(Yellow_image);   // pre-can the images into bitmaps so they can be rotated later
        Bitmap white1 = new Bitmap(White_image);
        Bitmap black1 = new Bitmap(Black_image);
        Bitmap red1 = new Bitmap(Red_image);

        //==================================================================================================

        // ======================================================
        // Variable Declarations 
        // ======================================================

        #region Variable Declarations


        // ======================================================
        // Form Declarations 
        // ======================================================

        public FlexControlBasicForm flexControlBasicForm;
        public FlexControlAdvancedForm flexControlAdvancedForm;
        public Http httpFile;                           // ke9ns add
        public HttpServer httpServer = null;           // rn3kk add


        //  public FlexControl FlexControl; //.250
        //   public FlexControlManager FlexControlManager; //.250


        public Setup setupForm;                        // ke9ns communications with setupform  (i.e. allow combometertype.text update from inside console.cs) 
        public SwlControl SwlForm;                         // ke9ns add band swl form

        public Skin skin1; // ke9ns add


        public IDBOX IDBOXForm;                          // ke9ns add ID Timer function function (idtimer)
        public TOTBOX TOTBOXForm;                          // ke9ns add Timeout Timer function function (tottimer)

        private CATParser parser;                       // ke9ns: add to allow serial port (but currently only used in setup for CATURL
        private CATCommands commands;                   // ke9ns: add


        public SpotControl SpotForm;                       // ke9ns add DX spotter function
        public SpotDecoder SpotDecoderForm;                // ke9ns add decoder function

        public ScanControl ScanForm;                       // ke9ns add freq Scanner function
        public StackControl StackForm;                     // ke9ns add band stack form

        public helpbox helpboxForm;                         // ke9ns add helpbox form
        public helpbox1 helpbox1Form;                         // ke9ns add helpbox1 form

        public CWX cwxForm;
        public UCBForm ucbForm;
        public XVTRForm xvtrForm;
        public VUForm vuForm;
        public EQForm eqForm;
        public FilterForm filterRX1Form;
        public FilterForm filterRX2Form;
        public FLEX5000LLHWForm flex5000LLHWForm;
        public FLEX5000DebugForm flex5000DebugForm;
        public FWCMixForm fwcMixForm;
        public FLEX3000MixerForm flex3000MixerForm;
        public FLEX1500MixerForm flex1500MixerForm;
        public FWCAntForm fwcAntForm;
        public FLEX5000RelayForm flex5000RelayForm;
        public FWCATUForm fwcAtuForm;
        public FLEX3000ATUForm flex3000ATUForm;
        public FWCTestForm fwcTestForm;
        public FLEX5000LPFForm flex5000LPFForm;
        public FWCCalForm fwcCalForm;
        public FLEX5000ProdTestForm flex5000ProdTestForm;
        public FLEX5000FinalTestForm flex5000FinalTestForm;
        public FLEX5000RX2CalForm flex5000RX2CalForm;
        public FLEX3000TestForm flex3000TestForm;
        public DSPTestForm dspTestForm;
        public PreSelForm preSelForm;
        public FLEX1500DebugForm flex1500DebugForm;
        public FLEX5000VUCalForm flex5000VUCalForm;
        public DiversityForm diversityForm;

        private AboutForm aboutForm;

        public HIDAntForm hidAntForm;

        public MemoryForm memoryForm;

        public WaveControl WaveForm;                       // ke9ns    communication with the waveform (i.e. allows audio to be played from console.cs)


        public PAQualify PAQualForm;
        public ProductionTest ProdTestForm;


        public HidDevice.PowerMate PowerMate;              // ke9ns add communicate with powermate HID

        HidDevice.PowerMate powerMate = new HidDevice.PowerMate();  // ke9ns add link back to PowerMate.cpp and PowerMate.h

        // ======================================================
        // thread Declarations 
        // ======================================================


        private Thread[] audio_process_thread;              // threads to run DttSP functions
        private Thread draw_display_thread;                 // draws the main display 
        private Thread multimeter_thread;                   // updates the rx1/tx meter data
        private Thread rx2_meter_thread;                    // updates the rx2 meter data
        private Thread poll_ptt_thread;                     // polls the PTT line on the parallel port
        private Thread poll_RXOnly_thread;  // ke9ns add
        private Thread poll_pa_pwr_thread;                  // polls the FWD and REV power if the PA is installed
        private Thread sql_update_thread;                   // polls the RX signal strength
        private Thread rx2_sql_update_thread;               // polls the RX2 signal strength
        private Thread vox_update_thread;                   // polls the mic input
        private Thread noise_gate_update_thread;			// polls the mic input during TX
        private Thread f3k_temp_thread;				        // polls the temp on the FLEX-3000 to turn fan on/off
        private Thread f3k_mic_function_thread;				// handles the FLEX-3000 mic inputs (Up, Down, Fast)
        //private Thread wbir_thread;
        //private Thread wbir_rx2_thread;
        private Thread update_rx1_dds_thread;
        private Thread update_rx2_dds_thread;
        private Thread update_tx_dds_thread;
        private Thread audio_watchdog_thread;
        //private HiPerfTimer polltimer;
        public Mutex calibration_mutex = new Mutex();

        private Mutex psdr2_mutex;                                  // Mutex for INNO installer
        private string psdr2_mutex_name = "PowerSDRv2.x_Mutex";     // Mutex name
        private bool psdr2_mutex_exists = false;                    // is true when Mutex has been created
        private bool dax_audio_enum = false;

        // ======================================================
        // variables Declarations 
        // ======================================================


        public int KBON = 0; // ke9ns add 1=knob present 0=knob not present
        public int speed = 0; // ke9ns add speed of knob freq change
        public int lastvalue = 0; // ke9ns add knob

        SpeechSynthesizer speaker = new SpeechSynthesizer(); // ke9ns add 

        public DSP dsp;
        private SIOListenerII siolisten = null;              // original CAT port

        private SIOListenerII2 siolisten2 = null;              // ke9ns.180  CAT port2
        private SIOListenerII3 siolisten3 = null;              // ke9ns CAT port3
        private SIOListenerII4 siolisten4 = null;              // ke9ns CAT port4
        private SIOListenerII5 siolisten5 = null;              // ke9ns CAT port5
        private SIOListenerII6 siolisten6 = null;              // ke9ns CAT port6 .200 spoof VFOA to B

        private bool calibration_running = false;
        private bool displaydidit = false;
        //private bool calibrationdidit = false;

        private SIOListenerIII siolisten1 = null;          // ke9ns add for ant rotor control

        public bool fwc_init = false;        // ke9ns:  true = Flex-5000 or Flex-3000 and stays TRUE forever (not used by SDR-1000 or Flex-1500)
        public int fwc_index = -1;
        private long fwc_last_cal_date_time = 0;
        private uint fwc_serial_num = 0;
        private uint fwc_trx_serial_num = 0;
        private uint rx2_trx_match_serial = 0;

        private int rx1_squelch_threshold_scroll = -160;
        private int rx2_squelch_threshold_scroll = -160;
        private bool rx1_squelch_on = false;
        private bool rx2_squelch_on = false;
        private int rx1_fm_squelch_threshold_scroll = 0;
        private int rx2_fm_squelch_threshold_scroll = 0;

        private long rx2_last_cal_date_time = 0;
        private uint rx2_serial_num = 0;

        public bool hid_init = false;
        public int hid_index = -1;
        private long hid_last_cal_date_time = 0;
        private uint hid_serial_num = 0;
        private uint hid_trx_serial_num = 0;


        private MemoryList memoryList;

        public MemoryList MemoryList
        {
            get { return memoryList; }
        }



        //====================================================================================
        // ke9ns add  dx cluster list
        private DXMemList dxmemList; // ke9ns add

        public DXMemList DXMemList // ke9ns add
        {
            get { return dxmemList; }
        }

        //=======================================================================================


        private HW hw;                                      // will eventually be an array of rigs to support multiple radios



        private bool run_setup_wizard;						// Used to run the wizard the first time the software comes up
        private bool show_alpha_warning = false;
        private bool show_beta_warning = true;
        private bool show_mobile_warning = true;

        //    public int[] band = new int[100];

        //   [StructLayout(LayoutKind.Explicit)]
        //  public struct UnionTest

        // {

        //   [FieldOffset(0)]  public int band_160m_index;                     // These band indexes are used to keep track of which
        //  [FieldOffset(0)]  band[0];
        // }


        public int[] band_index = new int[100];  //  replaces band_160m_index; 
        public int[] band_register = new int[100]; // replaces band_160m_register;	


        public int band_160m_index;                     // These band indexes are used to keep track of which
        public int band_80m_index;                          // location in the bandstack was last saved/recalled
        public int band_60m_index;
        public int band_40m_index;
        public int band_30m_index;
        public int band_20m_index;
        public int band_17m_index;
        public int band_15m_index;
        public int band_12m_index;
        public int band_10m_index;
        public int band_6m_index;
        public int band_2m_index;
        public int band_wwv_index;
        public int band_gen_index;

        public int band_LMF_index; // ke9ns add
        public int band_120m_index;
        public int band_90m_index;
        public int band_61m_index;
        public int band_49m_index;
        public int band_41m_index;
        public int band_31m_index;
        public int band_25m_index;
        public int band_22m_index;
        public int band_19m_index;
        public int band_16m_index;
        public int band_14m_index;
        public int band_13m_index;
        public int band_11m_index;

        public int band_vhf0_index;
        public int band_vhf1_index;
        public int band_vhf2_index;
        public int band_vhf3_index;
        public int band_vhf4_index;
        public int band_vhf5_index;
        public int band_vhf6_index;
        public int band_vhf7_index;
        public int band_vhf8_index;
        public int band_vhf9_index;
        public int band_vhf10_index;
        public int band_vhf11_index;
        public int band_vhf12_index;
        public int band_vhf13_index;



        public int band_160m_register;                      // These integers are the number of band stack registers
        public int band_80m_register;                       // found in the database for each band
        public int band_60m_register;
        public int band_40m_register;
        public int band_30m_register;
        public int band_20m_register;
        public int band_17m_register;
        public int band_15m_register;
        public int band_12m_register;
        public int band_10m_register;
        public int band_6m_register;
        public int band_2m_register;
        public int band_wwv_register;
        public int band_gen_register;

        public int band_LMF_register; // ke9ns add
        public int band_120m_register;
        public int band_90m_register;
        public int band_61m_register;
        public int band_49m_register;
        public int band_41m_register;
        public int band_31m_register;
        public int band_25m_register;
        public int band_22m_register;
        public int band_19m_register;
        public int band_16m_register;
        public int band_14m_register;
        public int band_13m_register;
        public int band_11m_register;

        public int band_vhf0_register;
        public int band_vhf1_register;
        public int band_vhf2_register;
        public int band_vhf3_register;
        public int band_vhf4_register;
        public int band_vhf5_register;
        public int band_vhf6_register;
        public int band_vhf7_register;
        public int band_vhf8_register;
        public int band_vhf9_register;
        public int band_vhf10_register;
        public int band_vhf11_register;
        public int band_vhf12_register;
        public int band_vhf13_register;



        //   private RadioButtonTS[] gen_text; // ke9ns add


        private bool was_panadapter = false;                // used to restore panadater when switching to spectrum DSP mode
        private bool was_waterfall = false;                 // used to restore waterfall when switching to spectrum DSP mode

        public float[] rx1_preamp_offset;                   // offset values for each preamp mode in dB
        public float[] rx2_preamp_offset;                   // offset values for each preamp mode in dB
        public float rx1_meter_cal_offset;                  // multimeter calibration offset per volume setting in dB
        public float rx2_meter_cal_offset;                  // multimeter calibration offset per volume setting in dB
        public float rx1_filter_size_cal_offset = 3;        // filter offset based on DSP filter size
        public float rx2_filter_size_cal_offset = 3;        // filter offset based on DSP filter size

        private bool meter_data_ready;                      // used to synchronize the new DSP data with the multimeter
                                                            //  private bool meter_data_ready2;                      // ke9ns add for using rx2 for extra tx meter

        public float new_meter_data;                       // new data for the multimeter from the DSP
        private float new_meter_data2;                       // ke9ns add for using RX2 for extra TX meter

        private float current_meter_data;                   // current data for the multimeter
        private int meter_peak_count;                       // Counter for peak hold on multimeter
        private float meter_peak_value;                     // Value for peak hold on multimeter
        private float[] meter_text_history;                 // Array used to output the peak power over a period of time
        private int meter_text_history_index;               // index used with above variable to do peak power

        private bool rx2_meter_data_ready;                  // used to synchronize the new DSP data with the multimeter
        private float rx2_meter_new_data;					// new data for the multimeter from the DSP
        private double tx2_meter_new_data;                  // ke9ns add to allow MIC dBm values while in RX mode
        private float rx2_meter_current_data;               // current data for the multimeter
        private int rx2_meter_peak_count;                   // Counter for peak hold on multimeter
        private float rx2_meter_peak_value;                 // Value for peak hold on multimeter

        public float[][] power_table;						// table used to store power in new power cal routine
        public float[] vhf_power_table;                     // table used to store VHF power (Audio.RadioVolume) in VU cal routine
        public float[] uhf_power_table;                     // table used to store UHF power (Audio.RadioVolume) in VU cal routine
        public double[] freqs_2m = { 144.0, 144.3, 144.6, 144.9, 145.2, 145.5, 145.8, 146.1, 146.4, 146.7, 147.0, 147.3, 147.9, 148.0 };
        public double[] freqs_70cm = { 430.0, 431.5, 433.0, 434.5, 436.0, 437.5, 439.0, 440.5, 442.0, 443.5, 445.0, 445.5, 446.0, 446.5, 447.0, 447.5, 448.0, 448.5, 449.0, 449.5, 449.975, 450.0 };

        public int pa_fwd_power;                            // forward power as read by the ADC on the PA
        public int pa_rev_power;                            // reverse power as read by the ADC on the PA
        public bool tuning;                                 // true when the TUN button is active
        public bool atu_tuning;                             // true while the atu is tuning
        private Band tuned_band;                            // last band that the atu was tuned on

        public float[] rx1_image_gain_table;                // table used to store image cal info
        public float[] rx1_image_phase_table;               // table used to store image cal info
        public float[] rx2_image_gain_table;                // table used to store image cal info
        public float[] rx2_image_phase_table;               // table used to store image cal info
        public float[] tx_image_gain_table;                 // table used to store image cal info
        public float[] tx_image_phase_table;                // table used to store image cal info
        public int[][] pa_bias_table;                       // table used to store PA Bias settings
        public float[][] rx1_level_table;                   // table used to store RX1 Level cal settings
        public float[][] rx2_level_table;                   // table used to store RX2 Level cal settings
        public float[][] pa_bridge_table;                   // table used to store PA Bridge cal settings
        public float[] swr_table;							// table used to calibrate SWR
        public float[] atu_swr_table;                       // table used to cal SWR at ATU power
        public float rx2_res_offset;
        public float[] vhf_level_table;
        public float[] uhf_level_table;

        //public int[][] tx_carrier_table;					// table used to store tx carrier cal info
        public SortedDictionary<double, uint> tx_carrier_cal;

        public byte rx1_level_checksum;
        public byte rx1_image_gain_checksum;
        public byte rx1_image_phase_checksum;
        public byte tx_image_gain_checksum;
        public byte tx_image_phase_checksum;
        public byte tx_carrier_checksum;
        public byte pa_bias_checksum;
        public byte pa_bridge_checksum;
        public byte pa_power_checksum;
        public byte pa_swr_checksum;
        public byte atu_swr_checksum;
        public byte vu_level_checksum;
        public byte vu_power_checksum;

        public byte rx2_level_checksum;
        public byte rx2_image_gain_checksum;
        public byte rx2_image_phase_checksum;


        public double[] CTCSS_array =  {
            67.0 , 69.3 , 71.9 , 74.4 , 77.0 , 79.7 , 82.5 , 85.4 , 88.5 , 91.5 ,
            94.8 , 97.4 , 100.0, 103.5, 107.2, 110.9, 114.8, 118.8, 123.0, 127.3,
            131.8, 136.5, 141.3, 146.2, 151.4, 156.7, 159.8, 162.2, 165.5, 167.9,
            171.3, 173.8, 177.3, 179.9, 183.5, 186.2, 189.9, 192.8, 199.5, 203.5,
            206.5, 210.7, 218.1, 225.7, 229.1, 233.6, 241.8, 250.3, 254.1};

        public double[] FM_deviation_array = { 9000, 5000, 2500 }; // ke9ns mod  was 5000, 2500. add 9000 (used my memoryform.cs)

        public bool oldATU = true;

        private bool shift_down;                            // used to modify tuning rate
        private bool calibrating;                           // true if running a calibration routine
        public bool manual_mox;                         // True if the MOX button was clicked on (not PTT)		

        public DSPMode vfob_dsp_mode;                       // Saves control pointer for last mode used on VFO B 
        private Filter vfob_filter;                         // Saves control pointer for last filter used on VFO B

        // txtVFOAFreq.Font (Standard VFO font size)
        private int vfo_char_width;                         // "0"                 (pixel width of large characters)                  Used to calibrate mousewheel tuning
        private int vfo_char_space;                         // "00" - 2*"0"        (pixel space in between 2 large characters)          Used to calibrate mousewheel tuning
        private int vfo_decimal_space;                      // "0.0"- 2*"0"        (pixel width of seperator char)                    Used to calibrate mousewheel tuning		
        private int vfo_pixel_offset;                       // "1234.678901"       (pixel width of this string)                       Used to calibrate mousewheel tuning

        // txtVFOALSD.Font (small VFO font size)
        private int vfo_small_char_width;                   // "0"                 (pixel width of small characters)                  Used to calibrate mousewheel tuning
        private int vfo_small_char_space;                   // "00" - 2*"0"        (pixel space in between small characters)          Used to calibrate mousewheel tuning

        // txtVFOABand.Font (veru small bandtext font size)
        private int vfo_sub_char_width;                     // "0"                 (pixel width of large char)                        Used to calibrate mousewheel tuning
        private int vfo_sub_char_space;                     // "00" - 2*"0"        (pixel space in between 2 large characters)         Used to calibrate mousewheel tuning
        private int vfo_sub_decimal_space;                  // "0.0" - 2*"0"       (pixel width of seperator char)   Used to calibrate mousewheel tuning	
        private int vfo_sub_pixel_offset;                   // "1234.678901"       (pixel width of this string)

        private int vfoa_hover_digit;                       // -1                  Digit for hover display
        private int vfoa_sub_hover_digit;                   // Digit for VFOA sub hover display
        private int vfob_hover_digit;                       // Digit for hover display

        public string last_band;							// Used in bandstacking algorithm
        public int last_band_index;                         // ke9ns add for display of bandstack frequencies
        public int last_band_index_size;                    // ke9ns add

        public string last_band2;							// Used in bandstacking algorithm .209 for VFOB
        public int last_band_index2;                         // ke9ns add for display of bandstack frequencies
        public int last_band_index_size2;                    // ke9ns add


        private DSPMode quick_save_mode;                    // Quick Save Mode
        private Filter quick_save_filter;                   // Quick Save Filter

        private int vfo_sub_decimal_width;                  // NOT USED  
        private int vfo_decimal_width;                      // NOT USED

        public NumberFormatInfo NI;                        // .240 to allow .NET 4.6 and higher used in  .ToString( ,NI); and double.Parse(  ,NI); and float.Parse(  ,NI);
        public string separator;                           // contains the locations specific decimal separator

        private int last_filter_shift;                      // VK6APH
        private int last_var1_shift;                        // VK6APH 
        private int last_var2_shift;                        // VK6APH

        public string[] CmdLineArgs;

        private double rx1_avg_last_ddsfreq = 0;                // Used to move the display average when tuning
        private double rx1_avg_last_dttsp_osc = 0;
        private double rx1_last_bin_shift_leftover = 0;

        private double rx2_avg_last_ddsfreq = 0;                // Used to move the display average when tuning
        private double rx2_avg_last_dttsp_osc = 0;
        private double rx2_last_bin_shift_leftover = 0;

        private HiPerfTimer break_in_timer;
        public double avg_vox_pwr = 0.0;

        // BT 11/05/2007
        public PowerSDR.RemoteProfiles ProfileForm; // CAT

        //EHR 25Mar08
        private TDxInput.Device TDxDevice;
        private TDxInput.Sensor TDxSensor;

        public bool initializing = true;

        private int h_delta = 0;        //k6jca 1/15/08
        private int v_delta = 0;        //k6jca 1/15/08

        private int previous_delta = 0;  //k6jca

        private Size console_basis_size = new Size(100, 100);       //k6jca
        private Point gr_filter_basis_location = new Point(100, 100);       //k6jca
        private Point gr_Multimeter_basis_location = new Point(100, 100);       //k6jca
        private Point gr_BandHF_basis_location = new Point(100, 100);       //k6jca
        private Point gr_BandGEN_basis_location = new Point(100, 100);       //ke9ns add
        private Point gr_BandVHF_basis_location = new Point(100, 100);      //k6jca

        private Point gr_BandHFRX2_basis_location = new Point(100, 100);
        private Point gr_BandGENRX2_basis_location = new Point(100, 100);       //ke9ns add
        private Point gr_BandVHFRX2_basis_location = new Point(100, 100);


        private Point gr_Mode_basis_location = new Point(100, 100);     //k6jca
        private Point gr_VFOB_basis_location = new Point(100, 100);     //k6jca
        private Point gr_VFOA_basis_location = new Point(100, 100);		//k6jca

        private Point gr_VFODialA_location = new Point(100, 100);     //ke9ns add
        private Point gr_VFODialB_location = new Point(100, 100);     //ke9ns add

        private Point gr_VFODialAA_location = new Point(100, 100);     //ke9ns add
        private Point gr_VFODialBB_location = new Point(100, 100);     //ke9ns add

        private Point gr_screencap_location = new Point(100, 100);     //ke9ns add
        private Point gr_buttoncall_location = new Point(100, 100);     //ke9ns add
        private Point gr_buttonVK1_location = new Point(100, 100);     //ke9ns add .189
        private Point gr_buttonVK2_location = new Point(100, 100);     //ke9ns add

        private Point gr_buttoncq_location = new Point(100, 100);     //ke9ns add

        private Point gr_udcqcqrepeat_location = new Point(100, 100);     //ke9ns add
        private Point autobrightbox_basis = new Point(100, 100);               // ke9ns add autobrightbox

        private Point gr_ModePhone_basis_location = new Point(100, 100);        //k6jca
        private Point gr_ModeCW_basis_location = new Point(100, 100);       //k6jca
        private Point gr_ModeDig_basis_location = new Point(100, 100);		//k6jca
        private Point gr_ModeFM_basis_location = new Point(100, 100);  // anonymous
        private Point gr_VFO_basis_location = new Point(100, 100);      //k6jca
        private Point gr_vfobetween_basis_location = new Point(100, 100);       //k6jca
        private Point btn_display_pan_center_basis = new Point(100, 100);       //k6jca
        private Point tb_display_pan_basis = new Point(100, 100);       //k6jca

        private Size tb_display_pan_size_basis = new Size(100, 100);        //k6jca
        private Size tb_display_pan2_size_basis = new Size(100, 100);        //.219

        private Point btn_display_zoom_4x_basis = new Point(100, 100);      //k6jca
        private Point btn_display_zoom_2x_basis = new Point(100, 100);      //k6jca
        private Point btn_display_zoom_1x_basis = new Point(100, 100);      //k6jca
        private Point btn_display_zoom_05_basis = new Point(100, 100);      //k6jca
        private Point tb_display_zoom_basis = new Point(100, 100);      //k6jca
        private Point tb2_display_zoom_basis = new Point(100, 100);      //.219

        private Point txt_display_peak_freq_basis = new Point(100, 100);        //k6jca
        private Point txt_display_peak_power_basis = new Point(100, 100);       //k6jca
        private Point txt_display_peak_offset_basis = new Point(100, 100);		//k6jca
        private Point lbl_display_zoom_basis = new Point(100, 100);     //k6jca
        private Size gr_display_size_basis = new Size(100, 100);        //k6jca
        private Size pic_display_size_basis = new Size(100, 100);       //k6jca
        private Size textbox1_size_basis = new Size(100, 100);      //k6jca
        private Point textbox1_basis = new Point(100, 100);     //k6jca
        private Point gr_display2_basis = new Point(100, 100);      //k6jca
        private Point gr_dsp_basis = new Point(100, 100);       //k6jca
        private Point tb_displaypan_basis = new Point(100, 100);        //k6jca
        private Point tb_displaypan2_basis = new Point(100, 100);        //.219

        private Point lbl_displaypan_basis = new Point(100, 100);       //k6jca
        private Point buttonVK1_basis = new Point(100, 100); //ke9ns
        private Point buttonVK2_basis = new Point(100, 100); //ke9ns
        private Point txt_display_cursor_freq_basis = new Point(100, 100);      //k6jca
        private Point txt_display_cursor_power_basis = new Point(100, 100);     //k6jca
        private Point txt_display_cursor_offset_basis = new Point(100, 100);        //k6jca
        private Point txt_screen_save_offset_basis = new Point(100, 100);        //ke9ns add

        private Point chk_power_basis = new Point(100, 100);        //k6jca
        private Point gr_multirx_basis = new Point(100, 100);       //k6jca

        private Point pan_rx2_divider_basis = new Point(100, 100);
        private Size pan_rx2_divider_size_basis = new Size(100, 100);

        private Point gr_display_split_basis = new Point(100, 100); // KE5DTO
        private Point gr_options_basis = new Point(100, 100);       //k6jca
        private Point gr_sound_controls_basis = new Point(100, 100);        //k6jca
        private Point chk_squelch_basis = new Point(100, 100);      //k6jca
        private Point ud_squelch_basis = new Point(100, 100);       //k6jca
        private Point pic_sql_basis = new Point(100, 100);      //k6jca
        private Point tb_sql_basis = new Point(100, 100);       //k6jca
        private Point gr_antenna_basis = new Point(100, 100);       //k6jca
        private Point chk_bci_basis = new Point(100, 100);      //k6jca
        private Point button1_basis = new Point(100, 100);      //k6jca
        private Point gr_date_time_basis = new Point(100, 100);     //k6jca
                                                                    //private Point lbl_cpu_meter_basis = new Point (100,100);		//k6jca

        private Point gr_rx2_meter_basis = new Point(100, 100);
        private Point gr_rx2_filter_basis = new Point(100, 100);
        private Point gr_rx2_mode_basis = new Point(100, 100);
        private Point gr_rx2_display_basis = new Point(100, 100);
        private Point gr_rx2_dsp_basis = new Point(100, 100);

        private Point lbl_rx2_rf_basis = new Point(100, 100);
        private Point ud_rx2_rf_basis = new Point(100, 100);
        private Point tb_rx2_rf_basis = new Point(100, 100);
        private Point chk_rx2_squelch_basis = new Point(100, 100);
        private Point ud_rx2_squelch_basis = new Point(100, 100);
        private Point tb_rx2_squelch_basis = new Point(100, 100);
        private Point pic_rx2_squelch_basis = new Point(100, 100);

        private Point gr_rx2_mixer_basis = new Point(100, 100);
        private Point chk_rx2_enable_basis = new Point(100, 100);
        private Point chk_rx2_preamp_basis = new Point(100, 100);
        private Point lbl_rx2_band_basis = new Point(100, 100);
        private Point combo_rx2_band_basis = new Point(100, 100);

        public bool swapping = false;   //used to supress V/U on both RX1/RX2 error while swapping

        public int AGCTAdj = 55; // ke9ns add: default AGCT gain adjustment for green line


#if (NO_DJ)
        //mod DH1TW
        public DJConsole DJConsoleObj;
        public DJConsoleUI.DJConsoleSelect DJConsoleConfigurator;

#endif




        #endregion


        #region Constructor and Destructor
        // ======================================================
        // Constructor and Destructor
        // ======================================================
        public Console(string[] args)                  // ke9ns: Main() called first
        {

            Debug.WriteLine("===START=== Console here");

            //====================================================================================
            //====================================================================================
            //====================================================================================
            // KE9NS ADD: the purpose of this function is to embed the fonts into the resource (PowerSDR.exe)
            // this for some reason requires using unmanaged memory as opposed to simply reading the file.
            //====================================================================================
            //====================================================================================
            //====================================================================================
            // Embed Swis721 BlkEx BT Font
            byte[] fontArray = Properties.Resources.swissek;  //  swissek buffer to hold Font file
            int dataLength = Properties.Resources.swissek.Length; //  swissek get length of Font file


            byte[] fontArray1 = Properties.Resources.swissb;  // swissbi  buffer to hold Font file     SWIS721 Bold
            int dataLength1 = Properties.Resources.swissb.Length; // swissbi  get length of Font file

            byte[] fontArray2 = Properties.Resources.swisscki;  // swisscki  buffer to hold Font file    SWIS721 Condensed Kerfed Italic FONT
            int dataLength2 = Properties.Resources.swisscki.Length; // swisscki  get length of Font file


            byte[] fontArray3 = Properties.Resources.swissbo;  // swisscbo  buffer to hold Font file     SWIS721 OUTLINE FONT
            int dataLength3 = Properties.Resources.swissbo.Length; // swisscbo  get length of Font file

            //  byte[] fontArray3 = Properties.Resources.napoli;  //   buffer to hold Font file
            //  int dataLength3 = Properties.Resources.napoli.Length; //   get length of Font file

            IntPtr ptrData = Marshal.AllocCoTaskMem(dataLength); //int pointer to a allocated block of unmanaged memory the size of the Font File
            IntPtr ptrData1 = Marshal.AllocCoTaskMem(dataLength1); //int pointer to a allocated block of unmanaged memory the size of the Font File
            IntPtr ptrData2 = Marshal.AllocCoTaskMem(dataLength2); //int pointer to a allocated block of unmanaged memory the size of the Font File
            IntPtr ptrData3 = Marshal.AllocCoTaskMem(dataLength3); //int pointer to a allocated block of unmanaged memory the size of the Font File


            Marshal.Copy(fontArray, 0, ptrData, dataLength); // copy Font File bytes source -> into unmanged memory block
            Marshal.Copy(fontArray1, 0, ptrData1, dataLength1); // copy Font File bytes source -> into unmanged memory block
            Marshal.Copy(fontArray2, 0, ptrData2, dataLength2); // copy Font File bytes source -> into unmanged memory block
            Marshal.Copy(fontArray3, 0, ptrData3, dataLength3); // copy Font File bytes source -> into unmanged memory block

            uint cFonts = 0;


            AddFontMemResourceEx(ptrData, (uint)fontArray.Length, IntPtr.Zero, ref cFonts); // class part of gdi32.dll add Font from unmanged memory block
            AddFontMemResourceEx(ptrData1, (uint)fontArray1.Length, IntPtr.Zero, ref cFonts); // class part of gdi32.dll add Font from unmanged memory block
            AddFontMemResourceEx(ptrData2, (uint)fontArray2.Length, IntPtr.Zero, ref cFonts); // class part of gdi32.dll add Font from unmanged memory block
            AddFontMemResourceEx(ptrData3, (uint)fontArray3.Length, IntPtr.Zero, ref cFonts); // class part of gdi32.dll add Font from unmanged memory block

            PrivateFontCollection pfc = new PrivateFontCollection();  // class to provide client provided fonts
            PrivateFontCollection pfc1 = new PrivateFontCollection();  // class to provide client provided fonts
            PrivateFontCollection pfc3 = new PrivateFontCollection();  // class to provide client provided fonts


            pfc.AddMemoryFont(ptrData, dataLength); // add Font from unmanaged memory block
            pfc.AddMemoryFont(ptrData1, dataLength1); // add Font from unmanaged memory block
            pfc1.AddMemoryFont(ptrData2, dataLength2); // add Font from unmanaged memory block
            pfc3.AddMemoryFont(ptrData3, dataLength3); // add Font from unmanaged memory block

            Marshal.FreeCoTaskMem(ptrData);  // release unmanaged memory block (safe again)
            Marshal.FreeCoTaskMem(ptrData1);  // release unmanaged memory block (safe again)
            Marshal.FreeCoTaskMem(ptrData2);  // release unmanaged memory block (safe again)
            Marshal.FreeCoTaskMem(ptrData3);  // release unmanaged memory block (safe again)

            S1 = pfc.Families[0]; // swissek
            S2 = pfc.Families[1]; // swissb  Swis721 BT Bold

            S3 = pfc1.Families[0]; //swisscki
            S4 = pfc3.Families[0]; //swisscbo

            ff = new Font(S1, 7.0f, FontStyle.Bold | FontStyle.Italic); // Swis721 BlkEx B  // analog meters
            ff1 = new Font(S1, 6.9f, FontStyle.Bold | FontStyle.Italic); // Swis721 BlkEx B // white numbers
            ff2 = new Font(S1, 5.5f, FontStyle.Bold | FontStyle.Italic); // Swis721 BlkEx B // red +numbers

            ff3 = new Font(S2, 14.0f, FontStyle.Bold); // Swis721 BT // digital meter values
            ff4 = new Font(S2, 12.0f, FontStyle.Bold); // Swis721 BT
            ff5 = new Font(S2, 8.25f, FontStyle.Bold); // Swis721 BT

            ff8 = new Font(S2, 11.0f, FontStyle.Bold | FontStyle.Italic); // Swis721 BT  font for meter indication

            //    f6 = new Font(S2, 32.0f, FontStyle.Italic); // Swis721 BT for txtVFOAMSD (A and B)
            //    f7 = new Font(S2, 27.0f, FontStyle.Italic); // Swis721 BT for txtVFOALSD (A and B)

            //   f6 = new Font(S3, 32.0f, FontStyle.Regular); // Swis721 BI for txtVFOAMSD (A and B) its already a Bold and Italic font
            //  f7 = new Font(S3, 27.0f, FontStyle.Regular); // Swis721 BI for txtVFOALSD (A and B)


            ff6 = new Font(S3, 32.0f, FontStyle.Bold | FontStyle.Italic); // Swis721 BI for txtVFOAMSD (A and B) its already a Bold and Italic font
            ff7 = new Font(S3, 27.0f, FontStyle.Bold | FontStyle.Italic); // Swis721 BI for txtVFOALSD (A and B)

            ff9 = new Font(S4, 32.5f, FontStyle.Bold); // Swis721 BO for txtVFOAMSD (A and B) its already a Open and Italic font
            ff9a = new Font(S4, 27.0f, FontStyle.Bold); // Swis721 BO for txtVFOAMSD (A and B) its already a Open and Italic font


            //============================================================================================================ ke9ns add end


            foreach (string s in args)
            {
                if (s.StartsWith("-datapath:"))
                {
                    string path = s.Trim().Substring(s.Trim().IndexOf(":") + 1);

                    if (path.EndsWith("\"")) path = path.Substring(0, path.Length - 1);

                    if (!path.EndsWith("\\")) path += "\\";

                    if (Directory.Exists(path)) AppDataPath = path;
                    else
                    {
                        DialogResult dr = MessageBox.Show(new Form { TopMost = true }, "-datapath: command line option found, but the folder specified was not found.\n" +
                            "Would you like to create this folder?  If not, the default folder will be used.\n\n" +
                            "(" + s + ")",
                            "Command Line Option: Create Folder?",
                            MessageBoxButtons.YesNo,
                            MessageBoxIcon.Question);

                        if (dr == DialogResult.Yes)
                        {
                            Directory.CreateDirectory(path);
                            AppDataPath = path;
                        }
                    }
                }
            }


            //---------------------------------------------------------------------------------
            // ke9ns info:    Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData)  ==   %userprofile%\AppData\Roaming

            if (app_data_path == "") // ke9ns: %userprofile%\AppData\Roaming\FlexRadio Systems\PowerSDR v2.8.0\
            {
                Assembly assembly = Assembly.GetExecutingAssembly();
                FileVersionInfo fvi = FileVersionInfo.GetVersionInfo(assembly.Location);
                string version = fvi.FileVersion.Substring(0, fvi.FileVersion.LastIndexOf("."));

                //  AppDataPath = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) + "\\FlexRadio Systems\\PowerSDR" + version + "\\"; // ke9ns original
                AppDataPath = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) + "\\FlexRadio Systems\\PowerSDR v2.8.0\\"; // keep it the same otherwise everyone starts with a new database
                                                                                                                                               //  AppDataPath1 = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) + "\\FlexRadio Systems\\PowerSDR v2.7.2\\"; // keep it the same otherwise everyone starts with a new database

            }

            // identify all detectable radios (FLEX-5000s, FLEX-3000s, FLEX-1500s)
            RadiosAvailable.Init();

            // check for existence of master file
            string master_path = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) + "\\FlexRadio Systems\\";  // %userprofile%\AppData\Roaming\FlexRadio Systems\
            string common_data_path = Environment.GetFolderPath(Environment.SpecialFolder.CommonApplicationData) + "\\FlexRadio Systems\\PowerSDR\\"; // C:\ProgramData\FlexRadio Systems\PowerSDR\

            if (File.Exists(master_path + "production")) production = true;  // ke9ns if an empty file called production is found in the  %userprofile%\AppData\Roaming\FlexRadio Systems\ folder

            if (File.Exists(master_path + "test_equip")) test_equip = true;   // ke9ns if an empty file called test_quip is found in the  %userprofile%\AppData\Roaming\FlexRadio Systems\ folder


            Debug.WriteLine("COMMON: " + common_data_path);
            Debug.WriteLine("Production: " + production);

            Master.Init();

            Debug.Assert(File.Exists(master_path + "master.xml"));

            // decide whether to present a choice of radios to the user
            Pal.Init();  // ke9ns: Performance Analysis Logger tool (PerfMon) currently at 4.1.3.17357 Flex Radio 1/30/2013

            RadiosAvailable.ScanPal(); // gather info on Pal radios

            if (RadiosAvailable.NumPresent == 0) // handle v1.x firmware
            {
                if (FWCMidi.Open())
                {
                    /*MessageBox.Show(new Form { TopMost = true }, "Error communicating with radio.  The program will now be closed.\n" +
                        "Please update the radio firmware to v2.0+ to prevent this issue.\n" +
                        "For instructions, visit:\n\n http://kc.flexradio.com/KnowledgebaseArticle50441.aspx",
                        "Communication Error",
                        MessageBoxButtons.OK,
                        MessageBoxIcon.Error);
                    Process.GetCurrentProcess().Kill();
                    return;*/

                    uint model;
                    int ret = FWC.GetModelMidi(out model);
                    if (model == 3) current_model = Model.FLEX3000;
                    else current_model = Model.FLEX5000;

                    DialogResult dr = MessageBox.Show(new Form { TopMost = true }, "A radio firmware update is required in order to continue.\n\n" +
                        "Would you like to update your firmware now?\n" +
                        "If not, PowerSDR will be closed.",
                        "Update Firmware Now?",
                        MessageBoxButtons.YesNo,
                        MessageBoxIcon.Question);

                    if (dr == DialogResult.No)
                    {
                        Process.GetCurrentProcess().Kill(); // program ends here
                        return; // this is just for code clarity
                    }

                    if (current_model == Model.FLEX5000)
                    {
                        dr = MessageBox.Show(new Form { TopMost = true }, "Is the radio in use a FLEX-5000?",
                            "FLEX-5000?",
                            MessageBoxButtons.YesNo,
                            MessageBoxIcon.Question);

                        if (dr == DialogResult.No)
                        {
                            dr = MessageBox.Show(new Form { TopMost = true }, "Is the radio in use a FLEX-3000?",
                                "FLEX-3000?",
                            MessageBoxButtons.YesNo,
                            MessageBoxIcon.Question);

                            if (dr == DialogResult.No)
                            {
                                MessageBox.Show(new Form { TopMost = true }, "The radio was not recognized.  Please try again.",
                                    "Radio Model Confusion",
                                    MessageBoxButtons.OK,
                                    MessageBoxIcon.Error);

                                Process.GetCurrentProcess().Kill(); // program ends here
                                return; // this is just for code clarity
                            }

                            current_model = Model.FLEX3000;
                        }
                    }

                    LoadFWCFirmware(VerToString(GetMinVersion(current_model)));

                    MessageBox.Show(new Form { TopMost = true }, "Update complete.  The program will now close.\n" +
                        "Please restart PowerSDR to continue.",
                        "Restart Required",
                        MessageBoxButtons.OK,
                        MessageBoxIcon.Information);

                    Process.GetCurrentProcess().Kill();
                }
            } // radiosavailable == 0

            Flex1500.Init();
            RadiosAvailable.Scan1500();



            int list_det_num = 0;
            int list_undet_num = 0; // ignore demo
            int list_det_present = 0;

            foreach (Radio r in RadiosAvailable.RadioList)
            {
                switch (r.Model)
                {
                    case Model.FLEX5000:
                    case Model.FLEX3000:
                    case Model.FLEX1500:
                        list_det_num++;
                        if (r.Present) list_det_present++;
                        break;
                    case Model.SDR1000:
                        //  case Model.SOFTROCK40:
                        list_undet_num++; break;
                }
            }

            if ((list_det_num == 1 && list_undet_num == 0) || (production && list_det_present == 1)) // skip form
            {
                foreach (Radio r in RadiosAvailable.RadioList)
                {
                    bool found = false;
                    switch (r.Model)
                    {
                        case Model.FLEX5000:
                        case Model.FLEX3000:
                            if (r.Present)
                            {
                                Pal.SelectDevice((uint)r.AccessObj);
                                found = true;
                            }
                            break;
                        case Model.FLEX1500:
                            if (r.Present)
                            {
                                Flex1500.SetActiveRadio((IntPtr)r.AccessObj);
                                found = true;
                            }
                            break;
                    }

                    if (found) // if a Flex radio found
                    {
                        radio_to_use = r;
                        //  DBFileName = app_data_path + r.GetDBFilename();  // ke9ns original this line of code

                        DBFileName = app_data_path + r.GetDBFilename1();  // ke9ns mod  this tells PowerSDR to look for a databaseRevQ_F5K_1610-2780.xml file

                        DBFileName1 = app_data_path + r.GetDBFilename(); // ke9ns add  this is the old original name database_F5K_1610-2780.xml file that we copy use to copy over to the RevQ when needed
                                                                         //            we do this just in case you need your original database for running an older copy of PowerSDR


                        break;
                    }

                } // foreach(radio)

                // add any new radios found to the master list
                foreach (Radio r in RadiosAvailable.RadioList)
                    Master.AddRadio(r);

                Master.Commit();

            } //  if ((list_det_num == 1 && list_undet_num == 0) || (production && list_det_present == 1)) // skip form

            // use one database for each model in production (not each serial)
            /*if (db_file_name != "" && production && radio_to_use.Model != Model.DEMO) 
            {
                int index = db_file_name.LastIndexOf("_");
                DBFileName = db_file_name.Substring(0, index) + ".xml";
            }*/

            if (radio_to_use == null)
            {
                RadioChoice choiceForm = new RadioChoice(this);
                choiceForm.ShowDialog();
            }

            foreach (string s in args)
            {
                if (s.StartsWith("-dbfilename:"))
                {
                    string path = s.Trim().Substring(s.Trim().IndexOf(":") + 1);

                    if (File.Exists(path))
                    {
                        DBFileName = path;
                    }
                    else
                    {
                        DialogResult dr = MessageBox.Show(new Form { TopMost = true }, "-dbfilename: command line option found, but the file specified was not found.\n" +
                            "Would you like to create this file?  If not, the default database will be used.\n\n" +
                            "(" + s + ")",
                            "Command Line Option: Create File?",
                            MessageBoxButtons.YesNo,
                            MessageBoxIcon.Question);

                        if (dr == DialogResult.Yes)
                            DBFileName = path;
                    }
                }
            }

#if (DEBUG)
            AppDataPath += "Debug\\";
#endif
            if (!Directory.Exists(app_data_path))
            {
                Directory.CreateDirectory(app_data_path); //%userprofile%\AppData\Roaming\FlexRadio Systems\PowerSDR v2.8.0\wisdom
            }

            if (db_file_name == "")
            {
                DBFileName = AppDataPath + "database.xml";
            }

            if (File.Exists(db_file_name))
            {
                if (Keyboard.IsKeyDown(Keys.LShiftKey) || Keyboard.IsKeyDown(Keys.RShiftKey))
                {
                    Thread.Sleep(500); // ensure this is intentional
                    if (Keyboard.IsKeyDown(Keys.LShiftKey) || Keyboard.IsKeyDown(Keys.RShiftKey))
                    {
                        DialogResult dr = MessageBox.Show(
                            "The Factory Defaults function has been tiggered.  Would you like to Reset to Factory Defaults?\n\n" +
                            "If so, a copy of the current database will be placed on the desktop with " +
                            "a date and time stamp in the file name before creating a brand new " +
                            "database for active use.",
                            "Factory Defaults?",
                            MessageBoxButtons.YesNo, MessageBoxIcon.Warning);

                        if (dr == DialogResult.Yes)
                        {
                            string desktop = Environment.GetFolderPath(Environment.SpecialFolder.Desktop);
                            string datetime = DateTime.Now.ToShortDateString().Replace("/", "-") + "_" +
                                DateTime.Now.ToShortTimeString().Replace(":", ".");

                            string file = db_file_name.Substring(db_file_name.LastIndexOf("\\") + 1);
                            file = file.Substring(0, file.Length - 4);

                            File.Copy(db_file_name, desktop + "\\PowerSDR_" + file + "_" + datetime + ".xml");

                            File.Delete(db_file_name);
                            Thread.Sleep(500);
                        }
                    }
                }
            } // file exists

            //===========================================================================================
            //===========================================================================================
            //===========================================================================================
            //===========================================================================================
            // SPLASH SCREEN STARTUP

            CmdLineArgs = args;

            Splash.ShowSplashScreen();							// Start splash screen

            Splash.SetStatus("Initializing Components");        // Set progress point

            InitializeComponent();                              // Windows Forms Generated Code

            //  SetProcessShutdownParameters(0x3FF, 0x00000001);  // ke9ns add: part of wndProc to allow shutdown
            //   ShutdownBlockReasonDestroy(this.Handle);

            // for resizing
            GrabConsoleSizeBasis();
            MinimumSize = this.Size;

            Splash.SetStatus("Initializing Database");			// Set progress point
            DB_Exists = DB.Init(radio_to_use.Model);		    // Initialize the database and pass the current radio model

            InitCTCSS();
            Splash.SetStatus("Initializing Hardware");			// Set progress point

            // check model in Options table
            ArrayList list = DB.GetVars("Options");				// Get the saved list of controls
            list.Sort();


            Splash.SetStatus("Enumerating Radio Hardware");     // Set progress point

            if (radio_to_use != null)
            {
                switch (radio_to_use.Model)
                {
                    case Model.FLEX5000:
                        current_model = Model.FLEX5000;
                        fwc_init = true;
                        hid_init = false;
                        FWC.SetPalCallback();
                        FWCMidi.Open();

                        if (list.Count == 0)
                        {
                            list.Add("radGenModelFLEX5000/True");
                            DB.SaveVars("Options", ref list);
                        }
                        break;
                    case Model.FLEX3000:
                        current_model = Model.FLEX3000;
                        fwc_init = true;
                        hid_init = false;
                        FWC.SetPalCallback();
                        FWCMidi.Open();

                        if (list.Count == 0)
                        {
                            list.Add("radGenModelFLEX5000/True");
                            DB.SaveVars("Options", ref list);
                        }
                        break;
                    case Model.FLEX1500:
                        current_model = Model.FLEX1500;
                        fwc_init = false;
                        hid_init = true;
                        if (list.Count == 0)
                        {
                            list.Add("radGenModelFLEX1500/True");
                            DB.SaveVars("Options", ref list);
                        }
                        break;
                    case Model.SDR1000:
                        current_model = Model.SDR1000;
                        fwc_init = false;
                        hid_init = false;
                        if (list.Count == 0)
                        {
                            list.Add("radGenModelSDR1000/True");
                            DB.SaveVars("Options", ref list);
                        }
                        run_setup_wizard = true;
                        break;
                    case Model.SOFTROCK40:
                        current_model = Model.SOFTROCK40;
                        fwc_init = false;
                        hid_init = false;
                        if (list.Count == 0)
                        {
                            list.Add("radGenModelSoftRock40/True");
                            DB.SaveVars("Options", ref list);
                        }
                        break;

                    default:
                        current_model = Model.DEMO;
                        fwc_init = false;
                        hid_init = false;
                        if (list.Count == 0)
                        {
                            list.Add("radGenModelDemoNone/True");
                            DB.SaveVars("Options", ref list);
                        }
                        break;
                }
            }

            if (fwc_init)
            {
                FWCEEPROM.Init();
                current_region = FWCEEPROM.Region;


                if (!db_exists) // modify bandtext and bandstack for non-US regions
                {
                    if (current_region != FRSRegion.US) // for Flex-3000 and 5000
                    {
                        Splash.SetStatus("Harmonizing BandText");
                        DB.UpdateRegion(current_region);
                    }
                }

                if (FWCEEPROM.NeedDump())
                {
                    Splash.HideForm();

                    FWCEEPROM.StartDump(); // fwc_eeprom.cs

                    Splash.UnHideForm();
                }

                switch (FWCEEPROM.Model)
                {
                    case 0:
                    case 1:
                    case 2:
                        current_model = Model.FLEX5000;
                        break;
                    case 3:
                        current_model = Model.FLEX3000;
                        break;
                }

                InitRadio();
            }
            if (hid_init)
            {
                HIDEEPROM.Init();
                current_region = HIDEEPROM.Region;

                if (!db_exists) // modify bandtext and bandstack for non-US regions
                {
                    if (current_region != FRSRegion.US) // for Flex-1500
                    {
                        Splash.SetStatus("Harmonizing BandText");
                        DB.UpdateRegion(current_region);
                    }
                }

                if (HIDEEPROM.NeedDump()) HIDEEPROM.StartDump();

                current_model = Model.FLEX1500;

                InitFLEX1500();
            }

            // ke9ns add
            if ((hid_init == false) && (fwc_init == false)) // ke9ns SDR1000 or softrock
            {
                if (File.Exists("TURF.txt")) // where powersdr.exe resides
                {
                    StreamReader sr = File.OpenText("TURF.txt");
                    string data = sr.ReadLine();
                    int x = Int32.Parse(data);

                    current_region = (FRSRegion)x;
                    sr.Close();
                }

            }

            //====================================================================================
            // ke9ns  this is where you determine if you have RX2  .210 and .212
            //====================================================================================

            if (fwc_init && current_model == Model.FLEX5000 && FWCEEPROM.RX2OK)  // original
            {
                chkRX2.Visible = true;
                lblAntRX2.Visible = true;
                lblAntRX2a.Visible = true;
                lblAntTX2.Visible = true; // .212
                lblAntTX2a.Visible = true;

                //  radBandVHF0RX2.Enabled = true; //.212
                //  radBandVHF1RX2.Enabled = true;
                // vhf_text2[index].Enabled = b;

                //   panelRX2Divider.Visible = true;

                //  RX2BandButton = true;
                //  comboRX2Band_SelectedIndexChanged(this, EventArgs.Empty); //.210

                this.MinimumSize = new Size(this.MinimumSize.Width, this.MinimumSize.Height - (panelRX2Filter.Height + 0));
                // panelAntenna.Size = new Size(115, 78); // ke9ns add .212 enlarge ant panel if 2nd rx
                panelAntenna.Size = new Size(115, 58); // ke9ns add .212 enlarge ant panel if 2nd rx(assume SO2R in Ant panel is off at start)

            }
            else // this is for 1500 and 3000 and 5000 with only RX1
            {
                panelAntenna.Size = new Size(115, 44); // ke9ns add .212 shrink ant panel if not 2nd rx

                textBox1.Size = new System.Drawing.Size(161, 200); //.228 was 151 ke9ns add .209 no need to have VFOB bandstack if no 2nd receiver RX2
                textBox2.Size = new System.Drawing.Size(1, 1);

                console_basis_size.Height -= (panelRX2Filter.Height + 8); // panelRX2Filter

                grpRX2Meter.Visible = false;

                panelRX2Mode.Visible = false;
                panelRX2Display.Visible = false;

                panelRX2DSP.Visible = false;

                panelRX2Mixer.Visible = false;

                lblRX2Band.Visible = false;

                chkRX2Preamp.Visible = false;

                ptbRX2RF.Visible = false;

                ptbRX2Squelch.Visible = false;

                comboRX2Band.Visible = false;

                panelBandHFRX2.Visible = false;
                panelBandVHFRX2.Visible = false;
                panelBandGNRX2.Visible = false;


                lblRX2RF.Visible = false;

                this.MinimumSize = new Size(this.MinimumSize.Width, this.MinimumSize.Height - (panelRX2Filter.Height + 8));

                if (chkRX2.Checked) chkRX2.Checked = false;

                this.Height -= (panelRX2Filter.Height + 8);
                panelRX2Filter.Visible = false;
                chkRX2Squelch.Visible = false;
            }

            Splash.SetStatus("Initializing Radio");				// Set progress point
            dsp = new DSP();								    // Initialize the Radio processor

            Splash.SetStatus("Initializing PortAudio");			// Set progress point
            PA19.PA_Initialize();								// Initialize the audio interface
            if (fwc_init) Thread.Sleep(600);

            Splash.SetStatus("Loading Main Form");				// Set progress point
            Splash.SplashForm.Owner = this;						// So that main form will show/focus when splash disappears
            break_in_timer = new HiPerfTimer();

#if (NO_DJ)
            //mod DH1TW
            DJConsoleObj = new DJConsole(this);

            //endmod
#endif



            InitConsole();										// Initialize all forms and main variables            

            Splash.SetStatus("Finished");                       // Set progress point
                                                                // Activates double buffering
                                                                //SetStyle(ControlStyles.DoubleBuffer, true);




            //===================================================================================

            this.SetStyle(ControlStyles.UserPaint | ControlStyles.AllPaintingInWmPaint | ControlStyles.OptimizedDoubleBuffer, true);
            this.UpdateStyles();

            Splash.CloseForm();									// End splash screen

            // create a Windows Mutex for PowerSDR.  Do not create a second Mutex if one already exists
            // ke9ns: Mutex prevents 2 or more threads from simultaneously accessing a resource
            try
            {
                psdr2_mutex = Mutex.OpenExisting(psdr2_mutex_name);
            }
            catch (WaitHandleCannotBeOpenedException)
            {
                psdr2_mutex = new Mutex(true, psdr2_mutex_name, out psdr2_mutex_exists);
            }




            // ke9ns: Extended capabilities Flex radio check

            if (fwc_init && (current_model == Model.FLEX3000 || current_model == Model.FLEX5000))
            {
                extended = FWC.GetStatus();
                //  Debug.WriteLine("EXTENDED " + FWC.GetStatus());

            }
            else if (hid_init && current_model == Model.FLEX1500) extended = USBHID.GetStatus();
            else if (File.Exists("extended.edf"))						// Check for extended capabilities file (where PowerSDR.exe file resides
            {

                ArrayList a = DB.GetVars("State");
                a.Sort();
                ArrayList names = new ArrayList();
                ArrayList vals = new ArrayList();

                foreach (string s in a)
                {
                    string[] str = s.Split('/');
                    if (str.Length > 2)
                    {
                        for (int j = 2; j < str.Length; j++)
                            str[1] += "/" + str[j];
                    }
                    names.Add(str[0]);
                    vals.Add(str[1]);
                }

                int i = names.BinarySearch("extended");

                if (i < 0) // If not found, prompt for logon info
                {
                    LogOn LogOnForm = new LogOn(this);
                    LogOnForm.ShowDialog();
                }
                else  // If found, check for existing logon info
                {
                    string text = (string)vals[i];

                    StreamReader sr = File.OpenText("extended.edf");
                    string data = sr.ReadLine();
                    sr.Close();

                    if (text == data) extended = true;
                    else	// Logon information found, but doesn't match
                    {
                        MessageBox.Show(new Form { TopMost = true }, "Error reading logon information.", "Logon Error",
                            MessageBoxButtons.OK, MessageBoxIcon.Error);
                        LogOn LogOnForm = new LogOn(this);
                        LogOnForm.ShowDialog();
                    }
                }
            } // check for extended file
            else if (File.Exists("extended1.edf"))
            {
                extended = true;
            }


            Rectangle screenRectangle = RectangleToScreen(this.ClientRectangle);

            int titleHeight = screenRectangle.Top - this.Top;

            //  int BorderWidth = (this.Width – this.ClientSize.Width) / 2;
            //  int TitlebarHeight = this.Height – this.ClientSize.Height – 2 * BorderWidth;

            Debug.WriteLine("titlebar " + titleHeight);

            // update titlebar
            this.Text = TitleBar.GetString();

            setupForm.UpdateCustomTitle();

            if (radio_to_use != null)
            {
                string s = "";

                switch (radio_to_use.Model)
                {
                    case Model.FLEX5000: s = "FLEX-5000"; break;
                    case Model.FLEX3000: s = "FLEX-3000"; break;
                    case Model.FLEX1500: s = "FLEX-1500"; break;
                    case Model.SDR1000: s = "SDR-1000"; break;
                    //  case Model.SOFTROCK40: s = "SoftRock"; break;
                    case Model.DEMO: s = "Demo"; break;
                }

                if (radio_to_use.Nickname == null || radio_to_use.Nickname == "")
                {
                    if ((radio_to_use.SerialNumber != null) && (radio_to_use.SerialNumber != ""))
                        s += ": " + radio_to_use.SerialNumber;
                }
                else
                {
                    if ((radio_to_use.Nickname != null) && (radio_to_use.Nickname != ""))
                        s += ": " + radio_to_use.Nickname;
                }

                this.Text += "   " + s + " : " + current_region + " ";  // ke9ns mod:  added FRSRegion to top line of console window
                if (extended == true) this.Text += "Extended";

                labelPowerSDR.Text = this.Text; // ke9ns add

            }



            if (show_alpha_warning && this.Text.ToLower().Contains("alpha") && !production)
            {
                AlphaWarnForm form = new AlphaWarnForm(this);
                form.ShowDialog();
            }

            if (show_beta_warning && this.Text.ToLower().Contains("beta") && !production)
            {
                BetaWarnForm form = new BetaWarnForm(this);
                form.ShowDialog();
            }

            if (show_mobile_warning && !production)
            {
                MobileWarnForm form = new MobileWarnForm(this);
                form.ShowDialog();
            }

            reportBugToolStripMenuItem.Visible = true;

            if (run_setup_wizard)
            {
                SetupWizard w = new SetupWizard(this, 0);
                w.ShowDialog();
                if (fwc_init && (current_model == Model.FLEX5000 || current_model == Model.FLEX3000))
                {
                    setupForm.ResetFLEX5000();
                    CheckCalData();
                    for (int i = 0; i < 8; i++)
                        flex5000DebugForm.SetPAPot(i, (byte)pa_bias_table[0][i]);
                    if (!FWCEEPROM.TRXChecksumPresent)
                    {
                        WriteTRXChecksums();
                        VerifyTRXChecksums();
                    }
                    RX1Band = RX2Band = TXBand = rx1_band;

                    switch (current_model)
                    {
                        case Model.FLEX5000:

                            Debug.WriteLine("rx1_band " + rx1_band);

                            fwcAntForm.SetBand(rx1_band);


                            fwcAntForm.CurrentAntMode = current_ant_mode;
                            fwcAntForm.RX1Ant = rx1_ant;
                            fwcAntForm.RX1Loop = rx1_loop;
                            fwcAntForm.RX2Ant = rx2_ant;
                            fwcAntForm.TXAnt = tx_ant;
                            fwcAntForm.TXAnt2 = tx_ant2; // ke9ns add .205
                            CheckRX2CalData();
                            break;
                    }
                }
                else if (hid_init && current_model == Model.FLEX1500)
                {
                    Check1500CalData();
                    Verify1500Checksums();

                    hidAntForm.SetBand(rx1_band);
                    hidAntForm.RXAnt = rx_ant_1500;
                    hidAntForm.TXAnt = tx_ant_1500;
                }
            } //  if (run_setup_wizard)

            if (rx1_meter_cal_offset == 0.0f)
            {
                switch (current_soundcard)
                {
                    case SoundCard.SANTA_CRUZ:
                        rx1_meter_cal_offset = -26.39952f;
                        break;
                    case SoundCard.AUDIGY_2_ZS:
                        rx1_meter_cal_offset = 1.024933f;
                        break;
                    case SoundCard.MP3_PLUS:
                        rx1_meter_cal_offset = -33.40224f;
                        break;
                    case SoundCard.EXTIGY:
                        rx1_meter_cal_offset = -29.30501f;
                        break;
                    case SoundCard.DELTA_44:
                        rx1_meter_cal_offset = -25.13887f;
                        break;
                    case SoundCard.FIREBOX:
                        rx1_meter_cal_offset = -20.94611f;
                        break;
                    case SoundCard.EDIROL_FA_66:
                        rx1_meter_cal_offset = -46.82864f;
                        break;
                    case SoundCard.UNSUPPORTED_CARD:
                        rx1_meter_cal_offset = -22.43533f;
                        break;
                }
            }

            if (rx1_display_cal_offset == 0.0f)
            {
                switch (current_soundcard)
                {
                    case SoundCard.SANTA_CRUZ:
                        RX1DisplayCalOffset = -56.56675f;
                        break;
                    case SoundCard.AUDIGY_2_ZS:
                        RX1DisplayCalOffset = -29.20928f;
                        break;
                    case SoundCard.MP3_PLUS:
                        RX1DisplayCalOffset = -62.84578f;
                        break;
                    case SoundCard.EXTIGY:
                        RX1DisplayCalOffset = -62.099f;
                        break;
                    case SoundCard.DELTA_44:
                        RX1DisplayCalOffset = -57.467f;
                        break;
                    case SoundCard.FIREBOX:
                        RX1DisplayCalOffset = -54.019f;
                        break;
                    case SoundCard.EDIROL_FA_66:
                        RX1DisplayCalOffset = -80.429f;
                        break;
                    case SoundCard.UNSUPPORTED_CARD:
                        RX1DisplayCalOffset = -48.62103f;
                        break;
                }
            }

            /*if(notify_on_beta || notify_on_release)
            {
                Thread t = new Thread(new ThreadStart(CheckForUpdates));
                t.IsBackground = true;
                t.Priority = ThreadPriority.Lowest;
                t.Name = "Update Check Thread";
                t.Start();
            }*/

            foreach (string s in CmdLineArgs)
            {
                if (s == "-autostart")
                    chkPower.Checked = true;
                else if (s.StartsWith("-datapath:"))
                {
                    string path = s.Substring(s.IndexOf(":") + 1);
                    if (Directory.Exists(path)) AppDataPath = path;
                }
            }

            Debug.WriteLine("console0");

            if ((current_model == Model.FLEX5000 || current_model == Model.FLEX3000) && !fwc_init)
                MessageBox.Show(new Form { TopMost = true }, "Error opening radio driver.", "Driver Error", MessageBoxButtons.OK, MessageBoxIcon.Error);

            if (current_model == Model.FLEX1500 && !hid_init)
                MessageBox.Show(new Form { TopMost = true }, "Error opening radio driver.", "Driver Error", MessageBoxButtons.OK, MessageBoxIcon.Error);

            if (!fwc_init || !FWCEEPROM.RX2OK)
            {
                chkRX2.Checked = false;
                chkSplitDisplay.Checked = false;
            }
            /*
             Common.RestoreForm(XVTRForm, "XVTR", false);
             if (FWCEEPROM.VUOK)
             {
                 FWC.SetEN2M(true); //XVINT
                 XVTRForm.udUCBAddr0.Value = 0;
                 XVTRForm.txtButtonText0.Text = "2m";
                 XVTRForm.udLOOffset0.Value = 125;
                 XVTRForm.udLOError0.Value = 0;
                 XVTRForm.udFreqBegin0.Value = 144;
                 XVTRForm.udFreqEnd0.Value = 148;
                 //XVTRForm.udRXGain0.Value = 32;
                 XVTRForm.chkRXOnly0.Checked = false;
                 XVTRForm.udPower0.Value = 100;
                 XVTRForm.chkXVTRRF0.Checked = false;

                 XVTRForm.udUCBAddr1.Value = 1;
                 XVTRForm.txtButtonText1.Text = "70cm";
                 XVTRForm.udLOOffset1.Value = 400;
                 XVTRForm.udLOError1.Value = 0;
                 XVTRForm.udFreqBegin1.Value = 430;
                 XVTRForm.udFreqEnd1.Value = 450;
                 //XVTRForm.udRXGain1.Value = 28;
                 XVTRForm.chkRXOnly1.Checked = false;
                 XVTRForm.udPower1.Value = 100;
                 XVTRForm.chkXVTRRF1.Checked = false;

                 XVTRForm.chkEnable0.Checked = true;
                 XVTRForm.chkEnable1.Checked = true;
                 XVTRForm.chkVHFIFGain.Enabled = true;
                 XVTRForm.chkUHFIFGain.Enabled = true;
                 XVTRForm.chkVHFPAEnable.Enabled = true;
                 XVTRForm.chkUHFPAEnable.Enabled = true;
                 XVTRForm.label_VUModulePresent.Visible = true;
                 XVTRForm.label_VUModuleNotPresent.Visible = false;

             }
             else
             {
                 XVTRForm.chkEnable0.Checked = false;
                 XVTRForm.chkEnable1.Checked = false;
                 XVTRForm.chkVHFIFGain.Enabled = false;
                 XVTRForm.chkUHFIFGain.Enabled = false;
                 XVTRForm.chkVHFPAEnable.Enabled = false;
                 XVTRForm.chkUHFPAEnable.Enabled = false;
                 XVTRForm.chkEnable0.Checked = false;
                 XVTRForm.chkEnable1.Checked = false;
                 XVTRForm.label_VUModulePresent.Visible = false;
                 XVTRForm.label_VUModuleNotPresent.Visible = true;
             }
              */

#if (DEBUG)
            //button1.Visible = true;
            //buttonTS1.Visible = true;
#endif
            SyncDSP();

            //  initializing = false; //.242 was here, no down below

#if (NO_DJ)
            //mod DH1TW
            //    this.Text = "PowerSDR-UI 0.997 based on FlexRadio Systems™ PowerSDR™ 2.7.2";
            //endmod

#endif
            txtVFOAFreq_LostFocus(this, EventArgs.Empty);
            txtVFOBFreq_LostFocus(this, EventArgs.Empty);

            if (setupForm != null)
            {
                if (setupForm.chkBoxAutoStart.Checked == true)
                {
                    chkPower.Checked = true;
                }
            }

            if (chkBoxBS.Checked == true) // ke9ns add: .153 turn on at startup if on when shut down last time.
            {
                BandStackMove(); // toggle on
            }


            // maximize3


            if (CONSOLEM == true)
            {
                //  Debug.WriteLine("MAXIMUM2" + CONSOLEL);
                this.Top = CONSOLET;
                this.Left = CONSOLEL;
                this.Width = CONSOLEW;
                this.Height = CONSOLEH;

                //  this.WindowState = FormWindowState.Normal;


                //   this.WindowState = FormWindowState.Maximized;


                //  Debug.WriteLine("MAXIMUM2");
            }

            // ke9ns .194  SS1 = panafall8020 = .833333  , SS2 = panafall = .5

            mouseholdY = (int)setupForm.udSS1H.Value; // ke9ns .197
            mouseholdYY = (int)setupForm.udSS2H.Value; // ke9ns .197


            if (!FWCEEPROM.RX2OK)
            {
                panelBandHFRX2.Enabled = false;
                panelBandGNRX2.Enabled = false;
                panelBandVHFRX2.Enabled = false;

                panelBandHFRX2.Visible = false;
                panelBandGNRX2.Visible = false;
                panelBandVHFRX2.Visible = false;
            }

            if (fwc_init && current_model == Model.FLEX5000 && FWCEEPROM.RX2OK)  // original
            {

                RX2BandButton = true;
                comboRX2Band_SelectedIndexChanged(this, EventArgs.Empty); //.210
            }

            if (radFMDeviation2kHz.Checked) //.236
            {
                lastdeviation = 2500;
                FMSEQ = 0;
                FMDeviation_Hz = 2500;
                radRX2ModeFMN.Text = "2FM";
                radModeFMN.Text = "2FM";
                dsp.GetDSPTX(0).TXFMDataMode = false;
                FMData = false;
            }
            else if (radFMDeviation5kHz.Checked)
            {
                lastdeviation = 5000;
                FMSEQ = 1;
                FMDeviation_Hz = 5000;
                radRX2ModeFMN.Text = "5FM";
                radModeFMN.Text = "5FM";
                dsp.GetDSPTX(0).TXFMDataMode = false;
                FMData = false;
            }
            else
            {
                lastdeviation = FMDataDeviation;
                FMSEQ = 2;
                radRX2ModeFMN.Text = "WFM";
                radModeFMN.Text = "WFM";
                FMDeviation_Hz = FMDataDeviation;
                FMData = true;
                FMDeviation10khz(); //.236
                dsp.GetDSPTX(0).TXFMDataMode = true;
            }

            dsp.GetDSPTX(0).TXFMDeviation = lastdeviation;

            Debug.WriteLine("===END=== Console here");

            initializing = false; //.242 moved down here

        } // public console


        //    protected override void OnClosed(EventArgs e)
        //    {
        //  base.OnClosed(e);

        //  Console.systemShutDown = true;

        //   }

        // protected override void OnClosing(CancelEventArgs e)
        //  {
        //  base.OnClosing(e);
        //   Console.systemShutDown = true;
        //  }



        //=============================================================================
        // ke9ns console_closing(), then formclosing, then Dispose(), then ExitConsole(), then back to Displose() to finish

        public bool reset_db = false;
        protected override void Dispose(bool disposing)
        {

            Debug.WriteLine("((((((((ENTER DISPOSE ROUTINE))))))))))))))))");

            StreamWriter writer = new StreamWriter(app_data_path + "shutdown2.log"); //   // look for %userprofile%\AppData\Roaming\FlexRadio Systems\PowerSDR v2.8.0\
            writer.AutoFlush = true;

            writer.WriteLine("Dispose: 1-5");

            writer.WriteLine("1) USB exit");

            USB.Exit(); // for 1500
            Thread.Sleep(300);

            writer.WriteLine("1) Done");

            writer.WriteLine("2) Disposing of components " + disposing);



            //   if (disposing)
            //  {
            if (components != null)
            {
                components.Dispose();
                writer.WriteLine("2a) Disposing of components " + disposing);

            }
            //  }


            Debug.WriteLine("disposed of components here");

            base.Dispose(disposing);


            writer.WriteLine("2) Done");


#if (NO_DJ)
            //mod DH1TW

            writer.WriteLine("3) Write DJConsole updates");

            try
            {
                if (DJConsoleObj != null) DJConsoleObj.Close(); //DJConsoleObj.Close();

            }
            catch (Exception e)
            {
                Debug.WriteLine("DJ exit fail " + e);
            }

            writer.WriteLine("3) Done");


            Thread.Sleep(200);
#endif

            Debug.WriteLine("((((((((Go to EXITCONSOLE here))))))))))))))))");

            writer.WriteLine("4) ExitConsole here... View PowerDown_3of3.log file for details");

            ExitConsole();   // ke9ns shutdown3.log    (PAL exit, TXProfile data, DB exit, DTTSP exit, and .Dispose of forms)

            writer.WriteLine("4) Done");
            Debug.WriteLine("((((((((return from EXITCONSOLE here))))))))))))))))");


            //-------------------------------------------------------------------------
            // ke9ns for a setup->factory defaults (reset the database)
            if (reset_db)
            {

                writer.WriteLine("5) reseting to factory defaults");

                string desktop = Environment.GetFolderPath(Environment.SpecialFolder.Desktop);
                string datetime = DateTime.Now.ToShortDateString().Replace("/", "-") + "_" + DateTime.Now.ToShortTimeString().Replace(":", ".");

                string file = db_file_name.Substring(db_file_name.LastIndexOf("\\") + 1);
                file = file.Substring(0, file.Length - 4);

                File.Copy(db_file_name, desktop + "\\PowerSDR_" + file + "_" + datetime + ".xml");
                File.Delete(db_file_name);

                writer.WriteLine("5) Done EXIT HERE");

            }
            else
            {
                writer.WriteLine("5) No Factory Defaults. done EXIT HERE");
            }



            Debug.WriteLine("((((((((TERMINATE PROGRM .......EXIT HERE.....))))))))))))))))");

            writer.Close(); // 2

            //    AutoClosingMessageBox.Show("Database Updated\nPowerSDR now Closed.", "PowerSDR Closed.", 2000);


        } // dispose


        #endregion


        #region Main
        // ======================================================
        // Main (this is called first, before Console()
        // ======================================================

        [STAThread]
        static void Main(string[] args)
        {

            Debug.WriteLine("===START=== Main here");

            string app_data_path = "";
            string app_data_path1 = ""; // ke9ns add for original 2.7.2 folder

            foreach (string s in args)
            {
                if (s.StartsWith("-datapath:"))
                {
                    string path = s.Trim().Substring(s.Trim().IndexOf(":") + 1);

                    if (path.EndsWith("\"")) path = path.Substring(0, path.Length - 1);

                    if (!path.EndsWith("\\")) path += "\\";
#if (DEBUG)
                    path += "Debug\\";
                  
#endif
                    if (Directory.Exists(path))
                        app_data_path = path;
                    else
                    {
                        DialogResult dr = MessageBox.Show(new Form { TopMost = true }, "-datapath: command line option found, but the folder specified was not found.\n" +
                            "Would you like to create this folder?  If not, the default folder will be used.\n\n" +
                            "(" + s + ")",
                            "Command Line Option: Create Folder?",
                            MessageBoxButtons.YesNo,
                            MessageBoxIcon.Question);

                        if (dr == DialogResult.Yes)
                        {
                            Directory.CreateDirectory(path);
                            app_data_path = path;
                        }
                    }
                }
            }




            //---------------------------------------------------------------------------------
            // ke9ns info:    Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData)  ==   %userprofile%\AppData\Roaming


            if (app_data_path == "")
            {
                Assembly assembly = Assembly.GetExecutingAssembly();
                FileVersionInfo fvi = FileVersionInfo.GetVersionInfo(assembly.Location);
                string version = fvi.FileVersion.Substring(0, fvi.FileVersion.LastIndexOf("."));
                //   app_data_path = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData)  + "\\FlexRadio Systems\\PowerSDR v" + version + "\\"; // ke9ns 2.8.0
                app_data_path = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) + "\\FlexRadio Systems\\PowerSDR v2.8.0\\"; // ke9ns add to copy over the old 2.7.2 folder into 2.8.0
                app_data_path1 = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) + "\\FlexRadio Systems\\PowerSDR v2.7.2\\"; // ke9ns add to copy over the old 2.7.2 folder into 2.8.0

#if (DEBUG)
                app_data_path += "Debug\\"; // ke9ns: this is what it will be:  %userprofile%\AppData\Roaming\FlexRadio Systems\PowerSDR v2.8.0\Debug\     C:\Users\RADIO\AppData\Roaming\FlexRadio Systems\PowerSDR v2.8.0\Debug\

#endif
            }

            try
            {
                if (!File.Exists(app_data_path + "wisdom"))  // look for %userprofile%\AppData\Roaming\FlexRadio Systems\PowerSDR v2.8.0\wisdom
                {
                    // Need to create the directory in %appdata% before we go run wisdom


                    if (!Directory.Exists(app_data_path))
                    {
                        Directory.CreateDirectory(app_data_path);   // create the new folder for the database and quickaudio:  %userprofile%\AppData\Roaming\FlexRadio Systems\PowerSDR v2.8.0\

                    }

                    if (!Directory.Exists(app_data_path + "\\QuickAudio")) // ke9ns add .190
                    {
                        Directory.CreateDirectory(app_data_path + "\\QuickAudio");   // create the new folder for the database and quickaudio:  %userprofile%\AppData\Roaming\FlexRadio Systems\PowerSDR v2.8.0\

                    }

                    /* 
                           ke9ns removed on 2/4/20 v2.7.2 causing issues with v2.8.0 database corruption

                                        if (Directory.Exists(app_data_path1)) // if 2.7.2 folder exists then copy is contents to new  2.8.0 folder
                                        {
                                            //  MessageBox.Show(new Form { TopMost = true }, "Found your 2.7.2 database and quickaudio files folder.\nFiles will be copied over so you dont lose anything.");

                                            DialogResult dr = MessageBox.Show(new Form { TopMost = true }, "Found your 2.7.2 database and quickaudio files folder.\nFiles will be copied over so you dont lose anything.",
                                              "Option:Copy 2.7.2 database and files to 2.8.0 Folder?",
                                              MessageBoxButtons.YesNo,
                                              MessageBoxIcon.Question);

                                            if (dr == DialogResult.Yes)
                                            {

                                                foreach (string dirPath in Directory.GetDirectories(app_data_path1, "*", SearchOption.AllDirectories))
                                                    Directory.CreateDirectory(dirPath.Replace(app_data_path1, app_data_path));

                                                //Copy all the files & Replaces any files with the same name
                                                foreach (string newPath in Directory.GetFiles(app_data_path1, "*.*", SearchOption.AllDirectories))
                                                    File.Copy(newPath, newPath.Replace(app_data_path1, app_data_path), true);

                                            }
                                        }
                                        else
                                        {
                                            MessageBox.Show(new Form { TopMost = true }, "No previous 2.7.2 folder found\nA new database file will be created and additional files will be installed");

                                        }

                    */
                    // ke9ns memory does not need to be copied, its back up 1 folder level in the  %userprofile%\AppData\Roaming\FlexRadio Systems\ folder

                    //-------------------------------------------------------------------------------------------
                    // ke9ns add: copy voacap and ke9ns folders from program files to roaming folder (THIS IS REQUIRED)

                    string path = Environment.GetFolderPath(Environment.SpecialFolder.CommonApplicationData) + "\\FlexRadio Systems\\PowerSDR";  // ke9ns this is the ProgramData folder
                                                                                                                                                 // Application.StartupPath  = \Program Files (x86)\FlexRadio Systems\PowerSDR v2.8.0

                    try
                    {
                        File.Copy(path + "\\ke9ns\\SWL.csv", app_data_path + "SWL.csv", true);
                    }
                    catch (Exception)
                    {

                    }

                    try
                    {
                        File.Copy(path + "\\ke9ns\\SWL2.csv", app_data_path + "SWL2.csv", true);
                    }
                    catch (Exception)
                    {

                    }
                    try
                    {
                        File.Copy(path + "\\ke9ns\\DXLOC.txt", app_data_path + "DXLOC.txt", true);
                    }
                    catch (Exception)
                    {

                    }
                    try
                    {
                        File.Copy(path + "\\ke9ns\\test24.bmp", app_data_path + "test24.bmp", true);
                    }
                    catch (Exception)
                    {

                    }
                    try
                    {
                        File.Copy(path + "\\ke9ns\\OP.bmp", app_data_path + "OP.bmp", true);
                    }
                    catch (Exception)
                    {

                    }
                    try
                    {
                        File.Copy(path + "\\ke9ns\\arrl.bmp", app_data_path + "arrl.bmp", true);
                    }
                    catch (Exception)
                    {

                    }
                    try
                    {
                        File.Copy(path + "\\ke9ns\\FCCDATA.dat", app_data_path + "FCCDATA.dat", true);
                    }
                    catch (Exception)
                    {

                    }
                    try
                    {
                        File.Copy(path + "\\ke9ns\\PowerSDR TX Waterfall ID.pdf", app_data_path + "PowerSDR TX Waterfall ID.pdf", true);
                    }
                    catch (Exception)
                    {

                    }

                    try
                    {
                        File.Copy(path + "\\ke9ns\\PowerSDR ke9ns v2.8 features_white.pdf", app_data_path + "PowerSDR ke9ns v2.8 features_white.pdf", true);
                    }
                    catch (Exception)
                    {

                    }
                    try
                    {
                        File.Copy(path + "\\ke9ns\\PowerSDR ke9ns keyboard shortcuts.pdf", app_data_path + "PowerSDR ke9ns keyboard shortcuts.pdf", true);
                    }
                    catch (Exception)
                    {

                    }
                    try
                    {

                        File.Copy(path + "\\ke9ns\\Quindar_tone_end.wav", app_data_path + "\\QuickAudio\\Quindar_tone_end.wav", true); // ke9ns add .190
                    }
                    catch (Exception)
                    {

                    }
                    try
                    {
                        File.Copy(path + "\\ke9ns\\Quindar_tone_start.wav", app_data_path + "\\QuickAudio\\Quindar_tone_start.wav", true);
                    }
                    catch (Exception)
                    {

                    }

                    foreach (string dirPath in Directory.GetDirectories(path + "\\itshfbc", "*", SearchOption.AllDirectories))
                        Directory.CreateDirectory(dirPath.Replace(path + "\\itshfbc", app_data_path + "\\itshfbc"));

                    foreach (string newPath in Directory.GetFiles(path + "\\itshfbc", "*.*", SearchOption.AllDirectories))
                        File.Copy(newPath, newPath.Replace(path + "\\itshfbc", app_data_path + "\\itshfbc"), true);


                    //-------------------------------------------------------------------------------------------------

                    Process p = Process.Start(Application.StartupPath + "\\fftw_wisdom.exe", "\"" + app_data_path);  //ke9ns  C:\Program Files (x86)\FlexRadio Systems\PowerSDR v2.8.0

                    // ke9ns creates wisdom file. used by sdr.c file

                    MessageBox.Show(new Form { TopMost = true }, "Running one time optimization.  Please wait patiently for " +
                        "this process to finish.\nTypically the optimization takes no more than 3-5 minutes.",
                        "Optimizing...",
                        MessageBoxButtons.OK,
                        MessageBoxIcon.Information);

                    p.WaitForExit();

                    /*    foreach (string dirPath in Directory.GetDirectories(SourcePath, "*",
                            SearchOption.AllDirectories))
                            Directory.CreateDirectory(dirPath.Replace(SourcePath, DestinationPath));

                        //Copy all the files & Replaces any files with the same name
                        foreach (string newPath in Directory.GetFiles(SourcePath, "*.*",
                            SearchOption.AllDirectories))
                            File.Copy(newPath, newPath.Replace(SourcePath, DestinationPath), true);
                    */

                }
                /*				else 
                                {
                                    string path = "wisdom";
                                    using (StreamReader sr = new StreamReader(path)) 
                                    {
                                        char [] block = new char[12];
                                        sr.ReadBlock(block,0,11);
                                        Debug.WriteLine("the block is "+block + "so let's check it");
                                        if (block.ToString() != "(fftw-3.2al")
                                        {
                                            sr.Close();
                                            File.Delete(Application.StartupPath+"\\wisdom");
                                            Process p = Process.Start(Application.StartupPath+"\\fftw_wisdom.exe");
                                            MessageBox.Show(new Form { TopMost = true }, "Running one time optimization.  Wisdom is from wrong version. Please wait patiently for "+
                                                "this process to finish.\nTypically the optimization takes no more than 3-5 minutes.",
                                                "Optimizing...",
                                                MessageBoxButtons.OK,
                                                MessageBoxIcon.Information);
                                            p.WaitForExit();
                                        }
                                    }

                                } */
                try
                {
                    if (!CheckForOpenProcesses()) // ke9ns check if another powersdr instance is running
                        return;
                }
                catch (Exception)
                {

                }
                Application.EnableVisualStyles();
                Application.DoEvents();

                //Application.Run(new Console(args));
                // wjt hacked

                Debug.WriteLine("===Start=== create Console() here "); // ke9ns: 

                theConsole = new Console(args);  // ke9ns: run Console here

                Debug.WriteLine("console1"); // ke9ns: 

                Application.Run(theConsole);

            }
            catch (Exception ex)
            {
                string msg = ex.Message + "\n\n" + ex.StackTrace.ToString();
                if (ex.InnerException != null) msg += "\n\n" + ex.InnerException.Message;
                MessageBox.Show(msg, "Fatal Error",
                    MessageBoxButtons.OK, MessageBoxIcon.Error);
            }

            Debug.WriteLine("===END=== MAIN here bad"); // ke9ns: never gets here
        } // main 

        #endregion


        #region Misc Routines
        // ======================================================
        // Misc Routines
        // ======================================================

        private void InitConsole()
        {

            separator = CultureInfo.CurrentCulture.NumberFormat.NumberDecimalSeparator; // .253 move here
            NI = CultureInfo.CurrentCulture.NumberFormat; //.240 to allow .NET 4.6 and higher

            Debug.WriteLine("CULTURE INFO >" + separator + "<>" + NI + "<");

            commands = new CATCommands(this, parser); // ke9ns add

            flexControlBasicForm = new FlexControlBasicForm(this);
            flexControlAdvancedForm = new FlexControlAdvancedForm(this);

            //--------------------------------------------------------------
            SetCurrentFlexControlMode(null, current_flexcontrol_mode);
            FlexControlScan_ThreadFunction();// FlexControlScan();


#if (DEBUG)
            uCBToolStripMenuItem.Visible = true;
            //button1.Visible = true;
#endif

#if (NO_TNF)
            btnTNFAdd.Visible = false;
            this.Controls.Remove(btnTNFAdd);
            btnTNFAdd = null;

            chkTNF.Visible = false;
            this.Controls.Remove(chkTNF);
            chkTNF = null;
#endif

            // EHR add nav support
            try
            {
                TDxDevice = new TDxInput.DeviceClass();
                TDxSensor = TDxDevice.Sensor;
                TDxDevice.Connect();
                if (TDxDevice.IsConnected)
                {
                    this.timer_navigate.Interval = 100; // 100mseconds
                    this.timer_navigate.Enabled = true;
                }
            }
            catch (Exception)
            {
                //MessageBox.Show(new Form { TopMost = true }, "SpaceNavigator not installed.", "No Navigator",
                //MessageBoxButtons.OK, MessageBoxIcon.Information);
            }
            // EHR end

            Thread.Sleep(300);
            UpdateBandStackRegisters();

            Audio.console = this;
            //FWCMidi.console = this;
            FWC.console = this;
            Display.console = this;  //

            Http.console = this;                   // ke9ns add


            Setup.console = this;                 // ke9ns add  setup.cs to this console so setup can talk to console
            IDBOX.console = this;                 // ke9ns add IDBOX to this console
            TOTBOX.console = this;                 // ke9ns add TOTBOX to this console


            SpotControl.console = this;           // ke9ns add  spot.cs to this console so spot can talk to console

            ScanControl.console = this;           // ke9ns add  scan.cs to this console so scan can talk to console
            StackControl.console = this;          // ke9ns add  stack.cs to this console so stack can talk to console
            SwlControl.console = this;            // ke9ns add  swl.cs to this console so stack can talk to console

            helpbox.console = this;            // ke9ns add  helpbox.cs to this console so stack can talk to console
            helpbox1.console = this;            // ke9ns add  helpbox1.cs to this console so stack can talk to console

            if (hid_init) Flex1500.Console = this;



            //--------------------------------------------------------------------------------------------------------
            // ke9ns: preload OFF defaults 

            chkDSPNB2.Enabled = true;

            vfoa_hover_digit = -1;
            vfob_hover_digit = -1;

            rx1_ant_by_band = new FWCAnt[(int)Band.LAST];

            for (int i = 0; i < (int)Band.LAST; i++) rx1_ant_by_band[i] = FWCAnt.ANT1;

            rx2_ant_by_band = new FWCAnt[(int)Band.LAST];
            for (int i = 0; i < (int)Band.LAST; i++) rx2_ant_by_band[i] = FWCAnt.RX2IN;

            tx_ant_by_band = new FWCAnt[(int)Band.LAST];
            for (int i = 0; i < (int)Band.LAST; i++) tx_ant_by_band[i] = FWCAnt.ANT1;

            tx_ant_by2_band = new FWCAnt[(int)Band.LAST]; // ke9ns add .205
            for (int i = 0; i < (int)Band.LAST; i++) tx_ant_by2_band[i] = FWCAnt.ANT1; // ke9ns add .205

            rx1_loop_by_band = new bool[(int)Band.LAST];
            rx1_preamp_by_band = new PreampMode[(int)Band.LAST];
            rx_ant_1500_by_band = new HIDAnt[(int)Band.LAST];
            for (int i = 0; i < (int)Band.LAST; i++) rx_ant_1500_by_band[i] = HIDAnt.PA;
            tx_ant_1500_by_band = new HIDAnt[(int)Band.LAST];
            for (int i = 0; i < (int)Band.LAST; i++) tx_ant_1500_by_band[i] = HIDAnt.PA;

            for (int i = 0; i < (int)Band.LAST; i++)
            {
                switch (current_model)
                {
                    case Model.FLEX1500:
                        switch ((Band)i)
                        {
                            case Band.B160M:
                            case Band.B80M:
                            case Band.B60M:
                            case Band.B40M:
                            case Band.B20M:
                                rx1_preamp_by_band[i] = (PreampMode)FLEX1500PreampMode.ZERO;
                                break;
                            case Band.B17M:
                            case Band.B15M:
                                rx1_preamp_by_band[i] = (PreampMode)FLEX1500PreampMode.PLUS_10;
                                break;
                            case Band.B12M:
                            case Band.B10M:
                                rx1_preamp_by_band[i] = (PreampMode)FLEX1500PreampMode.PLUS_20;
                                break;
                            case Band.B6M:
                                rx1_preamp_by_band[i] = (PreampMode)FLEX1500PreampMode.PLUS_30;
                                break;
                            default:
                                rx1_preamp_by_band[i] = (PreampMode)FLEX1500PreampMode.ZERO;
                                break;
                        }
                        break;
                    case Model.FLEX3000:
                        switch ((Band)i)
                        {
                            case Band.B6M:
                            case Band.B10M:
                                rx1_preamp_by_band[i] = PreampMode.HIGH;
                                break;
                            case Band.B12M:
                            case Band.B15M:
                                rx1_preamp_by_band[i] = PreampMode.MED;
                                break;
                            default:
                                rx1_preamp_by_band[i] = PreampMode.LOW;
                                break;
                        }
                        break;
                    case Model.FLEX5000:
                        switch ((Band)i)
                        {
                            case Band.B6M:
                            case Band.B10M:
                            case Band.B12M:
                            case Band.B15M:
                                rx1_preamp_by_band[i] = PreampMode.HIGH;
                                break;
                            default:
                                rx1_preamp_by_band[i] = PreampMode.OFF;
                                break;
                        }
                        break;
                    default:
                        rx1_preamp_by_band[i] = PreampMode.HIGH;
                        break;
                }
            }

            rx2_preamp_by_band = new PreampMode[(int)Band.LAST];
            for (int i = 0; i < (int)Band.LAST; i++) rx2_preamp_by_band[i] = PreampMode.HIGH;

            power_by_band = new int[(int)Band.LAST];
            for (int i = 0; i < (int)Band.LAST; i++) power_by_band[i] = 50;

            //=============================================
            // ke9ns add
            power_by_mode_by_band = new int[(int)Band.LAST, (int)DSPMode.LAST]; // set drive slider based on Mode and Band

            limit_by_mode_by_band = new int[(int)Band.LAST, (int)DSPMode.LAST]; // set TX max drive based on mode and band

            for (int i = 0; i < (int)Band.LAST; i++)
            {
                for (int ii = 0; ii < (int)DSPMode.LAST; ii++)
                {
                    power_by_mode_by_band[i, ii] = 50;    // default driver slider to 50
                    limit_by_mode_by_band[i, ii] = 100; // default drive limit to 100
                }
            }



            fm_tx_offset_by_band_mhz = new double[(int)Band.LAST];
            for (int i = 0; i < (int)Band.LAST; i++) // setup default FM offsets
            {
                switch ((Band)i)
                {
                    case Band.B6M: fm_tx_offset_by_band_mhz[i] = 1; break; // 1MHz
                    case Band.B10M: fm_tx_offset_by_band_mhz[i] = 0.1; break; // 100kHz
                    case Band.VHF0: fm_tx_offset_by_band_mhz[i] = 0.6; break; // 600kHz
                    case Band.VHF1: fm_tx_offset_by_band_mhz[i] = 5; break; // 5MHz
                    default: fm_tx_offset_by_band_mhz[i] = 0.1; break; // 100kHz
                }
            }

            rx1_agct_by_band = new int[(int)Band.LAST];
            rx2_agct_by_band = new int[(int)Band.LAST];

            for (int i = 0; i < (int)Band.LAST; i++)
            {
                switch ((Band)i)
                {
                    case Band.B160M:
                    case Band.B80M:
                    case Band.B60M:
                        rx1_agct_by_band[i] = 75;
                        rx2_agct_by_band[i] = 75;
                        break;
                    case Band.B40M:
                    case Band.B30M:
                        rx1_agct_by_band[i] = 80;
                        rx2_agct_by_band[i] = 80;
                        break;
                    case Band.B20M:
                    case Band.B17M:
                        rx1_agct_by_band[i] = 85;
                        rx2_agct_by_band[i] = 85;
                        break;
                    case Band.B10M:
                        rx1_agct_by_band[i] = 95;
                        rx2_agct_by_band[i] = 95;
                        break;
                    case Band.B6M:
                        switch (current_model)
                        {
                            case Model.FLEX3000:
                                rx1_agct_by_band[i] = 100;
                                break;
                            default:
                                rx1_agct_by_band[i] = 110;
                                break;
                        }
                        rx2_agct_by_band[i] = 110;
                        break;
                    default:
                        rx1_agct_by_band[i] = 90;
                        rx2_agct_by_band[i] = 90;
                        break;
                }
            }
            tx1_by_band = new bool[(int)Band.LAST];
            tx2_by_band = new bool[(int)Band.LAST];
            tx3_by_band = new bool[(int)Band.LAST];

            for (int i = 0; i < (int)Band.LAST; i++)
            {
                tx1_by_band[i] = tx2_by_band[i] = tx3_by_band[i] = true;
            }

            // ke9ns add .206
            tx1_by2_band = new bool[(int)Band.LAST];
            tx2_by2_band = new bool[(int)Band.LAST];
            tx3_by2_band = new bool[(int)Band.LAST];

            for (int i = 0; i < (int)Band.LAST; i++)
            {
                tx1_by2_band[i] = tx2_by2_band[i] = tx3_by2_band[i] = true;
            }


            vhf_text = new RadioButtonTS[15];
            vhf_text[0] = radBandVHF0;
            vhf_text[1] = radBandVHF1;
            vhf_text[2] = radBandVHF2;
            vhf_text[3] = radBandVHF3;
            vhf_text[4] = radBandVHF4;
            vhf_text[5] = radBandVHF5;
            vhf_text[6] = radBandVHF6;
            vhf_text[7] = radBandVHF7;
            vhf_text[8] = radBandVHF8;
            vhf_text[9] = radBandVHF9;
            vhf_text[10] = radBandVHF10;
            vhf_text[11] = radBandVHF11;
            vhf_text[12] = radBandVHF12;
            vhf_text[13] = radBandVHF13; //  vhf_text[index].Enabled = b;

            vhf_text2 = new RadioButtonTS[15]; //.212

            vhf_text2[0] = radBandVHF0RX2;
            vhf_text2[1] = radBandVHF1RX2;
            vhf_text2[2] = radBandVHF2RX2;
            vhf_text2[3] = radBandVHF3RX2;
            vhf_text2[4] = radBandVHF4RX2;
            vhf_text2[5] = radBandVHF5RX2;
            vhf_text2[6] = radBandVHF6RX2;
            vhf_text2[7] = radBandVHF7RX2;
            vhf_text2[8] = radBandVHF8RX2;
            vhf_text2[9] = radBandVHF9RX2;
            vhf_text2[10] = radBandVHF10RX2;
            vhf_text2[11] = radBandVHF11RX2;
            vhf_text2[12] = radBandVHF12RX2;
            vhf_text2[13] = radBandVHF13RX2; //  vhf_text2[index].Enabled = b;


            //   gen_text = new RadioButtonTS[15];  // ke9ns add dont know why yet
            //   gen_text[0] = radBandGEN0;
            //   gen_text[1] = radBandGEN1;
            //  gen_text[2] = radBandGEN2;
            //   gen_text[3] = radBandGEN3;
            //   gen_text[4] = radBandGEN4;
            //   gen_text[5] = radBandGEN5;
            //  gen_text[6] = radBandGEN6;
            //  gen_text[7] = radBandGEN7;
            //  gen_text[8] = radBandGEN8;
            //  gen_text[9] = radBandGEN9;
            //   gen_text[10] = radBandGEN10;
            //   gen_text[11] = radBandGEN11;
            //    gen_text[12] = radBandGEN12;
            //   gen_text[13] = radBandGEN13;



            radBandGN0.Enabled = true; // ke9ns add turn on all the buttons for GEN SWL
            radBandGN1.Enabled = true;
            radBandGN2.Enabled = true;
            radBandGN3.Enabled = true;
            radBandGN4.Enabled = true;
            radBandGN5.Enabled = true;
            radBandGN6.Enabled = true;
            radBandGN7.Enabled = true;
            radBandGN8.Enabled = true;
            radBandGN9.Enabled = true;
            radBandGN10.Enabled = true;
            radBandGN11.Enabled = true;
            radBandGN12.Enabled = true;
            radBandGN13.Enabled = true;

            radBandGN0RX2.Enabled = true; // ke9ns add turn on all the buttons for GEN SWL
            radBandGN1RX2.Enabled = true;
            radBandGN2RX2.Enabled = true;
            radBandGN3RX2.Enabled = true;
            radBandGN4RX2.Enabled = true;
            radBandGN5RX2.Enabled = true;
            radBandGN6RX2.Enabled = true;
            radBandGN7RX2.Enabled = true;
            radBandGN8RX2.Enabled = true;
            radBandGN9RX2.Enabled = true;
            radBandGN10RX2.Enabled = true;
            radBandGN11RX2.Enabled = true;
            radBandGN12RX2.Enabled = true;
            radBandGN13RX2.Enabled = true;


            vhf_power_table = new float[freqs_2m.Length];

            for (int i = 0; i < vhf_power_table.Length; i++)
            {
                vhf_power_table[i] = 0.0f;
            }
            uhf_power_table = new float[freqs_70cm.Length];

            for (int i = 0; i < vhf_power_table.Length; i++)
            {
                uhf_power_table[i] = 0.0f;
            }

            power_table = new float[(int)Band.LAST][];


            for (int i = 0; i < (int)Band.LAST; i++) // ke9ns: read all 42 band (13 values per band)
            {
                power_table[i] = new float[13]; // 1=160m, 8=15m band
            }

            rx1_image_gain_table = new float[(int)Band.LAST];
            rx1_image_phase_table = new float[(int)Band.LAST];
            rx2_image_gain_table = new float[(int)Band.LAST];
            rx2_image_phase_table = new float[(int)Band.LAST];
            tx_image_gain_table = new float[(int)Band.LAST];
            tx_image_phase_table = new float[(int)Band.LAST];

            tx_carrier_cal = new SortedDictionary<double, uint>();

            pa_bias_table = new int[4][]; // 4 groups of 8 pot settings
            for (int i = 0; i < 4; i++)
            {
                pa_bias_table[i] = new int[8];
                for (int j = 0; j < 8; j++)
                    pa_bias_table[i][j] = 0;
            }

            rx1_level_table = new float[(int)Band.LAST][]; // 3 settings per band (display_offset, preamp, multimeter offset)
            switch (current_model)
            {
                case Model.FLEX3000:
                    for (int i = 0; i < (int)Band.LAST; i++)
                    {
                        rx1_level_table[i] = new float[3];
                        rx1_level_table[i][0] = -71.0f;	// setup defaults;
                        rx1_level_table[i][1] = 19.8f;
                        rx1_level_table[i][2] = -26.0f;
                    }
                    break;
                case Model.FLEX1500:
                    for (int i = 0; i < (int)Band.LAST; i++)
                    {
                        rx1_level_table[i] = new float[3];
                        rx1_level_table[i][0] = -90.0f;	// setup defaults;
                        rx1_level_table[i][1] = 19.8f;
                        rx1_level_table[i][2] = 0.0f;
                    }
                    break;
                default:
                    for (int i = 0; i < (int)Band.LAST; i++)
                    {
                        rx1_level_table[i] = new float[3];
                        rx1_level_table[i][0] = -59.2f;	// setup defaults;
                        rx1_level_table[i][1] = -13.5f;
                        rx1_level_table[i][2] = -32.0f;
                    }
                    break;
            }

            rx2_level_table = new float[(int)Band.LAST][]; // 3 settings per band (display_offset, preamp, multimeter offset)
            for (int i = 0; i < (int)Band.LAST; i++)
            {
                rx2_level_table[i] = new float[3];
                rx2_level_table[i][0] = -59.2f; // setup defaults;
                rx2_level_table[i][1] = -13.5f;
                rx2_level_table[i][2] = -32.0f;
            }

            pa_bridge_table = new float[(int)Band.LAST][];
            for (int i = 0; i < (int)Band.LAST; i++)
            {
                pa_bridge_table[i] = new float[6]; // 1, 2, 5, 10, 20, 90
                for (int j = 0; j < 6; j++)
                    pa_bridge_table[i][j] = 0.0f;
            }

            swr_table = new float[(int)Band.LAST];
            for (int i = 0; i < (int)Band.LAST; i++)
                swr_table[i] = 1.0f;

            atu_swr_table = new float[(int)Band.LAST];
            for (int i = 0; i < (int)Band.LAST; i++)
                atu_swr_table[i] = 1.0f;

            uhf_level_table = new float[2];
            //uhf_level_table[0] = ??? // TODO: add default values
            //uhf_level_table[1] = ???

            vhf_level_table = new float[2];
            //vhf_level_table[0] = ???
            //vhf_level_table[1] = ???

            atu_tuning = false;
            tune_power = 10;
            calibrating = false;

            // get culture specific decimal separator

        //    separator = CultureInfo.CurrentCulture.NumberFormat.NumberDecimalSeparator;

       //     NI = CultureInfo.CurrentCulture.NumberFormat; //.240 to allow .NET 4.6 and higher

            // CultureInfo.DefaultThreadCurrentCulture = 



            last_band = "";						// initialize bandstack
            last_band2 = "";                    // .209

            tune_step_list = new List<TuneStep>();  // initialize wheel tuning list array
            tune_step_list.Add(new TuneStep(1, "1Hz")); //0
            tune_step_list.Add(new TuneStep(10, "10Hz")); //1
            tune_step_list.Add(new TuneStep(50, "50Hz")); //2
            tune_step_list.Add(new TuneStep(100, "100Hz")); //3
            tune_step_list.Add(new TuneStep(250, "250Hz"));
            tune_step_list.Add(new TuneStep(500, "500Hz"));
            tune_step_list.Add(new TuneStep(1000, "1kHz")); //6
            tune_step_list.Add(new TuneStep(2500, "2.5kHz"));
            tune_step_list.Add(new TuneStep(5000, "5kHz"));
            tune_step_list.Add(new TuneStep(6250, "6.25kHz"));
            tune_step_list.Add(new TuneStep(9000, "9kHz")); //10
            tune_step_list.Add(new TuneStep(10000, "10kHz"));
            tune_step_list.Add(new TuneStep(12500, "12.5kHz"));
            tune_step_list.Add(new TuneStep(15000, "15kHz"));
            tune_step_list.Add(new TuneStep(20000, "20kHz"));
            tune_step_list.Add(new TuneStep(25000, "25kHz"));
            tune_step_list.Add(new TuneStep(30000, "30kHz"));
            tune_step_list.Add(new TuneStep(50000, "50kHz"));
            tune_step_list.Add(new TuneStep(100000, "100kHz"));
            tune_step_list.Add(new TuneStep(250000, "250kHz"));
            tune_step_list.Add(new TuneStep(500000, "500kHz")); //20
            tune_step_list.Add(new TuneStep(1000000, "1MHz"));
            tune_step_list.Add(new TuneStep(10000000, "10MHz")); //22

            tune_step_index = 2;


            //  setupForm.tune_step_index2 = 2; // ke9ns add


            meter_text_history = new float[multimeter_text_peak_samples];

            current_meter_data = -200.0f;

            rx1_preamp_offset = new float[5];
            rx1_preamp_offset[(int)PreampMode.OFF] = 10.0f;
            rx1_preamp_offset[(int)PreampMode.LOW] = 0.0f;
            rx1_preamp_offset[(int)PreampMode.MED] = -16.0f;
            rx1_preamp_offset[(int)PreampMode.HIGH] = -26.0f;
            rx1_preamp_offset[(int)PreampMode.LAST] = -36.0f;

            rx2_preamp_offset = new float[4];
            rx2_preamp_offset[(int)PreampMode.OFF] = 0.0f;
            rx2_preamp_offset[(int)PreampMode.HIGH] = -14.0f;            // ke9ns mod  was 14.0f should be -14  not +14
                                                                         // when set to +14 it would cause the waterfall signal to jump up


            //--------------------------------------------------------------------------------------------------------
            // ke9ns: 

            Debug.WriteLine("INIT0");


            this.ActiveControl = chkPower;      // Power has focus initially

            Display.Target = picDisplay;         // ke9ns: resize to fill properly on startup?
            Display.Init();                     // Initialize Display variables
            InitDisplayModes();                 // Initialize Display Modes
            InitAGCModes();                     // Initialize AGC Modes
            InitMultiMeterModes();              // Initialize MultiMeter Modes
            Debug.WriteLine("INIT1");


            //--------------------------------------------------------------------------------------------------------
            // ke9ns: Start Threads up NOW
            ProcessSampleThreadController[] pstc = new ProcessSampleThreadController[3]; // DttSP.ProcessSamplesThread(thread); -> MUTE, Pass, Play, switch threads


            audio_process_thread = new Thread[3]; //  threads to run DttSP functions


            for (uint proc_thread = 0; proc_thread < 3; proc_thread++)
            {
                pstc[proc_thread] = new ProcessSampleThreadController(proc_thread);
                audio_process_thread[proc_thread] = new Thread(new ThreadStart(pstc[proc_thread].ProcessSampleThread));
                audio_process_thread[proc_thread].Name = "Audio Process Thread " + proc_thread.ToString();
                audio_process_thread[proc_thread].Priority = ThreadPriority.Highest;
                audio_process_thread[proc_thread].IsBackground = true;
                audio_process_thread[proc_thread].Start();

                /*				DttSP.SetThreadCom(proc_thread);

								audio_process_thread = new Thread(	// create audio process thread
									new ThreadStart(DttSP.ProcessSamplesThread));
								audio_process_thread.Name = "Audio Process Thread ";
								audio_process_thread.Priority = ThreadPriority.Highest;
								audio_process_thread.IsBackground = true;
								audio_process_thread.Start();
				*/
            }




            //	if(current_model == Model.SDR1000)              hw = new HW(0x378);				// create hardware object

            //BT 5/3/10 moved siolistener to last init item to prevent default data
            //being sent via CAT
            //EW 5/20/10 undid this change due to crashes when the secondary Keyer input was set to CAT
            siolisten = new SIOListenerII(this);    // original CAT
            siolisten2 = new SIOListenerII2(this);    // ke9ns .180 CAT port2
            siolisten3 = new SIOListenerII3(this);    // ke9ns CAT port3
            siolisten4 = new SIOListenerII4(this);    // ke9ns CAT port4
            siolisten5 = new SIOListenerII5(this);    // ke9ns CAT port5
            siolisten6 = new SIOListenerII6(this);    // ke9ns CAT port6 .200 spoof VFOA to B

            siolisten1 = new SIOListenerIII(this); // ke9ns add for rotor control


            CWSensorItem.Init();
            CWPTT.Init();
            CWPTT.MoxChanged += new CWPTT.MoxCallback(SetConsoleMox);
            CWPTT.MuteChanged += new CWPTT.MuteCallback(SetTRMute);

            eqForm = new EQForm(this);

            InitFilterPresets();                // Initialize filter values

            SwlForm = new SwlControl(this);         // ke9ns add communicate with swl list controls


            StackForm = new StackControl(this);     // ke9ns add communicate with bandstack controls
            helpboxForm = new helpbox(this);         // ke9ns add communicate with helpbox list controls
            helpbox1Form = new helpbox1(this);         // ke9ns add communicate with helpbox1 list controls

            httpFile = new Http(this);              // ke9ns add

            httpServer = new HttpServer(this);      // rn3kk add

            Debug.WriteLine("INIT2");

            setupForm = new Setup(this);        // ke9ns  create Setup form (needed so you can send data to setup form) Repeat for any form you want to send data too

            Debug.WriteLine("INIT3");

            skin1 = new Skin(this);

            IDBOXForm = new IDBOX(this);         // ke9ns create id timer message box now

            IDBOXForm.Show();
            IDBOXForm.Close();


            TOTBOXForm = new TOTBOX(this);         // ke9ns create TOT timer message box now

            TOTBOXForm.Show();
            TOTBOXForm.Close();


            setupForm.StartPosition = FormStartPosition.Manual;
            SwlForm.StartPosition = FormStartPosition.Manual;

            switch (current_model)
            {
                case Model.SDR1000:
                    Hdw.Init();                         // Power down hardware
                    Hdw.StandBy();                      // initialize hardware device
                    break;
                /*case Model.SDRX:
                    if(fwc_init)
                    {
                        byte mask;
                        FWC.GetRXPresentMask(out mask);
                        for(int i=0; i<8; i++)
                        {
                            if((mask>>i & 1) == 1)
                            {
                                fwc_index = i;
                                break;
                            }
                        }
                    }
                    break;*/
                case Model.FLEX5000:
                    if (fwc_init)
                        fwcMixForm = new FWCMixForm(this);
                    break;
                case Model.FLEX3000:
                    if (fwc_init)
                        flex3000MixerForm = new FLEX3000MixerForm(this);
                    break;
                case Model.FLEX1500:
                    if (hid_init)
                        flex1500MixerForm = new FLEX1500MixerForm(this);
                    break;
            }

            //SetupForm.GetTxProfiles();
            UpdateTXProfile(setupForm.TXProfile);

            Common.RestoreForm(eqForm, "EQForm", false);



            vuForm = new VUForm(this);
            xvtrForm = new XVTRForm(this);
            ucbForm = new UCBForm(this);

            WaveForm = new WaveControl(this);   // create Wave form

            WaveForm.StartPosition = FormStartPosition.Manual;

            ScanForm = new ScanControl(this);   // ke9ns add create Scan form
            ScanForm.StartPosition = FormStartPosition.Manual;

            memoryList = MemoryList.Restore();
            memoryList.CheckVersion();

            dxmemList = DXMemList.Restore1(); // ke9ns add for dx spotter
            dxmemList.CheckVersion1(); // ke9ns add


            InitMemoryFrontPanel();

            //rx1_filter = Filter.F2600;            

            //RX1AGCMode = AGCMode.MED;				// Initialize front panel controls
            comboPreamp.Text = "High";
            chkRX1Preamp.Checked = true;
            vfob_dsp_mode = DSPMode.LSB;
            vfob_filter = Filter.F3;
            comboDisplayMode.Text = "Panadapter";
            comboRX2DisplayMode.Text = "Panadapter";
            comboMeterRXMode.SelectedIndex = 0;
            comboRX2MeterMode.SelectedIndex = 0;
            comboTuneMode.SelectedIndex = 0;
            quick_save_filter = Filter.F3;
            quick_save_mode = DSPMode.LSB;
            ptbPWR.Value = 50;
            ptbTune.Value = 10; // ke9ns add
            btnDisplayPanCenter_Click(this, EventArgs.Empty);
            comboTXProfile.Text = setupForm.TXProfile;
            comboDigTXProfile.Text = setupForm.TXProfile;
            comboFMTXProfile.Text = setupForm.TXProfile;
            comboCWTXProfile.Text = setupForm.TXProfile;  // ke9ns add
            comboFMCTCSS.Text = "100.0";

            Debug.WriteLine("INIT4");

            GetState();                         // recall saved state

            Debug.WriteLine("INIT5");


            chkFullDuplex.Checked = false;
            if (rx1_dsp_mode == DSPMode.FIRST || rx1_dsp_mode == DSPMode.LAST)
                radModeSAM.Checked = true;
            if (rx2_dsp_mode == DSPMode.FIRST || rx2_dsp_mode == DSPMode.LAST)
                radRX2ModeSAM.Checked = true;
            if (rx1_filter == Filter.FIRST || rx1_filter == Filter.LAST ||
                (rx1_filter == Filter.NONE && rx1_dsp_mode != DSPMode.DRM && rx1_dsp_mode != DSPMode.SPEC))
                radFilter3.Checked = true;
            if (rx2_filter == Filter.FIRST || rx2_filter == Filter.LAST ||
                (rx2_filter == Filter.NONE && rx2_dsp_mode != DSPMode.DRM && rx2_dsp_mode != DSPMode.SPEC))
                radRX2Filter3.Checked = true;

            chkVFOATX_CheckedChanged(this, EventArgs.Empty);
            chkVFOBTX_CheckedChanged(this, EventArgs.Empty);
            
            Debug.WriteLine("INIT5a");
            txtVFOAFreq_LostFocus(this, EventArgs.Empty);
            txtVFOBFreq_LostFocus(this, EventArgs.Empty);

          


            if (fwc_init && !run_setup_wizard && (current_model == Model.FLEX5000 || current_model == Model.FLEX3000))
            {
                CheckCalData();

                if (!FWCEEPROM.TRXChecksumPresent) WriteTRXChecksums();

                VerifyTRXChecksums();

                if (fwcAntForm != null && !fwcAntForm.IsDisposed)
                {
                    Debug.WriteLine("1rx1_band " + rx1_band);

                    fwcAntForm.SetBand(rx1_band);
                    fwcAntForm.CurrentAntMode = current_ant_mode;
                    fwcAntForm.RX1Ant = rx1_ant;
                    fwcAntForm.RX1Loop = rx1_loop;
                    fwcAntForm.RX2Ant = rx2_ant;
                    fwcAntForm.TXAnt = tx_ant;
                    fwcAntForm.TXAnt2 = tx_ant2; // ke9ns add .205
                }
                RX1Ant = rx1_ant;
                if (FWCEEPROM.RX2OK)
                {
                    CheckRX2CalData();
                    if (!FWCEEPROM.RX2ChecksumPresent)
                        WriteRX2Checksums();
                    VerifyRX2Checksums();
                    RX2Ant = rx2_ant;
                }
            }
            else if (hid_init && !run_setup_wizard && current_model == Model.FLEX1500)
            {
                Check1500CalData();
                Verify1500Checksums();

                if (hidAntForm != null && !hidAntForm.IsDisposed)
                {
                    hidAntForm.SetBand(rx1_band);
                    hidAntForm.CurrentAntMode = current_ant_mode;
                    hidAntForm.RXAnt = rx_ant_1500;
                    hidAntForm.TXAnt = tx_ant_1500;
                }
                RXAnt1500 = rx_ant_1500;
                TXAnt1500 = tx_ant_1500;
            }
            else PAPresent = pa_present;

            if (comboAGC.SelectedIndex < 0) RX1AGCMode = AGCMode.MED;
            if (comboRX2AGC.SelectedIndex < 0) comboRX2AGC.Text = "Med";


            // ke9ns: call these routines to force initial updates to their values

            txtVFOBFreq_LostFocus(this, EventArgs.Empty);
            txtVFOAFreq_LostFocus(this, EventArgs.Empty);
            ptbTune_Scroll(this, EventArgs.Empty); // ke9ns add		
            ptbPWR_Scroll(this, EventArgs.Empty);

            ptbMON_Scroll(this, EventArgs.Empty); // ke9ns add

            ptbAF_Scroll(this, EventArgs.Empty);
            ptbSquelch_Scroll(this, EventArgs.Empty);
            ptbMic_Scroll(this, EventArgs.Empty);
            ptbDX_Scroll(this, EventArgs.Empty);
            ptbCPDR_Scroll(this, EventArgs.Empty);
            ptbVOX_Scroll(this, EventArgs.Empty);
            ptbNoiseGate_Scroll(this, EventArgs.Empty);
            ptbCWSpeed_Scroll(this, EventArgs.Empty);
            ptbPanMainRX_Scroll(this, EventArgs.Empty);
            ptbPanSubRX_Scroll(this, EventArgs.Empty);
            ptbRX2RF_Scroll(this, EventArgs.Empty);
            ptbRX2Squelch_Scroll(this, EventArgs.Empty);
            initializing = false;
            RX1PreampMode = rx1_preamp_mode;
            RX2PreampMode = rx2_preamp_mode;
            initializing = true;
            ptbDisplayZoom_Scroll(this, EventArgs.Empty);
            ptbRX0Gain_Scroll(this, EventArgs.Empty);
            ptbRX1Gain_Scroll(this, EventArgs.Empty);
            ptbPanMainRX_Scroll(this, EventArgs.Empty);
            ptbPanSubRX_Scroll(this, EventArgs.Empty);
            ptbRX2Pan_Scroll(this, EventArgs.Empty);
            ptbRX2Gain_Scroll(this, EventArgs.Empty);
            chkRX2Preamp_CheckedChanged(this, EventArgs.Empty);
            ptbRF_Scroll(this, EventArgs.Empty);
            ptbVACRXGain_Scroll(this, EventArgs.Empty);
            ptbVACTXGain_Scroll(this, EventArgs.Empty);


            CalcDisplayFreq();

            tune_step_index--;                  // Setup Mouse wheel tuning
            ChangeTuneStepUp();


            setupForm.tune_step_index2--;   // ke9ns add Powermate and Flexcontrol knob alt tuning #1
            setupForm.ChangeTuneStepUp2(); // ke9ns add

            setupForm.tune_step_index3--;   // ke9ns addadd Powermate  knob alt tuning #2
            setupForm.ChangeTuneStepUp3(); // ke9ns add

            setupForm.tune_step_index4 = setupForm.tune_step_index2;


            UpdateDisplayOffsets();

            setupForm.initCATandPTTprops();   // wjt added -- get console props setup for cat and ptt 
            if (CmdLineArgs != null)
            {
                for (int i = 0; i < CmdLineArgs.Length; i++)
                {

                }
            }

            if (comboMeterTXMode.Items.Count > 0 && comboMeterTXMode.SelectedIndex < 0) comboMeterTXMode.SelectedIndex = 0;

            if (comboMeterTX1Mode.Items.Count > 0 && comboMeterTX1Mode.SelectedIndex < 0) comboMeterTX1Mode.SelectedIndex = 0; // ke9ns add


            chkMOX.Enabled = false;

            //SyncDSP(); in a different location

            if (this.setupForm.FlexProfilerInstalled) remoteProfilesToolStripMenuItem.Visible = true;

            //EW 5/20/10 Moved this back up to where it was before to prevent crashes
            //siolisten = new SIOListenerII(this);

            if ((current_model == Model.FLEX1500) && !db_exists)    // for 1500 display centering
            {
                if_freq = 0.003800;
                setupForm.IFFreq = if_freq;
                chkSR.Checked = false;
                radDisplayZoom05.Checked = true;
            }


            Debug.WriteLine("Console: Create SpotControl Instance here");

            if (SpotForm == null || SpotForm.IsDisposed) SpotForm = new SpotControl(this);  // create spotform

            SpotForm.Show();
            SpotForm.Hide();


            if ((SpotForm.chkMapOn.Checked == true) && (SpotForm.mapon == false))
            {
                SpotForm.btnTrack_Click(this, EventArgs.Empty); // if box is checked and world map was OFF, Go turn ON
            }


            if ((SpotForm.chkDXOn.Checked == true) && (SpotForm.dxon == false))
            {
                SpotForm.SpotControl_Load(this, EventArgs.Empty);
                SpotForm.spotSSB_Click(this, EventArgs.Empty); // if box is checked and DX spotting OFF, Go turn ON
            }

            SpotForm.SWLLoad(); // ke9ns add preload up the SWL listing


            if (setupForm != null) // ke9ns add
            {
                Display.AGCT_Adj_Ratio = (double)setupForm.tbAGCTadj.Value / (double)1000.00;

                if (setupForm.chkBoxHERO.Checked == true)
                {
                    if ((fwc_init && (current_model == Model.FLEX5000 || current_model == Model.FLEX3000)) ||
                               (hid_init && current_model == Model.FLEX1500))
                    {
                        if (preSelForm == null || preSelForm.IsDisposed) preSelForm = new PreSelForm(this);

                        //  preSelForm.Show();
                        // preSelForm.Focus();
                        // preSelForm.WindowState = FormWindowState.Normal; // ke9ns add
                    }
                }
            }

            AutoWaterPan(); // ke9ns add .189 to force on/off
            setupForm.ChkSpectrumHiRes_CheckedChanged(this, EventArgs.Empty); // ke9ns add .189 to force on/off
            setupForm.chkBoxTOT_CheckedChanged(this, EventArgs.Empty); // ke9ns add .189 to force on/off

            if ((SpotForm.chkVoacap.Checked == true) && (SpotForm.voaon == false))
            {
                SpotForm.checkBoxMUF.Checked = true; // turn on voacap


                Debug.WriteLine("TURN ON MUF");

            }


            Debug.WriteLine("===END=== INITCONSOLE routine");

        } //Initconsole (from inside Console()  )


        //==================================================================
        // ke9ns disable this. caused a timing issue with CAT COM routines
        private void FlexControlScan()
        {
            //   Thread t = new Thread(new ThreadStart(FlexControlScan_ThreadFunction));
            //   t.Name = "FlexControl Scan";
            //   t.IsBackground = true;
            //   t.Priority = ThreadPriority.Normal;
            //  t.Start();
        }


        //===============================================================
        // ke9ns: no longer a thread. just do it and get over it.
        private void FlexControlScan_ThreadFunction()
        {

            FlexControlManager.Rescan();

            if (FlexControlManager.DeviceCount == 0) return;

            if (flexControlBasicForm.FlexControl == null) flexControlBasicForm.FlexControl = FlexControlManager.GetFlexControl(0);

            if (flexControlAdvancedForm.FlexControl == null) flexControlAdvancedForm.FlexControl = FlexControlManager.GetFlexControl(0);


        } // FlexControlScan_ThreadFunction()


        //================================================================
        // ke9ns: Get DSP up and running
        private void SyncDSP()
        {
            for (int i = 0; i < 2; i++)
            {
                for (int j = 0; j < 2; j++)
                {
                    DSPRX dsp_rx = dsp.GetDSPRX(i, j);
                    dsp_rx.Update = true;
                    dsp_rx.Force = true;
                    dsp_rx.BufferSize = dsp_rx.BufferSize;
                    dsp_rx.Force = false;
                }
            }

            for (int i = 0; i < 1; i++)
            {
                DSPTX dsp_tx = dsp.GetDSPTX(i);
                dsp_tx.Update = true;
                dsp_tx.Force = true;
                dsp_tx.BufferSize = dsp_tx.BufferSize;
                dsp_tx.Force = false;
            }

            DSP.SyncStatic();

            for (int i = 0; i < 2; i++)
            {
                for (int j = 0; j < 2; j++)
                {
                    DSPRX dsp_rx = dsp.GetDSPRX(i, j);
                    dsp_rx.Update = false;
                    dsp_rx.Force = true;
                    dsp_rx.Update = true;
                    dsp_rx.Force = false;
                }
            }

            for (int i = 0; i < 1; i++)
            {
                DSPTX dsp_tx = dsp.GetDSPTX(i);
                dsp_tx.Update = false;
                dsp_tx.Force = true;
                dsp_tx.Update = true;
                dsp_tx.Force = false;
            }
        } // SYNCDSP()


        //================================================================
        // ke9ns: Console_Closing(),  then Dispose() then ExitConsole();

        public void ExitConsole()
        {

            Debug.WriteLine("((((((((EXIT CONSOLE ENTER))))))))))))))))");

            StreamWriter writer = new StreamWriter(app_data_path + "shutdown3.log"); //   // look for %userprofile%\AppData\Roaming\FlexRadio Systems\PowerSDR v2.8.0\

            writer.AutoFlush = true;

            writer.WriteLine("ExitConsole(): 1-31");

            writer.WriteLine("1) PAL and FWCMIDI exit");

            try
            {   // always close Pal as it was open to detect radios
                //if (current_model == Model.FLEX5000 || current_model == Model.FLEX3000)
                {
                    Pal.Exit();
                    Thread.Sleep(100);
                    FWCMidi.Close();
                    Thread.Sleep(100);
                }
            }
            catch (Exception e)
            {
                Debug.WriteLine("PAL exit fail " + e);
                writer.WriteLine("1) PAL and FWCMIDI FAILURE");

            }

            writer.WriteLine("1) Done");


            //----------------------------------------------------------------------------------


            writer.WriteLine("2) Check for SaveTX profile on exit here");

            Debug.WriteLine("((((((((CHECK...SAVETXPROFILEDATA))))))))))))))))");

            if (setupForm != null)
            {
                if (SaveTXProfileOnExit == true)    // save the tx profile
                {
                    Debug.WriteLine("((((((((SAVETXPROFILEDATA))))))))))))))))");

                    setupForm.SaveTXProfileData();

                    writer.WriteLine("2) Saving TXPROFILE variables to ArrayList Database XML ");
                }
            }
            writer.WriteLine("2) Done");


            writer.WriteLine("3) SAVE DATABASE TO FILE NAME: " + db_file_name);
            writer.WriteLine("3) Check PowerDown3.log for DB details ");



            Thread.Sleep(100);

            Debug.WriteLine("((((((((SAVING DATABASE))))))))))))))))");

            DB.Exit();                  // close and save database

            writer.WriteLine("3) Done");
            Thread.Sleep(100);
            //----------------------------------------------------------------




            Debug.WriteLine("((((((((BEGIN DISPOSING FORMS))))))))))))))))");


            try
            {
                writer.WriteLine("5) Dispose memoryform");
                if (memoryForm != null) memoryForm.Dispose();
                writer.WriteLine("5) Done");
            }
            catch (Exception e)
            {
                writer.WriteLine("5) Failure " + e);
                Debug.WriteLine("Dispose failure14 " + e);
            }
            try
            {
                writer.WriteLine("6) Dispose cxw");
                if (cwxForm != null) cwxForm.Dispose();
                writer.WriteLine("6) Done");
            }
            catch (Exception e)
            {
                writer.WriteLine("6) Failure " + e);
                Debug.WriteLine("Dispose failure2 " + e);
            }

            try
            {
                writer.WriteLine("7) Dispose cxw");
                if (StackForm != null) StackForm.Dispose(); // ke9ns add
                writer.WriteLine("7) Done");
            }
            catch (Exception e)
            {
                writer.WriteLine("7) Failure " + e);
                Debug.WriteLine("Dispose failure18 " + e);
            }

            /*       try
                   {
                       writer.WriteLine("7a) Dispose SPOTFORM");
                       if (SpotForm != null) SpotForm.Dispose(); // ke9ns add
                       writer.WriteLine("7a) Done");
                   }
                   catch (Exception e)
                   {
                       writer.WriteLine("7a) Failure " + e);
                       Debug.WriteLine("Dispose failure18 " + e);
                   }
       */

            Debug.WriteLine("(((((((DISPOSING FORMS5))))))))))))))))");

            try
            {
                writer.WriteLine("8) Dispose scan");
                if (ScanForm != null) ScanForm.Dispose(); // ke9ns add scanner form
                writer.WriteLine("8) Done");
            }
            catch (Exception e)
            {
                writer.WriteLine("8) Failure " + e);
                Debug.WriteLine("Dispose failure20 " + e);
            }


            try
            {
                writer.WriteLine("9) Dispose scan");
                if (IDBOXForm != null) IDBOXForm.Dispose(); // ke9ns add ID timer box
                writer.WriteLine("9) Done");
            }
            catch (Exception e)
            {
                writer.WriteLine("9) Failure " + e);
                Debug.WriteLine("Dispose failure21 " + e);
            }

            try
            {
                writer.WriteLine("10) Dispose help");
                if (helpboxForm != null) helpboxForm.Dispose(); // ke9ns add help screen
                writer.WriteLine("10) Done");
            }
            catch (Exception e)
            {
                writer.WriteLine("10) Failure " + e);
                Debug.WriteLine("Dispose failure22 " + e);
            }

            try
            {
                writer.WriteLine("11) Dispose help1");
                if (helpbox1Form != null) helpbox1Form.Dispose(); // ke9ns add help screen
                writer.WriteLine("11) Done");
            }
            catch (Exception e)
            {
                writer.WriteLine("11) Failure " + e);
                Debug.WriteLine("Dispose failure22a " + e);
            }

            try
            {
                writer.WriteLine("12) Dispose totbox");
                if (TOTBOXForm != null) TOTBOXForm.Dispose(); // ke9ns add time out timer
                writer.WriteLine("12) Done");
            }
            catch (Exception e)
            {
                writer.WriteLine("12) failure " + e);
                Debug.WriteLine("Dispose failure " + e);
            }

            try
            {
                writer.WriteLine("13) Dispose eq");
                if (eqForm != null) eqForm.Dispose();
                writer.WriteLine("13) Done");
            }
            catch (Exception e)
            {
                writer.WriteLine("13) failure " + e);
                Debug.WriteLine("Dispose failure3 " + e);
            }

            try
            {
                writer.WriteLine("14) Dispose ucb");
                if (ucbForm != null) ucbForm.Dispose();
                writer.WriteLine("14) Done");
            }
            catch (Exception e)
            {
                writer.WriteLine("14) failure " + e);
                Debug.WriteLine("Dispose failure4 " + e);
            }

            try
            {
                writer.WriteLine("15) Dispose 3000mixer");
                if (flex3000MixerForm != null) flex3000MixerForm.Dispose();
                writer.WriteLine("15) Done");
            }
            catch (Exception e)
            {
                writer.WriteLine("15) failure " + e);
                Debug.WriteLine("Dispose failure5 " + e);
            }

            try
            {
                writer.WriteLine("16) Dispose xvtr");
                if (xvtrForm != null) xvtrForm.Dispose();
                writer.WriteLine("16) Done");
            }
            catch (Exception e)
            {
                writer.WriteLine("16) failure " + e);
                Debug.WriteLine("Dispose failure6 " + e);
            }

            try
            {
                writer.WriteLine("17) Dispose prodtest");
                if (ProdTestForm != null) ProdTestForm.Dispose();
                writer.WriteLine("17) Done");
            }
            catch (Exception e)
            {
                writer.WriteLine("17) failure " + e);
                Debug.WriteLine("Dispose failure7 " + e);
            }
            Debug.WriteLine("(((((((DISPOSING FORMS15))))))))))))))))");

            try
            {
                writer.WriteLine("18) Dispose fwcmix");
                if (fwcMixForm != null) fwcMixForm.Dispose();
                writer.WriteLine("18) Done");
            }
            catch (Exception e)
            {
                writer.WriteLine("18) failure " + e);
                Debug.WriteLine("Dispose failure8 " + e);
            }

            try
            {
                writer.WriteLine("19) Dispose 1500mix");
                if (flex1500MixerForm != null) flex1500MixerForm.Dispose();
                writer.WriteLine("19) Done");
            }
            catch (Exception e)
            {
                writer.WriteLine("19) failure " + e);
                Debug.WriteLine("Dispose failure9 " + e);
            }

            try
            {
                writer.WriteLine("20) Dispose 5000LLH");
                if (flex5000LLHWForm != null) flex5000LLHWForm.Dispose();
                writer.WriteLine("20) Done");
            }
            catch (Exception e)
            {
                writer.WriteLine("20) failure " + e);
                Debug.WriteLine("Dispose failure10 " + e);
            }

            try
            {
                writer.WriteLine("21) Dispose 5000debug");
                if (flex5000DebugForm != null) flex5000DebugForm.Dispose();
                writer.WriteLine("21) Done");
            }
            catch (Exception e)
            {
                writer.WriteLine("21) failure " + e);
                Debug.WriteLine("Dispose failure11 " + e);
            }

            try
            {
                writer.WriteLine("22) Dispose flexcontrolbasic");
                if (flexControlBasicForm != null) flexControlBasicForm.Dispose();
                writer.WriteLine("22) Done");
            }
            catch (Exception e)
            {
                writer.WriteLine("22) failure " + e);
                Debug.WriteLine("Dispose failure12 " + e);
            }

            try
            {
                writer.WriteLine("23) Dispose flexcontroladv");
                if (flexControlAdvancedForm != null) flexControlAdvancedForm.Dispose();
                writer.WriteLine("23) Done");
            }
            catch (Exception e)
            {
                writer.WriteLine("23) failure " + e);
                Debug.WriteLine("Dispose failure13 " + e);
            }


            try
            {
                writer.WriteLine("24) Dispose presel");
                if (preSelForm != null) preSelForm.Dispose();
                writer.WriteLine("24) Done");
            }
            catch (Exception e)
            {
                writer.WriteLine("24) failure " + e);
                Debug.WriteLine("Dispose failure15 " + e);
            }

            try
            {
                writer.WriteLine("25) Dispose wave");
                if (WaveForm != null) WaveForm.Dispose(); // ke9ns add
                writer.WriteLine("25) Done");
            }
            catch (Exception e)
            {
                writer.WriteLine("25) failure " + e);
                Debug.WriteLine("Dispose failure16 " + e);
            }

            try
            {
                writer.WriteLine("26) Dispose swl");
                if (SwlForm != null) SwlForm.Dispose(); // ke9ns add
                writer.WriteLine("26) Done");
            }
            catch (Exception e)
            {
                writer.WriteLine("26) failure " + e);
                Debug.WriteLine("Dispose failure17 " + e);
            }

            try
            {
                writer.WriteLine("27) Dispose fwcatu");
                if (fwcAtuForm != null) fwcAtuForm.Dispose();
                writer.WriteLine("27) Done");
            }
            catch (Exception e)
            {
                writer.WriteLine("27) failure " + e);
                Debug.WriteLine("Dispose failure30 " + e);
            }


            //-------------------------------------------------------------------
            if (chkPower.Checked == true) chkPower.Checked = false;   // make sure power is off		
            if (ckQuickRec.Checked == true) ckQuickRec.Checked = false; // make sure recording is stopped

            Thread.Sleep(100);

            writer.WriteLine("28) PA Terminate");

            Debug.WriteLine("((((((((PA TERMINATE))))))))))))))))");


            //			if(draw_display_thread != null)
            //				draw_display_thread.Abort();

            //Parallel.ExitPortTalk();	// close parallel port driver (SDR-1000 ?)
            PA19.PA_Terminate();        // terminate audio interface
                                        //Mixer.RestoreState();		// restore initial mixer state

            writer.WriteLine("28) Done");
            writer.WriteLine("29) DttSP Exit");
            Thread.Sleep(100);


            writer.WriteLine("29) DTTSP NOW");


            DttSP.Exit();               // deallocate DSP variables

            writer.WriteLine("29) Done");
            Debug.WriteLine("((((((((DTTSP EXIT))))))))))))))))");


            Thread.Sleep(100);

            writer.WriteLine("30) ReleaseMutex");
            //-----------------------------------------------------------------------------------
            // release PowerSDR Mutex from instance that created it
            try
            {
                if (psdr2_mutex_exists)
                {
                    psdr2_mutex.ReleaseMutex();
                }
                writer.WriteLine("30) Done");
            }
            catch (Exception e)
            {
                writer.WriteLine("30) Failure " + e);
                Debug.WriteLine("Mutex exit fail " + e);

            }


            try
            {
                writer.WriteLine("4) Dispose Setupform");
                if (setupForm != null && !setupForm.IsDisposed) setupForm.Dispose();
                writer.WriteLine("4) Done");
            }
            catch (Exception e)
            {
                writer.WriteLine("4) Failure " + e);
                Debug.WriteLine("Dispose failure1 " + e);
            }


            writer.WriteLine("31) EXITCONSOLE DONE. Rejoin back to shutdown");

            writer.Close();



            // ke9ns return back to dispose()
        } // ExitConsole()



        //==============================================================================================
        //==============================================================================================
        //ke9ns   SAVE in DATABASE 
        //==============================================================================================
        //==============================================================================================
        public void SaveState()
        {
            // Automatically saves all control settings to the database in the tab
            // pages on this form of the following types: CheckBox, ComboBox,
            // NumericUpDown, RadioButton, TextBox, and TrackBar (slider)



            string s;

            if (chkPower.Checked == true)
            {
                chkPower.Checked = false;       // turn off the power first
                Thread.Sleep(300);
            }

            //-------------------------------------------------------------------
            // ke9ns add  create database to store my stuff in

            SWR_Logger_Write(); // save SWR data


            //-------------------------------------------------------------------------------

            string file_name2 = AppDataPath + "ke9ns8.dat"; // save data for my mods

            FileStream stream2 = new FileStream(file_name2, FileMode.Create); // open  file
            BinaryWriter writer2 = new BinaryWriter(stream2);

            //    if (Audio.MON_PRE == 1) Debug.WriteLine("Saving PRE = 1");
            //    else Debug.WriteLine("Saving PRE = 0");

            writer2.Write((double)WaterfallLowThresholdMic);      // TX low level waterfall threshold
            writer2.Write(setupForm.checkWaterMoveSize.Checked);  // large waterfall move
            writer2.Write(Display.GrayScale);                    // color or grayscale watetfall
            writer2.Write((byte)WaveForm.BandL);                 // save mode for check of valid waterfall ID later  // RX1DSPMode != BandL
            writer2.Write(Display.PW_AVG);                       // save avgP or avgB  RX1
            writer2.Write(Display.PW_AVG2);                      // save avgp or avgB RX2
            writer2.Write(Audio.MON_PRE);                        // save MONitor pre or post audio

            if (setupForm.gridBoxTS.Checked == true) Display.GridOff = 1; // gridlines OFF
            else Display.GridOff = 0; // gridlines ON

            writer2.Write(Display.GridOff);                      // save panadapter grid on/off
            writer2.Write(WaveControl.QAC);                      // QUickaudio file #

            writer2.Write(SpotControl.nameB);               // name for dx spotter
            writer2.Write(SpotControl.callB);               // call sign for dx spotter
            writer2.Write(SpotControl.nodeB);               // node  for dx spotter
            writer2.Write(SpotControl.portB);               // port for dx spotter

            writer2.Write(callsign);                             // callsign for waterfall ID
            writer2.Write(lastcallsign);                         // last callsign test for valid waterfall ID

            writer2.Write((byte)PAON);                           // temp/volts on/off console display
            writer2.Write((byte)noaaON);                          // space weather console display

            writer2.Write((byte)setupForm.tune_step_index2);      // save Powermate knob index

            writer2.Write((byte)setupForm.tune_step_index3);      // save Powermate knob index

            writer2.Write("end");

            //  writer2.Write(callsign);                  // callsign test
            //  writer2.Write(Display.samplesPerSecondL);  // last samplerate


            writer2.Close();    // close  file
            stream2.Close();   // close stream
                               //   Debug.WriteLine("save database file on exit");

            PAON = 0;       // shut down PAON thread
                            //--------------------------------------------------------------------

            //   Debug.WriteLine("-nameB " + SpotControl.nameB);
            //   Debug.WriteLine("-portB " + SpotControl.portB);
            //  Debug.WriteLine("-callB " + SpotControl.callB);
            //  Debug.WriteLine("-nodeB " + SpotControl.nodeB);


            //   MessageBox.Show(new Form { TopMost = true }, "Done saving SWL_Logger, and ke9ns8.dat, now Put STATE variables into ArrayList database XML structure");


            Debug.WriteLine("KE9NS FILE CLOSED ");


            //   Debug.WriteLine("mic " + WaterfallLowThresholdMic);
            //   Debug.WriteLine("large " + setupForm.checkWaterMoveSize.Checked);
            //   Debug.WriteLine("call " + callsign);
            //   Debug.WriteLine("callL " + LastCall);

            ArrayList a = new ArrayList();     // storage for saving everything


            foreach (Control c in this.Controls)            // For each control
            {
                // if it is a groupbox or panel, check for sub controls
                if (c.GetType() == typeof(GroupBoxTS) || c.GetType() == typeof(PanelTS))
                {
                    foreach (Control c2 in c.Controls)  // for each sub-control
                    {   // check to see if it is a value type we need to save
                        if (c2.Enabled)
                        {
                            if (c2.GetType() == typeof(CheckBoxTS))
                                a.Add(c2.Name + "/" + ((CheckBoxTS)c2).Checked.ToString());
                            else if (c2.GetType() == typeof(ComboBoxTS))
                            {
                                if (((ComboBoxTS)c2).Items.Count > 0)
                                    a.Add(c2.Name + "/" + ((ComboBoxTS)c2).Text);
                            }
                            else if (c2.GetType() == typeof(NumericUpDownTS))
                                a.Add(c2.Name + "/" + ((NumericUpDownTS)c2).Value.ToString());
                            else if (c2.GetType() == typeof(RadioButtonTS))
                                a.Add(c2.Name + "/" + ((RadioButtonTS)c2).Checked.ToString());
                            else if (c2.GetType() == typeof(TextBoxTS))
                            {
                                if (((TextBoxTS)c2).ReadOnly == false)
                                    a.Add(c2.Name + "/" + ((TextBoxTS)c2).Text);
                            }
                            else if (c2.GetType() == typeof(TrackBarTS))
                                a.Add(c2.Name + "/" + ((TrackBarTS)c2).Value.ToString());
                            else if (c2.GetType() == typeof(PrettyTrackBar))
                                a.Add(c2.Name + "/" + ((PrettyTrackBar)c2).Value.ToString());
#if (DEBUG)
                            else if (c2.GetType() == typeof(GroupBox) ||
                                c2.GetType() == typeof(CheckBox) ||
                                c2.GetType() == typeof(ComboBox) ||
                                c2.GetType() == typeof(NumericUpDown) ||
                                c2.GetType() == typeof(RadioButton) ||
                                c2.GetType() == typeof(TextBox) ||
                                c2.GetType() == typeof(TrackBar))
                                Debug.WriteLine(c2.Name + " needs to be converted to a Thread Safe control.");
#endif
                        }
                    }
                }
                else // it is not a group box
                {   // check to see if it is a value type we need to save
                    if (c.Enabled)
                    {
                        if (c.GetType() == typeof(CheckBoxTS))
                            a.Add(c.Name + "/" + ((CheckBoxTS)c).Checked.ToString());
                        else if (c.GetType() == typeof(ComboBoxTS))
                        {
                            if (((ComboBoxTS)c).SelectedIndex >= 0)
                                a.Add(c.Name + "/" + ((ComboBoxTS)c).Text);
                        }
                        else if (c.GetType() == typeof(NumericUpDownTS))
                            a.Add(c.Name + "/" + ((NumericUpDownTS)c).Value.ToString());
                        else if (c.GetType() == typeof(RadioButtonTS))
                            a.Add(c.Name + "/" + ((RadioButtonTS)c).Checked.ToString());
                        else if (c.GetType() == typeof(TextBoxTS))
                        {
                            if (((TextBoxTS)c).ReadOnly == false)
                                a.Add(c.Name + "/" + ((TextBoxTS)c).Text);
                        }
                        else if (c.GetType() == typeof(TrackBarTS))
                            a.Add(c.Name + "/" + ((TrackBarTS)c).Value.ToString());
                        else if (c.GetType() == typeof(PrettyTrackBar))
                            a.Add(c.Name + "/" + ((PrettyTrackBar)c).Value.ToString());
#if (DEBUG)
                        else if (c.GetType() == typeof(GroupBox) ||
                            c.GetType() == typeof(CheckBox) ||
                            c.GetType() == typeof(ComboBox) ||
                            c.GetType() == typeof(NumericUpDown) ||
                            c.GetType() == typeof(RadioButton) ||
                            c.GetType() == typeof(TextBox) ||
                            c.GetType() == typeof(TrackBar))
                            Debug.WriteLine(c.Name + " needs to be converted to a Thread Safe control.");
#endif
                    }
                }
            }

            string ver_num = TitleBar.GetVerNum();

            a.Add("current_datetime_mode/" + (int)current_datetime_mode);
            a.Add("rx1_display_cal_offset/" + rx1_display_cal_offset.ToString("f3"));
            a.Add("rx1_meter_cal_offset/" + rx1_meter_cal_offset);

            a.Add("txtMemoryQuick/" + txtMemoryQuick.Text);     // save quick memory settings
            a.Add("quick_save_mode/" + (int)quick_save_mode);
            a.Add("quick_save_filter/" + (int)quick_save_filter);

            a.Add("hid_last_cal_date_time/" + hid_last_cal_date_time);
            a.Add("hid_serial_num/" + hid_serial_num);
            a.Add("hid_trx_serial_num/" + hid_trx_serial_num);

            a.Add("fwc_last_cal_date_time/" + fwc_last_cal_date_time);
            a.Add("fwc_serial_num/" + fwc_serial_num);
            a.Add("fwc_trx_serial_num/" + fwc_trx_serial_num);

            a.Add("rx2_last_cal_date_time/" + rx2_last_cal_date_time);
            a.Add("rx2_serial_num/" + rx2_serial_num);
            a.Add("rx2_trx_match_serial/" + rx2_trx_match_serial);

            //FM Squelch Save
            a.Add("rx1_squelch_on/" + rx1_squelch_on);
            a.Add("rx1_squelch_threshold_scroll/" + rx1_squelch_threshold_scroll);
            a.Add("rx1_fm_squelch_threshold_scroll/" + rx1_fm_squelch_threshold_scroll);

            a.Add("rx2_squelch_on/" + rx2_squelch_on);
            a.Add("rx2_squelch_threshold_scroll/" + rx2_squelch_threshold_scroll);
            a.Add("rx2_fm_squelch_threshold_scroll/" + rx2_fm_squelch_threshold_scroll);

            a.Add("current_flex_control_mode/" + current_flexcontrol_mode.ToString());
            a.Add("flexcontrol_autodetect/" + flexcontrol_autodetect);

            a.Add("waterfall_high_threshold_160m/" + waterfall_high_threshold_160m); // ke9ns: save these values to the database at power down.
            a.Add("waterfall_low_threshold_160m/" + waterfall_low_threshold_160m);
            a.Add("waterfall_high_threshold_80m/" + waterfall_high_threshold_80m);
            a.Add("waterfall_low_threshold_80m/" + waterfall_low_threshold_80m);
            a.Add("waterfall_high_threshold_60m/" + waterfall_high_threshold_60m);
            a.Add("waterfall_low_threshold_60m/" + waterfall_low_threshold_60m);
            a.Add("waterfall_high_threshold_40m/" + waterfall_high_threshold_40m);
            a.Add("waterfall_low_threshold_40m/" + waterfall_low_threshold_40m);
            a.Add("waterfall_high_threshold_30m/" + waterfall_high_threshold_30m);
            a.Add("waterfall_low_threshold_30m/" + waterfall_low_threshold_30m);
            a.Add("waterfall_high_threshold_20m/" + waterfall_high_threshold_20m);
            a.Add("waterfall_low_threshold_20m/" + waterfall_low_threshold_20m);
            a.Add("waterfall_high_threshold_17m/" + waterfall_high_threshold_17m);
            a.Add("waterfall_low_threshold_17m/" + waterfall_low_threshold_17m);
            a.Add("waterfall_high_threshold_15m/" + waterfall_high_threshold_15m);
            a.Add("waterfall_low_threshold_15m/" + waterfall_low_threshold_15m);
            a.Add("waterfall_high_threshold_12m/" + waterfall_high_threshold_12m);
            a.Add("waterfall_low_threshold_12m/" + waterfall_low_threshold_12m);
            a.Add("waterfall_high_threshold_10m/" + waterfall_high_threshold_10m);
            a.Add("waterfall_low_threshold_10m/" + waterfall_low_threshold_10m);
            a.Add("waterfall_high_threshold_6m/" + waterfall_high_threshold_6m);
            a.Add("waterfall_low_threshold_6m/" + waterfall_low_threshold_6m);
            a.Add("waterfall_high_threshold_wwv/" + waterfall_high_threshold_wwv);
            a.Add("waterfall_low_threshold_wwv/" + waterfall_low_threshold_wwv);
            a.Add("waterfall_high_threshold_gen/" + waterfall_high_threshold_gen);
            a.Add("waterfall_low_threshold_gen/" + waterfall_low_threshold_gen);
            a.Add("waterfall_high_threshold_xvtr/" + waterfall_high_threshold_xvtr);
            a.Add("waterfall_low_threshold_xvtr/" + waterfall_low_threshold_xvtr);

            a.Add("waterfall_high_threshold_LMF/" + waterfall_high_threshold_LMF); // ke9ns: .158 save SWL bands these values to the database at power down.
            a.Add("waterfall_low_threshold_LMF/" + waterfall_low_threshold_LMF);
            a.Add("waterfall_high_threshold_120m/" + waterfall_high_threshold_120m);
            a.Add("waterfall_low_threshold_120m/" + waterfall_low_threshold_120m);
            a.Add("waterfall_high_threshold_90m/" + waterfall_high_threshold_90m);
            a.Add("waterfall_low_threshold_90m/" + waterfall_low_threshold_90m);
            a.Add("waterfall_high_threshold_61m/" + waterfall_high_threshold_61m);
            a.Add("waterfall_low_threshold_61m/" + waterfall_low_threshold_61m);
            a.Add("waterfall_high_threshold_49m/" + waterfall_high_threshold_49m);
            a.Add("waterfall_low_threshold_49m/" + waterfall_low_threshold_49m);
            a.Add("waterfall_high_threshold_41m/" + waterfall_high_threshold_41m);
            a.Add("waterfall_low_threshold_41m/" + waterfall_low_threshold_41m);
            a.Add("waterfall_high_threshold_31m/" + waterfall_high_threshold_31m);
            a.Add("waterfall_low_threshold_31m/" + waterfall_low_threshold_31m);
            a.Add("waterfall_high_threshold_25m/" + waterfall_high_threshold_25m);
            a.Add("waterfall_low_threshold_25m/" + waterfall_low_threshold_25m);
            a.Add("waterfall_high_threshold_22m/" + waterfall_high_threshold_22m);
            a.Add("waterfall_low_threshold_22m/" + waterfall_low_threshold_22m);
            a.Add("waterfall_high_threshold_19m/" + waterfall_high_threshold_19m);
            a.Add("waterfall_low_threshold_19m/" + waterfall_low_threshold_19m);
            a.Add("waterfall_high_threshold_16m/" + waterfall_high_threshold_16m);
            a.Add("waterfall_low_threshold_16m/" + waterfall_low_threshold_16m);
            a.Add("waterfall_high_threshold_14m/" + waterfall_high_threshold_14m);
            a.Add("waterfall_low_threshold_14m/" + waterfall_low_threshold_14m);
            a.Add("waterfall_high_threshold_13m/" + waterfall_high_threshold_13m);
            a.Add("waterfall_low_threshold_13m/" + waterfall_low_threshold_13m);
            a.Add("waterfall_high_threshold_11m/" + waterfall_high_threshold_11m);
            a.Add("waterfall_low_threshold_11m/" + waterfall_low_threshold_11m);

            a.Add("waterfall_update_period/" + waterfall_update_period);
            a.Add("lsb_txprofile/" + lsb_txprofile);
            a.Add("usb_txprofile/" + usb_txprofile);
            a.Add("dsb_txprofile/" + dsb_txprofile);
            a.Add("cwl_txprofile/" + cwl_txprofile);
            a.Add("cwu_txprofile/" + cwu_txprofile);
            a.Add("fm_txprofile/" + fm_txprofile);
            a.Add("am_txprofile/" + am_txprofile);
            a.Add("sam_txprofile/" + sam_txprofile);
            a.Add("spec_txprofile/" + spec_txprofile);
            a.Add("digl_txprofile/" + digl_txprofile);
            a.Add("digu_txprofile/" + digu_txprofile);
            a.Add("drm_txprofile/" + drm_txprofile);

            for (int m = (int)DSPMode.FIRST + 1; m < (int)DSPMode.LAST; m++)
            {   // save filter settings per mode
                for (Filter f = Filter.FIRST + 1; f < Filter.LAST; f++)
                {
                    a.Add("rx1_filters[" + m.ToString() + "][" + ((int)f).ToString() + "]/" + rx1_filters[m].ToString(f));
                }
                a.Add("last_rx1_filter[" + m.ToString() + "]/" + rx1_filters[m].LastFilter.ToString());
            }

            for (int m = (int)DSPMode.FIRST + 1; m < (int)DSPMode.LAST; m++)
            {   // save filter settings per mode
                for (Filter f = Filter.FIRST + 1; f < Filter.LAST; f++)
                {
                    a.Add("rx2_filters[" + m.ToString() + "][" + ((int)f).ToString() + "]/" + rx2_filters[m].ToString(f));
                }
                a.Add("last_rx2_filter[" + m.ToString() + "]/" + rx2_filters[m].LastFilter.ToString());
            }

#if (!NO_TNF)
            for (int i = 0; i < NotchList.List.Count; i++)
            {
                // only save off the permanent notches (ones where a right-click remember has been performed)
                if (NotchList.List[i].Permanent)
                {
                    a.Add("notchlist[" + i + "]/" + NotchList.List[i].ToString());
                }
            }
#endif

            for (int i = 0; i < (int)Band.LAST; i++)
            {
                s = "power_table[" + i + "]/";
                for (int j = 0; j < 13; j++)
                    s += power_table[i][j].ToString("f4") + "|";
                s = s.Substring(0, s.Length - 1);
                a.Add(s);
            }

            s = "vhf_power_table/";
            for (int j = 0; j < vhf_power_table.Length; j++)
                s += vhf_power_table[j].ToString("f4") + "|";
            s = s.Substring(0, s.Length - 1);
            a.Add(s);

            s = "uhf_power_table/";
            for (int j = 0; j < uhf_power_table.Length; j++)
                s += uhf_power_table[j].ToString("f4") + "|";
            s = s.Substring(0, s.Length - 1);
            a.Add(s);

            s = "tx_carrier_cal/";
            foreach (KeyValuePair<double, uint> pair in tx_carrier_cal)
                s += Math.Round(pair.Key, 3).ToString("f3") + "#" + pair.Value.ToString("X") + "|";
            s = s.Substring(0, s.Length - 1); // remove last '|'
            a.Add(s);

            for (int i = 0; i < 4; i++)
            {
                s = "pa_bias_table[" + i + "]/";
                for (int j = 0; j < 8; j++)
                    s += pa_bias_table[i][j].ToString() + "|";
                s = s.Substring(0, s.Length - 1);
                a.Add(s);
            }

            for (int i = 0; i < (int)Band.LAST; i++)
            {
                s = "rx1_level_table[" + i + "]/";
                for (int j = 0; j < 3; j++)
                    s += rx1_level_table[i][j].ToString("f3") + "|";
                s = s.Substring(0, s.Length - 1);
                a.Add(s);
            }

            for (int i = 0; i < (int)Band.LAST; i++)
            {
                s = "rx2_level_table[" + i + "]/";
                for (int j = 0; j < 3; j++)
                    s += rx2_level_table[i][j].ToString("f3") + "|";
                s = s.Substring(0, s.Length - 1);
                a.Add(s);
            }

            if (FWCEEPROM.RX2OK)
            {
                a.Add("rx2_res_offset/" + rx2_res_offset.ToString("f6" ));
            }

            for (int i = 0; i < (int)Band.LAST; i++)
            {
                s = "pa_bridge_table[" + i + "]/";
                for (int j = 0; j < 6; j++)
                    s += pa_bridge_table[i][j].ToString("f4") + "|";
                s = s.Substring(0, s.Length - 1);
                a.Add(s);
            }

            for (int i = 0; i < (int)Band.LAST; i++)
            {
                s = "swr_table[" + i + "]/";
                s += swr_table[i].ToString("f4");
                a.Add(s);
            }

            for (int i = 0; i < (int)Band.LAST; i++)
            {
                s = "atu_swr_table[" + i + "]/";
                s += atu_swr_table[i].ToString("f4");
                a.Add(s);
            }

            s = "vhf_level_table/";
            for (int i = 0; i < 2; i++)
                s += vhf_level_table[i].ToString("f1") + "|";
            s = s.Substring(0, s.Length - 1);
            a.Add(s);

            s = "uhf_level_table/";
            for (int i = 0; i < 2; i++)
                s += uhf_level_table[i].ToString("f1") + "|";
            s = s.Substring(0, s.Length - 1);
            a.Add(s);

            a.Add("current_ant_mode/" + ((int)current_ant_mode).ToString());

            a.Add("rx1_ant/" + ((int)rx1_ant).ToString());
            s = "rx1_ant_by_band/";
            for (int i = 0; i < (int)Band.LAST; i++)
                s += ((int)rx1_ant_by_band[i]).ToString() + "|";
            s = s.Substring(0, s.Length - 1);
            a.Add(s);
            a.Add("rx1_loop/" + rx1_loop.ToString());

            a.Add("rx2_ant/" + ((int)rx2_ant).ToString());
            s = "rx2_ant_by_band/";
            for (int i = 0; i < (int)Band.LAST; i++)
                s += ((int)rx2_ant_by_band[i]).ToString() + "|";
            s = s.Substring(0, s.Length - 1);
            a.Add(s);

            a.Add("tx_ant/" + ((int)tx_ant).ToString());
            s = "tx_ant_by_band/";
            for (int i = 0; i < (int)Band.LAST; i++)
                s += ((int)tx_ant_by_band[i]).ToString() + "|";
            s = s.Substring(0, s.Length - 1);
            a.Add(s);

            // ke9ns add .205
            a.Add("tx_ant2/" + ((int)tx_ant2).ToString());
            s = "tx_ant_by2_band/";
            for (int i = 0; i < (int)Band.LAST; i++)
                s += ((int)tx_ant_by2_band[i]).ToString() + "|";
            s = s.Substring(0, s.Length - 1);
            a.Add(s);

            a.Add("rx_ant_1500/" + ((int)rx_ant_1500).ToString());
            s = "rx_ant_1500_by_band/";
            for (int i = 0; i < (int)Band.LAST; i++)
                s += ((int)rx_ant_1500_by_band[i]).ToString() + "|";
            s = s.Substring(0, s.Length - 1);
            a.Add(s);

            a.Add("tx_ant_1500/" + ((int)tx_ant_1500).ToString());
            s = "tx_ant_1500_by_band/";
            for (int i = 0; i < (int)Band.LAST; i++)
                s += ((int)tx_ant_1500_by_band[i]).ToString() + "|";
            s = s.Substring(0, s.Length - 1);
            a.Add(s);

            s = "rx1_loop_by_band/";
            for (int i = 0; i < (int)Band.LAST; i++)
                s += Convert.ToUInt16(rx1_loop_by_band[i]).ToString() + "|";
            s = s.Substring(0, s.Length - 1);
            a.Add(s);

            rx1_preamp_by_band[(int)rx1_band] = rx1_preamp_mode;
            for (int i = 0; i < (int)Band.LAST; i++)
            {
                if (rx1_preamp_by_band[i] == PreampMode.FIRST)
                    rx1_preamp_by_band[i] = PreampMode.OFF;
            }
            s = "rx1_preamp_by_band/";
            for (int i = 0; i < (int)Band.LAST; i++)
                s += ((int)rx1_preamp_by_band[i]).ToString() + "|";
            s = s.Substring(0, s.Length - 1);
            a.Add(s);

            rx2_preamp_by_band[(int)rx2_band] = rx2_preamp_mode;
            s = "rx2_preamp_by_band/";
            for (int i = 0; i < (int)Band.LAST; i++)
                s += ((int)rx2_preamp_by_band[i]).ToString() + "|";
            s = s.Substring(0, s.Length - 1);
            a.Add(s);

            s = "power_by_band/";
            for (int i = 0; i < (int)Band.LAST; i++)
                s += power_by_band[i].ToString() + "|";
            s = s.Substring(0, s.Length - 1);
            a.Add(s);

            //==========================================
            // ke9ns add
            s = "power_by_mode_by_band/";
            for (int i = 0; i < (int)Band.LAST; i++)
            {
                for (int ii = 0; ii < (int)DSPMode.LAST; ii++)
                {
                    s += power_by_mode_by_band[i, ii].ToString() + "|";
                }
            }
            s = s.Substring(0, s.Length - 1);
            a.Add(s);

            //==========================================
            // ke9ns add
            s = "limit_by_mode_by_band/";
            for (int i = 0; i < (int)Band.LAST; i++)
            {
                for (int ii = 0; ii < (int)DSPMode.LAST; ii++)
                {
                    s += limit_by_mode_by_band[i, ii].ToString() + "|";
                }
            }
            s = s.Substring(0, s.Length - 1);
            a.Add(s);


            //==========================================

            s = "fm_tx_offset_by_band_mhz/";
            for (int i = 0; i < (int)Band.LAST; i++)
                s += fm_tx_offset_by_band_mhz[i].ToString("R") + "|";
            s = s.Substring(0, s.Length - 1);
            a.Add(s);

            s = "rx1_agct_by_band/";
            for (int i = 0; i < (int)Band.LAST; i++)
                s += rx1_agct_by_band[i].ToString() + "|";
            s = s.Substring(0, s.Length - 1);
            a.Add(s);

            s = "rx2_agct_by_band/";
            for (int i = 0; i < (int)Band.LAST; i++)
                s += rx2_agct_by_band[i].ToString() + "|";
            s = s.Substring(0, s.Length - 1);
            a.Add(s);



            s = "tx1_by_band/";
            for (int i = 0; i < (int)Band.LAST; i++)
                s += Convert.ToUInt16(tx1_by_band[i]).ToString() + "|";
            s = s.Substring(0, s.Length - 1);
            a.Add(s);

            s = "tx2_by_band/";
            for (int i = 0; i < (int)Band.LAST; i++)
                s += Convert.ToUInt16(tx2_by_band[i]).ToString() + "|";
            s = s.Substring(0, s.Length - 1);
            a.Add(s);

            s = "tx3_by_band/";
            for (int i = 0; i < (int)Band.LAST; i++)
                s += Convert.ToUInt16(tx3_by_band[i]).ToString() + "|";
            s = s.Substring(0, s.Length - 1);
            a.Add(s);


            // ke9ns add .206 for RX2
            s = "tx1_by2_band/";
            for (int i = 0; i < (int)Band.LAST; i++)
                s += Convert.ToUInt16(tx1_by2_band[i]).ToString() + "|";
            s = s.Substring(0, s.Length - 1);
            a.Add(s);

            s = "tx2_by2_band/";
            for (int i = 0; i < (int)Band.LAST; i++)
                s += Convert.ToUInt16(tx2_by2_band[i]).ToString() + "|";
            s = s.Substring(0, s.Length - 1);
            a.Add(s);

            s = "tx3_by2_band/";
            for (int i = 0; i < (int)Band.LAST; i++)
                s += Convert.ToUInt16(tx3_by2_band[i]).ToString() + "|";
            s = s.Substring(0, s.Length - 1);
            a.Add(s);


            s = "rx1_image_gain_table/";
            for (int i = 0; i <= (int)Band.B6M; i++)
                s += rx1_image_gain_table[i].ToString("R") + "|";
            s = s.Substring(0, s.Length - 1);
            a.Add(s);

            s = "rx1_image_phase_table/";
            for (int i = 0; i <= (int)Band.B6M; i++)
                s += rx1_image_phase_table[i].ToString("R") + "|";
            s = s.Substring(0, s.Length - 1);
            a.Add(s);

            s = "rx2_image_gain_table/";
            for (int i = 0; i <= (int)Band.B6M; i++)
                s += rx2_image_gain_table[i].ToString("R") + "|";
            s = s.Substring(0, s.Length - 1);
            a.Add(s);

            s = "rx2_image_phase_table/";
            for (int i = 0; i <= (int)Band.B6M; i++)
                s += rx2_image_phase_table[i].ToString("R") + "|";
            s = s.Substring(0, s.Length - 1);
            a.Add(s);

            s = "tx_image_gain_table/";
            for (int i = 0; i <= (int)Band.B6M; i++)
                s += tx_image_gain_table[i].ToString("R") + "|";
            s = s.Substring(0, s.Length - 1);
            a.Add(s);

            s = "tx_image_phase_table/";
            for (int i = 0; i <= (int)Band.B6M; i++)
                s += tx_image_phase_table[i].ToString("R") + "|";
            s = s.Substring(0, s.Length - 1);
            a.Add(s);

            a.Add("rx1_level_checksum/" + rx1_level_checksum.ToString());
            a.Add("rx1_image_gain_checksum/" + rx1_image_gain_checksum.ToString());
            a.Add("rx1_image_phase_checksum/" + rx1_image_phase_checksum.ToString());
            a.Add("tx_image_gain_checksum/" + tx_image_gain_checksum.ToString());
            a.Add("tx_image_phase_checksum/" + tx_image_phase_checksum.ToString());
            a.Add("tx_carrier_checksum/" + tx_carrier_checksum.ToString());
            a.Add("pa_bias_checksum/" + pa_bias_checksum.ToString());
            a.Add("pa_bridge_checksum/" + pa_bridge_checksum.ToString());
            a.Add("pa_power_checksum/" + pa_power_checksum.ToString());
            a.Add("pa_swr_checksum/" + pa_swr_checksum.ToString());
            a.Add("atu_swr_checksum/" + atu_swr_checksum.ToString());
            a.Add("rx2_level_checksum/" + rx2_level_checksum.ToString());
            a.Add("rx2_image_gain_checksum/" + rx2_image_gain_checksum.ToString());
            a.Add("rx2_image_phase_checksum/" + rx2_image_phase_checksum.ToString());




            //------------------------------------------------------------------------
            // ke9ns      this saves the stuff here
            try
            {
                StreamWriter writer = new StreamWriter(app_data_path + "power.csv"); // "\\power.csv"  // look for %userprofile%\AppData\Roaming\FlexRadio Systems\PowerSDR v2.8.0\

                writer.WriteLine("Band, 1, 2, 5, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100");

                for (int i = 1; i <= (int)Band.B6M; i++)
                {
                    writer.Write(((Band)i).ToString() + ",");
                    for (int j = 0; j < 13; j++)
                        writer.Write(power_table[i][j].ToString("f4") + ",");
                    writer.WriteLine("");
                }
                writer.Close();
            }
            catch (Exception)
            {
                MessageBox.Show(new Form { TopMost = true }, "Error writing power.csv file.  Please make sure this file is not open and try again.",
                    "Error writing power.csv",
                    MessageBoxButtons.OK,
                    MessageBoxIcon.Error);
            }


            //   MessageBox.Show(new Form { TopMost = true }, "Done updating Power.CSV file");

            /*try
			{
				StreamWriter writer = new StreamWriter(app_data_path+"\\rx1_level.csv");
				writer.WriteLine("Band, 0, 1, 2");
				for(int i=1; i<=(int)Band.B6M; i++)
				{
					writer.Write(((Band)i).ToString()+",");
					for(int j=0; j<3; j++)
						writer.Write(rx1_level_table[i][j].ToString("f10")+",");
					writer.WriteLine("");
				}
				writer.Close();
			}
			catch(Exception)
			{
				MessageBox.Show(new Form { TopMost = true }, "Error writing rx1_level.csv file.  Please make sure this file is not open and try again.",
					"Error writing rx1_level.csv",
					MessageBoxButtons.OK,
					MessageBoxIcon.Error);
			}*/

            a.Add("rx2_fixed_gain/" + rx2_fixed_gain.ToString());
            a.Add("rx2_max_gain/" + rx2_max_gain.ToString());

            a.Add("band_160m_index/" + band_160m_index.ToString());
            a.Add("band_80m_index/" + band_80m_index.ToString());
            a.Add("band_60m_index/" + band_60m_index.ToString());
            a.Add("band_40m_index/" + band_40m_index.ToString());
            a.Add("band_30m_index/" + band_30m_index.ToString());
            a.Add("band_20m_index/" + band_20m_index.ToString());
            a.Add("band_17m_index/" + band_17m_index.ToString());
            a.Add("band_15m_index/" + band_15m_index.ToString());
            a.Add("band_12m_index/" + band_12m_index.ToString());
            a.Add("band_10m_index/" + band_10m_index.ToString());
            a.Add("band_6m_index/" + band_6m_index.ToString());
            a.Add("band_2m_index/" + band_2m_index.ToString());
            a.Add("band_wwv_index/" + band_wwv_index.ToString());
            a.Add("band_gen_index/" + band_gen_index.ToString());

            a.Add("band_LMF_index/" + band_LMF_index.ToString()); // ke9ns add
            a.Add("band_120m_index/" + band_120m_index.ToString());
            a.Add("band_90m_index/" + band_90m_index.ToString());
            a.Add("band_61m_index/" + band_61m_index.ToString());
            a.Add("band_49m_index/" + band_49m_index.ToString());
            a.Add("band_41m_index/" + band_41m_index.ToString());
            a.Add("band_31m_index/" + band_31m_index.ToString());
            a.Add("band_25m_index/" + band_25m_index.ToString());
            a.Add("band_22m_index/" + band_22m_index.ToString());
            a.Add("band_19m_index/" + band_19m_index.ToString());
            a.Add("band_16m_index/" + band_16m_index.ToString());
            a.Add("band_14m_index/" + band_14m_index.ToString());
            a.Add("band_13m_index/" + band_13m_index.ToString());
            a.Add("band_11m_index/" + band_11m_index.ToString());

            a.Add("band_vhf0_index/" + band_vhf0_index.ToString());
            a.Add("band_vhf1_index/" + band_vhf1_index.ToString());
            a.Add("band_vhf2_index/" + band_vhf2_index.ToString());
            a.Add("band_vhf3_index/" + band_vhf3_index.ToString());
            a.Add("band_vhf4_index/" + band_vhf4_index.ToString());
            a.Add("band_vhf5_index/" + band_vhf5_index.ToString());
            a.Add("band_vhf6_index/" + band_vhf6_index.ToString());
            a.Add("band_vhf7_index/" + band_vhf7_index.ToString());
            a.Add("band_vhf8_index/" + band_vhf8_index.ToString());
            a.Add("band_vhf9_index/" + band_vhf9_index.ToString());
            a.Add("band_vhf10_index/" + band_vhf10_index.ToString());
            a.Add("band_vhf11_index/" + band_vhf11_index.ToString());
            a.Add("band_vhf12_index/" + band_vhf12_index.ToString());
            a.Add("band_vhf13_index/" + band_vhf13_index.ToString());




            for (int i = (int)PreampMode.FIRST + 1; i < (int)PreampMode.LAST; i++)
                a.Add("rx1_preamp_offset[" + i.ToString() + "]/" + rx1_preamp_offset[i].ToString("f3"));

            //a.Add("fwc_preamp_offset/"+fwc_preamp_offset.ToString());
            /*for(int i=0; i<32; i++)
				a.Add("fwc_att_offset["+i.ToString()+"]/"+fwc_att_offset[i].ToString());*/

            a.Add("wheel_tune_index/" + tune_step_index.ToString());      // Save wheel tune value



            a.Add("vfob_dsp_mode/" + ((int)vfob_dsp_mode).ToString());  // Save VFO B values
            a.Add("vfob_filter/" + ((int)vfob_filter).ToString());

            a.Add("console_zaximize/" + this.WindowState.ToString()); // ke9ns add: for max detection

            a.Add("console_top/" + this.Top.ToString());                    // save form positions
            a.Add("console_left/" + this.Left.ToString());
            a.Add("console_width/" + this.Width.ToString());
            a.Add("console_height/" + this.Height.ToString());

            a.Add("setup_top/" + setupForm.Top.ToString());
            a.Add("setup_left/" + setupForm.Left.ToString());
            a.Add("saved_rx_only/" + saved_rx_only.ToString());
            a.Add("mon_recall/" + mon_recall.ToString());

            a.Add("Version/" + this.Text);		    // save the current title bar string
            a.Add("VersionNumber/" + ver_num);      // PowerSDR version number in a.b.c format
            a.Add("RadioType/" + CurrentModel);     // radio model string (ex. FLEX1500)
            a.Add("BandTextID/" + current_region);  // TURF Region
            a.Add("Opened/" + extended);            // has the radio been opened?


            // ke9ns add .186 (for scanner low/high edge save
            for (int i = 0; i < 50; i++)
            {
                // Debug.WriteLine("SCANNER: " + i);
                a.Add("SLowScan[" + i.ToString() + "]/" + SLowScan[i]);

            }
            for (int i = 0; i < 50; i++)
            {
                // Debug.WriteLine("SCANNER: " + i);
                a.Add("SHighScan[" + i.ToString() + "]/" + SHighScan[i]);

            }

            DB.PurgeNotches();                      // remove old notches from DB

            DB.SaveVars("State", ref a);            // save the "State" values to the DB

            //  MessageBox.Show(new Form { TopMost = true }, "Done updating the STATE variables ArrayList database XML structure");


        }  // SaveState()    




        public static byte moninit = 1;               // ke9ns used for chkMON startup

        public double[,,,] SWR_READ = new double[7, 11, 45, 3000]; //ke9ns: ScanControl Test# 1-5, Ant=1,2,3, band=1-30,freq slot = swr on band
        public int swr_testrun = 1; // ke9ns

        public int SWR_TESTRUN  // ke9ns: SWR scanner
        {
            get
            {
                return swr_testrun;
            }
            set
            {
                swr_testrun = value;
            }
        } // TESTRUN

        //=======================================================================================
        //=======================================================================================
        // ke9ns mod  LOAD UP DATABASE into PowerSDR 
        //=======================================================================================
        //=======================================================================================

        bool CONSOLEM = false; // ke9ns add: true = maximized size when restoring PowerSDR
        int CONSOLEH = 0;
        int CONSOLEW = 0;
        int CONSOLEL = 0;
        int CONSOLET = 0;

        public void GetState()
        {
            // Automatically restores all controls from the database in the
            // tab pages on this form of the following types: CheckBox, ComboBox,
            // NumericUpDown, RadioButton, TextBox, and TrackBar (slider)


            //--------------------------------------------------------
            // ke9ns add  open up database for my stuff  here
            // AppDataPath = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) + "\\FlexRadio Systems\\";
            string file_name3 = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) + "\\FlexRadio Systems\\" + "mem.bak"; // save original Memory.xml file just in case T10
            string file_name4 = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) + "\\FlexRadio Systems\\" + "memory.xml"; // save original Memory.xml file just in case T10

            if ((!File.Exists(file_name3)) && (File.Exists(file_name4)))
            {
                Debug.WriteLine("Backing up Memory file 1 time");

                System.IO.File.Copy(file_name4, file_name3); // old > new

            }


            //------------------------------------------------------------------
            // ke9ns RECALL SWR PLOTS
            string file_nameSWR = AppDataPath + "ke9ns_SWR1.dat"; // save data for my mods


            if (!File.Exists(file_nameSWR))
            {

                Debug.WriteLine("Create new SWR database file");

                SWR_Logger_Write();

            } //   ke9ns_SWR.dat file does NOT exist
            else //   ke9ns_SWR.dat file exists
            {

                Debug.WriteLine("READ SWR database file");

                SWR_Logger_Read();

            }  // ke9ns_SWR.dat file exists



            //----------------------------------------------------------------------------

            string file_name2 = AppDataPath + "ke9ns8.dat"; // save data for my mods


            if (!File.Exists(file_name2))
            {

                Debug.WriteLine("Create new database file");

                FileStream stream2 = new FileStream(file_name2, FileMode.Create); // open BMP  file
                BinaryWriter writer2 = new BinaryWriter(stream2);

                writer2.Write((double)WaterfallLowThresholdMic);      // TX low level waterfall threshold
                writer2.Write(setupForm.checkWaterMoveSize.Checked);  // large waterfall move
                writer2.Write(Display.GrayScale);                    // color or grayscale watetfall
                writer2.Write((byte)WaveForm.BandL);                 // save mode for check of valid waterfall ID later  // RX1DSPMode != BandL
                writer2.Write(Display.PW_AVG);                       // save avgP or avgB  RX1
                writer2.Write(Display.PW_AVG2);                      // save avgp or avgB RX2
                writer2.Write(Audio.MON_PRE);                        // save MONitor pre or post audio
                writer2.Write(Display.GridOff);                      // save panadapter grid on/off
                writer2.Write(WaveControl.QAC);                      // QUickaudio file #

                writer2.Write(SpotControl.nameB);               // name for dx spotter
                writer2.Write(SpotControl.callB);               // call sign for dx spotter
                writer2.Write(SpotControl.nodeB);               // node  for dx spotter
                writer2.Write(SpotControl.portB);               // port for dx spotter


                writer2.Write(callsign);                             // callsign for waterfall ID
                writer2.Write(lastcallsign);                         // last callsign test for valid waterfall ID

                writer2.Write((byte)PAON);                           // temp/volts on/off console display
                writer2.Write((byte)noaaON);                          // space weather console display

                writer2.Write((byte)setupForm.tune_step_index2);      // save Powermate knob index
                writer2.Write((byte)setupForm.tune_step_index3);      // save Powermate knob index

                writer2.Write("end");


                writer2.Close();    // close  file
                stream2.Close();   // close stream
                Debug.WriteLine("Create new database file");

            }
            else // yes ke9ns.dat file does exist
            {

                FileStream stream2 = new FileStream(file_name2, FileMode.Open); // open ke9ns file
                BinaryReader reader2 = new BinaryReader(stream2);

                WaterfallLowThresholdMic = (float)reader2.ReadDouble();            //  TX low level waterfall threshold
                setupForm.checkWaterMoveSize.Checked = reader2.ReadBoolean();      // large waterfall move
                Display.GrayScale = reader2.ReadByte();                            // color or grayscale waterfall 
                WaveForm.BandL = (DSPMode)reader2.ReadByte();                      // for check of valid waterfall id
                Display.PW_AVG = reader2.ReadByte();                               // avgP or avgB RX1
                Display.PW_AVG2 = reader2.ReadByte();                              // avgP or avgB RX2
                Audio.MON_PRE = reader2.ReadByte();                                // MONitor pre or post
                Display.GridOff = reader2.ReadByte();                              // panadapter grid on / off
                WaveControl.QAC = reader2.ReadInt32();                             // QUickaudio file #

                SpotControl.DXNAME = reader2.ReadString();                     // name for dx spotter
                SpotControl.DXCALL = reader2.ReadString();                     // call sign for dx spotter
                SpotControl.DXNODE = reader2.ReadString();                     // node for dx spotter
                SpotControl.DXPORT = reader2.ReadString();                     // port for dx spotter


                callsign = reader2.ReadString();                                   // callsign for waterfall ID
                lastcallsign = reader2.ReadString();                               // last callsign test of waterfall ID valid

                PAON = reader2.ReadByte();                                       // temp/volt on/off display
                noaaON = reader2.ReadByte();                                // space weather console display

                try
                {
                    setupForm.tune_step_index2 = reader2.ReadByte();            // Powermate knob index
                }
                catch (Exception)
                {
                    setupForm.tune_step_index2 = 2;
                    setupForm.tune_step_index2--;   // ke9ns add
                    setupForm.ChangeTuneStepUp2(); // ke9ns add


                }

                try
                {
                    setupForm.tune_step_index3 = reader2.ReadByte();            // Powermate knob index
                }
                catch (Exception)
                {
                    setupForm.tune_step_index3 = 2;
                    setupForm.tune_step_index3--;   // ke9ns add
                    setupForm.ChangeTuneStepUp3(); // ke9ns add


                }


                reader2.Close();    // close  file
                stream2.Close();   // close stream
                                   //   Debug.WriteLine("Read database file");

            } // yes ke9ns.dat file does exist


            //ke9ns add
            if (setupForm.chkBoxHTTP.Checked == true)
            {
                //   HttpServer2(); // ke9ns  start server

                Debug.WriteLine("ke9ns8 httplaunch");

                HttpServer = true;

                //  httpFile.HttpServer1();

            }

            //   Debug.WriteLine("1nameB " + SpotControl.nameB);
            //   Debug.WriteLine("1portB " + SpotControl.portB);
            //   Debug.WriteLine("1callB " + SpotControl.callB);
            //    Debug.WriteLine("1nodeB " + SpotControl.nodeB);

            if (Display.GridOff == 1)
            {
                setupForm.gridBoxTS.CheckedChanged -= setupForm.gridBoxTS_CheckedChanged;  // ke9ns turn off checkchanged temporarily    // ke9ns turn off valuechanged temporarily 
                setupForm.gridBoxTS.Checked = true;
                setupForm.gridBoxTS.CheckedChanged += setupForm.gridBoxTS_CheckedChanged;


            }

            //  if (Audio.MON_PRE == 1)
            //  {

            //   Audio.MON_PRE = 2;// initial startup

            //   chkMON.CheckedChanged -= chkMON_CheckedChanged;
            //    chkMON.Text = "MONpr";
            //   panelDisplay.Invalidate();
            //   chkMON.Invalidate();
            //   panelDisplay.Update();
            //    chkMON.CheckedChanged -= chkMON_CheckedChanged;

            //  }
            //  else
            //  {
            //   Debug.WriteLine("recall PRE = 0");
            //  Audio.MON_PRE = 1;

            //  chkMON.CheckedChanged -= chkMON_CheckedChanged;
            //   chkMON.Text = "MONps";
            //    panelDisplay.Invalidate();
            //  chkMON.Invalidate();
            //   panelDisplay.Update();
            //  chkMON.CheckedChanged += chkMON_CheckedChanged;

            // }




            if (Display.PW_AVG == 1)
            {
                //  Debug.WriteLine("avgP ");

                chkDisplayAVG.CheckedChanged -= chkDisplayAVG_CheckedChanged; // turn eventoff
                                                                              //  chkDisplayAVG.Checked = true;
                chkDisplayAVG.Enabled = true;

                chkDisplayAVG.Text = "AvgP"; // ke9ns 
                panelDisplay.Invalidate();
                chkDisplayAVG.Invalidate();
                panelDisplay.Update();

                chkDisplayAVG.CheckedChanged += chkDisplayAVG_CheckedChanged; // turn eventoff


            }
            else
            {
                //  chkDisplayAVG.Text = "AvgB"; // ke9ns 

            }
            if (Display.PW_AVG2 == 1)
            {
                // Debug.WriteLine("avgP ");

                chkRX2DisplayAVG.CheckedChanged -= chkRX2DisplayAVG_CheckedChanged; // turn eventoff
                                                                                    //  chkRX2DisplayAVG.Checked = true;

                chkRX2DisplayAVG.Enabled = true;

                chkRX2DisplayAVG.Text = "AvgP"; // ke9ns 
                panelRX2Display.Invalidate();
                chkRX2DisplayAVG.Invalidate();

                panelRX2Display.Update();
                chkRX2DisplayAVG.CheckedChanged += chkRX2DisplayAVG_CheckedChanged; // turn eventoff

            }
            else
            {
                // chkRX2DisplayAVG.Text = "AvgB"; // ke9ns 

            }

            if (Display.GrayScale == 1)
            {
                this.GrayMenuItem.Text = "ColorWtr";

            }
            if (setupForm.checkWaterMoveSize.Checked)
            {
                Display.WMS = 1;
            }
            callsignTextBox.Text = callsign;

            if ((callsign == lastcallsign) && (WaveForm.BandL == RX1DSPMode))
            {

                callsignTextBox.BackColor = Color.MediumSpringGreen;  // green if you created it or its still a valid wave
                menuStrip1.Invalidate();
                menuStrip1.Update();
            }



            //  Debug.WriteLine("mic " + WaterfallLowThresholdMic);
            //  Debug.WriteLine("large " + setupForm.checkWaterMoveSize.Checked);
            //  Debug.WriteLine("large " + Display.WMS);
            //  Debug.WriteLine("call " + callsign);
            //  Debug.WriteLine("callL " + LastCall);


            ArrayList a1 = DB.GetVars("WaveOptions");                          // Get the saved list of controls
            a1.Sort();

            foreach (string s in a1)             // string is in the format "name,value"
            {
                string[] vals = s.Split('/');
                if (vals.Length > 2)
                {
                    for (int i = 2; i < vals.Length; i++)
                        vals[1] += "/" + vals[i];
                }

                string name = vals[0];
                string val = vals[1];

                if (name.StartsWith("chkQuickAudioFolder"))
                {
                    // Debug.WriteLine("val======= " + val);

                    if (val.Contains("True")) WaveForm.chkQuickAudioFolder.Checked = true;


                }
            }
            //--------------------------------------------------------kes9ns mod end
            //=========================================================================================================




            ArrayList checkbox_list = new ArrayList();
            ArrayList combobox_list = new ArrayList();
            ArrayList numericupdown_list = new ArrayList();
            ArrayList radiobutton_list = new ArrayList();
            ArrayList textbox_list = new ArrayList();
            ArrayList trackbar_list = new ArrayList();
            ArrayList prettytrackbar_list = new ArrayList();

            //ArrayList controls = new ArrayList();	// list of controls to restore
            foreach (Control c in this.Controls)
            {
                // if control is a groupbox or panel, retrieve all subcontrols
                if (c.GetType() == typeof(GroupBoxTS) || c.GetType() == typeof(PanelTS))
                {
                    foreach (Control c2 in c.Controls)
                    {
                        if (c2.Enabled)
                        {
                            if (c2.GetType() == typeof(CheckBoxTS))			// the control is a CheckBox
                                checkbox_list.Add(c2);
                            else if (c2.GetType() == typeof(ComboBoxTS))		// the control is a ComboBox
                                combobox_list.Add(c2);
                            else if (c2.GetType() == typeof(NumericUpDownTS))	// the control is a NumericUpDown
                                numericupdown_list.Add(c2);
                            else if (c2.GetType() == typeof(RadioButtonTS))	// the control is a RadioButton
                                radiobutton_list.Add(c2);
                            else if (c2.GetType() == typeof(TextBoxTS))		// the control is a TextBox
                                textbox_list.Add(c2);
                            else if (c2.GetType() == typeof(TrackBarTS))		// the control is a TrackBar (slider)
                                trackbar_list.Add(c2);
                            else if (c2.GetType() == typeof(PrettyTrackBar))
                                prettytrackbar_list.Add(c2);
                        }
                    }
                }
                else
                {
                    if (c.Enabled)
                    {
                        if (c.GetType() == typeof(CheckBoxTS))              // the control is a CheckBox
                            checkbox_list.Add(c);
                        else if (c.GetType() == typeof(ComboBoxTS))     // the control is a ComboBox
                            combobox_list.Add(c);
                        else if (c.GetType() == typeof(NumericUpDownTS))    // the control is a NumericUpDown
                            numericupdown_list.Add(c);
                        else if (c.GetType() == typeof(RadioButtonTS))      // the control is a RadioButton
                            radiobutton_list.Add(c);
                        else if (c.GetType() == typeof(TextBoxTS))          // the control is a TextBox
                            textbox_list.Add(c);
                        else if (c.GetType() == typeof(TrackBarTS))     // the control is a TrackBar (slider)
                            trackbar_list.Add(c);
                        else if (c.GetType() == typeof(PrettyTrackBar))
                            prettytrackbar_list.Add(c);
                    }
                }
            }



            //=============================================================================================

            ArrayList a = DB.GetVars("State");                          // Get the saved list of controls
            a.Sort();
            int num_controls = checkbox_list.Count + combobox_list.Count +
                numericupdown_list.Count + radiobutton_list.Count +
                textbox_list.Count + trackbar_list.Count;

            foreach (string s in a)             // string is in the format "name,value"
            {
                string[] vals = s.Split('/');
                if (vals.Length > 2)
                {
                    for (int i = 2; i < vals.Length; i++)
                        vals[1] += "/" + vals[i];
                }

                string name = vals[0];
                string val = vals[1];
                int num = 0;

                if (name.StartsWith("rx1_filters["))
                {
                    int start = name.IndexOf("[") + 1;
                    int length = name.IndexOf("]") - start;
                    int mode_index = Int32.Parse(name.Substring(start, length));

                    start = name.LastIndexOf("[") + 1;
                    length = name.LastIndexOf("]") - start;
                    int filter_mode = Int32.Parse(name.Substring(start, length));

                    length = val.IndexOf(":");
                    string n = val.Substring(0, length);

                    if (!val.Contains("|")) val = val.Replace(",", "|");

                    start = val.IndexOf(":") + 2;
                    length = val.IndexOf("|") - start;
                    int low = Int32.Parse(val.Substring(start, length));

                    start = val.IndexOf("|") + 1;
                    int high = Int32.Parse(val.Substring(start));

                    rx1_filters[mode_index].SetFilter((Filter)filter_mode, low, high, n);
                }
                else if (name.StartsWith("rx2_filters["))
                {
                    int start = name.IndexOf("[") + 1;
                    int length = name.IndexOf("]") - start;
                    int mode_index = Int32.Parse(name.Substring(start, length));

                    start = name.LastIndexOf("[") + 1;
                    length = name.LastIndexOf("]") - start;
                    int filter_mode = Int32.Parse(name.Substring(start, length));

                    length = val.IndexOf(":");
                    string n = val.Substring(0, length);

                    if (!val.Contains("|"))
                        val = val.Replace(",", "|");

                    start = val.IndexOf(":") + 2;
                    length = val.IndexOf("|") - start;
                    int low = Int32.Parse(val.Substring(start, length));

                    start = val.IndexOf("|") + 1;
                    int high = Int32.Parse(val.Substring(start));

                    rx2_filters[mode_index].SetFilter((Filter)filter_mode, low, high, n);
                }
#if (!NO_TNF)
                else if (name.StartsWith("notchlist"))
                {
                    NotchList.List.Add(Notch.Parse(val));
                }
#endif
                else if (name.StartsWith("last_rx1_filter["))
                {
                    int start = name.IndexOf("[") + 1;
                    int length = name.IndexOf("]") - start;
                    int mode_index = Int32.Parse(name.Substring(start, length));

                    rx1_filters[mode_index].LastFilter = (Filter)Enum.Parse(typeof(Filter), val);
                }
                else if (name.StartsWith("last_rx2_filter["))
                {
                    int start = name.IndexOf("[") + 1;
                    int length = name.IndexOf("]") - start;
                    int mode_index = Int32.Parse(name.Substring(start, length));

                    rx2_filters[mode_index].LastFilter = (Filter)Enum.Parse(typeof(Filter), val);
                }
                else if (name.StartsWith("rx1_preamp_offset["))
                {
                    int start = name.IndexOf("[") + 1;
                    int length = name.IndexOf("]") - start;
                    int index = Int32.Parse(name.Substring(start, length));

                    rx1_preamp_offset[index] = (float)Math.Round(float.Parse(val), 3);
                }
                else if (name.StartsWith("SLowScan[")) // ke9ns add .186
                {
                    int start = name.IndexOf("[") + 1;
                    int length = name.IndexOf("]") - start;
                    int index = Int32.Parse(name.Substring(start, length));

                    SLowScan[index] = val;
                }
                else if (name.StartsWith("SHighScan[")) // ke9ns add .186
                {
                    int start = name.IndexOf("[") + 1;
                    int length = name.IndexOf("]") - start;
                    int index = Int32.Parse(name.Substring(start, length));

                    SHighScan[index] = val;
                }

                /*else if(name.StartsWith("fwc_att_offset"))
                {
                    int start = name.IndexOf("[")+1;
                    int length = name.IndexOf("]")-start;
                    int index = int.Parse(name.Substring(start, length));

                    fwc_att_offset[index] = float.Parse(val);
                }*/
                else if (name.StartsWith("power_table"))
                {
                    int start = name.IndexOf("[") + 1;
                    int length = name.IndexOf("]") - start;
                    int index = int.Parse(name.Substring(start, length));

                    string[] list = val.Split('|');
                    for (int i = 0; i < 13 && i < list.Length; i++)
                    {
                        power_table[index][i] = (float)Math.Round(float.Parse(list[i]), 4);
                    }
                }
                else if (name.StartsWith("vhf_power_table"))
                {
                    string[] list = val.Split('|');
                    for (int i = 0; i < list.Length; i++)
                        vhf_power_table[i] = (float)Math.Round(float.Parse(list[i]), 4);
                }
                else if (name.StartsWith("uhf_power_table"))
                {
                    string[] list = val.Split('|');
                    for (int i = 0; i < list.Length; i++)
                        uhf_power_table[i] = (float)Math.Round(float.Parse(list[i]), 4);
                }
                else if (name.StartsWith("tx_carrier_cal"))
                {
                    string[] pairs = val.Split('|');
                    tx_carrier_cal.Clear();
                    foreach (string p in pairs)
                    {
                        int index = p.IndexOf("#");
                        double freq = Math.Round(double.Parse(p.Substring(0, index)), 3);
                        uint x = uint.Parse(p.Substring(index + 1), NumberStyles.HexNumber);

                        if (tx_carrier_cal.ContainsKey(freq))
                            tx_carrier_cal[freq] = x;
                        else
                            tx_carrier_cal.Add(freq, x);
                    }
                }
                else if (name.StartsWith("pa_bias_table"))
                {
                    int start = name.IndexOf("[") + 1;
                    int length = name.IndexOf("]") - start;
                    int index = int.Parse(name.Substring(start, length));

                    string[] list = val.Split('|');
                    for (int i = 0; i < 8 && i < list.Length; i++)
                        pa_bias_table[index][i] = int.Parse(list[i]);

                    if (fwc_init && index == 0 &&
                        (current_model == Model.FLEX5000 || current_model == Model.FLEX3000))
                    {
                        if (flex5000DebugForm != null && !flex5000DebugForm.IsDisposed)
                        {
                            for (int i = 0; i < 8; i++)
                                flex5000DebugForm.SetPAPot(i, (byte)pa_bias_table[index][i]);
                        }
                    }
                }
                else if (name.StartsWith("rx1_level_table"))
                {
                    int start = name.IndexOf("[") + 1;
                    int length = name.IndexOf("]") - start;
                    int index = int.Parse(name.Substring(start, length));

                    string[] list = val.Split('|');
                    for (int i = 0; i < 3; i++)
                        rx1_level_table[index][i] = (float)Math.Round(float.Parse(list[i]), 3);
                }
                else if (name.StartsWith("rx2_level_table"))
                {
                    int start = name.IndexOf("[") + 1;
                    int length = name.IndexOf("]") - start;
                    int index = int.Parse(name.Substring(start, length));

                    string[] list = val.Split('|');
                    for (int i = 0; i < 3; i++)
                        rx2_level_table[index][i] = (float)Math.Round(float.Parse(list[i]), 3);
                }
                else if (name.StartsWith("pa_bridge_table"))
                {
                    int start = name.IndexOf("[") + 1;
                    int length = name.IndexOf("]") - start;
                    int index = int.Parse(name.Substring(start, length));

                    string[] list = val.Split('|');
                    for (int i = 0; i < 6; i++)
                        pa_bridge_table[index][i] = (float)Math.Round(float.Parse(list[i]), 4);
                }
                else if (name.StartsWith("swr_table"))
                {
                    int start = name.IndexOf("[") + 1;
                    int length = name.IndexOf("]") - start;
                    int index = int.Parse(name.Substring(start, length));

                    swr_table[index] = (float)Math.Round(float.Parse(val), 4);
                }
                else if (name.StartsWith("atu_swr_table"))
                {
                    int start = name.IndexOf("[") + 1;
                    int length = name.IndexOf("]") - start;
                    int index = int.Parse(name.Substring(start, length));

                    atu_swr_table[index] = (float)Math.Round(float.Parse(val), 4);
                }
                else if (name.StartsWith("vhf_level_table"))
                {
                    string[] list = val.Split('|');
                    for (int i = 0; i < 2; i++)
                        vhf_level_table[i] = float.Parse(list[i]);
                }
                else if (name.StartsWith("uhf_level_table"))
                {
                    string[] list = val.Split('|');
                    for (int i = 0; i < 2; i++)
                        uhf_level_table[i] = float.Parse(list[i]);
                }
                else if (name.StartsWith("rx1_ant_by_band"))  // ke9ns when you add bands, you need to add more values inside xml
                {
                    string[] list = val.Split('|');


                    for (int i = 0; i < (int)Band.LAST; i++)
                    {
                        if (i < list.Length) // ke9ns add to prevent index out of bounds
                        {
                            rx1_ant_by_band[i] = (FWCAnt)int.Parse(list[i]);
                        }
                        else Debug.WriteLine("index short");
                    }
                }
                else if (name.StartsWith("tx_ant_by_band")) // ke9ns add .205
                {
                    string[] list = val.Split('|');
                    for (int i = 0; i < (int)Band.LAST; i++)
                    {
                        if (i < list.Length)
                        {
                            tx_ant_by_band[i] = (FWCAnt)int.Parse(list[i]);
                        }
                        else Debug.WriteLine("index short2");
                    }
                }
                else if (name.StartsWith("rx2_ant_by_band"))
                {
                    string[] list = val.Split('|');

                    for (int i = 0; i < (int)Band.LAST; i++)
                    {
                        if (i < list.Length)
                        {
                            rx2_ant_by_band[i] = (FWCAnt)int.Parse(list[i]);
                        }
                        else Debug.WriteLine("index short");
                    }
                }
                else if (name.StartsWith("tx_ant_by2_band")) // ke9ns add .205
                {
                    string[] list = val.Split('|');
                    for (int i = 0; i < (int)Band.LAST; i++)
                    {
                        if (i < list.Length)
                        {
                            tx_ant_by2_band[i] = (FWCAnt)int.Parse(list[i]);
                        }
                        else Debug.WriteLine("index short2");
                    }
                }
                else if (name.StartsWith("rx_ant_1500_by_band"))
                {
                    string[] list = val.Split('|');
                    for (int i = 0; i < (int)Band.LAST; i++)
                    {
                        if (i < list.Length)
                        {
                            rx_ant_1500_by_band[i] = (HIDAnt)int.Parse(list[i]);
                        }
                        else Debug.WriteLine("index short");
                    }
                }
                else if (name.StartsWith("tx_ant_1500_by_band"))
                {
                    string[] list = val.Split('|');
                    for (int i = 0; i < (int)Band.LAST; i++)
                    {
                        if (i < list.Length)
                        {
                            tx_ant_1500_by_band[i] = (HIDAnt)int.Parse(list[i]);
                        }
                        else Debug.WriteLine("index short");
                    }
                }
                else if (name.StartsWith("rx1_loop_by_band"))
                {
                    string[] list = val.Split('|');
                    for (int i = 0; i < (int)Band.LAST; i++)
                    {
                        if (i < list.Length)
                        {
                            rx1_loop_by_band[i] = Convert.ToBoolean(int.Parse(list[i]));
                        }
                        else Debug.WriteLine("index short");
                    }
                }
                else if (name.StartsWith("rx1_preamp_by_band"))
                {
                    string[] list = val.Split('|');
                    for (int i = 0; i < (int)Band.LAST; i++)
                    {
                        if (i < list.Length)
                        {
                            rx1_preamp_by_band[i] = (PreampMode)(int.Parse(list[i]));
                        }
                        else Debug.WriteLine("index short");

                        if (rx1_preamp_by_band[i] == PreampMode.FIRST) rx1_preamp_by_band[i] = PreampMode.OFF;
                    }
                }
                else if (name.StartsWith("rx2_preamp_by_band"))
                {
                    string[] list = val.Split('|');
                    for (int i = 0; i < (int)Band.LAST; i++)
                    {
                        if (i < list.Length)
                        {
                            rx2_preamp_by_band[i] = (PreampMode)(int.Parse(list[i]));
                        }
                        else Debug.WriteLine("index short");
                    }
                }
                else if (name.StartsWith("power_by_band"))
                {
                    string[] list = val.Split('|');
                    for (int i = 0; i < (int)Band.LAST; i++)
                    {
                        if (i < list.Length)
                        {
                            power_by_band[i] = int.Parse(list[i]);
                        }
                        else Debug.WriteLine("index short");
                    }
                }

                //========================================================
                else if (name.StartsWith("power_by_mode_by_band")) // ke9ns add
                {
                    string[] list = val.Split('|');
                    for (int i = 0; i < (int)Band.LAST; i++)
                    {
                        for (int ii = 0; ii < (int)DSPMode.LAST; ii++)
                        {
                            if (((i * (int)DSPMode.LAST) + ii) < list.Length)
                            {
                                power_by_mode_by_band[i, ii] = int.Parse(list[(i * (int)DSPMode.LAST) + ii]); // (i * dspmode.last)+ii
                            }
                            else Debug.WriteLine("index short");
                        }
                    }
                }
                //========================================================
                else if (name.StartsWith("limit_by_mode_by_band")) // ke9ns add
                {
                    string[] list = val.Split('|');
                    for (int i = 0; i < (int)Band.LAST; i++)
                    {
                        for (int ii = 0; ii < (int)DSPMode.LAST; ii++)
                        {
                            if (((i * (int)DSPMode.LAST) + ii) < list.Length)
                            {
                                limit_by_mode_by_band[i, ii] = int.Parse(list[(i * (int)DSPMode.LAST) + ii]); // 
                            }
                            else Debug.WriteLine("index short");
                        }
                    }
                }
                else if (name.StartsWith("fm_tx_offset_by_band_mhz"))
                {
                    string[] list = val.Split('|');
                    for (int i = 0; i < (int)Band.LAST; i++)
                    {
                        if (i < list.Length)
                        {
                            fm_tx_offset_by_band_mhz[i] = double.Parse(list[i]);
                        }
                        else Debug.WriteLine("index short");
                    }
                }
                else if (name.StartsWith("rx1_agct_by_band"))
                {
                    string[] list = val.Split('|');
                    for (int i = 0; i < (int)Band.LAST; i++)
                    {
                        if (i < list.Length)
                        {
                            rx1_agct_by_band[i] = int.Parse(list[i]);
                        }
                        else Debug.WriteLine("index short");
                    }
                }
                else if (name.StartsWith("rx2_agct_by_band"))
                {
                    string[] list = val.Split('|');
                    for (int i = 0; i < (int)Band.LAST; i++)
                    {
                        if (i < list.Length)
                        {
                            rx2_agct_by_band[i] = int.Parse(list[i]);
                        }
                        else Debug.WriteLine("index short");
                    }
                }
                else if (name.StartsWith("tx1_by_band"))
                {
                    string[] list = val.Split('|');
                    for (int i = 0; i < (int)Band.LAST; i++)
                    {
                        if (i < list.Length)
                        {
                            tx1_by_band[i] = Convert.ToBoolean(int.Parse(list[i]));
                        }
                        else Debug.WriteLine("index short");
                    }
                }
                else if (name.StartsWith("tx2_by_band"))
                {
                    string[] list = val.Split('|');
                    for (int i = 0; i < (int)Band.LAST; i++)
                    {
                        if (i < list.Length)
                        {
                            tx2_by_band[i] = Convert.ToBoolean(int.Parse(list[i]));
                        }
                        else Debug.WriteLine("index short");
                    }
                }
                else if (name.StartsWith("tx3_by_band"))
                {
                    string[] list = val.Split('|');
                    for (int i = 0; i < (int)Band.LAST; i++)
                    {
                        if (i < list.Length)
                        {
                            tx3_by_band[i] = Convert.ToBoolean(int.Parse(list[i]));
                        }
                        else Debug.WriteLine("index short");
                    }
                }

                else if (name.StartsWith("tx1_by2_band")) // ke9ns add .206
                {
                    string[] list = val.Split('|');
                    for (int i = 0; i < (int)Band.LAST; i++)
                    {
                        if (i < list.Length)
                        {
                            tx1_by2_band[i] = Convert.ToBoolean(int.Parse(list[i]));
                        }
                        else Debug.WriteLine("index short");
                    }
                }
                else if (name.StartsWith("tx2_by2_band"))
                {
                    string[] list = val.Split('|');
                    for (int i = 0; i < (int)Band.LAST; i++)
                    {
                        if (i < list.Length)
                        {
                            tx2_by2_band[i] = Convert.ToBoolean(int.Parse(list[i]));
                        }
                        else Debug.WriteLine("index short");
                    }
                }
                else if (name.StartsWith("tx3_by2_band"))
                {
                    string[] list = val.Split('|');
                    for (int i = 0; i < (int)Band.LAST; i++)
                    {
                        if (i < list.Length)
                        {
                            tx3_by2_band[i] = Convert.ToBoolean(int.Parse(list[i]));
                        }
                        else Debug.WriteLine("index short");
                    }
                }


                switch (name)
                {
                    case "rx2_res_offset":
                        rx2_res_offset = float.Parse(val);
                        break;
                    case "current_ant_mode":
                        current_ant_mode = (AntMode)int.Parse(val);
                        break;
                    /*case "rx1_ant":
						rx1_ant = (FWCAnt)int.Parse(val);
						break;
					case "rx1_loop":
						rx1_loop = bool.Parse(val);
						break;
					case "rx2_ant":
						rx2_ant = (FWCAnt)int.Parse(val);
						break;
					case "tx_ant":
						tx_ant = (FWCAnt)int.Parse(val);
						break;*/
                    case "fwc_preamp_offset":
                        fwc_preamp_offset = float.Parse(val);
                        break;
                    case "fwc_last_cal_date_time":
                        fwc_last_cal_date_time = long.Parse(val);
                        break;
                    case "hid_last_cal_date_time":
                        hid_last_cal_date_time = long.Parse(val);
                        break;
                    case "fwc_serial_num":
                        fwc_serial_num = uint.Parse(val);
                        break;
                    case "hid_serial_num":
                        hid_serial_num = uint.Parse(val);
                        break;
                    case "fwc_trx_serial_num":
                        fwc_trx_serial_num = uint.Parse(val);
                        break;
                    case "hid_trx_serial_num":
                        hid_trx_serial_num = uint.Parse(val);
                        break;
                    case "rx2_last_cal_date_time":
                        rx2_last_cal_date_time = long.Parse(val);
                        break;
                    case "rx2_serial_num":
                        rx2_serial_num = uint.Parse(val);
                        break;
                    case "rx2_trx_match_serial":
                        rx2_trx_match_serial = uint.Parse(val);
                        break;
                    case "rx2_fixed_gain":
                        rx2_fixed_gain = int.Parse(val);
                        break;
                    case "rx2_max_gain":
                        rx2_max_gain = int.Parse(val);
                        break;



                    case "band_160m_index":
                        band_160m_index = Int32.Parse(val);
                        break;
                    case "band_80m_index":
                        band_80m_index = Int32.Parse(val);
                        break;
                    case "band_60m_index":
                        band_60m_index = Int32.Parse(val);
                        break;
                    case "band_40m_index":
                        band_40m_index = Int32.Parse(val);
                        break;
                    case "band_30m_index":
                        band_30m_index = Int32.Parse(val);
                        break;
                    case "band_20m_index":
                        band_20m_index = Int32.Parse(val);
                        break;
                    case "band_17m_index":
                        band_17m_index = Int32.Parse(val);
                        break;
                    case "band_15m_index":
                        band_15m_index = Int32.Parse(val);
                        break;
                    case "band_12m_index":
                        band_12m_index = Int32.Parse(val);
                        break;
                    case "band_10m_index":
                        band_10m_index = Int32.Parse(val);
                        break;
                    case "band_6m_index":
                        band_6m_index = Int32.Parse(val);
                        break;
                    case "band_2m_index":
                        band_2m_index = Int32.Parse(val);
                        break;
                    case "band_wwv_index":
                        band_wwv_index = Int32.Parse(val);
                        break;
                    case "band_gen_index":
                        band_gen_index = Int32.Parse(val);
                        break;


                    case "band_LMF_index":                     // ke9ns add
                        band_LMF_index = Int32.Parse(val);
                        break;
                    case "band_120m_index":
                        band_120m_index = Int32.Parse(val);
                        break;
                    case "band_90m_index":
                        band_90m_index = Int32.Parse(val);
                        break;
                    case "band_61m_index":
                        band_61m_index = Int32.Parse(val);
                        break;
                    case "band_49m_index":
                        band_49m_index = Int32.Parse(val);
                        break;
                    case "band_41m_index":
                        band_41m_index = Int32.Parse(val);
                        break;
                    case "band_31m_index":
                        band_31m_index = Int32.Parse(val);
                        break;
                    case "band_25m_index":
                        band_25m_index = Int32.Parse(val);
                        break;
                    case "band_22m_index":
                        band_22m_index = Int32.Parse(val);
                        break;
                    case "band_19m_index":
                        band_19m_index = Int32.Parse(val);
                        break;
                    case "band_16m_index":
                        band_16m_index = Int32.Parse(val);
                        break;
                    case "band_14m_index":
                        band_14m_index = Int32.Parse(val);
                        break;
                    case "band_13m_index":
                        band_13m_index = Int32.Parse(val);
                        break;
                    case "band_11m_index":
                        band_11m_index = Int32.Parse(val);
                        break;

                    case "band_vhf0_index":
                        band_vhf0_index = Int32.Parse(val);
                        break;
                    case "band_vhf1_index":
                        band_vhf1_index = Int32.Parse(val);
                        break;
                    case "band_vhf2_index":
                        band_vhf2_index = Int32.Parse(val);
                        break;
                    case "band_vhf3_index":
                        band_vhf3_index = Int32.Parse(val);
                        break;
                    case "band_vhf4_index":
                        band_vhf4_index = Int32.Parse(val);
                        break;
                    case "band_vhf5_index":
                        band_vhf5_index = Int32.Parse(val);
                        break;
                    case "band_vhf6_index":
                        band_vhf6_index = Int32.Parse(val);
                        break;
                    case "band_vhf7_index":
                        band_vhf7_index = Int32.Parse(val);
                        break;
                    case "band_vhf8_index":
                        band_vhf8_index = Int32.Parse(val);
                        break;
                    case "band_vhf9_index":
                        band_vhf9_index = Int32.Parse(val);
                        break;
                    case "band_vhf10_index":
                        band_vhf10_index = Int32.Parse(val);
                        break;
                    case "band_vhf11_index":
                        band_vhf11_index = Int32.Parse(val);
                        break;
                    case "band_vhf12_index":
                        band_vhf12_index = Int32.Parse(val);
                        break;
                    case "band_vhf13_index":
                        band_vhf13_index = Int32.Parse(val);
                        break;


                    case "current_datetime_mode":
                        CurrentDateTimeMode = (DateTimeMode)(Int32.Parse(val));
                        break;
                    case "wheel_tune_index":
                        tune_step_index = Int32.Parse(val);
                        break;
                    case "txtMemoryQuick":
                        txtMemoryQuick.Text = val;
                        break;
                    case "rx1_display_cal_offset":
                        RX1DisplayCalOffset = float.Parse(val);
                        break;
                    case "rx1_meter_cal_offset":
                        rx1_meter_cal_offset = float.Parse(val);
                        break;
                    case "quick_save_mode":
                        quick_save_mode = (DSPMode)(Int32.Parse(val));
                        break;
                    case "quick_save_filter":
                        quick_save_filter = (Filter)(Int32.Parse(val));
                        break;
                    case "vfob_dsp_mode":
                        vfob_dsp_mode = (DSPMode)(Int32.Parse(val));
                        break;
                    case "vfob_filter":
                        vfob_filter = (Filter)(Int32.Parse(val));
                        break;

                    case "console_top":
                        num = Int32.Parse(val);
                        CONSOLET = num;

                        this.Top = num;
                        Debug.WriteLine("TOPP" + num);

                        break;
                    case "console_left":
                        num = Int32.Parse(val);

                        CONSOLEL = num;
                        this.Left = num;
                        Debug.WriteLine("LEFTT" + num);

                        break;
                    case "console_width":

                        // if (dpi <= 96)
                        this.Width = CONSOLEW = int.Parse(val);
                        Debug.WriteLine("WIDTHH" + val);

                        break;
                    case "console_height":

                        // if (dpi <= 96) 
                        this.Height = CONSOLEH = int.Parse(val);
                        Debug.WriteLine("HEIGHTT" + val);

                        break;
                    case "console_zaximize":  //   a.Add("console_zaximize/" +this.WindowState.ToString()); // ke9ns add: for maximum form size detection _z so it loads after the top -8 and left 1912 settings

                        if (val == "Maximized")
                        {
                            CONSOLEM = true;
                            //  this.WindowState = FormWindowState.Maximized;
                            // this.WindowState = FormWindowState.Normal;
                            Debug.WriteLine("MAXIMUM1");
                        }
                        break;
                    case "setup_top":
                        num = Int32.Parse(val);
                        /*if((num < 0) || (num > Screen.PrimaryScreen.Bounds.Height && Screen.AllScreens.Length == 1))
							num = 0;*/
                        setupForm.Top = num;
                        break;
                    case "setup_left":
                        num = Int32.Parse(val);
                        /*if((num < 0) || (num > Screen.PrimaryScreen.Bounds.Width && Screen.AllScreens.Length == 1))
							num = 0;*/
                        setupForm.Left = num;
                        break;
                    case "SetupWizard":
                        if (val == "1")
                            run_setup_wizard = false;
                        break;
                    case "show_alpha_warning":
                        show_alpha_warning = bool.Parse(val);
                        break;
                    case "show_beta_warning":
                        show_beta_warning = bool.Parse(val);
                        break;
                    case "show_mobile_warning":
                        show_mobile_warning = bool.Parse(val);
                        break;
                    case "rx1_image_gain_table":
                        string[] list = val.Split('|');
                        for (int i = 0; i <= (int)Band.B6M && i < list.Length; i++)
                            rx1_image_gain_table[i] = float.Parse(list[i]);
                        break;
                    case "rx1_image_phase_table":
                        list = val.Split('|');
                        for (int i = 0; i <= (int)Band.B6M && i < list.Length; i++)
                            rx1_image_phase_table[i] = float.Parse(list[i]);
                        break;
                    case "rx2_image_gain_table":
                        list = val.Split('|');
                        for (int i = 0; i <= (int)Band.B6M && i < list.Length; i++)
                            rx2_image_gain_table[i] = float.Parse(list[i]);
                        break;
                    case "rx2_image_phase_table":
                        list = val.Split('|');
                        for (int i = 0; i <= (int)Band.B6M && i < list.Length; i++)
                            rx2_image_phase_table[i] = float.Parse(list[i]);
                        break;
                    case "tx_image_gain_table":
                        list = val.Split('|');
                        for (int i = 0; i <= (int)Band.B6M && i < list.Length; i++)
                            tx_image_gain_table[i] = float.Parse(list[i]);
                        break;
                    case "tx_image_phase_table":
                        list = val.Split('|');
                        for (int i = 0; i <= (int)Band.B6M && i < list.Length; i++)
                            tx_image_phase_table[i] = float.Parse(list[i]);
                        break;
                    case "rx1_level_checksum":
                        rx1_level_checksum = byte.Parse(val);
                        break;
                    case "rx1_image_gain_checksum":
                        rx1_image_gain_checksum = byte.Parse(val);
                        break;
                    case "rx1_image_phase_checksum":
                        rx1_image_phase_checksum = byte.Parse(val);
                        break;
                    case "tx_image_gain_checksum":
                        tx_image_gain_checksum = byte.Parse(val);
                        break;
                    case "tx_image_phase_checksum":
                        tx_image_phase_checksum = byte.Parse(val);
                        break;
                    case "tx_carrier_checksum":
                        tx_carrier_checksum = byte.Parse(val);
                        break;
                    case "pa_bias_checksum":
                        pa_bias_checksum = byte.Parse(val);
                        break;
                    case "pa_bridge_checksum":
                        pa_bridge_checksum = byte.Parse(val);
                        break;
                    case "pa_power_checksum":
                        pa_power_checksum = byte.Parse(val);
                        break;
                    case "pa_swr_checksum":
                        pa_swr_checksum = byte.Parse(val);
                        break;
                    case "atu_swr_checksum":
                        atu_swr_checksum = byte.Parse(val);
                        break;
                    case "rx2_level_checksum":
                        rx2_level_checksum = byte.Parse(val);
                        break;
                    case "rx2_image_gain_checksum":
                        rx2_image_gain_checksum = byte.Parse(val);
                        break;
                    case "rx2_image_phase_checksum":
                        rx2_image_phase_checksum = byte.Parse(val);
                        break;
                    case "saved_rx_only":
                        saved_rx_only = bool.Parse(val);
                        break;
                    case "mon_recall":
                        mon_recall = bool.Parse(val);
                        break;
                    case "rx1_squelch_on":
                        rx1_squelch_on = bool.Parse(val);
                        break;
                    case "rx1_squelch_threshold_scroll":
                        rx1_squelch_threshold_scroll = int.Parse(val);
                        break;
                    case "rx1_fm_squelch_threshold_scroll":
                        rx1_fm_squelch_threshold_scroll = int.Parse(val);
                        break;
                    case "rx2_squelch_on":
                        rx1_squelch_on = bool.Parse(val);
                        break;
                    case "rx2_squelch_threshold_scroll":
                        rx2_squelch_threshold_scroll = int.Parse(val);
                        break;
                    case "rx2_fm_squelch_threshold_scroll":
                        rx2_fm_squelch_threshold_scroll = int.Parse(val);
                        break;
                    case "current_flex_control_mode":
                        current_flexcontrol_mode = (FlexControlMode)Enum.Parse(typeof(FlexControlMode), val);
                        break;
                    case "flexcontrol_autodetect":
                        flexcontrol_autodetect = bool.Parse(val);
                        break;

                    case "waterfall_high_threshold_160m":
                        waterfall_high_threshold_160m = float.Parse(val);   // ke9ns: GET value from database
                        break;
                    case "waterfall_low_threshold_160m":
                        waterfall_low_threshold_160m = float.Parse(val);
                        waterfall_lowRX2_threshold_160m = float.Parse(val); // 
                        break;
                    case "waterfall_high_threshold_80m":
                        waterfall_high_threshold_80m = float.Parse(val);
                        break;
                    case "waterfall_low_threshold_80m":
                        waterfall_low_threshold_80m = float.Parse(val);
                        waterfall_lowRX2_threshold_80m = float.Parse(val);
                        break;
                    case "waterfall_high_threshold_60m":
                        waterfall_high_threshold_60m = float.Parse(val);
                        break;
                    case "waterfall_low_threshold_60m":
                        waterfall_low_threshold_60m = float.Parse(val);
                        waterfall_lowRX2_threshold_60m = float.Parse(val);
                        break;
                    case "waterfall_high_threshold_40m":
                        waterfall_high_threshold_40m = float.Parse(val);
                        break;
                    case "waterfall_low_threshold_40m":
                        waterfall_low_threshold_40m = float.Parse(val);
                        waterfall_lowRX2_threshold_40m = float.Parse(val);
                        break;
                    case "waterfall_high_threshold_30m":
                        waterfall_high_threshold_30m = float.Parse(val);
                        break;
                    case "waterfall_low_threshold_30m":
                        waterfall_low_threshold_30m = float.Parse(val);
                        waterfall_lowRX2_threshold_30m = float.Parse(val);
                        break;
                    case "waterfall_high_threshold_20m":
                        waterfall_high_threshold_20m = float.Parse(val);
                        break;
                    case "waterfall_low_threshold_20m":
                        waterfall_low_threshold_20m = float.Parse(val);
                        waterfall_lowRX2_threshold_40m = float.Parse(val);
                        break;
                    case "waterfall_high_threshold_17m":
                        waterfall_high_threshold_17m = float.Parse(val);
                        break;
                    case "waterfall_low_threshold_17m":
                        waterfall_low_threshold_17m = float.Parse(val);
                        waterfall_lowRX2_threshold_17m = float.Parse(val);
                        break;
                    case "waterfall_high_threshold_15m":
                        waterfall_high_threshold_15m = float.Parse(val);
                        break;
                    case "waterfall_low_threshold_15m":
                        waterfall_low_threshold_15m = float.Parse(val);
                        waterfall_lowRX2_threshold_15m = float.Parse(val);
                        break;
                    case "waterfall_high_threshold_12m":
                        waterfall_high_threshold_12m = float.Parse(val);
                        break;
                    case "waterfall_low_threshold_12m":
                        waterfall_low_threshold_12m = float.Parse(val);
                        waterfall_lowRX2_threshold_12m = float.Parse(val);
                        break;
                    case "waterfall_high_threshold_10m":
                        waterfall_high_threshold_10m = float.Parse(val);
                        break;
                    case "waterfall_low_threshold_10m":
                        waterfall_low_threshold_10m = float.Parse(val);
                        waterfall_lowRX2_threshold_10m = float.Parse(val);
                        break;
                    case "waterfall_high_threshold_6m":
                        waterfall_high_threshold_6m = float.Parse(val);
                        break;
                    case "waterfall_low_threshold_6m":
                        waterfall_low_threshold_6m = float.Parse(val);
                        waterfall_lowRX2_threshold_6m = float.Parse(val);
                        break;
                    case "waterfall_high_threshold_wwv":
                        waterfall_high_threshold_wwv = float.Parse(val);
                        break;
                    case "waterfall_low_threshold_wwv":
                        waterfall_low_threshold_wwv = float.Parse(val);
                        waterfall_lowRX2_threshold_wwv = float.Parse(val);
                        break;
                    case "waterfall_high_threshold_gen":
                        waterfall_high_threshold_gen = float.Parse(val);
                        break;
                    case "waterfall_low_threshold_gen":
                        waterfall_low_threshold_gen = float.Parse(val);
                        waterfall_lowRX2_threshold_gen = float.Parse(val);
                        break;
                    case "waterfall_high_threshold_xvtr":
                        waterfall_high_threshold_xvtr = float.Parse(val);
                        break;
                    case "waterfall_low_threshold_xvtr":
                        waterfall_low_threshold_xvtr = float.Parse(val);
                        waterfall_lowRX2_threshold_xvtr = float.Parse(val);
                        break;


                    case "waterfall_high_threshold_LMF":
                        waterfall_high_threshold_LMF = float.Parse(val);   // ke9ns: GET SWL value from database
                        break;
                    case "waterfall_low_threshold_LMF":
                        waterfall_low_threshold_LMF = float.Parse(val);
                        waterfall_lowRX2_threshold_LMF = float.Parse(val); // 
                        break;
                    case "waterfall_high_threshold_120m":
                        waterfall_high_threshold_120m = float.Parse(val);   // ke9ns: GET SWL value from database
                        break;
                    case "waterfall_low_threshold_120m":
                        waterfall_low_threshold_120m = float.Parse(val);
                        waterfall_lowRX2_threshold_120m = float.Parse(val); // 
                        break;
                    case "waterfall_high_threshold_90m":
                        waterfall_high_threshold_90m = float.Parse(val);
                        break;
                    case "waterfall_low_threshold_90m":
                        waterfall_low_threshold_90m = float.Parse(val);
                        waterfall_lowRX2_threshold_90m = float.Parse(val);
                        break;
                    case "waterfall_high_threshold_61m":
                        waterfall_high_threshold_61m = float.Parse(val);
                        break;
                    case "waterfall_low_threshold_61m":
                        waterfall_low_threshold_61m = float.Parse(val);
                        waterfall_lowRX2_threshold_61m = float.Parse(val);
                        break;
                    case "waterfall_high_threshold_49m":
                        waterfall_high_threshold_49m = float.Parse(val);
                        break;
                    case "waterfall_low_threshold_49m":
                        waterfall_low_threshold_49m = float.Parse(val);
                        waterfall_lowRX2_threshold_49m = float.Parse(val);
                        break;
                    case "waterfall_high_threshold_41m":
                        waterfall_high_threshold_41m = float.Parse(val);
                        break;
                    case "waterfall_low_threshold_41m":
                        waterfall_low_threshold_41m = float.Parse(val);
                        waterfall_lowRX2_threshold_41m = float.Parse(val);
                        break;
                    case "waterfall_high_threshold_31m":
                        waterfall_high_threshold_31m = float.Parse(val);
                        break;
                    case "waterfall_low_threshold_31m":
                        waterfall_low_threshold_31m = float.Parse(val);
                        waterfall_lowRX2_threshold_31m = float.Parse(val);
                        break;
                    case "waterfall_high_threshold_25m":
                        waterfall_high_threshold_25m = float.Parse(val);
                        break;
                    case "waterfall_low_threshold_25m":
                        waterfall_low_threshold_25m = float.Parse(val);
                        waterfall_lowRX2_threshold_25m = float.Parse(val);
                        break;
                    case "waterfall_high_threshold_22m":
                        waterfall_high_threshold_22m = float.Parse(val);
                        break;
                    case "waterfall_low_threshold_22m":
                        waterfall_low_threshold_22m = float.Parse(val);
                        waterfall_lowRX2_threshold_22m = float.Parse(val);
                        break;
                    case "waterfall_high_threshold_19m":
                        waterfall_high_threshold_19m = float.Parse(val);
                        break;
                    case "waterfall_low_threshold_19m":
                        waterfall_low_threshold_19m = float.Parse(val);
                        waterfall_lowRX2_threshold_19m = float.Parse(val);
                        break;
                    case "waterfall_high_threshold_16m":
                        waterfall_high_threshold_16m = float.Parse(val);
                        break;
                    case "waterfall_low_threshold_16m":
                        waterfall_low_threshold_16m = float.Parse(val);
                        waterfall_lowRX2_threshold_16m = float.Parse(val);
                        break;
                    case "waterfall_high_threshold_14m":
                        waterfall_high_threshold_14m = float.Parse(val);
                        break;
                    case "waterfall_low_threshold_14m":
                        waterfall_low_threshold_14m = float.Parse(val);
                        waterfall_lowRX2_threshold_14m = float.Parse(val);
                        break;
                    case "waterfall_high_threshold_13m":
                        waterfall_high_threshold_13m = float.Parse(val);
                        break;
                    case "waterfall_low_threshold_13m":
                        waterfall_low_threshold_13m = float.Parse(val);
                        waterfall_lowRX2_threshold_13m = float.Parse(val);
                        break;
                    case "waterfall_high_threshold_11m":
                        waterfall_high_threshold_11m = float.Parse(val);
                        break;
                    case "waterfall_low_threshold_11m":
                        waterfall_low_threshold_11m = float.Parse(val);
                        waterfall_lowRX2_threshold_11m = float.Parse(val);
                        break;


                    case "waterfall_update_period":
                        waterfall_update_period = int.Parse(val);
                        Display.WaterfallUpdatePeriod = waterfall_update_period;
                        break;
                    case "lsb_txprofile":
                        lsb_txprofile = val;
                        break;
                    case "usb_txprofile":
                        usb_txprofile = val;
                        break;
                    case "dsb_txprofile":
                        dsb_txprofile = val;
                        break;
                    case "cwl_txprofile":
                        cwl_txprofile = val;
                        break;
                    case "cwu_txprofile":
                        cwu_txprofile = val;
                        break;
                    case "fm_txprofile":
                        fm_txprofile = val;
                        break;
                    case "am_txprofile":
                        am_txprofile = val;
                        break;
                    case "sam_txprofile":
                        sam_txprofile = val;
                        break;
                    case "spec_txprofile":
                        spec_txprofile = val;
                        break;
                    case "digu_txprofile":
                        digu_txprofile = val;
                        break;
                    case "digl_txprofile":
                        digl_txprofile = val;
                        break;
                    case "drm_txprofile":
                        drm_txprofile = val;
                        break;
                }
            } // foreach item in the XML file here get items with state in name




            //==============================================================================================================================
            // restore saved values to the controls
            foreach (string s in a)             // string is in the format "name,value"
            {
                string[] vals = s.Split('/');
                string name = vals[0];
                string val = vals[1];

                if (s.StartsWith("chk"))            // control is a CheckBox
                {
                    for (int i = 0; i < checkbox_list.Count; i++)
                    {   // look through each control to find the matching name
                        CheckBoxTS c = (CheckBoxTS)checkbox_list[i];
                        if (c.Name.Equals(name))        // name found
                        {
                            c.Checked = bool.Parse(val);    // restore value
                            i = checkbox_list.Count + 1;
                        }
                        if (i == checkbox_list.Count)
                            MessageBox.Show(new Form { TopMost = true }, "Control not found: " + name, "GetState Error",
                                MessageBoxButtons.OK, MessageBoxIcon.Warning);
                    }
                }
                else if (s.StartsWith("combo")) // control is a ComboBox
                {
                    for (int i = 0; i < combobox_list.Count; i++)
                    {   // look through each control to find the matching name
                        ComboBoxTS c = (ComboBoxTS)combobox_list[i];
                        if (c.Name.Equals(name))        // name found
                        {
                            c.Text = val;   // restore value
                            i = combobox_list.Count + 1;
                        }
                        if (i == combobox_list.Count)
                            MessageBox.Show(new Form { TopMost = true }, "Control not found: " + name, "GetState Error",
                                MessageBoxButtons.OK, MessageBoxIcon.Warning);
                    }
                }
                else if (s.StartsWith("ud"))
                {
                    for (int i = 0; i < numericupdown_list.Count; i++)
                    {   // look through each control to find the matching name
                        NumericUpDownTS c = (NumericUpDownTS)numericupdown_list[i];
                        if (c.Name.Equals(name))        // name found
                        {
                            decimal num = decimal.Parse(val);

                            if (num > c.Maximum) num = c.Maximum;       // check endpoints
                            else if (num < c.Minimum) num = c.Minimum;
                            c.Value = num;          // restore value
                            i = numericupdown_list.Count + 1;
                        }
                        if (i == numericupdown_list.Count)
                            MessageBox.Show(new Form { TopMost = true }, "Control not found: " + name, "GetState Error",
                                MessageBoxButtons.OK, MessageBoxIcon.Warning);
                    }
                }
                else if (s.StartsWith("rad"))
                {   // look through each control to find the matching name
                    for (int i = 0; i < radiobutton_list.Count; i++)
                    {
                        RadioButtonTS c = (RadioButtonTS)radiobutton_list[i];
                        if (c.Name.Equals(name))        // name found
                        {
                            if (!val.ToLower().Equals("true") && !val.ToLower().Equals("false"))
                                val = "True";
                            c.Checked = bool.Parse(val);    // restore value
                            i = radiobutton_list.Count + 1;
                        }
                        if (i == radiobutton_list.Count)
                            MessageBox.Show(new Form { TopMost = true }, "Control not found: " + name, "GetState Error",
                                MessageBoxButtons.OK, MessageBoxIcon.Warning);
                    }
                }
                else if (s.StartsWith("txt")) // .186
                {   // look through each control to find the matching name
                    for (int i = 0; i < textbox_list.Count; i++)
                    {
                        TextBoxTS c = (TextBoxTS)textbox_list[i];
                        if (c.Name.Equals(name))        // name found
                        {
                            c.Text = val;   // restore value
                            i = textbox_list.Count + 1;
                        }
                        if (i == textbox_list.Count)
                            MessageBox.Show(new Form { TopMost = true }, "Control not found: " + name, "GetState Error",
                                MessageBoxButtons.OK, MessageBoxIcon.Warning);
                    }
                }


                else if (s.StartsWith("tb"))
                {
                    // look through each control to find the matching name
                    for (int i = 0; i < trackbar_list.Count; i++)
                    {
                        TrackBarTS c = (TrackBarTS)trackbar_list[i];
                        if (c.Name.Equals(name))        // name found
                        {
                            c.Value = Int32.Parse(val);
                            i = trackbar_list.Count + 1;
                        }
                        if (i == trackbar_list.Count)
                            MessageBox.Show(new Form { TopMost = true }, "Control not found: " + name, "GetState Error",
                                MessageBoxButtons.OK, MessageBoxIcon.Warning);
                    }
                }
                else if (s.StartsWith("ptb"))
                {
                    // look through each control to find the matching name
                    for (int i = 0; i < prettytrackbar_list.Count; i++)
                    {
                        PrettyTrackBar c = (PrettyTrackBar)prettytrackbar_list[i];
                        if (c.Name.Equals(name))		// name found
                        {
                            c.Value = Int32.Parse(val);
                            i = prettytrackbar_list.Count + 1;
                        }
                        if (i == prettytrackbar_list.Count)
                            MessageBox.Show(new Form { TopMost = true }, "Control not found: " + name, "GetState Error",
                                MessageBoxButtons.OK, MessageBoxIcon.Warning);
                    }
                }

            } // foreach


            Common.ForceFormOnScreen(this);
            Common.ForceFormOnScreen(setupForm);

            tempVFOAFreq = VFOAFreq; // ke9ns add get CTUN ready quickly


            //--------------------------------------------------------------------------------------------------------------------------------------------
            //ke9ns .248 copy over normal Ham band data into Extended SWL bands (since we only calibrate ham bands)
            //

            //.248 160m :0-2.099, 80M:2.1-4.099, 60-40M 4.1-7.399, 30-20m 7.4- 14.449, 17-15M 14.450-21.549,12-10m 21.550-29.799, 6m 29.8- ? mhz

            //  if (Band.BLMF == b) b1 = Band.B160M; // .47 mhz  (160m LPF ends at 2.1mhz)

            //  else if (Band.B120M == b) b1 = Band.B80M; // 2-3 mhz    (80m LPF ends at 4.1mhz)
            //  else if (Band.B90M == b) b1 = Band.B80M; // 3-3.5 mhz

            // else if (Band.B61M == b) b1 = Band.B60M; // 4-5.25 mhz  (60m-40m LPF ends at 7.4mhz)
            // else if (Band.B49M == b) b1 = Band.B40M; // 5.45 - 7 mhz

            //  else if (Band.B41M == b) b1 = Band.B30M; // 7.3-9 mhz   (30m-20m LPF ends at 14.45mhz)
            //  else if (Band.B31M == b) b1 = Band.B30M; // 9-10.1 mhz
            // else if (Band.B25M == b) b1 = Band.B30M; // 10.15-13.75 mhz
            //  else if (Band.B22M == b) b1 = Band.B20M; // 13.75-14 mhz

            //  else if (Band.B19M == b) b1 = Band.B17M; // 14.35-17 mhz  (17m-15m LPF ends at 21.55mhz)
            // else if (Band.B16M == b) b1 = Band.B17M; // 17-18 mhz
            // else if (Band.B14M == b) b1 = Band.B15M; // 18-21.5 mhz

            //  else if (Band.B13M == b) b1 = Band.B12M; // 21-25 mhz   (12-10m LPF ends at 29.8mhz)
            //  else if (Band.B11M == b) b1 = Band.B10M; // 25-28 mhz

            // ORIGINAL KEYS: GEN=0,B160M=1,B80M,B60M,B40M,B30M,B20M,B17M,B15M,B12M,B10M,B6M,B2M,WWV=13,VHF0,VHF1,VHF2=16,VHF3,VHF4,VHF5,VHF6,VHF7,VHF8,VHF9,VHF10,VHF11,VHF12,VHF13=27,
            // KE9NS keys added: BLMF=28,B120M,B90M,B61M,B49M,B41M,B31M,B25M,B22M,B19M,B16M,B14M,B13M,B11M=41

            for (int i = 0; i < 13; i++)
            {
                power_table[28][i] = power_table[1][i]; // 160M into BLMF band data       (160m LPF ends at 2.1mhz)

                power_table[29][i] = power_table[2][i]; // 80M into 120m band data 2.1mhz  (80m LPF ends at 4.1mhz)
                power_table[30][i] = power_table[2][i]; // 80M into 90m band data

                power_table[31][i] = power_table[3][i]; // 60M into 61m band data  (60m-40m LPF ends at 7.4mhz)
                power_table[32][i] = power_table[4][i]; // 40M into 49m band data

                power_table[33][i] = power_table[5][i]; // 30M into 41m band data (30m-20m LPF ends at 14.45mhz)
                power_table[34][i] = power_table[5][i]; // 30M into 31m band data
                power_table[35][i] = power_table[5][i]; // 30M into 25m band data
                power_table[36][i] = power_table[6][i]; // 20M into 22m band data

                power_table[37][i] = power_table[7][i]; // 17M into 19m band data   (17m-15m LPF ends at 21.55mhz)
                power_table[38][i] = power_table[7][i]; // 17M into 16m band data
                power_table[39][i] = power_table[8][i]; // 15M into 14m band data

                power_table[40][i] = power_table[9][i]; // 12M into 13m band data   (12-10m LPF ends at 29.8mhz)
                power_table[41][i] = power_table[10][i]; // 10M into 11m band data

            } // for

            for (int i = 0; i < 6; i++)
            {
                pa_bridge_table[28][i] = pa_bridge_table[1][i]; // 160M into BLMF band data

                pa_bridge_table[29][i] = pa_bridge_table[2][i]; // 80M into 120m band data
                pa_bridge_table[30][i] = pa_bridge_table[2][i]; // 80M into 90m band data

                pa_bridge_table[31][i] = pa_bridge_table[3][i]; // 60M into 61m band data
                pa_bridge_table[32][i] = pa_bridge_table[4][i]; // 40M into 49m band data

                pa_bridge_table[33][i] = pa_bridge_table[5][i]; // 30M into 41m band data
                pa_bridge_table[34][i] = pa_bridge_table[5][i]; // 30M into 31m band data
                pa_bridge_table[35][i] = pa_bridge_table[5][i]; // 30M into 25m band data
                pa_bridge_table[36][i] = pa_bridge_table[6][i]; // 20M into 22m band data

                pa_bridge_table[37][i] = pa_bridge_table[7][i]; // 17M into 19m band data
                pa_bridge_table[38][i] = pa_bridge_table[7][i]; // 17M into 16m band data
                pa_bridge_table[39][i] = pa_bridge_table[8][i]; // 15M into 14m band data

                pa_bridge_table[40][i] = pa_bridge_table[9][i]; // 12M into 13m band data
                pa_bridge_table[41][i] = pa_bridge_table[10][i]; // 10M into 11m band data

            } // for

            swr_table[28] = swr_table[1]; // 160M into BLMF band data

            swr_table[29] = swr_table[2]; // 80M into 120m band data
            swr_table[30] = swr_table[2]; // 80M into 90m band data

            swr_table[31] = swr_table[3]; // 60M into 61m band data
            swr_table[32] = swr_table[4]; // 60M into 49m band data

            swr_table[33] = swr_table[5]; // 40M into 41m band data
            swr_table[34] = swr_table[5]; // 30M into 31m band data
            swr_table[35] = swr_table[5]; // 20M into 25m band data
            swr_table[36] = swr_table[6]; // 20M into 22m band data

            swr_table[37] = swr_table[7]; // 17M into 19m band data
            swr_table[38] = swr_table[7]; // 17M into 16m band data
            swr_table[39] = swr_table[8]; // 15M into 14m band data

            swr_table[40] = swr_table[9]; // 12M into 13m band data
            swr_table[41] = swr_table[10]; // 10M into 11m band data

            atu_swr_table[28] = atu_swr_table[1]; // 160M into BLMF band data

            atu_swr_table[29] = atu_swr_table[2]; // 80M into 120m band data
            atu_swr_table[30] = atu_swr_table[2]; // 80M into 90m band data

            atu_swr_table[31] = atu_swr_table[3]; // 60M into 61m band data
            atu_swr_table[32] = atu_swr_table[4]; // 60M into 49m band data

            atu_swr_table[33] = atu_swr_table[5]; // 40M into 41m band data
            atu_swr_table[34] = atu_swr_table[5]; // 30M into 31m band data
            atu_swr_table[35] = atu_swr_table[5]; // 20M into 25m band data
            atu_swr_table[36] = atu_swr_table[6]; // 20M into 22m band data

            atu_swr_table[37] = atu_swr_table[7]; // 17M into 19m band data
            atu_swr_table[38] = atu_swr_table[7]; // 17M into 16m band data
            atu_swr_table[39] = atu_swr_table[8]; // 15M into 14m band data

            atu_swr_table[40] = atu_swr_table[9]; // 12M into 13m band data
            atu_swr_table[41] = atu_swr_table[10]; // 10M into 11m band data


            for (int i = 0; i < 3; i++)
            {
                rx1_level_table[28][i] = rx1_level_table[1][i]; // 160M into BLMF band data

                rx1_level_table[29][i] = rx1_level_table[2][i]; // 80M into 120m band data
                rx1_level_table[30][i] = rx1_level_table[2][i]; // 80M into 90m band data

                rx1_level_table[31][i] = rx1_level_table[3][i]; // 60M into 61m band data
                rx1_level_table[32][i] = rx1_level_table[4][i]; // 60M into 49m band data

                rx1_level_table[33][i] = rx1_level_table[5][i]; // 40M into 41m band data
                rx1_level_table[34][i] = rx1_level_table[5][i]; // 30M into 31m band data
                rx1_level_table[35][i] = rx1_level_table[5][i]; // 20M into 25m band data
                rx1_level_table[36][i] = rx1_level_table[6][i]; // 20M into 22m band data

                rx1_level_table[37][i] = rx1_level_table[7][i]; // 17M into 19m band data
                rx1_level_table[38][i] = rx1_level_table[7][i]; // 17M into 16m band data
                rx1_level_table[39][i] = rx1_level_table[8][i]; // 15M into 14m band data

                rx1_level_table[40][i] = rx1_level_table[9][i]; // 12M into 13m band data
                rx1_level_table[41][i] = rx1_level_table[10][i]; // 10M into 11m band data

            } // for

            for (int i = 0; i < 3; i++)
            {
                rx2_level_table[28][i] = rx2_level_table[1][i]; // 160M into BLMF band data

                rx2_level_table[29][i] = rx2_level_table[2][i]; // 80M into 120m band data
                rx2_level_table[30][i] = rx2_level_table[2][i]; // 80M into 90m band data

                rx2_level_table[31][i] = rx2_level_table[3][i]; // 60M into 61m band data
                rx2_level_table[32][i] = rx2_level_table[4][i]; // 60M into 49m band data

                rx2_level_table[33][i] = rx2_level_table[5][i]; // 40M into 41m band data
                rx2_level_table[34][i] = rx2_level_table[5][i]; // 30M into 31m band data
                rx2_level_table[35][i] = rx2_level_table[5][i]; // 20M into 25m band data
                rx2_level_table[36][i] = rx2_level_table[6][i]; // 20M into 22m band data

                rx2_level_table[37][i] = rx2_level_table[7][i]; // 17M into 19m band data
                rx2_level_table[38][i] = rx2_level_table[7][i]; // 17M into 16m band data
                rx2_level_table[39][i] = rx2_level_table[8][i]; // 15M into 14m band data

                rx2_level_table[40][i] = rx2_level_table[9][i]; // 12M into 13m band data
                rx2_level_table[41][i] = rx2_level_table[10][i]; // 10M into 11m band data

            } // for













        } // getstate

        private string VerToString(uint ver)
        {
            string s = "";
            s += ((byte)(ver >> 24)).ToString() + ".";
            s += ((byte)(ver >> 16)).ToString() + ".";
            s += ((byte)(ver >> 8)).ToString() + ".";
            s += ((byte)(ver >> 0)).ToString();
            return s;
        }

        private bool LessThan1GBRam()
        {
            bool ret = true;
            double installed_ram = 0;
            try
            {
                ObjectQuery objectQuery = new ObjectQuery("select * from Win32_PhysicalMemory");
                ManagementObjectSearcher searcher = new ManagementObjectSearcher(objectQuery);
                ManagementObjectCollection vals = searcher.Get();
                foreach (ManagementObject val in vals)
                {
                    installed_ram += System.Convert.ToDouble(val.GetPropertyValue("Capacity"));
                }
                if ((installed_ram / 1073741824) > 1) ret = false;
            }
            catch (Exception)
            {
                ret = false;
            }
            return ret;
        }

        //=============================================================
        // ke9ns add 01/04/17 From Eric
        // Firmware upate: Flex-5000 2017-01-04 2.1.4.4   Added 60m to several EU regions
        // Firmware upate: Flex-3000 2017-01-04 2.1.4.4   Added 60m to several EU regions
        // Firmware upate: Flex-1500 2017-01-04 0.5.3.13   Added 60m to several EU regions


        //========================================================================================
        // ke9ns add 05/08/17 From Eric and Tim to align with FRSRegions in SmartSDR
        // Firmware upate: Flex-5000 2017-05-07 2.1.4.5   
        // Firmware upate: Flex-3000 2017-05-07 2.1.4.5   
        // Firmware upate: Flex-1500 2017-05-07 0.5.3.14   

        //========================================================================================
        // ke9ns add 7/21/17 From Tim to align with FRSRegions in SmartSDR v2.0
        // Firmware upate: Flex-5000 2017-07-20 2.1.4.6   
        // Firmware upate: Flex-3000 2017-07-20 2.1.4.6   
        // Firmware upate: Flex-1500 2017-07-20 0.5.3.15   

        //========================================================================================
        // ke9ns add 9/6/17 From Tim to fix Aus 20m region
        // Firmware upate: Flex-5000 2017-07-20 2.1.4.7   
        // Firmware upate: Flex-3000 2017-07-20 2.1.4.7   
        // Firmware upate: Flex-1500 2017-07-20 0.5.3.16   

        //========================================================================================
        // ke9ns add 5/25/18 From Tim 
        // The following TURF change were made in SmartSDR v2.2.8
        //TURF: Modification to Belgium(EU04)
        //Belgium has increased the frequency allocations for the 160m band to 1.810 - 2.0

        //TURF: Modification to Netherlands(EU13)
        //The Netherlands have changed the frequency allocations for the 60m band to 5.351.5 to 5.366.5

        //TURF: add CDEMA(Caribbean Disaster Emergency Response Agency) frequencies to IARU 2 TURF
        //7.453.5 to 7.456.5MHz USB CDEMA Caribbean Disaster Emergency Response Agency
        //7.850 to 7.853MHz USB CDEMA Caribbean Disaster Emergency Response Agency
        //13.998 to 14.001MHz USB Caribbean Red Cross
        //14.415 to 14.418MHz USB CDEMA Caribbean Disaster Emergency Response Agency

        // Firmware upate: Flex-5000 2018-05-14 2.1.4.8   
        // Firmware upate: Flex-3000 2018-05-14 2.1.4.8   
        // Firmware upate: Flex-1500 2018-05-25 0.5.3.20   

        //========================================================================================
        // ke9ns add  11/8/2018  From Tim 
        //   v2.1.4.10 (2018-10-30)
        //   -Updated Hungary 40m increase, 60m add, Italy 60m add, and Belgium regions

        //    v2.1.4.9 (2018-05-30)
        //   -Added China region (same as IARU3 except for 60m tx)
        //  -Removed CB band in Russia (firmware only)

        // Firmware upate: Flex-5000 2017-07-20 2.1.4.10  
        // Firmware upate: Flex-3000 2017-07-20 2.1.4.10   
        // Firmware upate: Flex-1500 2017-07-20 0.5.3.22   

        //========================================================================================
        // ke9ns add 04/12/2019 From Tim
        // 

        // - expanded 12m for Norway
        // - Add 60m for Greece, EU Travel, France, Hungary
        // - Mod 40m for Hungary

        // Firmware upate: Flex-5000 2017-07-20 2.1.4.12  
        // Firmware upate: Flex-3000 2017-07-20 2.1.4.12   
        // Firmware upate: Flex-1500 2017-07-20 0.5.3.24   

        //========================================================================================



        private uint GetMinVersion(Model m)
        {
            uint MIN_VERSION = 0;
            switch (m)
            {
                case Model.FLEX5000: MIN_VERSION = 0x0201040c; break; // 0x0201040c = .12
                case Model.FLEX3000: MIN_VERSION = 0x0201040c; break; //  0x0201040c = .12
                case Model.FLEX1500: MIN_VERSION = 0x00050318; break;  //  0x00050318 = .24  EEPROM = 012d5-012d8


            }
            return MIN_VERSION;
        }

        private uint GetMaxVersion(Model m)
        {
            uint MAX_VERSION = 0;
            switch (m)
            {
                case Model.FLEX5000: MAX_VERSION = 0x0201FFFF; break;  // 0x0201FFFF
                case Model.FLEX3000: MAX_VERSION = 0x0201FFFF; break;  //  0x0201FFFF
                case Model.FLEX1500: MAX_VERSION = 0x0005FFFF; break;  // 0x0005FFFF
            }
            return MAX_VERSION;
        }

        private void InitRadio()
        {
            uint val;
            FWC.GetFirmwareRev(out val);

            if (val == 0)
            {
                Splash.HideForm();
                MessageBox.Show(new Form { TopMost = true }, "Error communicating with the radio.  Please reload PowerSDR to try again.\n" +
                    "Note that starting PowerSDR too quickly after powering on the radio can cause this problem.",
                    "Error: Radio Communication Problem",
                    MessageBoxButtons.OK,
                    MessageBoxIcon.Error);
                fwc_init = false;
                return;
            }

            uint MIN_VERSION = GetMinVersion(current_model);
            uint MAX_VERSION = GetMaxVersion(current_model);

            if (val < MIN_VERSION || val > MAX_VERSION) // revs outside of v2.1.*.*
            {
                Splash.HideForm();
                DialogResult dr = MessageBox.Show(new Form { TopMost = true }, "A radio firmware update is required in order to continue.\n" +
                    "(Looked for v" + VerToString(MIN_VERSION) + " and found v" + VerToString(val) + ")\n\n" +
                    "Would you like to update your firmware now?\n" +
                    "If not, PowerSDR will be closed.",
                    "Update Firmware Now?",
                    MessageBoxButtons.YesNo,
                    MessageBoxIcon.Question);

                if (dr == DialogResult.No)
                {
                    Process.GetCurrentProcess().Kill(); // program ends here
                    return; // this is just for code clarity
                }

                Application.DoEvents(); // clear the dialog sooner

                LoadFWCFirmware(VerToString(MIN_VERSION));
            }

            FWC.Initialize();
            FWC.SetTRXPreamp(false);

            if (current_model == Model.FLEX3000) FWC.SetRXAttn(false);

        } // InitRadio();

        private void InitFLEX1500()
        {
            if (!hid_init || current_model != Model.FLEX1500) return;
            uint val;
            USBHID.GetFirmwareRev(out val);
            if (val == 0)
            {
                Splash.HideForm();
                MessageBox.Show(new Form { TopMost = true }, "Error communicating with the radio.  Please reload PowerSDR to try again.",
                    "Error: Radio Communication Problem",
                    MessageBoxButtons.OK,
                    MessageBoxIcon.Error);
                hid_init = false;
                return;
            }

            uint MIN_VERSION = GetMinVersion(current_model);
            uint MAX_VERSION = GetMaxVersion(current_model);
            if (val < MIN_VERSION || val > MAX_VERSION)
            {
                Splash.HideForm();
                DialogResult dr = MessageBox.Show(
                    "A radio firmware update is required in order to continue.\n" +
                    "(Looked for v" + VerToString(MIN_VERSION) + " and found v" + VerToString(val) + ")\n\n" +
                    "Would you like to update your firmware now?\n" +
                    "If not, PowerSDR will be closed.",
                    "Update Firmware Now?",
                    MessageBoxButtons.YesNo,
                    MessageBoxIcon.Question);

                if (dr == DialogResult.No)
                {
                    Process.GetCurrentProcess().Kill();
                    return;
                }

                Application.DoEvents(); // clear the dialog sooner

                Load1500Firmware(VerToString(MIN_VERSION));
                USBHID.Initialize();
                USBHID.SetPreamp(FLEX1500PreampMode.ZERO);
                //USBHID.WriteI2C2Value(0x30, 0x0C, 0x50);
            }
        }

        private void LoadFWCFirmware(string version)
        {
            // load firmware image
            string path = Environment.GetFolderPath(Environment.SpecialFolder.CommonApplicationData)
                + "\\FlexRadio Systems\\FLEX Firmware\\";

            string file_name = path;
            switch (current_model)
            {
                case Model.FLEX5000: file_name = path + "FLEX-5000\\FLEX-5000_Firmware_v"; break;
                case Model.FLEX3000: file_name = path + "FLEX-3000\\FLEX-3000_Firmware_v"; break;
            }

            file_name += version + ".bin";

            if (!File.Exists(file_name))
            {
                DialogResult dr = MessageBox.Show(
                    "Unable to locate the firmware file in the default location.\n" +
                    "Would you like to try to locate the file manually?\n" +
                    "Otherwise, the application will close.\n\n" +
                    "(Default Path: " + file_name + ")",
                    "Try to locate file?",
                    MessageBoxButtons.YesNo,
                    MessageBoxIcon.Question);

                if (dr == DialogResult.No)
                    Process.GetCurrentProcess().Kill();

                OpenFileDialog dialog = new OpenFileDialog();
                dialog.Filter = "Firmware files (*.bin)|*.bin|All files (*.*)|*.*";
                dialog.Multiselect = false;
                dialog.InitialDirectory = file_name.Substring(0, file_name.LastIndexOf("\\") + 1);
                if (dialog.ShowDialog() == DialogResult.OK)
                {
                    file_name = dialog.FileName;
                }

                if (!File.Exists(file_name))
                {
                    MessageBox.Show(new Form { TopMost = true }, "File not chosen.  The program will now close");
                    Process.GetCurrentProcess().Kill();
                    return; // this is just for code clarity
                }
            }

            string tool_path = path + "tool.exe";

            if (!File.Exists(tool_path))
            {
                MessageBox.Show(new Form { TopMost = true }, "Firmware Update tool not found.  Please contact support.\n\n" +
                    "(Looked in " + tool_path + ")",
                    "Error: Update Tool Not Found",
                    MessageBoxButtons.OK,
                    MessageBoxIcon.Error);
                Process.GetCurrentProcess().Kill();
                return;
            }

            ProcessStartInfo proc_info = new ProcessStartInfo();
            proc_info.FileName = tool_path;
            proc_info.Arguments = "\"dfu" + file_name + "\"";
            proc_info.CreateNoWindow = true;
            proc_info.UseShellExecute = false;
            proc_info.RedirectStandardOutput = true;
            proc_info.WindowStyle = ProcessWindowStyle.Hidden;

            Progress p = new Progress("Firmware Update");
            p.PercentDigits = 0;
            p.SetPercent(0.0f);
            p.Show();
            p.Focus();
            Application.DoEvents();

            using (Process proc = Process.Start(proc_info))
            {
                StreamReader reader = proc.StandardOutput;
                string result = "";
                while ((result = reader.ReadLine()) != null)
                {
                    if (result.Contains("Uploading Binary"))
                    {
                        int start = result.IndexOf(":") + 1;
                        int end = result.IndexOf("%");
                        int progress = int.Parse(result.Substring(start, end - start));
                        p.SetPercent(progress / 100.0f * 0.33f);
                        Application.DoEvents();
                    }
                    else if (result.Contains("Programing Flash Image"))
                    {
                        int start = result.IndexOf(":") + 1;
                        int end = result.IndexOf("%");
                        int progress = int.Parse(result.Substring(start, end - start));
                        p.SetPercent(0.33f + progress / 100.0f * 0.67f);
                        Application.DoEvents();
                    }
                }
            }

            Thread.Sleep(3000); // wait for radio to reboot

            p.Hide();
            Application.DoEvents();

            MessageBox.Show(new Form { TopMost = true }, "Update complete.  The program will now close.\n" +
                         "Please restart PowerSDR to continue.",
                         "Restart Required",
                         MessageBoxButtons.OK,
                         MessageBoxIcon.Information);

            Process.GetCurrentProcess().Kill();
            return; // this is just for code clarity


            /*Thread.Sleep(2000); // wait for computer to redetect

            if (radio_to_use == null) return;

            // reinitialize Pal interface
            Pal.Exit();
            Pal.Init();
            Thread.Sleep(2000);

            // check that new version is within acceptable range
            uint val;
            FWC.GetFirmwareRev(out val);
            if (val < GetMinVersion(current_model) || val > GetMaxVersion(current_model))
            {
                MessageBox.Show(new Form { TopMost = true }, "The firmware revision chosen does not meet the requirements of this\n"+
                    "version of PowerSDR.  Please obtain firmware v" + version + " and try again.",
                    "Error: Firmware Revision",
                    MessageBoxButtons.OK,
                    MessageBoxIcon.Error);
                Process.GetCurrentProcess().Kill();
                return;
            }*/
        }

        private void Load1500Firmware(string version)
        {
            string file_name = Environment.GetFolderPath(Environment.SpecialFolder.CommonApplicationData) +
                    "\\FlexRadio Systems\\FLEX Firmware\\FLEX-1500\\FLEX-1500_Firmware_v" + version + ".bin";

            if (!File.Exists(file_name))
            {
                DialogResult dr = MessageBox.Show(
                    "Unable to locate the firmware file in the default location.\n" +
                    "Would you like to try to locate the file manually?\n" +
                    "Otherwise, the application will close.\n\n" +
                    "(Default Path: " + file_name,
                    "Try to locate file?",
                    MessageBoxButtons.YesNo,
                    MessageBoxIcon.Question);

                if (dr == DialogResult.No)
                    Process.GetCurrentProcess().Kill();

                OpenFileDialog dialog = new OpenFileDialog();
                dialog.Filter = "Firmware files (*.bin)|*.bin|All files (*.*)|*.*";
                dialog.Multiselect = false;
                dialog.InitialDirectory = file_name.Substring(0, file_name.LastIndexOf("\\") + 1);
                if (dialog.ShowDialog() == DialogResult.OK)
                {
                    file_name = dialog.FileName;
                }

                if (!File.Exists(file_name))
                {
                    MessageBox.Show(new Form { TopMost = true }, "File not chosen.  The program will now close");
                    Process.GetCurrentProcess().Kill();
                }
            }

            FileStream fs = File.Open(file_name, FileMode.Open, FileAccess.Read);
            BinaryReader reader = new BinaryReader(fs);

            int total_writes = (int)Math.Ceiling(fs.Length / 32.0);
            int write_count = 0;

            byte[] data = new byte[32];
            byte[] check = new byte[32];
            ushort offset = 0;
            bool eof = false;

            Progress p = new Progress("Firmware Update");
            p.PercentDigits = 0;
            p.SetPercent(0.0f);
            p.Show();
            p.Focus();
            Application.DoEvents();

            do
            {
                int num_read = reader.Read(data, 0, 32);
                bool validated = true;
                int count = 0;

                if (num_read == 0) break;
                do
                {
                    count++;
                    Flex1500.WriteEEPROM(offset, data);
                    Thread.Sleep(10);

                    Flex1500.ReadEEPROM(offset, (byte)num_read, out check);

                    validated = true;
                    for (int i = 0; i < num_read; i++)
                    {
                        if (check[i] != data[i])
                        {
                            validated = false;
                            break;
                        }
                    }
                }
                while (!validated && count < 10);

                if (count == 10)
                    MessageBox.Show(new Form { TopMost = true }, "Error writing firmware (0x" + offset.ToString("X").PadLeft(4, '0') + ")");

                offset += (ushort)num_read;
                eof = (num_read != 32);

                p.SetPercent(++write_count / (float)total_writes);
                Application.DoEvents();
            } while (!eof);

            p.Hide();
            Application.DoEvents();
            reader.Close();
            fs.Close();

            uint old_ver;
            USBHID.GetFirmwareRev(out old_ver);

            Thread.Sleep(500);
            Flex1500.StopListener(); // keep old object from causing problems

            // pause to allow reboot
            MessageBox.Show(new Form { TopMost = true }, "Please cycle power to the radio for the firmware change to take effect.",
                "Cycle Power",
                MessageBoxButtons.OK,
                MessageBoxIcon.Information);

            // reconnect the radio
            uint new_ver = old_ver;

            p.Text = "Cycle Radio Power...";
            p.SetPercent(0.0f);
            p.Show();
            p.Focus();
            Application.DoEvents();
            int wait_count = 0;

            // wait for radio to be powered off
            while (Flex1500.IsRadioPresent())
            {
                Thread.Sleep(1000);
                p.SetPercent(++wait_count / 60.0f);
                Application.DoEvents();
                if (wait_count > 60)
                {
                    p.Hide();
                    Application.DoEvents();
                    break;
                }
            }

            if (wait_count > 60) // timeout
            {
                MessageBox.Show(new Form { TopMost = true }, "Still waiting for radio power to be cycled...");
                p.SetPercent(0.0f);
                p.Show();
                p.Focus();
                wait_count = 0;

                while (Flex1500.IsRadioPresent())
                {
                    Thread.Sleep(1000);
                    p.SetPercent(++wait_count / 60.0f);
                    Application.DoEvents();
                    if (wait_count > 60)
                    {
                        p.Hide();
                        Application.DoEvents();
                        break;
                    }
                }

                if (wait_count > 60)
                {
                    MessageBox.Show(new Form { TopMost = true }, "Detecting radio power cycle failed.  The program will now close.");
                    Process.GetCurrentProcess().Kill();
                }
            }

            // by here, the radio has at least detached.  Time to look for it again.
            p.SetPercent(0.0f);
            wait_count = 0;
            while (!Flex1500.SetActiveRadio(radio_to_use.SerialNumber))
            {
                Thread.Sleep(1000);
                p.SetPercent(++wait_count / 60.0f);
                Application.DoEvents();
                if (wait_count > 60)
                {
                    p.Hide();
                    Application.DoEvents();
                    break;
                }
            }

            if (wait_count > 60) // timeout
            {
                MessageBox.Show(new Form { TopMost = true }, "Still waiting for radio power to be cycled...");
                p.SetPercent(0.0f);
                p.Show();
                p.Focus();
                wait_count = 0;

                while (!Flex1500.SetActiveRadio(radio_to_use.SerialNumber))
                {
                    Thread.Sleep(1000);
                    p.SetPercent(++wait_count / 60.0f);
                    Application.DoEvents();
                    if (wait_count > 60)
                    {
                        p.Hide();
                        Application.DoEvents();
                        break;
                    }
                }

                if (wait_count > 60)
                {
                    MessageBox.Show(new Form { TopMost = true }, "Detecting radio power cycle failed.  The program will now close.");
                    Process.GetCurrentProcess().Kill();
                }
            }

            p.Hide();
            Application.DoEvents();

            // radio has been rebooted -- verify new version
            USBHID.GetFirmwareRev(out new_ver);
            if (VerToString(new_ver) == version)
                return;

            // should never get here
            MessageBox.Show(new Form { TopMost = true }, "An error occurred while attempting to update the radio firmware.\n" +
                "If this is the first time this message has appeared, please try again.\n" +
                "Otherwise, please contact our support team using the information at\n" +
                "http://www.flexradio.com.",
                "Firmware Update Error",
                MessageBoxButtons.OK,
                MessageBoxIcon.Error);

            Process.GetCurrentProcess().Kill();
        }

        private void CheckCalData()
        {
            if (!fwc_init || (current_model != Model.FLEX5000 && current_model != Model.FLEX3000)) return;
            if (FWCEEPROM.LastCalDateTime == unchecked((long)0xffffffffffffffff))
            {
                //MessageBox.Show(new Form { TopMost = true }, "No Calibration Date/Time Found.");
                return;
            }

            if (fwc_serial_num != FWCEEPROM.SerialNumber)
            {
                if (fwc_serial_num != 0)
                {
                    /*string old_s = FWCEEPROM.SerialToString(fwc_serial_num);
					string new_s = FWCEEPROM.SerialToString(FWCEEPROM.SerialNumber);

					Splash.HideForm();
					DialogResult dr = MessageBox.Show(new Form { TopMost = true }, "New Radio Detected: Old Serial: "+old_s+"  New Serial: "+new_s+"\n"+
						"Do you want to update the PowerSDR calibration data from the EEPROM?\n"+
						"(Note that this may take as long as 90 seconds)",
						"New Radio: Update Cal?",
						MessageBoxButtons.YesNo,
						MessageBoxIcon.Question);

					if(dr == DialogResult.No) return;*/
                }
                else
                {
                    /*MessageBox.Show(new Form { TopMost = true }, "Please wait patiently while a one-time transfer of the\n"+
						"calibration data from the EEPROM is performed.  This\n"+
						"can take as long as 90 seconds.  Click OK to continue.",
						"Please wait for Cal Data Transfer",
						MessageBoxButtons.OK,
						MessageBoxIcon.Information);*/
                }
            }
            else if (fwc_trx_serial_num != FWCEEPROM.TRXSerial)
            {
                /*string old_s = FWCEEPROM.SerialToString(fwc_trx_serial_num);
				string new_s = FWCEEPROM.SerialToString(FWCEEPROM.TRXSerial);

				Splash.HideForm();
				DialogResult dr = MessageBox.Show(new Form { TopMost = true }, "New Radio Detected: Old TRX Serial: "+old_s+"  New Serial: "+new_s+"\n"+
					"Do you want to update the PowerSDR calibration data from the EEPROM?\n"+
					"(Note that this may take as long as 90 seconds)",
					"New Radio: Update Cal?",
					MessageBoxButtons.YesNo,
					MessageBoxIcon.Question);

				if(dr == DialogResult.No) return;*/
            }
            else if (fwc_last_cal_date_time < FWCEEPROM.LastCalDateTime)
            {
                /*try
				{
					DateTime old_date = DateTime.FromFileTimeUtc(fwc_last_cal_date_time);
					string old_d = old_date.ToShortDateString()+" "+old_date.ToShortTimeString();
					DateTime new_date = DateTime.FromFileTimeUtc(FWCEEPROM.LastCalDateTime);
					string new_d = new_date.ToShortDateString()+" "+new_date.ToShortTimeString();
				
					Splash.HideForm();
					DialogResult dr = MessageBox.Show(new Form { TopMost = true }, "Updated Calibration Data Detected:  Old: "+old_d+"  New: "+new_d+"\n"+
						"Do you want to update the PowerSDR calibration data from the EEPROM?\n"+
						"(Note that this may take as long as 90 seconds)",
						"New Data: Update Cal?",
						MessageBoxButtons.YesNo,
						MessageBoxIcon.Question);

					if(dr == DialogResult.No) return;
				}
				catch(Exception) { }*/
            }
            else return;

            // download cal data from EEPROM
            RestoreCalData();
        }

        private void Check1500CalData()
        {
            if (!hid_init || current_model != Model.FLEX1500) return;
            if (HIDEEPROM.LastCalDateTime == unchecked((long)0xffffffffffffffff))
            {
                //MessageBox.Show(new Form { TopMost = true }, "No Calibration Date/Time Found.");
                return;
            }

            if (hid_serial_num == HIDEEPROM.SerialNumber &&
                hid_trx_serial_num == HIDEEPROM.TRXSerial &&
                hid_last_cal_date_time >= HIDEEPROM.LastCalDateTime)
                return;

            // download cal data from EEPROM
            Restore1500CalData();
        }

        private void CheckRX2CalData()
        {
            if (!fwc_init || current_model != Model.FLEX5000 || !FWCEEPROM.RX2OK) return;
            if (FWCEEPROM.LastRX2CalDateTime == unchecked((long)0xffffffffffffffff))
            {
                //MessageBox.Show(new Form { TopMost = true }, "No Calibration Date/Time Found.");
                return;
            }

            if (rx2_serial_num != FWCEEPROM.RX2Serial)
            {
                if (rx2_serial_num != 0)
                {
                    /*string old_s = FWCEEPROM.SerialToString(rx2_serial_num);
					string new_s = FWCEEPROM.SerialToString(FWCEEPROM.RX2Serial);

					Splash.HideForm();
					DialogResult dr = MessageBox.Show(new Form { TopMost = true }, "New RX2 Detected: Old Serial: "+old_s+"  New Serial: "+new_s+"\n"+
						"Do you want to update the PowerSDR calibration data from the EEPROM?\n"+
						"(Note that this may take as long as 30 seconds)",
						"New RX2: Update Cal?",
						MessageBoxButtons.YesNo,
						MessageBoxIcon.Question);

					if(dr == DialogResult.No) return;*/
                }
                else
                {
                    /*MessageBox.Show(new Form { TopMost = true }, "Please wait patiently while a one-time transfer of the\n"+
						 "RX2 calibration data from the EEPROM is performed.  This\n"+
						 "can take as long as 30 seconds.  Click OK to continue.",
						 "Please wait for Cal Data Transfer",
						 MessageBoxButtons.OK,
						 MessageBoxIcon.Information);*/
                }
            }
            else if (rx2_last_cal_date_time < FWCEEPROM.LastRX2CalDateTime)
            {
                /*try
				{
					DateTime old_date = DateTime.FromFileTimeUtc(rx2_last_cal_date_time);
					string old_d = old_date.ToShortDateString()+" "+old_date.ToShortTimeString();
					DateTime new_date = DateTime.FromFileTimeUtc(FWCEEPROM.LastRX2CalDateTime);
					string new_d = new_date.ToShortDateString()+" "+new_date.ToShortTimeString();
				
					Splash.HideForm();
					DialogResult dr = MessageBox.Show(new Form { TopMost = true }, "Updated RX2 Calibration Data Detected:  Old: "+old_d+"  New: "+new_d+"\n"+
						"Do you want to update the PowerSDR calibration data from the EEPROM?\n"+
						"(Note that this may take as long as 30 seconds)",
						"New Data: Update Cal?",
						MessageBoxButtons.YesNo,
						MessageBoxIcon.Question);

					if(dr == DialogResult.No) return;
				}
				catch(Exception) { }*/
            }
            else return;

            // download cal data from EEPROM
            RX2RestoreCalData();
        }

        public void SyncCalDateTime()
        {
            switch (current_model)
            {
                case Model.FLEX5000:
                case Model.FLEX3000:
                    fwc_serial_num = FWCEEPROM.SerialNumber;
                    fwc_trx_serial_num = FWCEEPROM.TRXSerial;
                    fwc_last_cal_date_time = FWCEEPROM.LastCalDateTime;
                    break;
                case Model.FLEX1500:
                    hid_serial_num = HIDEEPROM.SerialNumber;
                    hid_trx_serial_num = HIDEEPROM.TRXSerial;
                    hid_last_cal_date_time = HIDEEPROM.LastCalDateTime;
                    break;
            }
        }

        public void RX2SyncCalDateTime()
        {
            rx2_serial_num = FWCEEPROM.RX2Serial;
            rx2_last_cal_date_time = FWCEEPROM.LastRX2CalDateTime;
        }

        public void WriteTRXChecksums()
        {
            rx1_level_checksum = Checksum.Calc(rx1_level_table);
            FWCEEPROM.WriteRXLevelChecksum(rx1_level_checksum);

            rx1_image_gain_checksum = Checksum.CalcHF(rx1_image_gain_table);
            FWCEEPROM.WriteRXImageGainChecksum(rx1_image_gain_checksum);

            rx1_image_phase_checksum = Checksum.CalcHF(rx1_image_phase_table);
            FWCEEPROM.WriteRXImagePhaseChecksum(rx1_image_phase_checksum);

            tx_image_gain_checksum = Checksum.CalcHF(tx_image_gain_table);
            FWCEEPROM.WriteTXImageGainChecksum(tx_image_gain_checksum);

            tx_image_phase_checksum = Checksum.CalcHF(tx_image_phase_table);
            FWCEEPROM.WriteTXImagePhaseChecksum(tx_image_phase_checksum);

            tx_carrier_checksum = Checksum.Calc(tx_carrier_cal);
            FWCEEPROM.WriteTXCarrierChecksum(tx_carrier_checksum);

            if (FWCEEPROM.PAOK)
            {
                pa_bias_checksum = Checksum.Calc(pa_bias_table, false);
                FWCEEPROM.WritePABiasChecksum(pa_bias_checksum);

                pa_bridge_checksum = Checksum.Calc(pa_bridge_table);
                FWCEEPROM.WritePABridgeChecksum(pa_bridge_checksum);

                pa_power_checksum = Checksum.Calc(power_table);
                FWCEEPROM.WritePAPowerChecksum(pa_power_checksum);

                pa_swr_checksum = Checksum.CalcHF(swr_table);
                FWCEEPROM.WritePASWRChecksum(pa_swr_checksum);

                if (current_model == Model.FLEX3000)
                {
                    atu_swr_checksum = Checksum.CalcHF(atu_swr_table);
                    FWCEEPROM.WriteATUSWRChecksum(atu_swr_checksum);
                }
            }

            if (FWCEEPROM.VUOK)
            {
                vu_level_checksum = Checksum.Calc(vhf_level_table, uhf_level_table);
                FWCEEPROM.WriteVULevelChecksum(vu_level_checksum);

                vu_power_checksum = Checksum.Calc(vhf_power_table, uhf_power_table);
                FWCEEPROM.WriteVUPowerChecksum(vu_power_checksum);
            }

            FWCEEPROM.TRXChecksumPresent = true;
        }

        public void Verify1500Checksums()
        {
            byte calc = 0, eeprom = 0;
            bool error_flag = false;
            string error = "";

            eeprom = HIDEEPROM.ReadRXLevelChecksum();
            calc = Checksum.Calc(rx1_level_table);
            if (rx1_level_checksum != eeprom ||
                rx1_level_checksum != calc)
            {
                error_flag = true;
                error += "RX1 Level Checksum Error " +
                    "DB: " + rx1_level_checksum.ToString("X") +
                    " EEPROM: " + eeprom.ToString("X") +
                    " Calculated: " + calc.ToString("X") + "\n";
            }

            eeprom = HIDEEPROM.ReadRXImageGainChecksum();
            calc = Checksum.CalcHF(rx1_image_gain_table);
            if (rx1_image_gain_checksum != eeprom ||
                rx1_image_gain_checksum != calc)
            {
                error_flag = true;
                error += "RX Image Gain Checksum Error " +
                    "DB: " + rx1_image_gain_checksum.ToString("X") +
                    " EEPROM: " + eeprom.ToString("X") +
                    " Calculated: " + calc.ToString("X") + "\n"; ;
            }

            eeprom = HIDEEPROM.ReadRXImagePhaseChecksum();
            calc = Checksum.CalcHF(rx1_image_phase_table);
            if (rx1_image_phase_checksum != eeprom ||
                rx1_image_phase_checksum != calc)
            {
                error_flag = true;
                error += "RX1 Image Phase Checksum Error " +
                    "DB: " + rx1_image_phase_checksum.ToString("X") +
                    " EEPROM: " + eeprom.ToString("X") +
                    " Calculated: " + calc.ToString("X") + "\n";
            }

            eeprom = HIDEEPROM.ReadTXImageGainChecksum();
            calc = Checksum.CalcHF(tx_image_gain_table);
            if (tx_image_gain_checksum != eeprom ||
                tx_image_gain_checksum != calc)
            {
                error_flag = true;
                error += "TX Image Gain Checksum Error " +
                    "DB: " + tx_image_gain_checksum.ToString("X") +
                    " EEPROM: " + eeprom.ToString("X") +
                    " Calculated: " + calc.ToString("X") + "\n";
            }

            eeprom = HIDEEPROM.ReadTXImagePhaseChecksum();
            calc = Checksum.CalcHF(tx_image_phase_table);
            if (tx_image_phase_checksum != eeprom ||
                tx_image_phase_checksum != calc)
            {
                error_flag = true;
                error += "TX Image Phase Checksum Error " +
                    "DB: " + tx_image_phase_checksum.ToString("X") +
                    " EEPROM: " + eeprom.ToString("X") +
                    " Calculated: " + calc.ToString("X") + "\n";
            }

            eeprom = HIDEEPROM.ReadPAPowerChecksum();
            calc = Checksum.Calc(power_table);
            if (pa_power_checksum != eeprom ||
                pa_power_checksum != calc)
            {
                error_flag = true;
                error += "PA Power Checksum Error " +
                    "DB: " + pa_power_checksum.ToString("X") +
                    " EEPROM: " + eeprom.ToString("X") +
                    " Calculated: " + calc.ToString("X") + "\n";
            }

            if (error_flag)
            {
                TextWriter writer = new StreamWriter(app_data_path + "checksum_error.log", true);    //  "\\checksum_error.log"
                string s = DateTime.Now.ToShortDateString() + "  " + DateTime.Now.ToShortTimeString();
                writer.WriteLine(s + "  " + error);
                writer.Close();
            }
        }

        public void VerifyTRXChecksums()
        {
            byte calc = 0, eeprom = 0;
            bool error_flag = false;
            string error = "";

            eeprom = FWCEEPROM.ReadRXLevelChecksum();
            calc = Checksum.Calc(rx1_level_table);
            if (rx1_level_checksum != eeprom ||
                rx1_level_checksum != calc)
            {
                error_flag = true;
                error += "RX1 Level Checksum Error " +
                    "DB: " + rx1_level_checksum.ToString("X") +
                    " EEPROM: " + eeprom.ToString("X") +
                    " Calculated: " + calc.ToString("X") + " | \n";
            }

            eeprom = FWCEEPROM.ReadRXImageGainChecksum();
            calc = Checksum.CalcHF(rx1_image_gain_table);
            if (rx1_image_gain_checksum != eeprom ||
                rx1_image_gain_checksum != calc)
            {
                error_flag = true;
                error += "RX1 Image Gain Checksum Error " +
                    "DB: " + rx1_image_gain_checksum.ToString("X") +
                    " EEPROM: " + eeprom.ToString("X") +
                    " Calculated: " + calc.ToString("X") + " | \n";
            }

            eeprom = FWCEEPROM.ReadRXImagePhaseChecksum();
            calc = Checksum.CalcHF(rx1_image_phase_table);
            if (rx1_image_phase_checksum != eeprom ||
                rx1_image_phase_checksum != calc)
            {
                error_flag = true;
                error += "RX1 Image Phase Checksum Error " +
                    "DB: " + rx1_image_phase_checksum.ToString("X") +
                    " EEPROM: " + eeprom.ToString("X") +
                    " Calculated: " + calc.ToString("X") + " | \n";
            }

            eeprom = FWCEEPROM.ReadTXImageGainChecksum();
            calc = Checksum.CalcHF(tx_image_gain_table);
            if (tx_image_gain_checksum != eeprom ||
                tx_image_gain_checksum != calc)
            {
                error_flag = true;
                error += "TX Image Gain Checksum Error " +
                    "DB: " + tx_image_gain_checksum.ToString("X") +
                    " EEPROM: " + eeprom.ToString("X") +
                    " Calculated: " + calc.ToString("X") + " | \n";
            }

            eeprom = FWCEEPROM.ReadTXImagePhaseChecksum();
            calc = Checksum.CalcHF(tx_image_phase_table);
            if (tx_image_phase_checksum != eeprom ||
                tx_image_phase_checksum != calc)
            {
                error_flag = true;
                error += "TX Image Phase Checksum Error " +
                    "DB: " + tx_image_phase_checksum.ToString("X") +
                    " EEPROM: " + eeprom.ToString("X") +
                    " Calculated: " + calc.ToString("X") + " | \n";
            }

            eeprom = FWCEEPROM.ReadTXCarrierChecksum();
            calc = Checksum.Calc(tx_carrier_cal);
            if (tx_carrier_checksum != eeprom ||
                tx_carrier_checksum != calc)
            {
                error_flag = true;
                error += "TX Carrier Checksum Error " +
                    "DB: " + tx_carrier_checksum.ToString("X") +
                    " EEPROM: " + eeprom.ToString("X") +
                    " Calculated: " + calc.ToString("X") + " | \n";
            }

            if (FWCEEPROM.PAOK)
            {
                eeprom = FWCEEPROM.ReadPABiasChecksum();
                calc = Checksum.Calc(pa_bias_table, false);
                if (pa_bias_checksum != eeprom ||
                    pa_bias_checksum != calc)
                {
                    error_flag = true;
                    error += "PA Bias Checksum Error " +
                        "DB: " + pa_bias_checksum.ToString("X") +
                        " EEPROM: " + eeprom.ToString("X") +
                        " Calculated: " + calc.ToString("X") + " | \n";
                }

                eeprom = FWCEEPROM.ReadPABridgeChecksum();
                calc = Checksum.Calc(pa_bridge_table);
                if (pa_bridge_checksum != eeprom ||
                    pa_bridge_checksum != calc)
                {
                    error_flag = true;
                    error += "PA Bridge Checksum Error " +
                        "DB: " + pa_bridge_checksum.ToString("X") +
                        " EEPROM: " + eeprom.ToString("X") +
                        " Calculated: " + calc.ToString("X") + " | \n";
                }

                eeprom = FWCEEPROM.ReadPAPowerChecksum();
                calc = Checksum.Calc(power_table);
                if (pa_power_checksum != eeprom ||
                    pa_power_checksum != calc)
                {
                    error_flag = true;
                    error += "PA Power Checksum Error " +
                        "DB: " + pa_power_checksum.ToString("X") +
                        " EEPROM: " + eeprom.ToString("X") +
                        " Calculated: " + calc.ToString("X") + " | \n";
                }

                eeprom = FWCEEPROM.ReadPASWRChecksum();
                calc = Checksum.CalcHF(swr_table);
                if (pa_swr_checksum != eeprom ||
                    pa_swr_checksum != calc)
                {
                    error_flag = true;
                    error += "PA SWR Checksum Error " +
                        "DB: " + pa_swr_checksum.ToString("X") +
                        " EEPROM: " + eeprom.ToString("X") +
                        " Calculated: " + calc.ToString("X") + " | \n";
                }

                if (current_model == Model.FLEX3000)
                {
                    eeprom = FWCEEPROM.ReadATUSWRChecksum();
                    calc = Checksum.CalcHF(atu_swr_table);
                    if (atu_swr_checksum != eeprom ||
                        atu_swr_checksum != calc)
                    {
                        error_flag = true;
                        error += "ATU SWR Checksum Error " +
                            "DB: " + atu_swr_checksum.ToString("X") +
                            " EEPROM: " + eeprom.ToString("X") +
                            " CAlculated: " + calc.ToString("X") + " | \n";
                    }
                }
            }

            if (current_model == Model.FLEX5000 && FWCEEPROM.VUOK)
            {
                eeprom = FWCEEPROM.ReadVULevelChecksum();
                calc = Checksum.Calc(vhf_level_table, uhf_level_table);
                if (vu_level_checksum != eeprom ||
                    vu_level_checksum != calc)
                {
                    error_flag = true;
                    error += "VU Level Checksum Error " +
                        "DB: " + vu_level_checksum.ToString("X") +
                        " EEPROM: " + eeprom.ToString("X") +
                        " Calculated: " + calc.ToString("X") + " | \n";
                }

                eeprom = FWCEEPROM.ReadVUPowerChecksum();
                calc = Checksum.Calc(vhf_power_table, uhf_power_table);
                if (vu_power_checksum != eeprom ||
                    vu_power_checksum != calc)
                {
                    error_flag = true;
                    error += "VU Power Checksum Error " +
                        "DB: " + vu_level_checksum.ToString("X") +
                        " EEPROM: " + eeprom.ToString("X") +
                        " Calculated: " + calc.ToString("X") + " | \n";
                }
            }

            if (error_flag)
            {
                TextWriter writer = new StreamWriter(app_data_path + "checksum_error.log", true); // "\\checksum_error.log"
                string s = DateTime.Now.ToShortDateString() + "  " + DateTime.Now.ToShortTimeString();
                writer.WriteLine(s + "  " + error);
                writer.Close();
                FWCEEPROM.TRXChecksumPresent = false;
            }
        }

        public void WriteRX2Checksums()
        {
            rx2_level_checksum = Checksum.Calc(rx2_level_table);
            FWCEEPROM.WriteRX2LevelChecksum(rx2_level_checksum);

            rx2_image_gain_checksum = Checksum.CalcHF(rx2_image_gain_table);
            FWCEEPROM.WriteRX2ImageGainChecksum(rx2_image_gain_checksum);

            rx2_image_phase_checksum = Checksum.CalcHF(rx2_image_phase_table);
            FWCEEPROM.WriteRX2ImagePhaseChecksum(rx2_image_phase_checksum);

            FWCEEPROM.RX2ChecksumPresent = true;
        }

        public void VerifyRX2Checksums()
        {
            byte calc = 0, eeprom = 0;
            bool error_flag = false;
            string error = "";

            eeprom = FWCEEPROM.ReadRX2LevelChecksum();
            calc = Checksum.Calc(rx2_level_table);
            if (rx2_level_checksum != eeprom ||
                rx2_level_checksum != calc)
            {
                error_flag = true;
                error += "RX2 Level Checksum Error " +
                    "DB: " + rx2_level_checksum.ToString("X") +
                    " EEPROM: " + eeprom.ToString("X") +
                    " Calculated: " + calc.ToString("X") + " | \n";
            }

            eeprom = FWCEEPROM.ReadRX2ImageGainChecksum();
            calc = Checksum.CalcHF(rx2_image_gain_table);
            if (rx2_image_gain_checksum != eeprom ||
                rx2_image_gain_checksum != calc)
            {
                error_flag = true;
                error += "RX2 Image Gain Checksum Error " +
                    "DB: " + rx2_image_gain_checksum.ToString("X") +
                    " EEPROM: " + eeprom.ToString("X") +
                    " Calculated: " + calc.ToString("X") + " | \n";
            }

            eeprom = FWCEEPROM.ReadRX2ImagePhaseChecksum();
            calc = Checksum.CalcHF(rx2_image_phase_table);
            if (rx2_image_phase_checksum != eeprom ||
                rx2_image_phase_checksum != calc)
            {
                error_flag = true;
                error += "RX2 Image Phase Checksum Error.\n" +
                    "DB: " + rx2_image_phase_checksum.ToString("X") +
                    " EEPROM: " + eeprom.ToString("X") +
                    " Calculated: " + calc.ToString("X") + " | \n";
            }

            if (error_flag)
            {
                TextWriter writer = new StreamWriter(app_data_path + "checksum_error.log", true); //"\\checksum_error.log"
                string s = DateTime.Now.ToShortDateString() + "  " + DateTime.Now.ToShortTimeString();
                writer.WriteLine(s + "  " + error);
                writer.Close();
                FWCEEPROM.RX2ChecksumPresent = false;
            }
        }

        public void Restore1500CalData()
        {
            int checksum_error = 0;
            bool error_flag = false;
            string error = "";
            Progress p = new Progress("Retrieving Calibration Data from EEPROM");
            p.SetPercent(0.0f);
            this.Invoke(new MethodInvoker(p.Show));
            Application.DoEvents();
            float total_reads = 7.0f;
            int count = 0;

            checksum_error = 0;
            while (true)
            {
                HIDEEPROM.ReadPAPower(power_table); // 1 read
                pa_power_checksum = Checksum.Calc(power_table);
                if (Checksum.Match(power_table, HIDEEPROM.ReadPAPowerChecksum())) break;

                checksum_error++;
                if (checksum_error > 2)
                {
                    error_flag = true;
                    error += "PA Power Checksum verification error.\n" +
                        "DB: " + pa_power_checksum.ToString("X") +
                        " EEPROM: " + HIDEEPROM.ReadPAPowerChecksum().ToString("X") +
                        " Calculated: " + Checksum.Calc(power_table).ToString("X") + "\n";
                    break;
                }
            }
            p.SetPercent((count += 1) / total_reads);
            Application.DoEvents();


            checksum_error = 0;
            while (true)
            {
                HIDEEPROM.ReadRXLevel(rx1_level_table); // 2 reads
                rx1_level_checksum = Checksum.Calc(rx1_level_table);
                if (Checksum.Match(rx1_level_table, HIDEEPROM.ReadRXLevelChecksum())) break;

                checksum_error++;
                if (checksum_error > 2)
                {
                    error_flag = true;
                    error += "RX1 Level Checksum verification error.\n" +
                        "DB: " + rx1_level_checksum.ToString("X") +
                        " EEPROM: " + HIDEEPROM.ReadRXLevelChecksum().ToString("X") +
                        " Calculated: " + Checksum.Calc(rx1_level_table).ToString("X") + "\n";
                    break;
                }
            }
            p.SetPercent((count += 2) / total_reads);
            Application.DoEvents();

            checksum_error = 0;
            while (true)
            {
                HIDEEPROM.ReadRXImage(rx1_image_gain_table, rx1_image_phase_table); // 22 reads
                rx1_image_gain_checksum = Checksum.CalcHF(rx1_image_gain_table);
                rx1_image_phase_checksum = Checksum.CalcHF(rx1_image_phase_table);
                if (Checksum.MatchHF(rx1_image_gain_table, HIDEEPROM.ReadRXImageGainChecksum()) &&
                    Checksum.MatchHF(rx1_image_phase_table, HIDEEPROM.ReadRXImagePhaseChecksum()))
                    break;

                checksum_error++;
                if (checksum_error > 2)
                {
                    error_flag = true;
                    error += "RX Image Gain/Phase Checksum verification error.\n" +
                        "DB: " + rx1_image_gain_checksum.ToString("X") + "/" + rx1_image_phase_checksum.ToString("X") +
                        " EEPROM: " + HIDEEPROM.ReadRXImageGainChecksum().ToString("X") + "/" + HIDEEPROM.ReadRXImagePhaseChecksum().ToString("X") +
                        " Calculated: " + Checksum.CalcHF(rx1_image_gain_table).ToString("X") + "/" + Checksum.CalcHF(rx1_image_phase_table).ToString("X") + "\n";
                    break;
                }
            }
            p.SetPercent((count += 2) / total_reads);
            Application.DoEvents();

            checksum_error = 0;
            while (true)
            {
                HIDEEPROM.ReadTXImage(tx_image_gain_table, tx_image_phase_table); // 22 reads
                tx_image_gain_checksum = Checksum.CalcHF(tx_image_gain_table);
                tx_image_phase_checksum = Checksum.CalcHF(tx_image_phase_table);
                if (Checksum.MatchHF(tx_image_gain_table, HIDEEPROM.ReadTXImageGainChecksum()) &&
                    Checksum.MatchHF(tx_image_phase_table, HIDEEPROM.ReadTXImagePhaseChecksum()))
                    break;

                checksum_error++;
                if (checksum_error > 2)
                {
                    error_flag = true;
                    error += "TX Image Gain/Phase Checksum verification error.\n" +
                        "DB: " + tx_image_gain_checksum.ToString("X") + "/" + tx_image_phase_checksum.ToString("X") +
                        " EEPROM: " + HIDEEPROM.ReadTXImageGainChecksum().ToString("X") + "/" + HIDEEPROM.ReadTXImagePhaseChecksum().ToString("X") +
                        " Calculated: " + Checksum.CalcHF(tx_image_gain_table).ToString("X") + "/" + Checksum.CalcHF(tx_image_phase_table).ToString("X") + "\n";
                    break;
                }
            }
            p.SetPercent((count += 2) / total_reads);
            Application.DoEvents();


            if (error_flag)
            {
                TextWriter writer = new StreamWriter(app_data_path + "checksum_error.log", true); // "\\checksum_error.log"
                string s = DateTime.Now.ToShortDateString() + "  " + DateTime.Now.ToShortTimeString();
                writer.WriteLine(s + "  " + error);
                writer.Close();
            }

            SyncCalDateTime();
            p.Hide();
            p.Close();
            Application.DoEvents();

            bool save_init = initializing;
            initializing = true;
            RX1Band = rx1_band;
            TXBand = tx_band;
            initializing = save_init;
        } // restor 1500 call data

        public void RestoreCalData()
        {
            bool trx_checksum_present = FWCEEPROM.TRXChecksumPresent;
            int checksum_error = 0;
            bool error_flag = false;
            string error = "";
            Progress p = new Progress("Retrieving Calibration Data from TRX EEPROM");
            p.SetPercent(0.0f);
            this.Invoke(new MethodInvoker(p.Show));
            Application.DoEvents();
            float total_reads = 324.0f;
            if (current_model == Model.FLEX3000)
                total_reads += 11.0f;  // for ATU SWR table
            else if (current_model == Model.FLEX5000 && FWCEEPROM.VUOK)
                total_reads += 40.0f; // for all VU tables
            int count = 0;

            checksum_error = 0;
            while (true)
            {
                FWCEEPROM.ReadRXLevel(rx1_level_table); // 33 reads
                rx1_level_checksum = Checksum.Calc(rx1_level_table);
                if (!trx_checksum_present) FWCEEPROM.WriteRXLevelChecksum(rx1_level_checksum);
                if (Checksum.Match(rx1_level_table, FWCEEPROM.ReadRXLevelChecksum())) break;

                checksum_error++;
                if (checksum_error > 2)
                {
                    error_flag = true;
                    error += "RX1 Level Checksum verification error.\n" +
                        "DB: " + rx1_level_checksum.ToString("X") +
                        " EEPROM: " + FWCEEPROM.ReadRXLevelChecksum().ToString("X") +
                        " Calculated: " + Checksum.Calc(rx1_level_table).ToString("X") + "\n";
                    break;
                }
            }
            p.SetPercent((count += 33) / total_reads);
            Application.DoEvents();

            checksum_error = 0;
            while (true)
            {
                FWCEEPROM.ReadRXImage(rx1_image_gain_table, rx1_image_phase_table); // 22 reads
                rx1_image_gain_checksum = Checksum.CalcHF(rx1_image_gain_table);
                if (!trx_checksum_present) FWCEEPROM.WriteRXImageGainChecksum(rx1_image_gain_checksum);
                if (Checksum.MatchHF(rx1_image_gain_table, FWCEEPROM.ReadRXImageGainChecksum())) break;

                checksum_error++;
                if (checksum_error > 2)
                {
                    error_flag = true;
                    error += "RX1 Image Gain Checksum verification error.\n" +
                        "DB: " + rx1_image_gain_checksum.ToString("X") +
                        " EEPROM: " + FWCEEPROM.ReadRXImageGainChecksum().ToString("X") +
                        " Calculated: " + Checksum.CalcHF(rx1_image_gain_table).ToString("X") + "\n";
                    break;
                }
            }

            checksum_error = 0;
            do
            {
                rx1_image_phase_checksum = Checksum.CalcHF(rx1_image_phase_table);
                if (!trx_checksum_present) FWCEEPROM.WriteRXImagePhaseChecksum(rx1_image_phase_checksum);
                if (Checksum.MatchHF(rx1_image_phase_table, FWCEEPROM.ReadRXImagePhaseChecksum())) break;

                checksum_error++;
                if (checksum_error > 2)
                {
                    error_flag = true;
                    error += "RX1 Image Phase Checksum verification error.\n" +
                        "DB: " + rx1_image_phase_checksum.ToString("X") +
                        " EEPROM: " + FWCEEPROM.ReadRXImagePhaseChecksum().ToString("X") +
                        " Calculated: " + Checksum.CalcHF(rx1_image_phase_table).ToString("X") + "\n";
                    break;
                }
                FWCEEPROM.ReadRXImage(rx1_image_gain_table, rx1_image_phase_table); // 22 reads
            } while (true);
            p.SetPercent((count += 22) / total_reads);
            Application.DoEvents();

            checksum_error = 0;
            while (true)
            {
                FWCEEPROM.ReadTXImage(tx_image_gain_table, tx_image_phase_table); // 22 reads
                tx_image_gain_checksum = Checksum.CalcHF(tx_image_gain_table);
                if (!trx_checksum_present) FWCEEPROM.WriteTXImageGainChecksum(tx_image_gain_checksum);
                if (Checksum.MatchHF(tx_image_gain_table, FWCEEPROM.ReadTXImageGainChecksum())) break;

                checksum_error++;
                if (checksum_error > 2)
                {
                    error_flag = true;
                    error += "TX Image Gain Checksum verification error.\n" +
                        "DB: " + tx_image_gain_checksum.ToString("X") +
                        " EEPROM: " + FWCEEPROM.ReadTXImageGainChecksum().ToString("X") +
                        " Calculated: " + Checksum.CalcHF(tx_image_gain_table).ToString("X") + "\n";
                    break;
                }
            }

            checksum_error = 0;
            do
            {
                tx_image_phase_checksum = Checksum.CalcHF(tx_image_phase_table);
                if (!trx_checksum_present) FWCEEPROM.WriteTXImagePhaseChecksum(tx_image_phase_checksum);
                if (Checksum.MatchHF(tx_image_phase_table, FWCEEPROM.ReadTXImagePhaseChecksum())) break;

                checksum_error++;
                if (checksum_error > 2)
                {
                    error_flag = true;
                    error += "TX Image Phase Checksum verification error.\n" +
                        "DB: " + tx_image_phase_checksum.ToString("X") +
                        " EEPROM: " + FWCEEPROM.ReadTXImagePhaseChecksum().ToString("X") +
                        " Calculated: " + Checksum.CalcHF(tx_image_phase_table).ToString("X") + "\n";
                    break;
                }
                FWCEEPROM.ReadTXImage(tx_image_gain_table, tx_image_phase_table); // 22 reads
            } while (true);
            p.SetPercent((count += 22) / total_reads);
            Application.DoEvents();

            checksum_error = 0;
            while (true)
            {
                FWCEEPROM.ReadTXCarrier(tx_carrier_cal); // 11 reads
                tx_carrier_checksum = Checksum.Calc(tx_carrier_cal);
                if (!trx_checksum_present) FWCEEPROM.WriteTXCarrierChecksum(tx_carrier_checksum);
                if (Checksum.Match(tx_carrier_cal, FWCEEPROM.ReadTXCarrierChecksum())) break;

                checksum_error++;
                if (checksum_error > 2)
                {
                    error_flag = true;
                    error += "TX Carrier Checksum verification error.\n" +
                        "DB: " + tx_carrier_checksum.ToString("X") +
                        " EEPROM: " + FWCEEPROM.ReadTXCarrierChecksum().ToString("X") +
                        " Calculated: " + Checksum.Calc(tx_carrier_cal).ToString("X") + "\n";
                    break;
                }
            }
            p.SetPercent((count += 11) / total_reads);
            Application.DoEvents();

            checksum_error = 0;
            while (true)
            {
                FWCEEPROM.ReadPABias(pa_bias_table); // 8 reads
                pa_bias_checksum = Checksum.Calc(pa_bias_table, false);
                if (!trx_checksum_present) FWCEEPROM.WritePABiasChecksum(pa_bias_checksum);
                if (Checksum.Match(pa_bias_table, FWCEEPROM.ReadPABiasChecksum(), false)) break;

                checksum_error++;
                if (checksum_error > 2)
                {
                    error_flag = true;
                    error += "PA Bias Checksum verification error.\n" +
                        "DB: " + pa_bias_checksum.ToString("X") +
                        " EEPROM: " + FWCEEPROM.ReadPABiasChecksum().ToString("X") +
                        " Calculated: " + Checksum.Calc(pa_bias_table, false).ToString("X") + "\n";
                    break;
                }
            }
            p.SetPercent((count += 8) / total_reads);
            Application.DoEvents();

            checksum_error = 0;
            while (true)
            {
                FWCEEPROM.ReadPAPower(power_table); // 143 reads
                pa_power_checksum = Checksum.Calc(power_table);
                if (!trx_checksum_present) FWCEEPROM.WritePAPowerChecksum(pa_power_checksum);
                if (Checksum.Match(power_table, FWCEEPROM.ReadPAPowerChecksum())) break;

                checksum_error++;
                if (checksum_error > 2)
                {
                    error_flag = true;
                    error += "PA Power Checksum verification error.\n" +
                        "DB: " + pa_power_checksum.ToString("X") +
                        " EEPROM: " + FWCEEPROM.ReadPAPowerChecksum().ToString("X") +
                        " Calculated: " + Checksum.Calc(power_table).ToString("X") + "\n";
                    break;
                }
            }
            p.SetPercent((count += 143) / total_reads);
            Application.DoEvents();

            checksum_error = 0;
            while (true)
            {
                FWCEEPROM.ReadPABridge(pa_bridge_table); // 66 reads
                pa_bridge_checksum = Checksum.Calc(pa_bridge_table);
                if (!trx_checksum_present) FWCEEPROM.WritePABridgeChecksum(pa_bridge_checksum);
                if (Checksum.Match(pa_bridge_table, FWCEEPROM.ReadPABridgeChecksum())) break;

                checksum_error++;
                if (checksum_error > 2)
                {
                    error_flag = true;
                    error += "PA Bridge Checksum verification error.\n" +
                        "DB: " + pa_bridge_checksum.ToString("X") +
                        " EEPROM: " + FWCEEPROM.ReadPABridgeChecksum().ToString("X") +
                        " Calculated: " + Checksum.Calc(pa_bridge_table).ToString("X") + "\n";
                    break;
                }
            }
            p.SetPercent((count += 66) / total_reads);
            Application.DoEvents();

            checksum_error = 0;
            while (true)
            {
                FWCEEPROM.ReadPASWR(swr_table); // 11 reads
                pa_swr_checksum = Checksum.CalcHF(swr_table);
                if (!trx_checksum_present) FWCEEPROM.WritePASWRChecksum(pa_swr_checksum);
                if (Checksum.MatchHF(swr_table, FWCEEPROM.ReadPASWRChecksum())) break;

                checksum_error++;
                if (checksum_error > 2)
                {
                    error_flag = true;
                    error += "PA SWR Checksum verification error.\n" +
                        "DB: " + pa_swr_checksum.ToString("X") +
                        " EEPROM: " + FWCEEPROM.ReadPASWRChecksum().ToString("X") +
                        " Calculated: " + Checksum.CalcHF(swr_table).ToString("X") + "\n";
                    break;
                }
            }
            p.SetPercent((count += 11) / total_reads);
            Application.DoEvents();

            if (current_model == Model.FLEX3000)
            {
                checksum_error = 0;
                while (true)
                {
                    FWCEEPROM.ReadATUSWR(atu_swr_table); // 11 reads
                    atu_swr_checksum = Checksum.CalcHF(atu_swr_table);
                    if (!trx_checksum_present) FWCEEPROM.WriteATUSWRChecksum(atu_swr_checksum);
                    if (Checksum.MatchHF(atu_swr_table, FWCEEPROM.ReadATUSWRChecksum())) break;

                    checksum_error++;
                    if (checksum_error > 2)
                    {
                        error_flag = true;
                        error += "ATU SWR Checksum verification error.\n" +
                            "DB: " + atu_swr_checksum.ToString("X") +
                            " EEPROM: " + FWCEEPROM.ReadATUSWRChecksum().ToString("X") +
                            " Calculated: " + Checksum.CalcHF(atu_swr_table).ToString("X") + "\n";
                        break;
                    }
                }
                p.SetPercent((count += 11) / total_reads);
                Application.DoEvents();
            }

            if (current_model == Model.FLEX5000 && FWCEEPROM.VUOK)
            {
                checksum_error = 0;
                while (true)
                {
                    FWCEEPROM.ReadVULevel(vhf_level_table, uhf_level_table); // 4 reads
                    vu_level_checksum = Checksum.Calc(vhf_level_table, uhf_level_table);
                    if (!trx_checksum_present) FWCEEPROM.WriteATUSWRChecksum(atu_swr_checksum);
                    if (Checksum.Match(vhf_level_table, uhf_level_table, FWCEEPROM.ReadVULevelChecksum())) break;

                    checksum_error++;
                    if (checksum_error > 2)
                    {
                        error_flag = true;
                        error += "VU Level Checksum verification error.\n" +
                            "DB: " + atu_swr_checksum.ToString("X") +
                            " EEPROM: " + FWCEEPROM.ReadVULevelChecksum().ToString("X") +
                            " Calculated: " + Checksum.Calc(vhf_level_table, uhf_level_table).ToString("X") + "\n";
                        break;
                    }
                }
                p.SetPercent((count += 4) / total_reads);
                Application.DoEvents();

                checksum_error = 0;
                while (true)
                {
                    FWCEEPROM.ReadVUPower(vhf_power_table, uhf_power_table); // 36 reads
                    vu_power_checksum = Checksum.Calc(vhf_power_table, uhf_power_table);
                    if (!trx_checksum_present) FWCEEPROM.WriteVUPowerChecksum(vu_power_checksum);
                    if (Checksum.Match(vhf_power_table, uhf_power_table, FWCEEPROM.ReadVUPowerChecksum())) break;

                    checksum_error++;
                    if (checksum_error > 2)
                    {
                        error_flag = true;
                        error += "VU Power Checksum verification error.\n" +
                            "DB: " + vu_power_checksum.ToString("X") +
                            " EEPROM: " + FWCEEPROM.ReadVUPowerChecksum().ToString("X") +
                            " Calculated: " + Checksum.Calc(vhf_power_table, uhf_power_table).ToString("X") + "\n";
                        break;
                    }
                }
                p.SetPercent((count += 36) / total_reads);
                Application.DoEvents();
            }

            if (error_flag)
            {
                TextWriter writer = new StreamWriter(app_data_path + "checksum_error.log", true); // "\\checksum_error.log"
                string s = DateTime.Now.ToShortDateString() + "  " + DateTime.Now.ToShortTimeString();
                writer.WriteLine(s + "  " + error);
                writer.Close();
                FWCEEPROM.TRXChecksumPresent = false;
            }

            if (flex5000DebugForm != null && !flex5000DebugForm.IsDisposed)
            {
                for (int i = 0; i < 8; i++)
                    flex5000DebugForm.SetPAPot(i, (byte)pa_bias_table[0][i]);
            }
            p.SetPercent((count += 8) / total_reads);
            Application.DoEvents();

            SyncCalDateTime();
            p.Hide();
            p.Close();
            Application.DoEvents();

            for (int i = (int)Band.B2M; i < (int)Band.BLMF; i++) //.250 was  for (int i = (int)Band.B2M; i < (int)Band.LAST; i++)
            {
                for (int j = 0; j < 13; j++)
                    power_table[i][j] = power_table[10][j]; // ke9ns: copy 10m into 2m and all VHF/UHF tables but not SWL bands above it
            }

            for (int i = 0; i < 13; i++) //.250
            {
                power_table[28][i] = power_table[1][i]; // 160M into BLMF band data       (160m LPF ends at 2.1mhz)

                power_table[29][i] = power_table[2][i]; // 80M into 120m band data 2.1mhz  (80m LPF ends at 4.1mhz)
                power_table[30][i] = power_table[2][i]; // 80M into 90m band data

                power_table[31][i] = power_table[3][i]; // 60M into 61m band data  (60m-40m LPF ends at 7.4mhz)
                power_table[32][i] = power_table[4][i]; // 40M into 49m band data

                power_table[33][i] = power_table[5][i]; // 30M into 41m band data (30m-20m LPF ends at 14.45mhz)
                power_table[34][i] = power_table[5][i]; // 30M into 31m band data
                power_table[35][i] = power_table[5][i]; // 30M into 25m band data
                power_table[36][i] = power_table[6][i]; // 20M into 22m band data

                power_table[37][i] = power_table[7][i]; // 17M into 19m band data   (17m-15m LPF ends at 21.55mhz)
                power_table[38][i] = power_table[7][i]; // 17M into 16m band data
                power_table[39][i] = power_table[8][i]; // 15M into 14m band data

                power_table[40][i] = power_table[9][i]; // 12M into 13m band data   (12-10m LPF ends at 29.8mhz)
                power_table[41][i] = power_table[10][i]; // 10M into 11m band data

            } // for

            for (int i = 0; i < 6; i++) //.250
            {
                pa_bridge_table[28][i] = pa_bridge_table[1][i]; // 160M into BLMF band data

                pa_bridge_table[29][i] = pa_bridge_table[2][i]; // 80M into 120m band data
                pa_bridge_table[30][i] = pa_bridge_table[2][i]; // 80M into 90m band data

                pa_bridge_table[31][i] = pa_bridge_table[3][i]; // 60M into 61m band data
                pa_bridge_table[32][i] = pa_bridge_table[4][i]; // 40M into 49m band data

                pa_bridge_table[33][i] = pa_bridge_table[5][i]; // 30M into 41m band data
                pa_bridge_table[34][i] = pa_bridge_table[5][i]; // 30M into 31m band data
                pa_bridge_table[35][i] = pa_bridge_table[5][i]; // 30M into 25m band data
                pa_bridge_table[36][i] = pa_bridge_table[6][i]; // 20M into 22m band data

                pa_bridge_table[37][i] = pa_bridge_table[7][i]; // 17M into 19m band data
                pa_bridge_table[38][i] = pa_bridge_table[7][i]; // 17M into 16m band data
                pa_bridge_table[39][i] = pa_bridge_table[8][i]; // 15M into 14m band data

                pa_bridge_table[40][i] = pa_bridge_table[9][i]; // 12M into 13m band data
                pa_bridge_table[41][i] = pa_bridge_table[10][i]; // 10M into 11m band data

            } // for


            //.250
            swr_table[28] = swr_table[1]; // 160M into BLMF band data

            swr_table[29] = swr_table[2]; // 80M into 120m band data
            swr_table[30] = swr_table[2]; // 80M into 90m band data

            swr_table[31] = swr_table[3]; // 60M into 61m band data
            swr_table[32] = swr_table[4]; // 60M into 49m band data

            swr_table[33] = swr_table[5]; // 40M into 41m band data
            swr_table[34] = swr_table[5]; // 30M into 31m band data
            swr_table[35] = swr_table[5]; // 20M into 25m band data
            swr_table[36] = swr_table[6]; // 20M into 22m band data

            swr_table[37] = swr_table[7]; // 17M into 19m band data
            swr_table[38] = swr_table[7]; // 17M into 16m band data
            swr_table[39] = swr_table[8]; // 15M into 14m band data

            swr_table[40] = swr_table[9]; // 12M into 13m band data
            swr_table[41] = swr_table[10]; // 10M into 11m band data

            atu_swr_table[28] = atu_swr_table[1]; // 160M into BLMF band data

            atu_swr_table[29] = atu_swr_table[2]; // 80M into 120m band data
            atu_swr_table[30] = atu_swr_table[2]; // 80M into 90m band data

            atu_swr_table[31] = atu_swr_table[3]; // 60M into 61m band data
            atu_swr_table[32] = atu_swr_table[4]; // 60M into 49m band data

            atu_swr_table[33] = atu_swr_table[5]; // 40M into 41m band data
            atu_swr_table[34] = atu_swr_table[5]; // 30M into 31m band data
            atu_swr_table[35] = atu_swr_table[5]; // 20M into 25m band data
            atu_swr_table[36] = atu_swr_table[6]; // 20M into 22m band data

            atu_swr_table[37] = atu_swr_table[7]; // 17M into 19m band data
            atu_swr_table[38] = atu_swr_table[7]; // 17M into 16m band data
            atu_swr_table[39] = atu_swr_table[8]; // 15M into 14m band data

            atu_swr_table[40] = atu_swr_table[9]; // 12M into 13m band data
            atu_swr_table[41] = atu_swr_table[10]; // 10M into 11m band data


            for (int i = 0; i < 3; i++) //.250
            {
                rx1_level_table[28][i] = rx1_level_table[1][i]; // 160M into BLMF band data

                rx1_level_table[29][i] = rx1_level_table[2][i]; // 80M into 120m band data
                rx1_level_table[30][i] = rx1_level_table[2][i]; // 80M into 90m band data

                rx1_level_table[31][i] = rx1_level_table[3][i]; // 60M into 61m band data
                rx1_level_table[32][i] = rx1_level_table[4][i]; // 60M into 49m band data

                rx1_level_table[33][i] = rx1_level_table[5][i]; // 40M into 41m band data
                rx1_level_table[34][i] = rx1_level_table[5][i]; // 30M into 31m band data
                rx1_level_table[35][i] = rx1_level_table[5][i]; // 20M into 25m band data
                rx1_level_table[36][i] = rx1_level_table[6][i]; // 20M into 22m band data

                rx1_level_table[37][i] = rx1_level_table[7][i]; // 17M into 19m band data
                rx1_level_table[38][i] = rx1_level_table[7][i]; // 17M into 16m band data
                rx1_level_table[39][i] = rx1_level_table[8][i]; // 15M into 14m band data

                rx1_level_table[40][i] = rx1_level_table[9][i]; // 12M into 13m band data
                rx1_level_table[41][i] = rx1_level_table[10][i]; // 10M into 11m band data

            } // for




            bool save_init = initializing;
            initializing = true;
            RX1Band = rx1_band;
            TXBand = tx_band;
            initializing = save_init;


        } // RestoreCalData

        public void RX2RestoreCalData()
        {
            bool rx2_checksum_present = FWCEEPROM.RX2ChecksumPresent;
            int checksum_error = 0;
            bool error_flag = false;
            string error = "";
            Progress p = new Progress("Retrieving Calibration Data from RX2 EEPROM");
            p.SetPercent(0.0f);
            this.Invoke(new MethodInvoker(p.Show));
            Application.DoEvents();
            float total_reads = 55.0f;
            int count = 0;

            checksum_error = 0;
            while (true)
            {
                FWCEEPROM.ReadRX2Level(rx2_level_table); // 33 reads
                rx2_level_checksum = Checksum.Calc(rx2_level_table);
                if (!rx2_checksum_present) FWCEEPROM.WriteRX2LevelChecksum(rx2_level_checksum);
                if (Checksum.Match(rx2_level_table, FWCEEPROM.ReadRX2LevelChecksum())) break;

                checksum_error++;
                if (checksum_error > 2)
                {
                    error_flag = true;
                    error += "RX2 Level Checksum verification error.\n" +
                        "DB: " + rx2_level_checksum.ToString("X") +
                        " EEPROM: " + FWCEEPROM.ReadRX2LevelChecksum().ToString("X") +
                        " Calculated: " + Checksum.Calc(rx2_level_table).ToString("X") + "\n";
                    break;
                }
            }
            p.SetPercent((count += 33) / total_reads);
            Application.DoEvents();

            checksum_error = 0;
            while (true)
            {
                FWCEEPROM.ReadRX2Image(rx2_image_gain_table, rx2_image_phase_table); // 22 reads
                rx2_image_gain_checksum = Checksum.CalcHF(rx2_image_gain_table);
                if (!rx2_checksum_present) FWCEEPROM.WriteRX2ImageGainChecksum(rx2_image_gain_checksum);
                if (Checksum.MatchHF(rx2_image_gain_table, FWCEEPROM.ReadRX2ImageGainChecksum())) break;

                checksum_error++;
                if (checksum_error > 2)
                {
                    error_flag = true;
                    error += "RX2 Image Gain Checksum verification error.\n" +
                        "DB: " + rx2_image_gain_checksum.ToString("X") +
                        " EEPROM: " + FWCEEPROM.ReadRX2ImageGainChecksum().ToString("X") +
                        " Calculated: " + Checksum.CalcHF(rx2_image_gain_table).ToString("X") + "\n";
                    break;
                }
            }

            checksum_error = 0;
            do
            {
                rx2_image_phase_checksum = Checksum.CalcHF(rx2_image_phase_table);
                if (!rx2_checksum_present) FWCEEPROM.WriteRX2ImagePhaseChecksum(rx2_image_phase_checksum);
                if (Checksum.MatchHF(rx2_image_phase_table, FWCEEPROM.ReadRX2ImagePhaseChecksum())) break;

                checksum_error++;
                if (checksum_error > 2)
                {
                    error_flag = true;
                    error += "RX2 Image Phase Checksum verification error.\n" +
                        "DB: " + rx2_image_phase_checksum.ToString("X") +
                        " EEPROM: " + FWCEEPROM.ReadRX2ImagePhaseChecksum().ToString("X") +
                        " Calculated: " + Checksum.CalcHF(rx2_image_phase_table).ToString("X") + "\n";
                    break;
                }
                FWCEEPROM.ReadRX2Image(rx2_image_gain_table, rx2_image_phase_table); // 22 reads
            } while (true);
            p.SetPercent((count += 22) / total_reads);
            Application.DoEvents();

            if (error_flag)
            {
                TextWriter writer = new StreamWriter(app_data_path + "checksum_error.log", true); // "\\checksum_error.log"
                string s = DateTime.Now.ToShortDateString() + "  " + DateTime.Now.ToShortTimeString();
                writer.WriteLine(s + "  " + error);
                writer.Close();
                FWCEEPROM.RX2ChecksumPresent = false;
            }

            RX2SyncCalDateTime();
            p.Hide();
            p.Close();

            for (int i = 0; i < 3; i++)  //.250
            {
                rx2_level_table[28][i] = rx2_level_table[1][i]; // 160M into BLMF band data

                rx2_level_table[29][i] = rx2_level_table[2][i]; // 80M into 120m band data
                rx2_level_table[30][i] = rx2_level_table[2][i]; // 80M into 90m band data

                rx2_level_table[31][i] = rx2_level_table[3][i]; // 60M into 61m band data
                rx2_level_table[32][i] = rx2_level_table[4][i]; // 60M into 49m band data

                rx2_level_table[33][i] = rx2_level_table[5][i]; // 40M into 41m band data
                rx2_level_table[34][i] = rx2_level_table[5][i]; // 30M into 31m band data
                rx2_level_table[35][i] = rx2_level_table[5][i]; // 20M into 25m band data
                rx2_level_table[36][i] = rx2_level_table[6][i]; // 20M into 22m band data

                rx2_level_table[37][i] = rx2_level_table[7][i]; // 17M into 19m band data
                rx2_level_table[38][i] = rx2_level_table[7][i]; // 17M into 16m band data
                rx2_level_table[39][i] = rx2_level_table[8][i]; // 15M into 14m band data

                rx2_level_table[40][i] = rx2_level_table[9][i]; // 12M into 13m band data
                rx2_level_table[41][i] = rx2_level_table[10][i]; // 10M into 11m band data

            } // for



            bool save_init = initializing;
            initializing = true;
            RX2Band = rx2_band;
            initializing = save_init;
        }

        public void Write1500CalData() // ke9ns write EEPROM data from 0x3000 and up
        {
            if (!hid_init || current_model != Model.FLEX1500) return;

            HIDEEPROM.WriteRXLevel(rx1_level_table, out rx1_level_checksum);
            HIDEEPROM.WriteRXImage(rx1_image_gain_table, rx1_image_phase_table, out rx1_image_gain_checksum, out rx1_image_phase_checksum);
            HIDEEPROM.WriteTXImage(tx_image_gain_table, tx_image_phase_table, out tx_image_gain_checksum, out tx_image_phase_checksum);
            HIDEEPROM.WritePAPower(power_table, out pa_power_checksum);

            SyncCalDateTime();
        }

        public void WriteCalData()
        {
            if (!fwc_init || (current_model != Model.FLEX5000 && current_model != Model.FLEX3000)) return;

            FWCEEPROM.WriteRXLevel(rx1_level_table, out rx1_level_checksum);
            FWCEEPROM.WriteRXImage(rx1_image_gain_table, rx1_image_phase_table, out rx1_image_gain_checksum, out rx1_image_phase_checksum);
            FWCEEPROM.WriteTXImage(tx_image_gain_table, tx_image_phase_table, out tx_image_gain_checksum, out tx_image_phase_checksum);
            FWCEEPROM.WriteTXCarrier(tx_carrier_cal, out tx_carrier_checksum);
            FWCEEPROM.WritePABias(pa_bias_table, out pa_bias_checksum);
            FWCEEPROM.WritePABridge(pa_bridge_table, out pa_bridge_checksum);
            FWCEEPROM.WritePAPower(power_table, out pa_power_checksum);
            FWCEEPROM.WritePASWR(swr_table, out pa_swr_checksum);
            FWCEEPROM.WriteATUSWR(atu_swr_table, out atu_swr_checksum);

            if (FWCEEPROM.VUOK)
            {
                FWCEEPROM.WriteVULevel(vhf_level_table, uhf_level_table, out vu_level_checksum);
                FWCEEPROM.WriteVUPower(vhf_power_table, uhf_power_table, out vu_power_checksum);
            }

            SyncCalDateTime();
        }

        public void WriteRX2CalData()
        {
            if (!fwc_init || current_model != Model.FLEX5000 || !FWCEEPROM.RX2OK) return;

            FWCEEPROM.WriteRX2Level(rx2_level_table, out rx2_level_checksum);
            FWCEEPROM.WriteRX2Image(rx2_image_gain_table, rx2_image_phase_table, out rx2_image_gain_checksum, out rx2_image_phase_checksum);

            SyncCalDateTime();
        }

        public float GetRX1Level(Band b, int index)
        {
            return rx1_level_table[(int)b][index];
        }

        public float GetRX2Level(Band b, int index)
        {
            return rx2_level_table[(int)b][index];
        }

        public FilterPreset[] rx1_filters = new FilterPreset[(int)DSPMode.LAST];
        public FilterPreset[] rx2_filters = new FilterPreset[(int)DSPMode.LAST];

        private void InitFilterPresets()
        {
            InitFilterPresets(rx1_filters);
            InitFilterPresets(rx2_filters);
        }

        private void InitFilterPresets(FilterPreset[] preset)
        {
            // used to initialize all the filter variables
            // changed digi mode preset filters to center on digi mode click tune offset - W4TME

            for (int m = (int)DSPMode.FIRST + 1; m < (int)DSPMode.LAST; m++)
            {
                preset[m] = new FilterPreset();
                for (Filter f = Filter.F1; f != Filter.LAST; f++)
                {
                    switch (m)
                    {
                        case (int)DSPMode.LSB:
                            switch (f)
                            {
                                case Filter.F1:
                                    preset[m].SetFilter(f, -5150, -150, "5.0k");
                                    break;
                                case Filter.F2:
                                    preset[m].SetFilter(f, -4550, -150, "4.4k");
                                    break;
                                case Filter.F3:
                                    preset[m].SetFilter(f, -3950, -150, "3.8k");
                                    break;
                                case Filter.F4:
                                    preset[m].SetFilter(f, -3450, -150, "3.3k");
                                    break;
                                case Filter.F5:
                                    preset[m].SetFilter(f, -3050, -150, "2.9k");
                                    break;
                                case Filter.F6:
                                    preset[m].SetFilter(f, -2850, -150, "2.7k");
                                    break;
                                case Filter.F7:
                                    preset[m].SetFilter(f, -2550, -150, "2.4k");
                                    break;
                                case Filter.F8:
                                    preset[m].SetFilter(f, -2250, -150, "2.1k");
                                    break;
                                case Filter.F9:
                                    preset[m].SetFilter(f, -1950, -150, "1.8k");
                                    break;
                                case Filter.F10:
                                    preset[m].SetFilter(f, -1150, -150, "1.0k");
                                    break;
                                case Filter.VAR1:
                                    preset[m].SetFilter(f, -2850, -150, "Var 1");
                                    break;
                                case Filter.VAR2:
                                    preset[m].SetFilter(f, -2850, -150, "Var 2");
                                    break;
                            }
                            preset[m].LastFilter = Filter.F6;
                            break; // lsb
                        case (int)DSPMode.USB:
                            switch (f)
                            {
                                case Filter.F1:
                                    preset[m].SetFilter(f, 150, 5150, "5.0k");
                                    break;
                                case Filter.F2:
                                    preset[m].SetFilter(f, 150, 4550, "4.4k");
                                    break;
                                case Filter.F3:
                                    preset[m].SetFilter(f, 150, 3950, "3.8k");
                                    break;
                                case Filter.F4:
                                    preset[m].SetFilter(f, 150, 3450, "3.3k");
                                    break;
                                case Filter.F5:
                                    preset[m].SetFilter(f, 150, 3050, "2.9k");
                                    break;
                                case Filter.F6:
                                    preset[m].SetFilter(f, 150, 2850, "2.7k");
                                    break;
                                case Filter.F7:
                                    preset[m].SetFilter(f, 150, 2550, "2.4k");
                                    break;
                                case Filter.F8:
                                    preset[m].SetFilter(f, 150, 2250, "2.1k");
                                    break;
                                case Filter.F9:
                                    preset[m].SetFilter(f, 150, 1950, "1.8k");
                                    break;
                                case Filter.F10:
                                    preset[m].SetFilter(f, 150, 1150, "1.0k");
                                    break;
                                case Filter.VAR1:
                                    preset[m].SetFilter(f, 150, 2850, "Var 1");
                                    break;
                                case Filter.VAR2:
                                    preset[m].SetFilter(f, 150, 2850, "Var 2");
                                    break;
                            }
                            preset[m].LastFilter = Filter.F6;
                            break; //usb
                        case (int)DSPMode.DIGL:
                            switch (f)
                            {
                                case Filter.F1:
                                    preset[m].SetFilter(f, -digl_click_tune_offset - 1500, -digl_click_tune_offset + 1500, "3.0k");
                                    break;
                                case Filter.F2:
                                    preset[m].SetFilter(f, -digl_click_tune_offset - 1250, -digl_click_tune_offset + 1250, "2.5k");
                                    break;
                                case Filter.F3:
                                    preset[m].SetFilter(f, -digl_click_tune_offset - 1000, -digl_click_tune_offset + 1000, "2.0k");
                                    break;
                                case Filter.F4:
                                    preset[m].SetFilter(f, -digl_click_tune_offset - 750, -digl_click_tune_offset + 750, "1.5k");
                                    break;
                                case Filter.F5:
                                    preset[m].SetFilter(f, -digl_click_tune_offset - 500, -digl_click_tune_offset + 500, "1.0k");
                                    break;
                                case Filter.F6:
                                    preset[m].SetFilter(f, -digl_click_tune_offset - 400, -digl_click_tune_offset + 400, "800");
                                    break;
                                case Filter.F7:
                                    preset[m].SetFilter(f, -digl_click_tune_offset - 300, -digl_click_tune_offset + 300, "600");
                                    break;
                                case Filter.F8:
                                    preset[m].SetFilter(f, -digl_click_tune_offset - 150, -digl_click_tune_offset + 150, "300");
                                    break;
                                case Filter.F9:
                                    preset[m].SetFilter(f, -digl_click_tune_offset - 75, -digl_click_tune_offset + 75, "150");
                                    break;
                                case Filter.F10:
                                    preset[m].SetFilter(f, -digl_click_tune_offset - 38, -digl_click_tune_offset + 38, "75");
                                    break;
                                case Filter.VAR1:
                                    preset[m].SetFilter(f, -digl_click_tune_offset - 400, -digl_click_tune_offset + 400, "Var 1");
                                    break;
                                case Filter.VAR2:
                                    preset[m].SetFilter(f, -digl_click_tune_offset - 400, -digl_click_tune_offset + 400, "Var 2");
                                    break;
                            }
                            preset[m].LastFilter = Filter.F5;
                            break; //digl
                        case (int)DSPMode.DIGU:
                            switch (f)
                            {
                                case Filter.F1:
                                    preset[m].SetFilter(f, digu_click_tune_offset - 1500, digu_click_tune_offset + 1500, "3.0k");
                                    break;
                                case Filter.F2:
                                    preset[m].SetFilter(f, digu_click_tune_offset - 1250, digu_click_tune_offset + 1250, "2.5k");
                                    break;
                                case Filter.F3:
                                    preset[m].SetFilter(f, digu_click_tune_offset - 1000, digu_click_tune_offset + 1000, "2.0k");
                                    break;
                                case Filter.F4:
                                    preset[m].SetFilter(f, digu_click_tune_offset - 750, digu_click_tune_offset + 750, "1.5k");
                                    break;
                                case Filter.F5:
                                    preset[m].SetFilter(f, digu_click_tune_offset - 500, digu_click_tune_offset + 500, "1.0k");
                                    break;
                                case Filter.F6:
                                    preset[m].SetFilter(f, digu_click_tune_offset - 400, digu_click_tune_offset + 400, "800");
                                    break;
                                case Filter.F7:
                                    preset[m].SetFilter(f, digu_click_tune_offset - 300, digu_click_tune_offset + 300, "600");
                                    break;
                                case Filter.F8:
                                    preset[m].SetFilter(f, digu_click_tune_offset - 150, digu_click_tune_offset + 150, "300");
                                    break;
                                case Filter.F9:
                                    preset[m].SetFilter(f, digu_click_tune_offset - 75, digu_click_tune_offset + 75, "150");
                                    break;
                                case Filter.F10:
                                    preset[m].SetFilter(f, digu_click_tune_offset - 38, digu_click_tune_offset + 38, "75");
                                    break;
                                case Filter.VAR1:
                                    preset[m].SetFilter(f, digu_click_tune_offset - 400, digu_click_tune_offset + 400, "Var 1");
                                    break;
                                case Filter.VAR2:
                                    preset[m].SetFilter(f, digu_click_tune_offset - 400, digu_click_tune_offset + 400, "Var 2");
                                    break;
                            }
                            preset[m].LastFilter = Filter.F5;
                            break;  // digu
                        case (int)DSPMode.CWL:
                            switch (f)
                            {
                                case Filter.F1:
                                    preset[m].SetFilter(f, -cw_pitch - 500, -cw_pitch + 500, "1.0k");
                                    break;
                                case Filter.F2:
                                    preset[m].SetFilter(f, -cw_pitch - 400, -cw_pitch + 400, "800");
                                    break;
                                case Filter.F3:
                                    preset[m].SetFilter(f, -cw_pitch - 375, -cw_pitch + 375, "750");
                                    break;
                                case Filter.F4:
                                    preset[m].SetFilter(f, -cw_pitch - 300, -cw_pitch + 300, "600");
                                    break;
                                case Filter.F5:
                                    preset[m].SetFilter(f, -cw_pitch - 250, -cw_pitch + 250, "500");
                                    break;
                                case Filter.F6:
                                    preset[m].SetFilter(f, -cw_pitch - 200, -cw_pitch + 200, "400");
                                    break;
                                case Filter.F7:
                                    preset[m].SetFilter(f, -cw_pitch - 125, -cw_pitch + 125, "250");
                                    break;
                                case Filter.F8:
                                    preset[m].SetFilter(f, -cw_pitch - 50, -cw_pitch + 50, "100");
                                    break;
                                case Filter.F9:
                                    preset[m].SetFilter(f, -cw_pitch - 25, -cw_pitch + 25, "50");
                                    break;
                                case Filter.F10:
                                    preset[m].SetFilter(f, -cw_pitch - 13, -cw_pitch + 13, "25");
                                    break;
                                case Filter.VAR1:
                                    preset[m].SetFilter(f, -cw_pitch - 250, -cw_pitch + 250, "Var 1");
                                    break;
                                case Filter.VAR2:
                                    preset[m].SetFilter(f, -cw_pitch - 250, -cw_pitch + 250, "Var 2");
                                    break;
                            }
                            preset[m].LastFilter = Filter.F5;
                            break; // cwl
                        case (int)DSPMode.CWU:
                            switch (f)
                            {
                                case Filter.F1:
                                    preset[m].SetFilter(f, cw_pitch - 500, cw_pitch + 500, "1.0k");
                                    break;
                                case Filter.F2:
                                    preset[m].SetFilter(f, cw_pitch - 400, cw_pitch + 400, "800");
                                    break;
                                case Filter.F3:
                                    preset[m].SetFilter(f, cw_pitch - 375, cw_pitch + 375, "750");
                                    break;
                                case Filter.F4:
                                    preset[m].SetFilter(f, cw_pitch - 300, cw_pitch + 300, "600");
                                    break;
                                case Filter.F5:
                                    preset[m].SetFilter(f, cw_pitch - 250, cw_pitch + 250, "500");
                                    break;
                                case Filter.F6:
                                    preset[m].SetFilter(f, cw_pitch - 200, cw_pitch + 200, "400");
                                    break;
                                case Filter.F7:
                                    preset[m].SetFilter(f, cw_pitch - 125, cw_pitch + 125, "250");
                                    break;
                                case Filter.F8:
                                    preset[m].SetFilter(f, cw_pitch - 50, cw_pitch + 50, "100");
                                    break;
                                case Filter.F9:
                                    preset[m].SetFilter(f, cw_pitch - 25, cw_pitch + 25, "50");
                                    break;
                                case Filter.F10:
                                    preset[m].SetFilter(f, cw_pitch - 13, cw_pitch + 13, "25");
                                    break;
                                case Filter.VAR1:
                                    preset[m].SetFilter(f, cw_pitch - 250, cw_pitch + 250, "Var 1");
                                    break;
                                case Filter.VAR2:
                                    preset[m].SetFilter(f, cw_pitch - 250, cw_pitch + 250, "Var 2");
                                    break;
                            }
                            preset[m].LastFilter = Filter.F5;
                            break; //cwu
                        case (int)DSPMode.AM:
                        case (int)DSPMode.SAM:
                        case (int)DSPMode.DSB:
                            switch (f)
                            {
                                case Filter.F1:
                                    preset[m].SetFilter(f, -8000, 8000, "16k");
                                    break;
                                case Filter.F2:
                                    preset[m].SetFilter(f, -6000, 6000, "12k");
                                    break;
                                case Filter.F3:
                                    preset[m].SetFilter(f, -5000, 5000, "10k");
                                    break;
                                case Filter.F4:
                                    preset[m].SetFilter(f, -4000, 4000, "8.0k");
                                    break;
                                case Filter.F5:
                                    preset[m].SetFilter(f, -3300, 3300, "6.6k");
                                    break;
                                case Filter.F6:
                                    preset[m].SetFilter(f, -2600, 2600, "5.2k");
                                    break;
                                case Filter.F7:
                                    preset[m].SetFilter(f, -2000, 2000, "4.0k");
                                    break;
                                case Filter.F8:
                                    preset[m].SetFilter(f, -1550, 1550, "3.1k");
                                    break;
                                case Filter.F9:
                                    preset[m].SetFilter(f, -1450, 1450, "2.9k");
                                    break;
                                case Filter.F10:
                                    preset[m].SetFilter(f, -1200, 1200, "2.4k");
                                    break;
                                case Filter.VAR1:
                                    preset[m].SetFilter(f, -3300, 3300, "Var 1");
                                    break;
                                case Filter.VAR2:
                                    preset[m].SetFilter(f, -3300, 3300, "Var 2");
                                    break;
                            }
                            preset[m].LastFilter = Filter.F5;
                            break; // am,dsb
                        default:
                            preset[m].LastFilter = Filter.NONE;
                            break;
                    }
                }
            }
        } // initfilterpresets

        private void InitDisplayModes()
        {
            // populate the display mode list
            for (DisplayMode dm = DisplayMode.FIRST + 1; dm < DisplayMode.LAST; dm++)
            {
                string s = dm.ToString().ToLower();

                s = s.Substring(0, 1).ToUpper() + s.Substring(1, s.Length - 1);

                comboDisplayMode.Items.Add(s);
            }
        }

        private void InitAGCModes()
        {
            // populate the AGC mode list
            for (AGCMode agc = AGCMode.FIRST + 1; agc < AGCMode.LAST; agc++)
            {
                string s = agc.ToString().ToLower();
                s = s.Substring(0, 1).ToUpper() + s.Substring(1, s.Length - 1);
                comboAGC.Items.Add(s);
            }

            for (AGCMode agc = AGCMode.FIRST + 1; agc < AGCMode.CUSTOM; agc++) //ke9ns mod to add custom for (AGCMode agc = AGCMode.FIRST + 1; agc < AGCMode.CUSTOM; agc++)
            {
                string s = agc.ToString().ToLower();
                s = s.Substring(0, 1).ToUpper() + s.Substring(1, s.Length - 1);
                comboRX2AGC.Items.Add(s);
            }
        }

        private void InitMultiMeterModes()
        {
            comboMeterRXMode.Items.Add("Signal");
            comboMeterRXMode.Items.Add("Sig Avg");
            comboMeterRXMode.Items.Add("Sig Pk"); // ke9ns ADD new meter mode (Signal Peak hold reading)
            comboMeterRXMode.Items.Add("ADC L");
            comboMeterRXMode.Items.Add("ADC R");
            comboMeterRXMode.Items.Add("ADC2 L");
            comboMeterRXMode.Items.Add("ADC2 R");
            comboMeterRXMode.Items.Add("Off");

            comboRX2MeterMode.Items.Add("Signal");
            comboRX2MeterMode.Items.Add("Sig Avg");
            comboRX2MeterMode.Items.Add("Sig Pk"); // ke9ns ADD new meter mode (Signal Peak hold reading)
            comboRX2MeterMode.Items.Add("ADC L");
            comboRX2MeterMode.Items.Add("ADC R");
            comboRX2MeterMode.Items.Add("ADC2 L");
            comboRX2MeterMode.Items.Add("ADC2 R");
            comboRX2MeterMode.Items.Add("Off");

            comboMeterTXMode.Items.Add("Fwd Pwr");
            comboMeterTXMode.Items.Add("Ref Pwr");
            comboMeterTXMode.Items.Add("SWR");
            comboMeterTXMode.Items.Add("Mic");
            comboMeterTXMode.Items.Add("EQ");
            comboMeterTXMode.Items.Add("Leveler");
            comboMeterTXMode.Items.Add("Lev Gain");
            comboMeterTXMode.Items.Add("ALC");
            comboMeterTXMode.Items.Add("ALC Comp");
            comboMeterTXMode.Items.Add("CPDR");

            comboMeterTXMode.Items.Add("Off");


            //ke9ns add block below
            comboMeterTX1Mode.Items.Add("Fwd Pwr");
            comboMeterTX1Mode.Items.Add("Ref Pwr");
            comboMeterTX1Mode.Items.Add("SWR");
            comboMeterTX1Mode.Items.Add("Mic");
            comboMeterTX1Mode.Items.Add("EQ");
            comboMeterTX1Mode.Items.Add("Leveler");
            comboMeterTX1Mode.Items.Add("Lev Gain");
            comboMeterTX1Mode.Items.Add("ALC");
            comboMeterTX1Mode.Items.Add("ALC Comp");
            comboMeterTX1Mode.Items.Add("CPDR");
            comboMeterTX1Mode.Items.Add("Combo"); // ke9ns add for combo meter
            comboMeterTX1Mode.Items.Add("Off");

        }// initmultimeterModes()

        private void DisableAllFilters()
        {
            foreach (Control c in panelFilter.Controls)
            {
                if (c.GetType() == typeof(RadioButtonTS))
                {
                    c.Enabled = false;
                }
            }
        }

        private void DisableAllRX2Filters()
        {
            foreach (Control c in panelRX2Filter.Controls)
            {
                if (c.GetType() == typeof(RadioButtonTS))
                {
                    c.Enabled = false;
                }
            }
        }

        private void EnableAllFilters()
        {
            foreach (Control c in panelFilter.Controls)
            {
                if (c.GetType() == typeof(RadioButtonTS))
                {
                    c.Enabled = true;

                    if (c.BackColor == vfo_text_dark_color)
                    {
                        c.BackColor = button_selected_color;
                    }
                }
            }
        }

        private void EnableAllRX2Filters()
        {
            foreach (Control c in panelRX2Filter.Controls)
            {
                if (c.GetType() == typeof(RadioButtonTS))
                {
                    c.Enabled = true;

                    if (c.BackColor == vfo_text_dark_color)
                    {
                        c.BackColor = button_selected_color;
                    }
                }
            }
        }

        //=============================================================
        // ke9ns used to disable all the buttons on the HF,VHF,SWL band panel
        private void DisableAllBands()
        {
            foreach (Control c in panelBandHF.Controls)
            {
                c.Enabled = false;

                RadioButtonTS b = c as RadioButtonTS;
                if (b != null)
                {
                    if (b.BackColor == button_selected_color)
                    {
                        b.BackColor = vfo_text_dark_color;
                    }
                }
            }


            foreach (Control c in panelBandVHF.Controls)
            {
                c.Enabled = false;

                RadioButtonTS b = c as RadioButtonTS;
                if (b != null)
                {
                    if (b.BackColor == button_selected_color)
                    {
                        b.BackColor = vfo_text_dark_color;
                    }
                }
            }

            foreach (Control c in panelBandGN.Controls)
            {
                //   c.Enabled = false;

                RadioButtonTS b = c as RadioButtonTS;
                if (b != null)
                {
                    if (b.BackColor == button_selected_color)
                    {
                        b.BackColor = vfo_text_dark_color;
                    }
                }
            }

            foreach (Control c in panelBandHFRX2.Controls)
            {
                c.Enabled = false;

                RadioButtonTS b = c as RadioButtonTS;
                if (b != null)
                {
                    if (b.BackColor == button_selected_color)
                    {
                        b.BackColor = vfo_text_dark_color;
                    }
                }
            }


            foreach (Control c in panelBandVHFRX2.Controls)
            {
                c.Enabled = false;

                RadioButtonTS b = c as RadioButtonTS;
                if (b != null)
                {
                    if (b.BackColor == button_selected_color)
                    {
                        b.BackColor = vfo_text_dark_color;
                    }
                }
            }

            foreach (Control c in panelBandGNRX2.Controls)
            {
                //   c.Enabled = false;

                RadioButtonTS b = c as RadioButtonTS;
                if (b != null)
                {
                    if (b.BackColor == button_selected_color)
                    {
                        b.BackColor = vfo_text_dark_color;
                    }
                }
            }

        } // DisableAllBands()


        //=================================================================================
        // ke9ns turns on buttons on all 3 band panels HF,VHF, SWL

        private void EnableAllBands()
        {


            foreach (Control c in panelBandHF.Controls)
            {
                RadioButtonTS b = c as RadioButtonTS;
                if (b != null)
                {
                    if (b.Text == "2") b.Enabled = XVTRPresent;
                    else b.Enabled = true;

                    if (b.BackColor == vfo_text_dark_color) b.BackColor = button_selected_color;
                }
                else c.Enabled = true;
            }


            foreach (Control c in panelBandGN.Controls) // ke9ns add
            {
                RadioButtonTS b = c as RadioButtonTS;
                //   Debug.WriteLine("enableallbands");

                if (b != null)
                {

                    if (b.Name == "panelBandHF")
                    {
                        b.Enabled = true;
                    }
                    else
                    {
                        b.Enabled = true;

                    }

                    if (b.BackColor == vfo_text_dark_color) b.BackColor = button_selected_color;
                }
                else
                {
                    c.Enabled = true;

                }
            }


            foreach (Control c in panelBandVHF.Controls)
            {
                RadioButtonTS b = c as RadioButtonTS;
                if (b != null)
                {
                    if (b.Name == "panelBandHF") b.Enabled = true;
                    else
                    {
                        int index = Int32.Parse(b.Name.Substring(10));
                        if (xvtrForm.GetEnabled(index))
                            b.Enabled = true;
                    }

                    if (b.BackColor == vfo_text_dark_color)
                        b.BackColor = button_selected_color;
                }
                else c.Enabled = true;
            }

            //...........................



            foreach (Control c in panelBandHFRX2.Controls)
            {
                RadioButtonTS b = c as RadioButtonTS;
                if (b != null)
                {
                    if (b.Text == "2") b.Enabled = XVTRPresent;
                    else b.Enabled = true;

                    if (b.BackColor == vfo_text_dark_color) b.BackColor = button_selected_color;
                }
                else c.Enabled = true;
            }


            foreach (Control c in panelBandGNRX2.Controls) // ke9ns add
            {
                RadioButtonTS b = c as RadioButtonTS;
                //   Debug.WriteLine("enableallbands");

                if (b != null)
                {

                    if (b.Name == "panelBandHFRX2")
                    {
                        b.Enabled = true;
                    }
                    else
                    {
                        b.Enabled = true;

                    }

                    if (b.BackColor == vfo_text_dark_color) b.BackColor = button_selected_color;
                }
                else
                {
                    c.Enabled = true;

                }
            }

            //   Debug.WriteLine("NOW VHFRX2");

            foreach (Control c in panelBandVHFRX2.Controls)
            {
                RadioButtonTS b = c as RadioButtonTS;
                if (b != null)
                {
                    if (b.Name == "panelBandHFRX2") b.Enabled = true;
                    else
                    {
                        int e = b.Name.IndexOf("RX2"); // ke9ns 

                        string d = b.Name.Substring(10, (e - 10));
                        //  int index = Int32.Parse(b.Name.Substring(10));
                        int index = Int32.Parse(d);

                        if (xvtrForm.GetEnabled(index)) b.Enabled = true;
                    }

                    if (b.BackColor == vfo_text_dark_color) b.BackColor = button_selected_color;
                }
                else c.Enabled = true;
            }

        } // EnableAllBands()



        //============================================================================================
        private void DisableAllModes()
        {
            foreach (RadioButtonTS r in panelMode.Controls)
            {
                r.Enabled = false;
                if (r.BackColor == button_selected_color)
                    r.BackColor = vfo_text_dark_color;
            }
        }

        private void EnableAllModes()
        {
            foreach (RadioButtonTS r in panelMode.Controls)
            {
                if (r.Text != "") r.Enabled = true;
                if (r.BackColor == vfo_text_dark_color) r.BackColor = button_selected_color;
            }
        }

        private void DisableFilters(int lowcutoff)
        {
            // Disables all filters below the number passed in. 
            // For example, DisableFilters(100) would cause the
            // 100Hz, 50Hz and 25Hz filters to be disabled.

            foreach (Control c in panelFilter.Controls)
            {
                if (c.GetType() == typeof(RadioButtonTS) && c.Name.IndexOf("Var") < 0)
                {
                    string name = c.Name;
                    int begin, len;
                    begin = name.IndexOf("Filter") + 6;
                    len = name.Length - begin;

                    int filter_width = Int32.Parse(name.Substring(begin, len));
                    if (filter_width < lowcutoff)
                    {
                        c.Enabled = false;
                        ((RadioButtonTS)c).Checked = false;
                    }
                }
            }
        }

        private void GetVFOCharWidth()
        {
            // This function calculates the pixel width of the VFO display.
            // This information is used for mouse wheel hover tuning.

            Graphics g = txtVFOAFreq.CreateGraphics();

            SizeF size = g.MeasureString("0", txtVFOAFreq.Font, 1000, StringFormat.GenericTypographic);
            vfo_char_width = (int)Math.Round(size.Width - 2.0f, 0); // subtract 2 since measure string includes 1 pixel border on each side
            float float_char_width = size.Width - 2.0f;

            size = g.MeasureString("00", txtVFOAFreq.Font, 1000, StringFormat.GenericTypographic);
            vfo_char_space = (int)Math.Round(size.Width - 2.0f - 2 * float_char_width, 0);

            size = g.MeasureString(separator, txtVFOAFreq.Font, 1000, StringFormat.GenericTypographic);
            vfo_decimal_width = (int)(size.Width - 2.0f);

            size = g.MeasureString("0" + separator + "0", txtVFOAFreq.Font, 1000, StringFormat.GenericTypographic);
            vfo_decimal_space = (int)Math.Round(size.Width - 2.0f - 2 * float_char_width, 0);


            size = g.MeasureString("1234.678901", txtVFOAFreq.Font, 1000, StringFormat.GenericTypographic); // ke9ns: only setup for 9999.999999 ghz max (you lose 1hz digit at 10ghz)
            vfo_pixel_offset = (int)Math.Round(size.Width - 2.0f, 0);

            size = g.MeasureString("0", txtVFOALSD.Font, 1000, StringFormat.GenericTypographic);
            vfo_small_char_width = (int)Math.Round(size.Width - 2.0f, 0);
            float_char_width = size.Width - 2.0f;

            size = g.MeasureString("00", txtVFOALSD.Font, 1000, StringFormat.GenericTypographic);
            vfo_small_char_space = (int)Math.Round(size.Width - 2.0f - 2 * float_char_width, 0);

            g.Dispose();
        } // GetVFOCharWidth()

        private void GetVFOSubCharWidth()
        {
            // This function calculates the pixel width of the VFO display.
            // This information is used for mouse wheel hover tuning.

            Graphics g = txtVFOABand.CreateGraphics();

            SizeF size = g.MeasureString("0", txtVFOABand.Font, 1000, StringFormat.GenericTypographic);
            vfo_sub_char_width = (int)Math.Round(size.Width - 2.0f, 0); // subtract 2 since measure string includes 1 pixel border on each side
            float float_char_width = size.Width - 2.0f;

            size = g.MeasureString("00", txtVFOABand.Font, 1000, StringFormat.GenericTypographic);
            vfo_sub_char_space = (int)Math.Round(size.Width - 2.0f - 2 * float_char_width, 0);

            size = g.MeasureString(separator, txtVFOABand.Font, 1000, StringFormat.GenericTypographic);
            vfo_sub_decimal_width = (int)(size.Width - 2.0f);

            size = g.MeasureString("0" + separator + "0", txtVFOABand.Font, 1000, StringFormat.GenericTypographic);
            vfo_sub_decimal_space = (int)Math.Round(size.Width - 2.0f - 2 * float_char_width, 0);


            size = g.MeasureString("1234.678901", txtVFOABand.Font, 1000, StringFormat.GenericTypographic);
            vfo_sub_pixel_offset = (int)Math.Round(size.Width - 2.0f, 0);

            /*size = g.MeasureString("0", txtVFOALSD.Font, 1000, StringFormat.GenericTypographic);
			vfo_small_char_width = (int)Math.Round(size.Width-2.0f, 0);
			float_char_width = size.Width-2.0f;

			size = g.MeasureString("00", txtVFOALSD.Font, 1000, StringFormat.GenericTypographic);
			vfo_small_char_space = (int)Math.Round(size.Width-2.0f - 2*float_char_width, 0);*/

            g.Dispose();
        }  // GetVFOsubcharwidth()

        public string[] filter2 = new string[20]; // ke9ns add for bandstack locking (= "@" if locked)
        public string[] filter22 = new string[20]; // ke9ns add for bandstack locking .209 vfoB
        public int iii = 0;
        public int iii2 = 0; // .209


        //==================================================================================
        // ke9ns add   VFOA and B
        public bool SaveBandAA()
        {
            //---------------------------- VFOA
            try
            {

                StackForm.bandstackupdate(); // ke9ns add: to update filter2[]


                iii = Convert.ToInt32((string)regBox1.Text);
                Debug.WriteLine("LOCK STATUS filter2[] = " + filter2[iii]);

                iii = iii - 1;

                Debug.WriteLine("index status = " + iii);

                if (iii < 0) return false; // ke9ns add  usually only happens after a new installation

            }
            catch (Exception)
            {
                Debug.WriteLine("Cant get bandstack info");
                iii = 0;
                filter2[0] = "";
                return false;
            }

            if (filter2[iii] == "@")
            {
                BandStackLock = 1;
            }
            else
            {
                BandStackLock = 0;
            }

            return true;

        } // SaveBandAA()


        //=====================================================
        public bool SaveBandBB() //.209 VFOB
        {

            try
            {
                StackForm.bandstackupdate(); // ke9ns add: to update filter22[]

                iii2 = Convert.ToInt32((string)regBox12);
                Debug.WriteLine("LOCK STATUS filter22[] = " + filter22[iii2]);

                iii2 = iii2 - 1;

                Debug.WriteLine("index status = " + iii2);

                if (iii2 < 0) return false; // ke9ns add  usually only happens after a new installation

            }
            catch (Exception)
            {
                Debug.WriteLine("Cant get bandstack info");
                iii2 = 0;
                filter22[0] = "";
                return false;
            }

            if (filter22[iii2] == "@")
            {
                BandStackLock2 = 1;
            }
            else
            {
                BandStackLock2 = 0;
            }

            return true;

        } // SaveBandBB()


        //======================================================================================
        public void SaveBandA()
        {
            checkBoxIICPTT.Checked = false; // ke9ns add

            if (SaveBandAA() == false) // get bandstack Locking info
            {
                return; // prior bandstack has a problem so dont try to save.
            }

            // Used in Bandstacking algorithm
            double freq = Math.Round(VFOAFreq, 6);

            string filter = rx1_filter.ToString() + filter2[iii]; // ke9ns mod:  (add filter2 for bandstack locking)

            Debug.WriteLine("filterA save " + filter);

            string mode = rx1_dsp_mode.ToString();

            switch (rx1_band)
            {
                case Band.B160M:
                    if (freq >= 1.8 && freq < 2.0)
                        DB.SaveBandStack("160M", band_160m_index, mode, filter, freq);
                    break;
                case Band.B80M:
                    if (freq >= 3.5 && freq < 4.0)
                        DB.SaveBandStack("80M", band_80m_index, mode, filter, freq);
                    break;
                case Band.B60M:

                    if (extended || (current_region != FRSRegion.US))
                    {
                        if (freq >= 5.25 && freq < 5.45) //   if (freq >= 5.0 && freq < 6.0)
                        {
                            switch (current_region)
                            {
                                case FRSRegion.UK_Plus:     // do not save 60m bandstack changes for non-channelized EU using band segments

                                    break;
                                default:
                                    DB.SaveBandStack("60M", band_60m_index, mode, filter, freq);
                                    break;
                            }
                        }
                    }
                    else
                    {
                        if (RX1IsOn60mChannel())
                            DB.SaveBandStack("60M", band_60m_index, mode, filter, freq);
                    }
                    break;
                case Band.B40M:
                    if (freq >= 7.0 && freq < 7.3)
                        DB.SaveBandStack("40M", band_40m_index, mode, filter, freq);
                    break;
                case Band.B30M:
                    if (freq >= 10.1 && freq < 10.15)
                        DB.SaveBandStack("30M", band_30m_index, mode, filter, freq);
                    break;
                case Band.B20M:
                    if (freq >= 14.0 && freq < 14.350)
                        DB.SaveBandStack("20M", band_20m_index, mode, filter, freq);
                    break;
                case Band.B17M:
                    if (freq >= 18.068 && freq < 18.168)
                        DB.SaveBandStack("17M", band_17m_index, mode, filter, freq);
                    break;
                case Band.B15M:
                    if (freq >= 21.0 && freq < 21.45)
                        DB.SaveBandStack("15M", band_15m_index, mode, filter, freq);
                    break;
                case Band.B12M:
                    if (freq >= 24.890 && freq < 24.990)
                        DB.SaveBandStack("12M", band_12m_index, mode, filter, freq);
                    break;
                case Band.B10M:
                    if (freq >= 28.0 && freq < 29.7)
                        DB.SaveBandStack("10M", band_10m_index, mode, filter, freq);
                    break;
                case Band.B6M:
                    if (freq >= 50.0 && freq < 54.0)
                        DB.SaveBandStack("6M", band_6m_index, mode, filter, freq);
                    break;
                case Band.B2M:
                    if (freq >= 134.0 && freq < 163.0) // ke9ns test was 144.0 and 148.0 .217
                        DB.SaveBandStack("2M", band_2m_index, mode, filter, freq);
                    break;
                case Band.WWV:
                    if (freq == 2.5 || freq == 5.0 || freq == 10.0 || freq == 15.0 ||
                        freq == 20.0 || freq == 25.0 || freq == 3.33 || freq == 7.85 || freq == 14.67)  // ke9ns mod added 25mhz
                        DB.SaveBandStack("WWV", band_wwv_index, mode, filter, freq);
                    break;
                case Band.GEN:
                    DB.SaveBandStack("GEN", band_gen_index, mode, filter, freq);
                    break;


                case Band.VHF0:
                    if (freq >= xvtrForm.GetBegin(0) && freq <= xvtrForm.GetEnd(0))
                        DB.SaveBandStack("VHF0", band_vhf0_index, mode, filter, freq);
                    break;
                case Band.VHF1:
                    if (freq >= xvtrForm.GetBegin(1) && freq <= xvtrForm.GetEnd(1))
                        DB.SaveBandStack("VHF1", band_vhf1_index, mode, filter, freq);
                    break;
                case Band.VHF2:

                    if (freq >= xvtrForm.GetBegin(2) && freq <= xvtrForm.GetEnd(2)) // displays as 1240,001 in europe or 1240.001 in US
                        DB.SaveBandStack("VHF2", band_vhf2_index, mode, filter, freq);
                    break;
                case Band.VHF3:
                    if (freq >= xvtrForm.GetBegin(3) && freq <= xvtrForm.GetEnd(3))
                        DB.SaveBandStack("VHF3", band_vhf3_index, mode, filter, freq);
                    break;
                case Band.VHF4:
                    if (freq >= xvtrForm.GetBegin(4) && freq <= xvtrForm.GetEnd(4))
                        DB.SaveBandStack("VHF4", band_vhf4_index, mode, filter, freq);
                    break;
                case Band.VHF5:
                    if (freq >= xvtrForm.GetBegin(5) && freq <= xvtrForm.GetEnd(5))
                        DB.SaveBandStack("VHF5", band_vhf5_index, mode, filter, freq);
                    break;
                case Band.VHF6:
                    if (freq >= xvtrForm.GetBegin(6) && freq <= xvtrForm.GetEnd(6))
                        DB.SaveBandStack("VHF6", band_vhf6_index, mode, filter, freq);
                    break;
                case Band.VHF7:
                    if (freq >= xvtrForm.GetBegin(7) && freq <= xvtrForm.GetEnd(7))
                        DB.SaveBandStack("VHF7", band_vhf7_index, mode, filter, freq);
                    break;
                case Band.VHF8:
                    if (freq >= xvtrForm.GetBegin(8) && freq <= xvtrForm.GetEnd(8))
                        DB.SaveBandStack("VHF8", band_vhf8_index, mode, filter, freq);
                    break;
                case Band.VHF9:
                    if (freq >= xvtrForm.GetBegin(9) && freq <= xvtrForm.GetEnd(9))
                        DB.SaveBandStack("VHF9", band_vhf9_index, mode, filter, freq);
                    break;
                case Band.VHF10:
                    if (freq >= xvtrForm.GetBegin(10) && freq <= xvtrForm.GetEnd(10))
                        DB.SaveBandStack("VHF10", band_vhf10_index, mode, filter, freq);
                    break;
                case Band.VHF11:
                    if (freq >= xvtrForm.GetBegin(11) && freq <= xvtrForm.GetEnd(11))
                        DB.SaveBandStack("VHF11", band_vhf11_index, mode, filter, freq);
                    break;
                case Band.VHF12:
                    if (freq >= xvtrForm.GetBegin(12) && freq <= xvtrForm.GetEnd(12))
                        DB.SaveBandStack("VHF12", band_vhf12_index, mode, filter, freq);
                    break;
                case Band.VHF13:
                    if (freq >= xvtrForm.GetBegin(13) && freq <= xvtrForm.GetEnd(13))
                        DB.SaveBandStack("VHF13", band_vhf13_index, mode, filter, freq);
                    break;



                case Band.BLMF:                                                                     // ke9ns add down below vhf
                    if (freq >= 0.20 && freq < 1.80)
                        DB.SaveBandStack("LMF", band_LMF_index, mode, filter, freq);
                    break;
                case Band.B120M:
                    if (freq >= 2.0 && freq < 3.0)
                        DB.SaveBandStack("120M", band_120m_index, mode, filter, freq);
                    break;
                case Band.B90M:
                    if (freq >= 3.0 && freq < 3.50)
                        DB.SaveBandStack("90M", band_90m_index, mode, filter, freq);
                    break;
                case Band.B61M:
                    if (freq > 4.00 && freq < 5.25) // was 5.06
                        DB.SaveBandStack("61M", band_61m_index, mode, filter, freq);
                    break;
                case Band.B49M:
                    if (freq >= 5.45 && freq < 7.00)
                        DB.SaveBandStack("49M", band_49m_index, mode, filter, freq);
                    break;
                case Band.B41M:
                    if (freq >= 7.30 && freq < 9.0)
                        DB.SaveBandStack("41M", band_41m_index, mode, filter, freq);
                    break;
                case Band.B31M:
                    if (freq >= 9.0 && freq < 10.0 || freq >= 10.0 && freq < 10.1) // ke9ns mod 
                        DB.SaveBandStack("31M", band_31m_index, mode, filter, freq);
                    break;
                case Band.B25M:
                    if (freq > 10.15 && freq < 13.57)
                        DB.SaveBandStack("25M", band_25m_index, mode, filter, freq);
                    break;
                case Band.B22M:
                    if (freq >= 13.57 && freq < 14.00) // was 13.87
                        DB.SaveBandStack("22M", band_22m_index, mode, filter, freq);
                    break;

                case Band.B19M:
                    if (freq >= 14.350 && freq < 17.0)
                        DB.SaveBandStack("19M", band_19m_index, mode, filter, freq);
                    break;

                case Band.B16M:
                    if (freq >= 17.0 && freq < 18.0)
                        DB.SaveBandStack("16M", band_16m_index, mode, filter, freq);
                    break;
                case Band.B14M:
                    if (freq >= 18.0 && freq < 21.0)
                        DB.SaveBandStack("14M", band_14m_index, mode, filter, freq);
                    break;

                case Band.B13M:
                    if (freq >= 21.00 && freq < 25.0)
                        DB.SaveBandStack("13M", band_13m_index, mode, filter, freq);
                    break;

                case Band.B11M:
                    if (freq >= 25.0 && freq < 28.0)
                        DB.SaveBandStack("11M", band_11m_index, mode, filter, freq);
                    break;

            } // switch rx1band



        } // saveband


        //======================================================================================
        // ke9ns add .209
        public void SaveBandB()
        {

            // checkBoxIICPTT.Checked = false; // ke9ns add

            if (SaveBandBB() == false) // get bandstack Locking info
            {
                return; // prior bandstack has a problem so dont try to save.
            }

            // Used in Bandstacking algorithm
            double freq = Math.Round(VFOBFreq, 6);

            string filter = rx2_filter.ToString() + filter22[iii2]; // ke9ns mod:  (add filter2 for bandstack locking)

            Debug.WriteLine("filter22");

            string mode = rx2_dsp_mode.ToString();


            switch (rx2_band)
            {
                case Band.B160M:
                    if (freq >= 1.8 && freq < 2.0)
                        DB.SaveBandStack2("160M", band_160m_index, mode, filter, freq);
                    break;
                case Band.B80M:
                    if (freq >= 3.5 && freq < 4.0)
                        DB.SaveBandStack2("80M", band_80m_index, mode, filter, freq);
                    break;
                case Band.B60M:

                    if (extended || (current_region != FRSRegion.US))
                    {
                        if (freq >= 5.25 && freq < 5.45) //   if (freq >= 5.0 && freq < 6.0)
                        {
                            switch (current_region)
                            {
                                case FRSRegion.UK_Plus:     // do not save 60m bandstack changes for non-channelized EU using band segments

                                    break;
                                default:
                                    DB.SaveBandStack2("60M", band_60m_index, mode, filter, freq);
                                    break;
                            }
                        }
                    }
                    else
                    {
                        if (RX2IsOn60mChannel())
                            DB.SaveBandStack2("60M", band_60m_index, mode, filter, freq);
                    }
                    break;
                case Band.B40M:
                    if (freq >= 7.0 && freq < 7.3)
                        DB.SaveBandStack2("40M", band_40m_index, mode, filter, freq);
                    break;
                case Band.B30M:
                    if (freq >= 10.1 && freq < 10.15)
                        DB.SaveBandStack2("30M", band_30m_index, mode, filter, freq);
                    break;
                case Band.B20M:
                    if (freq >= 14.0 && freq < 14.350)
                        DB.SaveBandStack2("20M", band_20m_index, mode, filter, freq);
                    break;
                case Band.B17M:
                    if (freq >= 18.068 && freq < 18.168)
                        DB.SaveBandStack2("17M", band_17m_index, mode, filter, freq);
                    break;
                case Band.B15M:
                    if (freq >= 21.0 && freq < 21.45)
                        DB.SaveBandStack2("15M", band_15m_index, mode, filter, freq);
                    break;
                case Band.B12M:
                    if (freq >= 24.890 && freq < 24.990)
                        DB.SaveBandStack2("12M", band_12m_index, mode, filter, freq);
                    break;
                case Band.B10M:
                    if (freq >= 28.0 && freq < 29.7)
                        DB.SaveBandStack2("10M", band_10m_index, mode, filter, freq);
                    break;
                case Band.B6M:
                    if (freq >= 50.0 && freq < 54.0)
                        DB.SaveBandStack2("6M", band_6m_index, mode, filter, freq);
                    break;
                case Band.B2M:
                    if (freq >= 134.0 && freq < 163.0) // ke9ns test was 144.0 and 148.0 .217
                        DB.SaveBandStack2("2M", band_2m_index, mode, filter, freq);
                    break;
                case Band.WWV:
                    if (freq == 2.5 || freq == 5.0 || freq == 10.0 || freq == 15.0 ||
                        freq == 20.0 || freq == 25.0 || freq == 3.33 || freq == 7.85 || freq == 14.67)  // ke9ns mod added 25mhz
                        DB.SaveBandStack2("WWV", band_wwv_index, mode, filter, freq);
                    break;
                case Band.GEN:
                    DB.SaveBandStack2("GEN", band_gen_index, mode, filter, freq);
                    break;


                case Band.VHF0:
                    if (freq >= xvtrForm.GetBegin(0) && freq <= xvtrForm.GetEnd(0))
                        DB.SaveBandStack2("VHF0", band_vhf0_index, mode, filter, freq);
                    break;
                case Band.VHF1:
                    if (freq >= xvtrForm.GetBegin(1) && freq <= xvtrForm.GetEnd(1))
                        DB.SaveBandStack2("VHF1", band_vhf1_index, mode, filter, freq);
                    break;
                case Band.VHF2:

                    if (freq >= xvtrForm.GetBegin(2) && freq <= xvtrForm.GetEnd(2)) // displays as 1240,001 in europe or 1240.001 in US
                        DB.SaveBandStack2("VHF2", band_vhf2_index, mode, filter, freq);
                    break;
                case Band.VHF3:
                    if (freq >= xvtrForm.GetBegin(3) && freq <= xvtrForm.GetEnd(3))
                        DB.SaveBandStack2("VHF3", band_vhf3_index, mode, filter, freq);
                    break;
                case Band.VHF4:
                    if (freq >= xvtrForm.GetBegin(4) && freq <= xvtrForm.GetEnd(4))
                        DB.SaveBandStack2("VHF4", band_vhf4_index, mode, filter, freq);
                    break;
                case Band.VHF5:
                    if (freq >= xvtrForm.GetBegin(5) && freq <= xvtrForm.GetEnd(5))
                        DB.SaveBandStack2("VHF5", band_vhf5_index, mode, filter, freq);
                    break;
                case Band.VHF6:
                    if (freq >= xvtrForm.GetBegin(6) && freq <= xvtrForm.GetEnd(6))
                        DB.SaveBandStack2("VHF6", band_vhf6_index, mode, filter, freq);
                    break;
                case Band.VHF7:
                    if (freq >= xvtrForm.GetBegin(7) && freq <= xvtrForm.GetEnd(7))
                        DB.SaveBandStack2("VHF7", band_vhf7_index, mode, filter, freq);
                    break;
                case Band.VHF8:
                    if (freq >= xvtrForm.GetBegin(8) && freq <= xvtrForm.GetEnd(8))
                        DB.SaveBandStack2("VHF8", band_vhf8_index, mode, filter, freq);
                    break;
                case Band.VHF9:
                    if (freq >= xvtrForm.GetBegin(9) && freq <= xvtrForm.GetEnd(9))
                        DB.SaveBandStack2("VHF9", band_vhf9_index, mode, filter, freq);
                    break;
                case Band.VHF10:
                    if (freq >= xvtrForm.GetBegin(10) && freq <= xvtrForm.GetEnd(10))
                        DB.SaveBandStack2("VHF10", band_vhf10_index, mode, filter, freq);
                    break;
                case Band.VHF11:
                    if (freq >= xvtrForm.GetBegin(11) && freq <= xvtrForm.GetEnd(11))
                        DB.SaveBandStack2("VHF11", band_vhf11_index, mode, filter, freq);
                    break;
                case Band.VHF12:
                    if (freq >= xvtrForm.GetBegin(12) && freq <= xvtrForm.GetEnd(12))
                        DB.SaveBandStack2("VHF12", band_vhf12_index, mode, filter, freq);
                    break;
                case Band.VHF13:
                    if (freq >= xvtrForm.GetBegin(13) && freq <= xvtrForm.GetEnd(13))
                        DB.SaveBandStack2("VHF13", band_vhf13_index, mode, filter, freq);
                    break;



                case Band.BLMF:                                                                     // ke9ns add down below vhf
                    if (freq >= 0.20 && freq < 1.80)
                        DB.SaveBandStack2("LMF", band_LMF_index, mode, filter, freq);
                    break;
                case Band.B120M:
                    if (freq >= 2.0 && freq < 3.0)
                        DB.SaveBandStack2("120M", band_120m_index, mode, filter, freq);
                    break;
                case Band.B90M:
                    if (freq >= 3.0 && freq < 3.50)
                        DB.SaveBandStack2("90M", band_90m_index, mode, filter, freq);
                    break;
                case Band.B61M:
                    if (freq > 4.00 && freq < 5.25) // was 5.06
                        DB.SaveBandStack2("61M", band_61m_index, mode, filter, freq);
                    break;
                case Band.B49M:
                    if (freq >= 5.45 && freq < 7.00)
                        DB.SaveBandStack2("49M", band_49m_index, mode, filter, freq);
                    break;
                case Band.B41M:
                    if (freq >= 7.30 && freq < 9.0)
                        DB.SaveBandStack2("41M", band_41m_index, mode, filter, freq);
                    break;
                case Band.B31M:
                    if (freq >= 9.0 && freq < 10.0 || freq >= 10.0 && freq < 10.1) // ke9ns mod 
                        DB.SaveBandStack2("31M", band_31m_index, mode, filter, freq);
                    break;
                case Band.B25M:
                    if (freq > 10.15 && freq < 13.57)
                        DB.SaveBandStack2("25M", band_25m_index, mode, filter, freq);
                    break;
                case Band.B22M:
                    if (freq >= 13.57 && freq < 14.00) // was 13.87
                        DB.SaveBandStack2("22M", band_22m_index, mode, filter, freq);
                    break;

                case Band.B19M:
                    if (freq >= 14.350 && freq < 17.0)
                        DB.SaveBandStack2("19M", band_19m_index, mode, filter, freq);
                    break;

                case Band.B16M:
                    if (freq >= 17.0 && freq < 18.0)
                        DB.SaveBandStack2("16M", band_16m_index, mode, filter, freq);
                    break;
                case Band.B14M:
                    if (freq >= 18.0 && freq < 21.0)
                        DB.SaveBandStack2("14M", band_14m_index, mode, filter, freq);
                    break;

                case Band.B13M:
                    if (freq >= 21.00 && freq < 25.0)
                        DB.SaveBandStack2("13M", band_13m_index, mode, filter, freq);
                    break;

                case Band.B11M:
                    if (freq >= 25.0 && freq < 28.0)
                        DB.SaveBandStack2("11M", band_11m_index, mode, filter, freq);
                    break;

            } // switch rx2band



        } // saveband2



        public void SetBand(string mode, string filter, double freq)
        {
            if (filter.Contains("@"))
            {
                filter = filter.Substring(0, (filter.Length) - 1); // ke9ns add: for bandstack lockout
            }
            if (freq > 9999.999999) // .228
            {
                if (setupForm != null && setupForm.chkVFOLargeWindow.Checked == false) setupForm.chkVFOLargeWindow.Checked = true;
            }

            // Set mode, filter, and frequency according to passed parameters
            RX1DSPMode = (DSPMode)Enum.Parse(typeof(DSPMode), mode, true);

            if (rx1_dsp_mode != DSPMode.DRM && rx1_dsp_mode != DSPMode.SPEC)
            {
                RX1Filter = (Filter)Enum.Parse(typeof(Filter), filter, true);
            }

            VFOAFreq = freq;

            tempVFOAFreq = VFOAFreq; // ke9ns add  CTUN operation changed freq so update temp value

            if (SpotForm != null) // ke9ns add .157
            {
                if (SpotControl.SP_Active > 2)
                {
                    SpotForm.processTCPMessage(); // upate the spotter that you changed bands
                }

            }

            // voacap

        } // setband

        // ke9ns add .206 band stack to vfoB
        public void SetBand2(string mode, string filter, double freq)
        {
            if (filter.Contains("@"))
            {
                filter = filter.Substring(0, (filter.Length) - 1); // ke9ns add: for bandstack lockout
            }

            if (freq > 9999.999999) // .228
            {
                if (setupForm != null && setupForm.chkVFOLargeWindow.Checked == false) setupForm.chkVFOLargeWindow.Checked = true;
            }

            // Set mode, filter, and frequency according to passed parameters
            RX2DSPMode = (DSPMode)Enum.Parse(typeof(DSPMode), mode, true);

            if (rx2_dsp_mode != DSPMode.DRM && rx2_dsp_mode != DSPMode.SPEC)
            {
                RX2Filter = (Filter)Enum.Parse(typeof(Filter), filter, true);
            }

            VFOBFreq = freq;

            //  tempVFOAFreq = VFOAFreq; // ke9ns add  CTUN operation changed freq so update temp value

            if (SpotForm != null) // ke9ns add .157
            {
                if (SpotControl.SP_Active > 2)
                {
                    SpotForm.processTCPMessage(); // upate the spotter that you changed bands
                }

            }



        } // setband2




        public int last_MHZ = 0; // ke9ns  used on voacap routine
        public DSPMode last_MODE = DSPMode.LAST;

        private void ChangeTuneStepUp()
        {
            tune_step_index = (tune_step_index + 1) % tune_step_list.Count;
            txtWheelTune.Text = tune_step_list[tune_step_index].Name;

        }

        private void ChangeTuneStepDown()
        {
            tune_step_index = (tune_step_index - 1 + tune_step_list.Count) % tune_step_list.Count;
            txtWheelTune.Text = tune_step_list[tune_step_index].Name;

        }

        private void UpdateBandButtonColors()
        {
            /*SetRX1BandButtonColor(rx1_band);
			SetTXBandButtonColor(tx_band);
			SetRX2BandButtonColor(rx2_band);*/


            SetRX1BandButton(rx1_band);

            if (FWCEEPROM.RX2OK) SetRX2BandButton(rx2_band);
        }

        private void DeselectHF()
        {
            radBand160.Checked = false;
            radBand80.Checked = false;
            radBand60.Checked = false;
            radBand40.Checked = false;
            radBand30.Checked = false;
            radBand20.Checked = false;
            radBand17.Checked = false;
            radBand15.Checked = false;
            radBand12.Checked = false;
            radBand10.Checked = false;
            radBand6.Checked = false;
            radBandWWV.Checked = false;
            radBandGEN.Checked = false;
            radBand2.Checked = false;
        }

        // ke9ns .203
        private void DeselectHFRX2()
        {
            radBand160RX2.Checked = false;
            radBand80RX2.Checked = false;
            radBand60RX2.Checked = false;
            radBand40RX2.Checked = false;
            radBand30RX2.Checked = false;
            radBand20RX2.Checked = false;
            radBand17RX2.Checked = false;
            radBand15RX2.Checked = false;
            radBand12RX2.Checked = false;
            radBand10RX2.Checked = false;
            radBand6RX2.Checked = false;
            radBandWWVRX2.Checked = false;
            radBandGENRX2.Checked = false;
            radBand2RX2.Checked = false;
        }

        private void DeselectGEN()  // ke9ns add
        {
            radBandGN0.Checked = false;
            radBandGN1.Checked = false;
            radBandGN2.Checked = false;
            radBandGN3.Checked = false;
            radBandGN4.Checked = false;
            radBandGN5.Checked = false;
            radBandGN6.Checked = false;
            radBandGN7.Checked = false;
            radBandGN8.Checked = false;
            radBandGN9.Checked = false;
            radBandGN10.Checked = false;
            radBandGN11.Checked = false;
            radBandGN12.Checked = false;
            radBandGN13.Checked = false;

        }
        private void DeselectGENRX2()  // ke9ns add
        {
            radBandGN0RX2.Checked = false;
            radBandGN1RX2.Checked = false;
            radBandGN2RX2.Checked = false;
            radBandGN3RX2.Checked = false;
            radBandGN4RX2.Checked = false;
            radBandGN5RX2.Checked = false;
            radBandGN6RX2.Checked = false;
            radBandGN7RX2.Checked = false;
            radBandGN8RX2.Checked = false;
            radBandGN9RX2.Checked = false;
            radBandGN10RX2.Checked = false;
            radBandGN11RX2.Checked = false;
            radBandGN12RX2.Checked = false;
            radBandGN13RX2.Checked = false;

        }

        private void DeselectVHF()
        {
            radBandVHF0.Checked = false;
            radBandVHF1.Checked = false;
            radBandVHF2.Checked = false;
            radBandVHF3.Checked = false;
            radBandVHF4.Checked = false;
            radBandVHF5.Checked = false;
            radBandVHF6.Checked = false;
            radBandVHF7.Checked = false;
            radBandVHF8.Checked = false;
            radBandVHF9.Checked = false;
            radBandVHF10.Checked = false;
            radBandVHF11.Checked = false;
            radBandVHF12.Checked = false;
            radBandVHF13.Checked = false;

        }

        private void DeselectVHFRX2()
        {
            radBandVHF0RX2.Checked = false;
            radBandVHF1RX2.Checked = false;
            radBandVHF2RX2.Checked = false;
            radBandVHF3RX2.Checked = false;
            radBandVHF4RX2.Checked = false;
            radBandVHF5RX2.Checked = false;
            radBandVHF6RX2.Checked = false;
            radBandVHF7RX2.Checked = false;
            radBandVHF8RX2.Checked = false;
            radBandVHF9RX2.Checked = false;
            radBandVHF10RX2.Checked = false;
            radBandVHF11RX2.Checked = false;
            radBandVHF12RX2.Checked = false;
            radBandVHF13RX2.Checked = false;

        }


        //===================================================





        //====================================================================
        // ke9ns mod  change the band button as you click them for RX1
        private void SetRX1BandButton(Band b)
        {

            SpotControl.VFOLOW = 0;   // ke9ns add default values (used in spot.cs for mapping dx spots)
            SpotControl.VFOHIGH = 1;  // ke9ns add default values

            switch (b)
            {
                case Band.B160M:
                    SpotControl.VFOLOW = 1800000; // ke9ns add
                    SpotControl.VFOHIGH = 2000000;// ke9ns add

                    last_band = "160M"; // ke9ns add
                    radBand160.Checked = true;
                    regBox.Text = band_160m_register.ToString();     // ke9ns add box to show the total # of bankstacks in memory
                    regBox1.Text = (band_160m_index + 1).ToString();  // ke9ns add box to show which bandstack your on
                    DeselectVHF();
                    DeselectGEN(); // ke9ns add
                    break;
                case Band.B80M:
                    last_band = "80M";// ke9ns add
                    SpotControl.VFOLOW = 3500000;
                    SpotControl.VFOHIGH = 4000000;
                    radBand80.Checked = true;
                    regBox.Text = band_80m_register.ToString();
                    regBox1.Text = (band_80m_index + 1).ToString();
                    DeselectVHF();
                    DeselectGEN(); // ke9ns add
                    break;
                case Band.B60M:
                    last_band = "60M";// ke9ns add
                    SpotControl.VFOLOW = 5250000; // was  5000000
                    SpotControl.VFOHIGH = 5450000; // was 6000000
                    radBand60.Checked = true;
                    regBox.Text = band_60m_register.ToString();
                    regBox1.Text = (band_60m_index + 1).ToString();
                    DeselectVHF();
                    DeselectGEN(); // ke9ns add
                    break;
                case Band.B40M:
                    last_band = "40M";// ke9ns add
                    SpotControl.VFOLOW = 7000000;
                    SpotControl.VFOHIGH = 7300000;
                    radBand40.Checked = true;
                    regBox.Text = band_40m_register.ToString();
                    regBox1.Text = (band_40m_index + 1).ToString();
                    DeselectVHF();
                    DeselectGEN(); // ke9ns add
                    break;
                case Band.B30M:
                    last_band = "30M";// ke9ns add
                    SpotControl.VFOLOW = 10100000;
                    SpotControl.VFOHIGH = 10150000;
                    radBand30.Checked = true;
                    regBox.Text = band_30m_register.ToString();
                    regBox1.Text = (band_30m_index + 1).ToString();
                    DeselectVHF();
                    DeselectGEN(); // ke9ns add
                    break;
                case Band.B20M:
                    last_band = "20M";// ke9ns add
                    SpotControl.VFOLOW = 14000000;
                    SpotControl.VFOHIGH = 14350000;
                    radBand20.Checked = true;
                    regBox.Text = band_20m_register.ToString();
                    regBox1.Text = (band_20m_index + 1).ToString();
                    DeselectVHF();
                    DeselectGEN(); // ke9ns add
                    break;
                case Band.B17M:
                    last_band = "17M";// ke9ns add
                    SpotControl.VFOLOW = 18000000; // 18.068
                    SpotControl.VFOHIGH = 18200000; // 18.168
                    radBand17.Checked = true;
                    regBox.Text = band_17m_register.ToString();
                    regBox1.Text = (band_17m_index + 1).ToString();
                    DeselectVHF();
                    DeselectGEN(); // ke9ns add
                    break;
                case Band.B15M:
                    last_band = "15M";// ke9ns add
                    SpotControl.VFOLOW = 21000000; // 
                    SpotControl.VFOHIGH = 21450000; // 
                    radBand15.Checked = true;
                    regBox.Text = band_15m_register.ToString();
                    regBox1.Text = (band_15m_index + 1).ToString();
                    DeselectVHF();
                    DeselectGEN(); // ke9ns add
                    break;
                case Band.B12M:
                    last_band = "12M";// ke9ns add
                    SpotControl.VFOLOW = 24890000; // 24.89
                    SpotControl.VFOHIGH = 24990000; // 24.99
                    radBand12.Checked = true;
                    regBox.Text = band_12m_register.ToString();
                    regBox1.Text = (band_12m_index + 1).ToString();
                    DeselectVHF();
                    DeselectGEN(); // ke9ns add
                    break;
                case Band.B10M:
                    last_band = "10M";// ke9ns add
                    SpotControl.VFOLOW = 28000000; // 
                    SpotControl.VFOHIGH = 30000000; // 
                    radBand10.Checked = true;
                    regBox.Text = band_10m_register.ToString();
                    regBox1.Text = (band_10m_index + 1).ToString();
                    DeselectVHF();
                    DeselectGEN(); // ke9ns add
                    break;
                case Band.B6M:
                    last_band = "6M";// ke9ns add
                    SpotControl.VFOLOW = 50000000; // 
                    SpotControl.VFOHIGH = 54000000; //
                    radBand6.Checked = true;
                    regBox.Text = band_6m_register.ToString();
                    regBox1.Text = (band_6m_index + 1).ToString();
                    DeselectVHF();
                    DeselectGEN(); // ke9ns add
                    break;
                case Band.B2M:
                    //  last_band = "2M";// ke9ns add // ke9ns mod
                    //  SpotControl.VFOLOW = 144000000; // 
                    //  SpotControl.VFOHIGH = 146000000; // 
                    //  radBand2.Checked = true;
                    //   regBox.Text = band_2m_register.ToString();
                    //  regBox1.Text = (band_2m_index + 1).ToString();
                    DeselectVHF();
                    DeselectGEN(); // ke9ns add
                    break;
                case Band.WWV:
                    last_band = "WWV";// ke9ns add
                    radBandWWV.Checked = true;
                    regBox.Text = band_wwv_register.ToString();
                    regBox1.Text = (band_wwv_index + 1).ToString();
                    DeselectVHF();
                    DeselectGEN(); // ke9ns add
                    break;
                case Band.GEN:
                    last_band = "GEN";// ke9ns add
                                      //   Debug.WriteLine("gen pushed");
                    radBandGEN.Checked = true;
                    DeselectVHF();
                    DeselectHF(); // ke9ns add
                    break;


                case Band.VHF0:
                    last_band = "VHF0";// ke9ns add
                    SpotControl.VFOLOW = 144000000; // 
                    SpotControl.VFOHIGH = 146000000; // 
                    radBandVHF0.Checked = true;
                    regBox.Text = band_vhf0_register.ToString();
                    regBox1.Text = (band_vhf0_index + 1).ToString();
                    DeselectHF();
                    DeselectGEN(); // ke9ns add
                    break;
                case Band.VHF1:
                    last_band = "VHF1";// ke9ns add
                    SpotControl.VFOLOW = 430000000; // 
                    SpotControl.VFOHIGH = 445000000; // 
                    radBandVHF1.Checked = true;
                    regBox.Text = band_vhf1_register.ToString();
                    regBox1.Text = (band_vhf1_index + 1).ToString();
                    DeselectHF();
                    DeselectGEN(); // ke9ns add
                    break;
                case Band.VHF2:
                    last_band = "VHF2";// ke9ns add
                    SpotControl.VFOLOW = 445000000; // 
                    SpotControl.VFOHIGH = 990000000; //
                    radBandVHF2.Checked = true;
                    regBox.Text = band_vhf2_register.ToString();
                    regBox1.Text = (band_vhf2_index + 1).ToString();
                    DeselectHF();
                    DeselectGEN(); // ke9ns add
                    break;
                case Band.VHF3:
                    last_band = "VHF3";// ke9ns add
                    SpotControl.VFOLOW = 445000000; // 
                    SpotControl.VFOHIGH = 9999999999; //
                    radBandVHF3.Checked = true;
                    regBox.Text = band_vhf3_register.ToString();
                    regBox1.Text = (band_vhf3_index + 1).ToString();
                    DeselectHF();
                    DeselectGEN(); // ke9ns add
                    break;
                case Band.VHF4:
                    last_band = "VHF4";// ke9ns add
                    SpotControl.VFOLOW = 445000000; // 
                    SpotControl.VFOHIGH = 9999999999; //
                    radBandVHF4.Checked = true;
                    regBox.Text = band_vhf4_register.ToString();
                    regBox1.Text = (band_vhf4_index + 1).ToString();
                    DeselectHF();
                    DeselectGEN(); // ke9ns add
                    break;
                case Band.VHF5:
                    last_band = "VHF5";// ke9ns add
                    SpotControl.VFOLOW = 445000000; // 
                    SpotControl.VFOHIGH = 9999999999; //
                    radBandVHF5.Checked = true;
                    regBox.Text = band_vhf5_register.ToString();
                    regBox1.Text = (band_vhf5_index + 1).ToString();
                    DeselectHF();
                    DeselectGEN(); // ke9ns add
                    break;
                case Band.VHF6:
                    last_band = "VHF6";// ke9ns add
                    SpotControl.VFOLOW = 445000000; // 
                    SpotControl.VFOHIGH = 9999999999; //
                    radBandVHF6.Checked = true;
                    regBox.Text = band_vhf6_register.ToString();
                    regBox1.Text = (band_vhf6_index + 1).ToString();
                    DeselectHF();
                    DeselectGEN(); // ke9ns add
                    break;
                case Band.VHF7:
                    last_band = "VHF7";// ke9ns add
                    SpotControl.VFOLOW = 445000000; // 
                    SpotControl.VFOHIGH = 9999999999; //
                    radBandVHF7.Checked = true;
                    regBox.Text = band_vhf7_register.ToString();
                    regBox1.Text = (band_vhf7_index + 1).ToString();
                    DeselectHF();
                    DeselectGEN(); // ke9ns add
                    break;
                case Band.VHF8:
                    last_band = "VHF8";// ke9ns add
                    SpotControl.VFOLOW = 445000000; // 
                    SpotControl.VFOHIGH = 9999999999; //
                    radBandVHF8.Checked = true;
                    regBox.Text = band_vhf8_register.ToString();
                    regBox1.Text = (band_vhf8_index + 1).ToString();
                    DeselectHF();
                    DeselectGEN(); // ke9ns add
                    break;
                case Band.VHF9:
                    last_band = "VHF9";// ke9ns add 
                    SpotControl.VFOLOW = 445000000; // 
                    SpotControl.VFOHIGH = 9999999999; //
                    radBandVHF9.Checked = true;
                    regBox.Text = band_vhf9_register.ToString();
                    regBox1.Text = (band_vhf9_index + 1).ToString();
                    DeselectHF();
                    DeselectGEN(); // ke9ns add
                    break;
                case Band.VHF10:
                    last_band = "VHF10";// ke9ns add
                    SpotControl.VFOLOW = 445000000; // 
                    SpotControl.VFOHIGH = 9999999999; //
                    radBandVHF10.Checked = true;
                    regBox.Text = band_vhf10_register.ToString();
                    regBox1.Text = (band_vhf10_index + 1).ToString();
                    DeselectHF();
                    DeselectGEN(); // ke9ns add
                    break;
                case Band.VHF11:
                    last_band = "VHF11";// ke9ns add
                    SpotControl.VFOLOW = 445000000; // 
                    SpotControl.VFOHIGH = 9999999999; //
                    radBandVHF11.Checked = true;
                    regBox.Text = band_vhf11_register.ToString();
                    regBox1.Text = (band_vhf11_index + 1).ToString();
                    DeselectHF();
                    DeselectGEN(); // ke9ns add
                    break;
                case Band.VHF12:
                    last_band = "VHF12";// ke9ns add
                    SpotControl.VFOLOW = 445000000; // 
                    SpotControl.VFOHIGH = 9999999999; //
                    radBandVHF12.Checked = true;
                    regBox.Text = band_vhf12_register.ToString();
                    regBox1.Text = (band_vhf12_index + 1).ToString();
                    DeselectHF();
                    DeselectGEN(); // ke9ns add
                    break;
                case Band.VHF13:
                    last_band = "VHF13";// ke9ns add 
                    SpotControl.VFOLOW = 445000000; // 
                    SpotControl.VFOHIGH = 9999999999; //
                    radBandVHF13.Checked = true;
                    regBox.Text = band_vhf13_register.ToString();
                    regBox1.Text = (band_vhf13_index + 1).ToString();
                    DeselectHF();
                    DeselectGEN(); // ke9ns add
                    break;


                case Band.BLMF:
                    last_band = "LMF";// ke9ns add
                    radBandGN0.Checked = true;
                    regBox.Text = band_LMF_register.ToString();
                    regBox1.Text = (band_LMF_index + 1).ToString();
                    DeselectHF();
                    DeselectVHF(); // ke9ns add
                    break;
                case Band.B120M:
                    last_band = "120M";// ke9ns add
                    radBandGN1.Checked = true;
                    regBox.Text = band_120m_register.ToString();
                    regBox1.Text = (band_120m_index + 1).ToString();
                    DeselectHF();
                    DeselectVHF(); // ke9ns add
                    break;
                case Band.B90M:
                    last_band = "90M";// ke9ns add
                    radBandGN2.Checked = true;
                    regBox.Text = band_90m_register.ToString();
                    regBox1.Text = (band_90m_index + 1).ToString();
                    DeselectHF();
                    DeselectVHF(); // ke9ns add
                    break;
                case Band.B61M:
                    last_band = "61M";// ke9ns add
                    radBandGN3.Checked = true;
                    regBox.Text = band_61m_register.ToString();
                    regBox1.Text = (band_61m_index + 1).ToString();
                    DeselectHF();
                    DeselectVHF(); // ke9ns add
                    break;
                case Band.B49M:
                    //   Debug.WriteLine("================49==============");
                    last_band = "49M";// ke9ns add
                    radBandGN4.Checked = true;
                    regBox.Text = band_49m_register.ToString();
                    regBox1.Text = (band_49m_index + 1).ToString();
                    DeselectHF();
                    DeselectVHF(); // ke9ns add
                    break;
                case Band.B41M:
                    last_band = "41M";// ke9ns add
                                      //  Debug.WriteLine("================41==============");

                    radBandGN5.Checked = true;
                    regBox.Text = band_41m_register.ToString();
                    regBox1.Text = (band_41m_index + 1).ToString();
                    DeselectHF();
                    DeselectVHF(); // ke9ns add
                    break;
                case Band.B31M:
                    last_band = "31M";// ke9ns add
                    radBandGN6.Checked = true;
                    regBox.Text = band_31m_register.ToString();
                    regBox1.Text = (band_31m_index + 1).ToString();
                    DeselectHF();
                    DeselectVHF(); // ke9ns add
                    break;
                case Band.B25M:
                    last_band = "25M";// ke9ns add
                    radBandGN7.Checked = true;
                    regBox.Text = band_25m_register.ToString();
                    regBox1.Text = (band_25m_index + 1).ToString();
                    DeselectHF();
                    DeselectVHF(); // ke9ns add
                    break;
                case Band.B22M:
                    last_band = "22M";// ke9ns add
                    radBandGN8.Checked = true;
                    regBox.Text = band_22m_register.ToString();
                    regBox1.Text = (band_22m_index + 1).ToString();
                    DeselectHF();
                    DeselectVHF(); // ke9ns add
                    break;
                case Band.B19M:
                    last_band = "19M";// ke9ns add
                    radBandGN9.Checked = true;
                    regBox.Text = band_19m_register.ToString();
                    regBox1.Text = (band_19m_index + 1).ToString();
                    DeselectHF();
                    DeselectVHF(); // ke9ns add
                    break;
                case Band.B16M:
                    last_band = "16M";// ke9ns add
                    radBandGN10.Checked = true;
                    regBox.Text = band_16m_register.ToString();
                    regBox1.Text = (band_16m_index + 1).ToString();
                    DeselectHF();
                    DeselectVHF(); // ke9ns add
                    break;
                case Band.B14M:
                    last_band = "14M";// ke9ns add
                    radBandGN11.Checked = true;
                    regBox.Text = band_14m_register.ToString();
                    regBox1.Text = (band_14m_index + 1).ToString();
                    DeselectHF();
                    DeselectVHF(); // ke9ns add
                    break;
                case Band.B13M:
                    last_band = "13M";// ke9ns add
                    radBandGN12.Checked = true;
                    regBox.Text = band_13m_register.ToString();
                    regBox1.Text = (band_13m_index + 1).ToString();
                    DeselectHF();
                    DeselectVHF(); // ke9ns add
                    break;
                case Band.B11M:
                    last_band = "11M";// ke9ns add
                    radBandGN13.Checked = true;
                    regBox.Text = band_11m_register.ToString();
                    regBox1.Text = (band_11m_index + 1).ToString();
                    DeselectHF();
                    DeselectVHF(); // ke9ns add
                    break;


            }


            StackForm.bandstackupdate(); // ke9ns add update band stack screen 




        } // setrx1 band button
        public string regBox2 = "";
        public string regBox12 = "";

        //====================================================================
        // ke9ns mod  change the band button as you click them for RX2 .209
        private void SetRX2BandButton(Band b)
        {

            switch (b)
            {
                case Band.B160M:
                    last_band2 = "160M"; // ke9ns add
                    radBand160RX2.Checked = true;
                    regBox2 = band_160m_register.ToString();     // ke9ns add box to show the total # of bankstacks in memory
                    regBox12 = (band_160m_index + 1).ToString();  // ke9ns add box to show which bandstack your on
                    DeselectVHFRX2();
                    DeselectGENRX2(); // ke9ns add
                    break;
                case Band.B80M:
                    last_band2 = "80M";// ke9ns add
                    radBand80RX2.Checked = true;
                    regBox2 = band_80m_register.ToString();
                    regBox12 = (band_80m_index + 1).ToString();
                    DeselectVHFRX2();
                    DeselectGENRX2(); // ke9ns add
                    break;
                case Band.B60M:
                    last_band2 = "60M";// ke9ns add
                    radBand60RX2.Checked = true;
                    regBox2 = band_60m_register.ToString();
                    regBox12 = (band_60m_index + 1).ToString();
                    DeselectVHFRX2();
                    DeselectGENRX2(); // ke9ns add
                    break;
                case Band.B40M:
                    last_band2 = "40M";// ke9ns add
                    radBand40RX2.Checked = true;
                    regBox2 = band_40m_register.ToString();
                    regBox12 = (band_40m_index + 1).ToString();
                    DeselectVHFRX2();
                    DeselectGENRX2(); // ke9ns add
                    break;
                case Band.B30M:
                    last_band2 = "30M";// ke9ns add
                    radBand30RX2.Checked = true;
                    regBox2 = band_30m_register.ToString();
                    regBox12 = (band_30m_index + 1).ToString();
                    DeselectVHFRX2();
                    DeselectGENRX2(); // ke9ns add
                    break;
                case Band.B20M:
                    last_band2 = "20M";// ke9ns add
                    radBand20RX2.Checked = true;
                    regBox2 = band_20m_register.ToString();
                    regBox12 = (band_20m_index + 1).ToString();
                    DeselectVHFRX2();
                    DeselectGENRX2(); // ke9ns add
                    break;
                case Band.B17M:
                    last_band2 = "17M";// ke9ns add
                    radBand17RX2.Checked = true;
                    regBox2 = band_17m_register.ToString();
                    regBox12 = (band_17m_index + 1).ToString();
                    DeselectVHFRX2();
                    DeselectGENRX2(); // ke9ns add
                    break;
                case Band.B15M:
                    last_band2 = "15M";// ke9ns add
                    radBand15RX2.Checked = true;
                    regBox2 = band_15m_register.ToString();
                    regBox12 = (band_15m_index + 1).ToString();
                    DeselectVHFRX2();
                    DeselectGENRX2(); // ke9ns add
                    break;
                case Band.B12M:
                    last_band2 = "12M";// ke9ns add
                    SpotControl.VFOLOW = 24890000; // 24.89
                    SpotControl.VFOHIGH = 24990000; // 24.99
                    radBand12RX2.Checked = true;
                    regBox2 = band_12m_register.ToString();
                    regBox12 = (band_12m_index + 1).ToString();
                    DeselectVHFRX2();
                    DeselectGENRX2(); // ke9ns add
                    break;
                case Band.B10M:
                    last_band2 = "10M";// ke9ns add
                    radBand10RX2.Checked = true;
                    regBox2 = band_10m_register.ToString();
                    regBox12 = (band_10m_index + 1).ToString();
                    DeselectVHFRX2();
                    DeselectGENRX2(); // ke9ns add
                    break;
                case Band.B6M:
                    last_band2 = "6M";// ke9ns add
                    radBand6RX2.Checked = true;
                    regBox2 = band_6m_register.ToString();
                    regBox12 = (band_6m_index + 1).ToString();
                    DeselectVHFRX2();
                    DeselectGENRX2(); // ke9ns add
                    break;
                case Band.B2M:
                    //  last_band2 = "2M";// ke9ns add // ke9ns mod
                    //  radBand2RX2.Checked = true;
                    //   regBox2  = band_2m_register.ToString();
                    //  regBox12  = (band_2m_index + 1).ToString();
                    DeselectVHFRX2();
                    DeselectGENRX2(); // ke9ns add
                    break;
                case Band.WWV:
                    last_band2 = "WWV";// ke9ns add
                    radBandWWVRX2.Checked = true;
                    regBox2 = band_wwv_register.ToString();
                    regBox12 = (band_wwv_index + 1).ToString();
                    DeselectVHFRX2();
                    DeselectGENRX2(); // ke9ns add
                    break;
                case Band.GEN:
                    last_band2 = "GEN";// ke9ns add
                                       //   Debug.WriteLine("gen pushed");
                    radBandGENRX2.Checked = true;
                    DeselectVHFRX2();
                    DeselectHFRX2(); // ke9ns add
                    break;


                case Band.VHF0:
                    last_band2 = "VHF0";// ke9ns add
                    radBandVHF0RX2.Checked = true;
                    regBox2 = band_vhf0_register.ToString();
                    regBox12 = (band_vhf0_index + 1).ToString();
                    DeselectHFRX2();
                    DeselectGENRX2(); // ke9ns add
                    break;
                case Band.VHF1:
                    last_band2 = "VHF1";// ke9ns add
                    radBandVHF1RX2.Checked = true;
                    regBox2 = band_vhf1_register.ToString();
                    regBox12 = (band_vhf1_index + 1).ToString();
                    DeselectHFRX2();
                    DeselectGENRX2(); // ke9ns add
                    break;
                case Band.VHF2:
                    last_band2 = "VHF2";// ke9ns add
                    radBandVHF2RX2.Checked = true;
                    regBox2 = band_vhf2_register.ToString();
                    regBox12 = (band_vhf2_index + 1).ToString();
                    DeselectHFRX2();
                    DeselectGENRX2(); // ke9ns add
                    break;
                case Band.VHF3:
                    last_band2 = "VHF3";// ke9ns add
                    radBandVHF3RX2.Checked = true;
                    regBox2 = band_vhf3_register.ToString();
                    regBox12 = (band_vhf3_index + 1).ToString();
                    DeselectHFRX2();
                    DeselectGENRX2(); // ke9ns add
                    break;
                case Band.VHF4:
                    last_band2 = "VHF4";// ke9ns add
                    radBandVHF4RX2.Checked = true;
                    regBox2 = band_vhf4_register.ToString();
                    regBox12 = (band_vhf4_index + 1).ToString();
                    DeselectHFRX2();
                    DeselectGENRX2(); // ke9ns add
                    break;
                case Band.VHF5:
                    last_band2 = "VHF5";// ke9ns add
                    radBandVHF5RX2.Checked = true;
                    regBox2 = band_vhf5_register.ToString();
                    regBox12 = (band_vhf5_index + 1).ToString();
                    DeselectHFRX2();
                    DeselectGENRX2(); // ke9ns add
                    break;
                case Band.VHF6:
                    last_band2 = "VHF6";// ke9ns add
                    radBandVHF6RX2.Checked = true;
                    regBox2 = band_vhf6_register.ToString();
                    regBox12 = (band_vhf6_index + 1).ToString();
                    DeselectHFRX2();
                    DeselectGENRX2(); // ke9ns add
                    break;
                case Band.VHF7:
                    last_band2 = "VHF7";// ke9ns add
                    radBandVHF7RX2.Checked = true;
                    regBox2 = band_vhf7_register.ToString();
                    regBox12 = (band_vhf7_index + 1).ToString();
                    DeselectHFRX2();
                    DeselectGENRX2(); // ke9ns add
                    break;
                case Band.VHF8:
                    last_band2 = "VHF8";// ke9ns add
                    radBandVHF8RX2.Checked = true;
                    regBox2 = band_vhf8_register.ToString();
                    regBox12 = (band_vhf8_index + 1).ToString();
                    DeselectHFRX2();
                    DeselectGENRX2(); // ke9ns add
                    break;
                case Band.VHF9:
                    last_band2 = "VHF9";// ke9ns add 
                    radBandVHF9RX2.Checked = true;
                    regBox2 = band_vhf9_register.ToString();
                    regBox12 = (band_vhf9_index + 1).ToString();
                    DeselectHFRX2();
                    DeselectGENRX2(); // ke9ns add
                    break;
                case Band.VHF10:
                    last_band2 = "VHF10";// ke9ns add
                    radBandVHF10RX2.Checked = true;
                    regBox2 = band_vhf10_register.ToString();
                    regBox12 = (band_vhf10_index + 1).ToString();
                    DeselectHFRX2();
                    DeselectGENRX2(); // ke9ns add
                    break;
                case Band.VHF11:
                    last_band2 = "VHF11";// ke9ns add
                    radBandVHF11RX2.Checked = true;
                    regBox2 = band_vhf11_register.ToString();
                    regBox12 = (band_vhf11_index + 1).ToString();
                    DeselectHFRX2();
                    DeselectGENRX2(); // ke9ns add
                    break;
                case Band.VHF12:
                    last_band2 = "VHF12";// ke9ns add
                    radBandVHF12RX2.Checked = true;
                    regBox2 = band_vhf12_register.ToString();
                    regBox12 = (band_vhf12_index + 1).ToString();
                    DeselectHFRX2();
                    DeselectGENRX2(); // ke9ns add
                    break;
                case Band.VHF13:
                    last_band2 = "VHF13";// ke9ns add 
                    radBandVHF13RX2.Checked = true;
                    regBox2 = band_vhf13_register.ToString();
                    regBox12 = (band_vhf13_index + 1).ToString();
                    DeselectHFRX2();
                    DeselectGENRX2(); // ke9ns add
                    break;


                case Band.BLMF:
                    last_band2 = "LMF";// ke9ns add
                    radBandGN0RX2.Checked = true;
                    regBox2 = band_LMF_register.ToString();
                    regBox12 = (band_LMF_index + 1).ToString();
                    DeselectHFRX2();
                    DeselectVHFRX2(); // ke9ns add
                    break;
                case Band.B120M:
                    last_band2 = "120M";// ke9ns add
                    radBandGN1RX2.Checked = true;
                    regBox2 = band_120m_register.ToString();
                    regBox12 = (band_120m_index + 1).ToString();
                    DeselectHFRX2();
                    DeselectVHFRX2(); // ke9ns add
                    break;
                case Band.B90M:
                    last_band2 = "90M";// ke9ns add
                    radBandGN2RX2.Checked = true;
                    regBox2 = band_90m_register.ToString();
                    regBox12 = (band_90m_index + 1).ToString();
                    DeselectHFRX2();
                    DeselectVHFRX2(); // ke9ns add
                    break;
                case Band.B61M:
                    last_band2 = "61M";// ke9ns add
                    radBandGN3RX2.Checked = true;
                    regBox2 = band_61m_register.ToString();
                    regBox12 = (band_61m_index + 1).ToString();
                    DeselectHFRX2();
                    DeselectVHFRX2(); // ke9ns add
                    break;
                case Band.B49M:
                    //   Debug.WriteLine("================49==============");
                    last_band2 = "49M";// ke9ns add
                    radBandGN4RX2.Checked = true;
                    regBox2 = band_49m_register.ToString();
                    regBox12 = (band_49m_index + 1).ToString();
                    DeselectHFRX2();
                    DeselectVHFRX2(); // ke9ns add
                    break;
                case Band.B41M:
                    last_band2 = "41M";// ke9ns add
                                       //  Debug.WriteLine("================41==============");

                    radBandGN5RX2.Checked = true;
                    regBox2 = band_41m_register.ToString();
                    regBox12 = (band_41m_index + 1).ToString();
                    DeselectHFRX2();
                    DeselectVHFRX2(); // ke9ns add
                    break;
                case Band.B31M:
                    last_band2 = "31M";// ke9ns add
                    radBandGN6RX2.Checked = true;
                    regBox2 = band_31m_register.ToString();
                    regBox12 = (band_31m_index + 1).ToString();
                    DeselectHFRX2();
                    DeselectVHFRX2(); // ke9ns add
                    break;
                case Band.B25M:
                    last_band2 = "25M";// ke9ns add
                    radBandGN7RX2.Checked = true;
                    regBox2 = band_25m_register.ToString();
                    regBox12 = (band_25m_index + 1).ToString();
                    DeselectHFRX2();
                    DeselectVHFRX2(); // ke9ns add
                    break;
                case Band.B22M:
                    last_band2 = "22M";// ke9ns add
                    radBandGN8RX2.Checked = true;
                    regBox2 = band_22m_register.ToString();
                    regBox12 = (band_22m_index + 1).ToString();
                    DeselectHFRX2();
                    DeselectVHFRX2(); // ke9ns add
                    break;
                case Band.B19M:
                    last_band2 = "19M";// ke9ns add
                    radBandGN9RX2.Checked = true;
                    regBox2 = band_19m_register.ToString();
                    regBox12 = (band_19m_index + 1).ToString();
                    DeselectHFRX2();
                    DeselectVHFRX2(); // ke9ns add
                    break;
                case Band.B16M:
                    last_band2 = "16M";// ke9ns add
                    radBandGN10RX2.Checked = true;
                    regBox2 = band_16m_register.ToString();
                    regBox12 = (band_16m_index + 1).ToString();
                    DeselectHFRX2();
                    DeselectVHFRX2(); // ke9ns add
                    break;
                case Band.B14M:
                    last_band2 = "14M";// ke9ns add
                    radBandGN11RX2.Checked = true;
                    regBox2 = band_14m_register.ToString();
                    regBox12 = (band_14m_index + 1).ToString();
                    DeselectHFRX2();
                    DeselectVHFRX2(); // ke9ns add
                    break;
                case Band.B13M:
                    last_band2 = "13M";// ke9ns add
                    radBandGN12RX2.Checked = true;
                    regBox2 = band_13m_register.ToString();
                    regBox12 = (band_13m_index + 1).ToString();
                    DeselectHFRX2();
                    DeselectVHFRX2(); // ke9ns add
                    break;
                case Band.B11M:
                    last_band2 = "11M";// ke9ns add
                    radBandGN13RX2.Checked = true;
                    regBox2 = band_11m_register.ToString();
                    regBox12 = (band_11m_index + 1).ToString();
                    DeselectHFRX2();
                    DeselectVHFRX2(); // ke9ns add
                    break;


            }

            StackForm.bandstackupdate(); // ke9ns add update band stack screen 


        } // setrx2 band button



        private void SetRX1BandButtonColor(Band b)
        {
            // Sets band button color based on passed band.

            /*Button btn = null;
			switch(b)
			{
				case Band.GEN:
					btn = btnBandGEN;
					break;
				case Band.B160M:
					btn = btnBand160;
					break;
				case Band.B80M:
					btn = btnBand80;
					break;
				case Band.B60M:
					btn = btnBand60;
					break;
				case Band.B40M:
					btn = btnBand40;
					break;
				case Band.B30M:
					btn = btnBand30;
					break;
				case Band.B20M:
					btn = btnBand20;
					break;
				case Band.B17M:
					btn = btnBand17;
					break;
				case Band.B15M:
					btn = btnBand15;
					break;
				case Band.B12M:
					btn = btnBand12;
					break;
				case Band.B10M:
					btn = btnBand10;
					break;
				case Band.B6M:
					btn = btnBand6;
					break;
				case Band.B2M:
					btn = btnBand2;
					break;
				case Band.WWV:
					btn = btnBandWWV;
					break;
				case Band.VHF0:
					btn = btnBandVHF0;
					break;
				case Band.VHF1:
					btn = btnBandVHF1;
					break;
				case Band.VHF2:
					btn = btnBandVHF2;
					break;
				case Band.VHF3:
					btn = btnBandVHF3;
					break;
				case Band.VHF4:
					btn = btnBandVHF4;
					break;
				case Band.VHF5:
					btn = btnBandVHF5;
					break;
				case Band.VHF6:
					btn = btnBandVHF6;
					break;
				case Band.VHF7:
					btn = btnBandVHF7;
					break;
				case Band.VHF8:
					btn = btnBandVHF8;
					break;
				case Band.VHF9:
					btn = btnBandVHF9;
					break;
				case Band.VHF10:
					btn = btnBandVHF10;
					break;
				case Band.VHF11:
					btn = btnBandVHF11;
					break;
				case Band.VHF12:
					btn = btnBandVHF12;
					break;
				case Band.VHF13:
					btn = btnBandVHF13;
					break;
			}

			foreach(Button b2 in panelBandHF.Controls)
			{
				if(b2 == btn)
				{
					b2.BackColor = rx1_band_color;
				}
				else
				{
					if(b2.BackColor == rx1_band_color)
						b2.BackColor = SystemColors.Control;
				}
			}

			foreach(Button b2 in panelBandVHF.Controls)
			{
				if(b2 == btn)
				{
					b2.BackColor = rx1_band_color;
				}
				else
				{
					if(b2.BackColor == rx1_band_color)
						b2.BackColor = SystemColors.Control;
				}
			}*/
        }

        private void SetRX2BandButtonColor(Band b)
        {
            /*// Sets band button color based on passed band.
			if(!rx2_enabled) b = Band.FIRST;
			Button btn = null;
			switch(b)
			{
				case Band.GEN:
					btn = btnBandGEN;
					break;
				case Band.B160M:
					btn = btnBand160;
					break;
				case Band.B80M:
					btn = btnBand80;
					break;
				case Band.B60M:
					btn = btnBand60;
					break;
				case Band.B40M:
					btn = btnBand40;
					break;
				case Band.B30M:
					btn = btnBand30;
					break;
				case Band.B20M:
					btn = btnBand20;
					break;
				case Band.B17M:
					btn = btnBand17;
					break;
				case Band.B15M:
					btn = btnBand15;
					break;
				case Band.B12M:
					btn = btnBand12;
					break;
				case Band.B10M:
					btn = btnBand10;
					break;
				case Band.B6M:
					btn = btnBand6;
					break;
				case Band.B2M:
					btn = btnBand2;
					break;
				case Band.WWV:
					btn = btnBandWWV;
					break;
				case Band.VHF0:
					btn = btnBandVHF0;
					break;
				case Band.VHF1:
					btn = btnBandVHF1;
					break;
				case Band.VHF2:
					btn = btnBandVHF2;
					break;
				case Band.VHF3:
					btn = btnBandVHF3;
					break;
				case Band.VHF4:
					btn = btnBandVHF4;
					break;
				case Band.VHF5:
					btn = btnBandVHF5;
					break;
				case Band.VHF6:
					btn = btnBandVHF6;
					break;
				case Band.VHF7:
					btn = btnBandVHF7;
					break;
				case Band.VHF8:
					btn = btnBandVHF8;
					break;
				case Band.VHF9:
					btn = btnBandVHF9;
					break;
				case Band.VHF10:
					btn = btnBandVHF10;
					break;
				case Band.VHF11:
					btn = btnBandVHF11;
					break;
				case Band.VHF12:
					btn = btnBandVHF12;
					break;
				case Band.VHF13:
					btn = btnBandVHF13;
					break;
			}

			foreach(Button b2 in panelBandHF.Controls)
			{
				if(b2 == btn && b2.BackColor != rx1_band_color && b2.BackColor != tx_band_color)
				{
					b2.BackColor = rx2_band_color;
				}
				else
				{
					if(b2.BackColor == rx2_band_color)
						b2.BackColor = SystemColors.Control;
				}
			}

			foreach(Button b2 in panelBandVHF.Controls)
			{
				if(b2 == btn && b2.BackColor != rx1_band_color && b2.BackColor != tx_band_color)
				{
					b2.BackColor = rx2_band_color;
				}
				else
				{
					if(b2.BackColor == rx2_band_color)
						b2.BackColor = SystemColors.Control;
				}
			}
			/*if(b < Band.VHF0)
			{
//				if(!grpBandHF.Visible)
//				{
//					grpBandHF.Visible = true;
//					grpBandVHF.Visible = false;
//				}

				foreach(Button b2 in grpBandVHF.Controls)
					b2.BackColor = SystemColors.Control;

				foreach(Button b2 in grpBandHF.Controls)
				{
					if(b2 == btn && b2.BackColor != rx1_band_color && b2.BackColor != tx_band_color)
					{
						b2.BackColor = rx2_band_color;
					}
					else
					{
						if(b2.BackColor == rx2_band_color)
							b2.BackColor = SystemColors.Control;
					}

//					Color c = SystemColors.Control;
//					if(b2 == btn)
//						c = button_selected_color;
//
//					b2.BackColor = c;
				}
			}
			else
			{
//				if(!grpBandVHF.Visible)
//				{
//					grpBandVHF.Visible = true;
//					grpBandHF.Visible = false;
//				}

				foreach(Button b2 in grpBandHF.Controls)
					b2.BackColor = SystemColors.Control;

				foreach(Button b2 in grpBandVHF.Controls)
				{
					if(b2 == btn && b2.BackColor != rx1_band_color && b2.BackColor != tx_band_color)
					{
						b2.BackColor = rx2_band_color;
					}
					else
					{
						if(b2.BackColor == rx2_band_color)
							b2.BackColor = SystemColors.Control;
					}

//					Color c = SystemColors.Control;
//					if(b2 == btn)
//						c = button_selected_color;
//
//					b2.BackColor = c;
				}
			}*/
        }

        private void SetTXBandButtonColor(Band b)
        {
            /*// Sets band button color based on passed band.

			Button btn = null;
			switch(b)
			{
				case Band.GEN:
					btn = btnBandGEN;
					break;
				case Band.B160M:
					btn = btnBand160;
					break;
				case Band.B80M:
					btn = btnBand80;
					break;
				case Band.B60M:
					btn = btnBand60;
					break;
				case Band.B40M:
					btn = btnBand40;
					break;
				case Band.B30M:
					btn = btnBand30;
					break;
				case Band.B20M:
					btn = btnBand20;
					break;
				case Band.B17M:
					btn = btnBand17;
					break;
				case Band.B15M:
					btn = btnBand15;
					break;
				case Band.B12M:
					btn = btnBand12;
					break;
				case Band.B10M:
					btn = btnBand10;
					break;
				case Band.B6M:
					btn = btnBand6;
					break;
				case Band.B2M:
					btn = btnBand2;
					break;
				case Band.WWV:
					btn = btnBandWWV;
					break;
				case Band.VHF0:
					btn = btnBandVHF0;
					break;
				case Band.VHF1:
					btn = btnBandVHF1;
					break;
				case Band.VHF2:
					btn = btnBandVHF2;
					break;
				case Band.VHF3:
					btn = btnBandVHF3;
					break;
				case Band.VHF4:
					btn = btnBandVHF4;
					break;
				case Band.VHF5:
					btn = btnBandVHF5;
					break;
				case Band.VHF6:
					btn = btnBandVHF6;
					break;
				case Band.VHF7:
					btn = btnBandVHF7;
					break;
				case Band.VHF8:
					btn = btnBandVHF8;
					break;
				case Band.VHF9:
					btn = btnBandVHF9;
					break;
				case Band.VHF10:
					btn = btnBandVHF10;
					break;
				case Band.VHF11:
					btn = btnBandVHF11;
					break;
				case Band.VHF12:
					btn = btnBandVHF12;
					break;
				case Band.VHF13:
					btn = btnBandVHF13;
					break;
			}

			foreach(Button b2 in panelBandHF.Controls)
			{
				if(b2 == btn && b2.BackColor != rx1_band_color)
				{
					b2.BackColor = tx_band_color;
				}
				else
				{
					if(b2.BackColor == tx_band_color)
						b2.BackColor = SystemColors.Control;
				}
			}
			/*if(b < Band.VHF0)
			{
//				if(!grpBandHF.Visible)
//				{
//					grpBandHF.Visible = true;
//					grpBandVHF.Visible = false;
//				}

				foreach(Button b2 in grpBandVHF.Controls)
					b2.BackColor = SystemColors.Control;

				foreach(Button b2 in grpBandHF.Controls)
				{
					if(b2 == btn && b2.BackColor != rx1_band_color)
					{
						b2.BackColor = tx_band_color;
					}
					else
					{
						if(b2.BackColor == tx_band_color)
							b2.BackColor = SystemColors.Control;
					}

//					Color c = SystemColors.Control;
//					if(b2 == btn)
//						c = button_selected_color;
//
//					b2.BackColor = c;
				}
			}
			else
			{
//				if(!grpBandVHF.Visible)
//				{
//					grpBandVHF.Visible = true;
//					grpBandHF.Visible = false;
//				}

				foreach(Button b2 in grpBandHF.Controls)
					b2.BackColor = SystemColors.Control;

				foreach(Button b2 in grpBandVHF.Controls)
				{
					if(b2 == btn && b2.BackColor != rx1_band_color)
					{
						b2.BackColor = tx_band_color;
					}
					else
					{
						if(b2.BackColor == tx_band_color)
							b2.BackColor = SystemColors.Control;
					}

//					Color c = SystemColors.Control;
//					if(b2 == btn)
//						c = button_selected_color;
//
//					b2.BackColor = c;
				}
			}*/
        }

        //=====================================================================================
        private Band BandByFreq(double freq, int xvtr_index, bool tx, FRSRegion region)
        {

            // ke9ns add: A   because both VFOA and VFOB call this routine, but panelBandGN,HF, and VHF are only for VFOA
            // panelBandGNRX2 is for VFOB
            // ke9ns: But freq here is after conversion to 28mhz region (if its an xvtr) xvtrForm.TranslateFreq(VFOAFreq)

            bool A = false;


            if (freq == VFOAFreq)
            {
                Debug.WriteLine("VFO.....A " + freq + " , " + xvtr_index);
                A = true; // 
            }
            else if (freq == VFOBFreq)
            {
                Debug.WriteLine("VFO.....B " + freq + " , " + xvtr_index);
                A = false;
            }
            else if (freq == xvtrForm.TranslateFreq(VFOAFreq)) // .217
            {
                Debug.WriteLine("VFO..xvtr....A " + freq + " , " + xvtr_index + " , " + xvtrForm.TranslateFreq(VFOAFreq));
                A = true; // 
            }
            else if (freq == xvtrForm.TranslateFreq(VFOBFreq))
            {
                Debug.WriteLine("VFO..xvtr....B " + freq + " , " + xvtr_index + " , " + xvtrForm.TranslateFreq(VFOBFreq));
                A = false; // 
            }



            if (xvtr_index >= 0)
            {
                if (A)
                {
                    panelBandGN.Visible = false;
                    panelBandHF.Visible = false;
                    panelBandVHF.Visible = true; // ke9ns add keep VHF panel open when VHF button selected
                }
                else  // vfob below
                {

                    panelBandGNRX2.Visible = false; // .203
                    panelBandHFRX2.Visible = false;
                    if (FWCEEPROM.RX2OK)
                    {
                        if (FWCEEPROM.VUOK) panelBandVHFRX2.Visible = true; // ke9ns add keep VHF panel open when VHF button selected
                    }


                }


                Debug.WriteLine("VHF HERE======>" + (Band)(Band.VHF0 + xvtr_index));

                return (Band)(Band.VHF0 + xvtr_index); // 14 t0 27
            }

            //  Debug.WriteLine("REGION=========================== " + region+ " freq " + freq + " ,VFOA:" + A);

            if (extended && tx) // ke9ns this is for Flex radios with extended MARS capability
            {

                //.248
                //   Debug.WriteLine("EXTENDED========================");
                /*
                                if (Band.BLMF) tx_band = Band.B160M;
                                else if (Band.B120M) tx_band = Band.B160M;
                                else if (Band.B90M) tx_band = Band.B80M;
                                else if (Band.B61M) tx_band = Band.B80M;
                                else if (Band.B49M) tx_band = Band.B60M;
                                else if (Band.B41M) tx_band = Band.B40M;
                                else if (Band.B31M) tx_band = Band.B30M;
                                else if (Band.B25M) tx_band = Band.B20M;
                                else if (Band.B22M) tx_band = Band.B20M;
                                else if (Band.B19M) tx_band = Band.B17M;
                                else if (Band.B16M) tx_band = Band.B17M;
                                else if (Band.B14M) tx_band = Band.B15M;
                                else if (Band.B13M) tx_band = Band.B12M;
                                else if (Band.B11M) tx_band = Band.B10M;
                */

                // ke9ns add
                if (freq >= 0.20 && freq < 1.80)
                {
                    if (A)
                    {
                        panelBandHF.Visible = false;
                        panelBandGN.Visible = true;
                    }
                    else
                    {
                        if (FWCEEPROM.RX2OK)
                        {
                            panelBandHFRX2.Visible = false;
                            if (FWCEEPROM.RX2OK) if (FWCEEPROM.RX2OK) panelBandGNRX2.Visible = true;
                        }
                    }

                    return Band.BLMF;
                    //  return Band.B160M;
                }
                else if (freq == 2.5 || freq == 5.0 || freq == 10.0 || freq == 15.0 ||
                       freq == 20.0 || freq == 25.0 || freq == 3.33 || freq == 7.85 || freq == 14.67)
                {
                    if (A)
                    {
                        panelBandHF.Visible = true;
                        panelBandGN.Visible = false;
                    }
                    else
                    {
                        if (FWCEEPROM.RX2OK)
                        {
                            if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true;
                            panelBandGNRX2.Visible = false;
                        }

                    }

                    return Band.WWV;
                }


                else if (freq >= 2.00 && freq < 3.0)
                {
                    if (A)
                    {
                        panelBandHF.Visible = false;
                        panelBandGN.Visible = true;
                    }
                    else
                    {
                        if (FWCEEPROM.RX2OK)
                        {
                            panelBandHFRX2.Visible = false;
                            if (FWCEEPROM.RX2OK) panelBandGNRX2.Visible = true;
                        }
                    }
                    return Band.B120M;
                    //  return Band.B160M;
                }

                else if (freq >= 3.0 && freq < 3.50)
                {
                    if (A)
                    {
                        panelBandHF.Visible = false;
                        panelBandGN.Visible = true;
                    }
                    else
                    {
                        if (FWCEEPROM.RX2OK)
                        {
                            panelBandHFRX2.Visible = false;
                            if (FWCEEPROM.RX2OK) panelBandGNRX2.Visible = true;
                        }
                    }

                    return Band.B90M;
                    // return Band.B80M;
                }

                else if (freq > 4.00 && freq < 5.25)
                {

                    if (A)
                    {
                        panelBandHF.Visible = false;
                        panelBandGN.Visible = true;
                    }
                    else
                    {
                        if (FWCEEPROM.RX2OK)
                        {
                            panelBandHFRX2.Visible = false;
                            if (FWCEEPROM.RX2OK) panelBandGNRX2.Visible = true;
                        }
                    }
                    return Band.B61M;
                    //  return Band.B80M;
                }

                else if (freq >= 5.45 && freq < 7.00)
                {

                    if (A)
                    {
                        panelBandHF.Visible = false;
                        panelBandGN.Visible = true;
                    }
                    else
                    {
                        panelBandHFRX2.Visible = false;
                        if (FWCEEPROM.RX2OK) panelBandGNRX2.Visible = true;
                    }
                    return Band.B49M;
                    //  return Band.B60M;
                }

                else if (freq >= 7.30 && freq < 9.0)
                {
                    if (A)
                    {
                        panelBandHF.Visible = false;
                        panelBandGN.Visible = true;
                    }
                    else
                    {
                        panelBandHFRX2.Visible = false;
                        if (FWCEEPROM.RX2OK) panelBandGNRX2.Visible = true;
                    }

                    return Band.B41M;
                    //  return Band.B40M;
                }

                else if (freq >= 9.0 && freq < 10.1) // EXTENDED and TX
                {

                    if (A)
                    {
                        panelBandHF.Visible = false;
                        panelBandGN.Visible = true;
                    }
                    else
                    {
                        panelBandHFRX2.Visible = false;
                        if (FWCEEPROM.RX2OK) panelBandGNRX2.Visible = true;
                    }


                    return Band.B31M;
                    // return Band.B30M;
                }

                else if (freq > 10.15 && freq < 13.57)
                {
                    if (A)
                    {
                        panelBandHF.Visible = false;
                        panelBandGN.Visible = true;
                    }
                    else
                    {
                        panelBandHFRX2.Visible = false;
                        if (FWCEEPROM.RX2OK) panelBandGNRX2.Visible = true;
                    }

                    return Band.B25M;
                    //  return Band.B20M;
                }

                else if (freq >= 13.57 && freq < 14.0)
                {
                    if (A)
                    {
                        panelBandHF.Visible = false;
                        panelBandGN.Visible = true;
                    }
                    else
                    {
                        panelBandHFRX2.Visible = false;
                        if (FWCEEPROM.RX2OK) panelBandGNRX2.Visible = true;
                    }
                    return Band.B22M;
                    //  return Band.B20M;
                }

                else if (freq >= 14.350 && freq < 17.0)
                {
                    if (A)
                    {
                        panelBandHF.Visible = false;
                        panelBandGN.Visible = true;
                    }
                    else
                    {
                        panelBandHFRX2.Visible = false;
                        if (FWCEEPROM.RX2OK) panelBandGNRX2.Visible = true;
                    }
                    return Band.B19M;
                    // return Band.B17M;
                }

                else if (freq >= 17.0 && freq < 18.068)
                {

                    if (A)
                    {
                        panelBandHF.Visible = false;
                        panelBandGN.Visible = true;
                    }
                    else
                    {
                        panelBandHFRX2.Visible = false;
                        if (FWCEEPROM.RX2OK) panelBandGNRX2.Visible = true;
                    }
                    return Band.B16M;
                    //return Band.B17M;
                }

                else if (freq >= 18.168 && freq < 21.0)
                {
                    if (A)
                    {
                        panelBandHF.Visible = false;
                        panelBandGN.Visible = true;
                    }
                    else
                    {
                        panelBandHFRX2.Visible = false;
                        if (FWCEEPROM.RX2OK) panelBandGNRX2.Visible = true;
                    }
                    return Band.B14M;
                    //  return Band.B15M;
                }
                else if (freq >= 21.450 && freq < 24.89)
                {
                    if (A)
                    {
                        panelBandHF.Visible = false;
                        panelBandGN.Visible = true;
                    }
                    else
                    {
                        panelBandHFRX2.Visible = false;
                        if (FWCEEPROM.RX2OK) panelBandGNRX2.Visible = true;
                    }
                    return Band.B13M;
                    //  return Band.B12M;
                }

                else if (freq >= 24.99 && freq < 28.0)
                {
                    if (A)
                    {
                        panelBandHF.Visible = false;
                        panelBandGN.Visible = true;
                    }
                    else
                    {
                        panelBandHFRX2.Visible = false;
                        if (FWCEEPROM.RX2OK) panelBandGNRX2.Visible = true;
                    }
                    return Band.B11M;
                    // return Band.B10M;
                }

                // original code below 
                else if (freq >= 0.0 && freq <= 2.75)
                {

                    if (A)
                    {
                        panelBandHF.Visible = true;
                        panelBandGN.Visible = false;
                    }
                    else
                    {
                        if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true;
                        panelBandGNRX2.Visible = false;
                    }


                    return Band.B160M;
                }
                else if (freq > 2.75 && freq < 5.3305)
                {
                    if (A)
                    {
                        panelBandHF.Visible = true;
                        panelBandGN.Visible = false;
                    }
                    else
                    {
                        if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true;
                        panelBandGNRX2.Visible = false;
                    }
                    return Band.B80M;
                }
                else if (freq >= 5.250 && freq < 5.450) // ke9ns was else if (freq >= 5.3305 && freq < 7.0)
                {
                    if (A)
                    {
                        panelBandHF.Visible = true;
                        panelBandGN.Visible = false;
                    }
                    else
                    {
                        if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true;
                        panelBandGNRX2.Visible = false;
                    }
                    return Band.B60M;
                }
                else if (freq >= 7.0 && freq <= 8.7)
                {
                    if (A)
                    {
                        panelBandHF.Visible = true;
                        panelBandGN.Visible = false;
                    }
                    else
                    {
                        if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true;
                        panelBandGNRX2.Visible = false;
                    }
                    return Band.B40M;
                }
                else if (freq >= 8.7 && freq <= 12.075)  //   else if (freq > 10 && freq <= 10.15)
                {
                    if (A)
                    {
                        panelBandHF.Visible = true;
                        panelBandGN.Visible = false;
                    }
                    else
                    {
                        if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true;
                        panelBandGNRX2.Visible = false;
                    }
                    return Band.B30M;
                }
                else if (freq >= 12.075 && freq <= 16.209)
                {
                    if (A)
                    {
                        panelBandHF.Visible = true;
                        panelBandGN.Visible = false;
                    }
                    else
                    {
                        if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true;
                        panelBandGNRX2.Visible = false;
                    }
                    return Band.B20M;
                }
                else if (freq >= 16.209 && freq <= 19.584)
                {
                    if (A)
                    {
                        panelBandHF.Visible = true;
                        panelBandGN.Visible = false;
                    }
                    else
                    {
                        if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true;
                        panelBandGNRX2.Visible = false;
                    }
                    return Band.B17M;
                }
                else if (freq >= 19.584 && freq <= 23.17)
                {
                    if (A)
                    {
                        panelBandHF.Visible = true;
                        panelBandGN.Visible = false;
                    }
                    else
                    {
                        if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true;
                        panelBandGNRX2.Visible = false;
                    }
                    return Band.B15M;
                }
                else if (freq >= 23.17 && freq <= 26.495)
                {
                    if (A)
                    {
                        panelBandHF.Visible = true;
                        panelBandGN.Visible = false;
                    }
                    else
                    {
                        if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true;
                        panelBandGNRX2.Visible = false;
                    }
                    return Band.B12M;
                }
                else if (freq >= 26.495 && freq <= 29.7)
                {
                    if (A)
                    {
                        panelBandHF.Visible = true;
                        panelBandGN.Visible = false;
                    }
                    else
                    {
                        if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true;
                        panelBandGNRX2.Visible = false;
                    }
                    return Band.B10M;
                }
                else if (freq >= 50.0 && freq <= 54.0)
                {
                    if (A)
                    {
                        panelBandHF.Visible = true;
                        panelBandGN.Visible = false;
                    }
                    else
                    {
                        if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true;
                        panelBandGNRX2.Visible = false;
                    }
                    return Band.B6M;
                }
                else if (freq >= 134.0 && freq <= 163.0) // ke9ns test was 144.0 and 148.0 .217  extended here
                {
                    if (A)
                    {
                        panelBandHF.Visible = true;
                        panelBandGN.Visible = false;
                    }
                    else
                    {
                        if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true;
                        panelBandGNRX2.Visible = false;
                    }
                    return Band.B2M;
                }


                else
                    return Band.GEN;
            } // extened above

            if (region == FRSRegion.US)
            {
                //   Debug.WriteLine("US BAND========================");

                if (freq >= 1.8 && freq <= 2.0)
                {
                    if (A)
                    {
                        panelBandHF.Visible = true;
                        panelBandGN.Visible = false;
                    }
                    else
                    {
                        if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true;
                        panelBandGNRX2.Visible = false;
                    }

                    return Band.B160M;
                }
                else if (freq >= 3.5 && freq <= 4.0)
                {
                    if (A)
                    {
                        panelBandHF.Visible = true;
                        panelBandGN.Visible = false;
                    }
                    else
                    {
                        if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true;
                        panelBandGNRX2.Visible = false;
                    }

                    return Band.B80M;
                }
                else if (freq >= 5.25 && freq <= 5.45) // else if (freq >= 5.1 && freq <= 5.5)
                {
                    if (A)
                    {
                        panelBandHF.Visible = true;
                        panelBandGN.Visible = false;
                    }
                    else
                    {
                        if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true;
                        panelBandGNRX2.Visible = false;
                    }

                    return Band.B60M;
                }
                else if (freq >= 7.0 && freq <= 7.3)
                {
                    if (A)
                    {
                        panelBandHF.Visible = true;
                        panelBandGN.Visible = false;
                    }
                    else
                    {
                        if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true;
                        panelBandGNRX2.Visible = false;
                    }

                    return Band.B40M;
                }
                else if (freq >= 10.1 && freq <= 10.15)
                {
                    if (A)
                    {
                        panelBandHF.Visible = true;
                        panelBandGN.Visible = false;
                    }
                    else
                    {
                        if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true;
                        panelBandGNRX2.Visible = false;
                    }

                    return Band.B30M;
                }
                else if (freq >= 14.0 && freq <= 14.35)
                {
                    if (A)
                    {
                        panelBandHF.Visible = true;
                        panelBandGN.Visible = false;
                    }
                    else
                    {
                        if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true;
                        panelBandGNRX2.Visible = false;
                    }

                    return Band.B20M;
                }
                else if (freq >= 18.068 && freq <= 18.168)
                {
                    if (A)
                    {
                        panelBandHF.Visible = true;
                        panelBandGN.Visible = false;
                    }
                    else
                    {
                        if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true;
                        panelBandGNRX2.Visible = false;
                    }

                    return Band.B17M;
                }
                else if (freq >= 21.0 && freq <= 21.450)
                {
                    if (A)
                    {
                        panelBandHF.Visible = true;
                        panelBandGN.Visible = false;
                    }
                    else
                    {
                        if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true;
                        panelBandGNRX2.Visible = false;
                    }


                    return Band.B15M;
                }
                else if (freq >= 24.89 && freq <= 24.99)
                {
                    if (A)
                    {
                        panelBandHF.Visible = true;
                        panelBandGN.Visible = false;
                    }
                    else
                    {
                        if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true;
                        panelBandGNRX2.Visible = false;
                    }

                    return Band.B12M;
                }
                else if (freq >= 28.0 && freq <= 29.7)
                {
                    if (A)
                    {
                        panelBandHF.Visible = true;
                        panelBandGN.Visible = false;
                    }
                    else
                    {
                        if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true;
                        panelBandGNRX2.Visible = false;
                    }
                    return Band.B10M;
                }
                else if (freq >= 50.0 && freq <= 54.0)
                {
                    if (A)
                    {
                        panelBandHF.Visible = true;
                        panelBandGN.Visible = false;
                    }
                    else
                    {
                        if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true;
                        panelBandGNRX2.Visible = false;
                    }
                    return Band.B6M;
                }
                else if (freq >= 134.0 && freq <= 163.0) // ke9ns test was 144.0 148.0 .217  US region here
                {
                    if (A)
                    {
                        panelBandHF.Visible = true;
                        panelBandGN.Visible = false;
                    }
                    else
                    {
                        if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true;
                        panelBandGNRX2.Visible = false;
                    }
                    return Band.B2M;
                }
                else if (freq == 2.5 || freq == 5.0 || freq == 10.0 || freq == 15.0 ||
                        freq == 20.0 || freq == 25.0 || freq == 3.33 || freq == 7.85 || freq == 14.67)
                {
                    if (A)
                    {
                        panelBandHF.Visible = true;
                        panelBandGN.Visible = false;
                    }
                    else
                    {
                        if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true;
                        panelBandGNRX2.Visible = false;
                    }
                    return Band.WWV;
                }

                // ke9ns add
                else if (freq >= 0.20 && freq < 1.80)
                {
                    if (A)
                    {
                        panelBandHF.Visible = false;
                        panelBandGN.Visible = true;
                    }
                    else
                    {
                        panelBandHFRX2.Visible = false;
                        if (FWCEEPROM.RX2OK) panelBandGNRX2.Visible = true;
                    }
                    return Band.BLMF;
                }

                else if (freq >= 2.0 && freq < 3.0) // FRSRegion.US
                {
                    if (A)
                    {
                        panelBandHF.Visible = false;
                        panelBandGN.Visible = true;
                    }
                    else
                    {
                        panelBandHFRX2.Visible = false;
                        if (FWCEEPROM.RX2OK) panelBandGNRX2.Visible = true;
                    }
                    return Band.B120M;
                }

                else if (freq >= 3.0 && freq < 3.5)
                {
                    if (A)
                    {
                        panelBandHF.Visible = false;
                        panelBandGN.Visible = true;
                    }
                    else
                    {
                        panelBandHFRX2.Visible = false;
                        if (FWCEEPROM.RX2OK) panelBandGNRX2.Visible = true;
                    }
                    return Band.B90M;
                }

                else if (freq > 4.00 && freq < 5.25)
                {
                    if (A)
                    {
                        panelBandHF.Visible = false;
                        panelBandGN.Visible = true;
                    }
                    else
                    {
                        panelBandHFRX2.Visible = false;
                        if (FWCEEPROM.RX2OK) panelBandGNRX2.Visible = true;
                    }
                    return Band.B61M;
                }

                else if (freq >= 5.45 && freq < 7.00)
                {
                    //   Debug.WriteLine("bandbyfreq 49");
                    if (A)
                    {
                        panelBandHF.Visible = false;
                        panelBandGN.Visible = true;
                    }
                    else
                    {
                        panelBandHFRX2.Visible = false;
                        if (FWCEEPROM.RX2OK) panelBandGNRX2.Visible = true;
                    }
                    return Band.B49M;
                }

                else if (freq >= 7.20 && freq < 9.0)
                {
                    //  Debug.WriteLine("bandbyfreq 41");
                    if (A)
                    {
                        panelBandHF.Visible = false;
                        panelBandGN.Visible = true;
                    }
                    else
                    {
                        panelBandHFRX2.Visible = false;
                        if (FWCEEPROM.RX2OK) panelBandGNRX2.Visible = true;
                    }
                    return Band.B41M;
                }

                else if (freq >= 9.0 && freq < 10.1) // us band plan
                {
                    if (A)
                    {
                        panelBandHF.Visible = false;
                        panelBandGN.Visible = true;
                    }
                    else
                    {
                        panelBandHFRX2.Visible = false;
                        if (FWCEEPROM.RX2OK) panelBandGNRX2.Visible = true;
                    }
                    return Band.B31M;
                }

                else if (freq > 10.15 && freq < 13.57)
                {
                    if (A)
                    {
                        panelBandHF.Visible = false;
                        panelBandGN.Visible = true;
                    }
                    else
                    {
                        panelBandHFRX2.Visible = false;
                        if (FWCEEPROM.RX2OK) panelBandGNRX2.Visible = true;
                    }
                    return Band.B25M;
                }

                else if (freq >= 13.57 && freq < 14.0)
                {
                    if (A)
                    {
                        panelBandHF.Visible = false;
                        panelBandGN.Visible = true;
                    }
                    else
                    {
                        panelBandHFRX2.Visible = false;
                        if (FWCEEPROM.RX2OK) panelBandGNRX2.Visible = true;
                    }
                    return Band.B22M;
                }

                else if (freq >= 14.350 && freq < 17.0)
                {
                    if (A)
                    {
                        panelBandHF.Visible = false;
                        panelBandGN.Visible = true;
                    }
                    else
                    {
                        panelBandHFRX2.Visible = false;
                        if (FWCEEPROM.RX2OK) panelBandGNRX2.Visible = true;
                    }
                    return Band.B19M;
                }

                else if (freq >= 17.0 && freq < 18.0)
                {

                    if (A)
                    {
                        panelBandHF.Visible = false;
                        panelBandGN.Visible = true;
                    }
                    else
                    {
                        panelBandHFRX2.Visible = false;
                        if (FWCEEPROM.RX2OK) panelBandGNRX2.Visible = true;
                    }
                    return Band.B16M;
                }

                else if (freq >= 18.0 && freq < 21.0)
                {
                    if (A)
                    {
                        panelBandHF.Visible = false;
                        panelBandGN.Visible = true;
                    }
                    else
                    {
                        panelBandHFRX2.Visible = false;
                        if (FWCEEPROM.RX2OK) panelBandGNRX2.Visible = true;
                    }
                    return Band.B14M;
                }
                else if (freq >= 21.00 && freq < 25.0)
                {
                    if (A)
                    {
                        panelBandHF.Visible = false;
                        panelBandGN.Visible = true;
                    }
                    else
                    {
                        panelBandHFRX2.Visible = false;
                        if (FWCEEPROM.RX2OK) panelBandGNRX2.Visible = true;
                    }
                    return Band.B13M;
                }

                else if (freq >= 25.0 && freq < 28.0)
                {
                    if (A)
                    {
                        panelBandHF.Visible = false;
                        panelBandGN.Visible = true;
                    }
                    else
                    {
                        panelBandHFRX2.Visible = false;
                        if (FWCEEPROM.RX2OK) panelBandGNRX2.Visible = true;
                    }
                    return Band.B11M;
                }

                else
                    return Band.GEN;
            }

            else if (region == FRSRegion.UK)
            {
                if (freq >= 1.80 && freq <= 2.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B160M;
                }
                else if (freq >= 3.5 && freq <= 4.0) //3.8
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B80M;
                }
                else if (freq >= 5.250 && freq < 5.450) // ke9ns was else if (freq >= 5.3305 && freq < 7.0)
                {
                    if (A)
                    {
                        panelBandHF.Visible = true;
                        panelBandGN.Visible = false;
                    }
                    else
                    {
                        if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true;
                        panelBandGNRX2.Visible = false;
                    }
                    return Band.B60M;
                }
                else if (freq >= 7.0 && freq <= 7.3)
                {
                    if (A)
                    {
                        panelBandHF.Visible = true;
                        panelBandGN.Visible = false;
                    }
                    else
                    {
                        if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true;
                        panelBandGNRX2.Visible = false;
                    }
                    return Band.B40M;
                }
                else if (freq >= 10.1 && freq <= 10.15)
                {
                    if (A)
                    {
                        panelBandHF.Visible = true;
                        panelBandGN.Visible = false;
                    }
                    else
                    {
                        if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true;
                        panelBandGNRX2.Visible = false;
                    }
                    return Band.B30M;
                }
                else if (freq >= 14.0 && freq <= 14.35)
                {
                    if (A)
                    {
                        panelBandHF.Visible = true;
                        panelBandGN.Visible = false;
                    }
                    else
                    {
                        if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true;
                        panelBandGNRX2.Visible = false;
                    }
                    return Band.B20M;
                }
                else if (freq >= 18.068 && freq <= 18.168)
                {
                    if (A)
                    {
                        panelBandHF.Visible = true;
                        panelBandGN.Visible = false;
                    }
                    else
                    {
                        if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true;
                        panelBandGNRX2.Visible = false;
                    }
                    return Band.B17M;
                }
                else if (freq >= 21.0 && freq <= 21.45)
                {
                    if (A)
                    {
                        panelBandHF.Visible = true;
                        panelBandGN.Visible = false;
                    }
                    else
                    {
                        if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true;
                        panelBandGNRX2.Visible = false;
                    }
                    return Band.B15M;
                }
                else if (freq >= 24.89 && freq <= 24.99)
                {
                    if (A)
                    {
                        panelBandHF.Visible = true;
                        panelBandGN.Visible = false;
                    }
                    else
                    {
                        if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true;
                        panelBandGNRX2.Visible = false;
                    }
                    return Band.B12M;
                }
                else if (freq >= 28.0 && freq <= 29.7)
                {
                    if (A)
                    {
                        panelBandHF.Visible = true;
                        panelBandGN.Visible = false;
                    }
                    else
                    {
                        if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true;
                        panelBandGNRX2.Visible = false;
                    }
                    return Band.B10M;
                }
                else if (freq >= 50.0 && freq <= 54.0)
                {
                    if (A)
                    {
                        panelBandHF.Visible = true;
                        panelBandGN.Visible = false;
                    }
                    else
                    {
                        if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true;
                        panelBandGNRX2.Visible = false;
                    }
                    return Band.B6M;
                }
                else if (freq >= 134.0 && freq <= 163.0)
                {
                    if (A)
                    {
                        panelBandHF.Visible = true;
                        panelBandGN.Visible = false;
                    }
                    else
                    {
                        if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true;
                        panelBandGNRX2.Visible = false;
                    }
                    return Band.B2M;
                }
                else if (freq == 2.5 || freq == 5.0 || freq == 10.0 || freq == 15.0 ||
                        freq == 20.0 || freq == 25.0 || freq == 3.33 || freq == 7.85 || freq == 14.67)
                {
                    if (A)
                    {
                        panelBandHF.Visible = true;
                        panelBandGN.Visible = false;
                    }
                    else
                    {
                        if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true;
                        panelBandGNRX2.Visible = false;
                    }
                    return Band.WWV;
                }

                // ke9ns add
                else if (freq >= 0.20 && freq < 1.80)
                {
                    if (A)
                    {
                        panelBandHF.Visible = false;
                        panelBandGN.Visible = true;
                    }
                    else
                    {
                        panelBandHFRX2.Visible = false;
                        if (FWCEEPROM.RX2OK) panelBandGNRX2.Visible = true;
                    }
                    return Band.BLMF;
                }

                else if (freq >= 2.0 && freq < 3.0)
                {
                    if (A)
                    {
                        panelBandHF.Visible = false;
                        panelBandGN.Visible = true;
                    }
                    else
                    {
                        panelBandHFRX2.Visible = false;
                        if (FWCEEPROM.RX2OK) panelBandGNRX2.Visible = true;
                    }
                    return Band.B120M;
                }

                else if (freq >= 3.0 && freq < 3.50)
                {
                    if (A)
                    {
                        panelBandHF.Visible = false;
                        panelBandGN.Visible = true;
                    }
                    else
                    {
                        panelBandHFRX2.Visible = false;
                        if (FWCEEPROM.RX2OK) panelBandGNRX2.Visible = true;
                    }
                    return Band.B90M;
                }

                else if (freq > 3.8 && freq < 5.25)
                {
                    if (A)
                    {
                        panelBandHF.Visible = false;
                        panelBandGN.Visible = true;
                    }
                    else
                    {
                        panelBandHFRX2.Visible = false;
                        if (FWCEEPROM.RX2OK) panelBandGNRX2.Visible = true;
                    }
                    return Band.B61M;
                }

                else if (freq >= 5.45 && freq < 7.00)
                {
                    if (A)
                    {
                        panelBandHF.Visible = false;
                        panelBandGN.Visible = true;
                    }
                    else
                    {
                        panelBandHFRX2.Visible = false;
                        if (FWCEEPROM.RX2OK) panelBandGNRX2.Visible = true;
                    }
                    return Band.B49M;
                }

                else if (freq >= 7.20 && freq < 9.0)
                {
                    if (A)
                    {
                        panelBandHF.Visible = false;
                        panelBandGN.Visible = true;
                    }
                    else
                    {
                        panelBandHFRX2.Visible = false;
                        if (FWCEEPROM.RX2OK) panelBandGNRX2.Visible = true;
                    }
                    return Band.B41M;
                }

                else if (freq >= 9.0 && freq < 10.1)
                {
                    if (A)
                    {
                        panelBandHF.Visible = false;
                        panelBandGN.Visible = true;
                    }
                    else
                    {
                        panelBandHFRX2.Visible = false;
                        if (FWCEEPROM.RX2OK) panelBandGNRX2.Visible = true;
                    }
                    return Band.B31M;
                }

                else if (freq > 10.15 && freq < 13.57)
                {
                    if (A)
                    {
                        panelBandHF.Visible = false;
                        panelBandGN.Visible = true;
                    }
                    else
                    {
                        panelBandHFRX2.Visible = false;
                        if (FWCEEPROM.RX2OK) panelBandGNRX2.Visible = true;
                    }
                    return Band.B25M;
                }

                else if (freq >= 13.57 && freq < 14.0)
                {
                    if (A)
                    {
                        panelBandHF.Visible = false;
                        panelBandGN.Visible = true;
                    }
                    else
                    {
                        panelBandHFRX2.Visible = false;
                        if (FWCEEPROM.RX2OK) panelBandGNRX2.Visible = true;
                    }
                    return Band.B22M;
                }

                else if (freq >= 14.350 && freq < 17.0)
                {
                    if (A)
                    {
                        panelBandHF.Visible = false;
                        panelBandGN.Visible = true;
                    }
                    else
                    {
                        panelBandHFRX2.Visible = false;
                        if (FWCEEPROM.RX2OK) panelBandGNRX2.Visible = true;
                    }
                    return Band.B19M;
                }

                else if (freq >= 17.0 && freq < 18.0)
                {

                    if (A)
                    {
                        panelBandHF.Visible = false;
                        panelBandGN.Visible = true;
                    }
                    else
                    {
                        panelBandHFRX2.Visible = false;
                        if (FWCEEPROM.RX2OK) panelBandGNRX2.Visible = true;
                    }
                    return Band.B16M;
                }

                else if (freq >= 18.0 && freq < 21.0)
                {
                    if (A)
                    {
                        panelBandHF.Visible = false;
                        panelBandGN.Visible = true;
                    }
                    else
                    {
                        panelBandHFRX2.Visible = false;
                        if (FWCEEPROM.RX2OK) panelBandGNRX2.Visible = true;
                    }
                    return Band.B14M;
                }
                else if (freq >= 21.00 && freq < 25.0)
                {
                    if (A)
                    {
                        panelBandHF.Visible = false;
                        panelBandGN.Visible = true;
                    }
                    else
                    {
                        panelBandHFRX2.Visible = false;
                        if (FWCEEPROM.RX2OK) panelBandGNRX2.Visible = true;
                    }
                    return Band.B13M;
                }

                else if (freq >= 25.0 && freq < 28.0)
                {
                    if (A)
                    {
                        panelBandHF.Visible = false;
                        panelBandGN.Visible = true;
                    }
                    else
                    {
                        panelBandHFRX2.Visible = false;
                        if (FWCEEPROM.RX2OK) panelBandGNRX2.Visible = true;
                    }
                    return Band.B11M;
                }


                else
                    return Band.GEN;
            }
            else if (region == FRSRegion.Europe)
            {
                if (freq >= 1.80 && freq <= 2.0)
                {
                    if (A)
                    {
                        panelBandHF.Visible = true;
                        panelBandGN.Visible = false;
                    }
                    else
                    {
                        if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true;
                        panelBandGNRX2.Visible = false;
                    }
                    return Band.B160M;
                }
                else if (freq >= 3.5 && freq <= 4.0) //3.8
                {
                    if (A)
                    {
                        panelBandHF.Visible = true;
                        panelBandGN.Visible = false;
                    }
                    else
                    {
                        if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true;
                        panelBandGNRX2.Visible = false;
                    }
                    return Band.B80M;
                }
                else if (freq >= 5.250 && freq < 5.450) // ke9ns                             // else if (freq >= 5.3515 && freq < 5.3665) // w4tme - matches region allocation
                {
                    if (A)
                    {
                        panelBandHF.Visible = true;
                        panelBandGN.Visible = false;
                    }
                    else
                    {
                        if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true;
                        panelBandGNRX2.Visible = false;
                    }
                    return Band.B60M;
                }
                else if (freq >= 7.0 && freq <= 7.3)
                {
                    if (A)
                    {
                        panelBandHF.Visible = true;
                        panelBandGN.Visible = false;
                    }
                    else
                    {
                        if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true;
                        panelBandGNRX2.Visible = false;
                    }
                    return Band.B40M;
                }
                else if (freq >= 10.1 && freq <= 10.15)
                {
                    if (A)
                    {
                        panelBandHF.Visible = true;
                        panelBandGN.Visible = false;
                    }
                    else
                    {
                        if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true;
                        panelBandGNRX2.Visible = false;
                    }
                    return Band.B30M;
                }
                else if (freq >= 14.0 && freq <= 14.35)
                {
                    if (A)
                    {
                        panelBandHF.Visible = true;
                        panelBandGN.Visible = false;
                    }
                    else
                    {
                        if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true;
                        panelBandGNRX2.Visible = false;
                    }
                    return Band.B20M;
                }
                else if (freq >= 18.068 && freq <= 18.168)
                {
                    if (A)
                    {
                        panelBandHF.Visible = true;
                        panelBandGN.Visible = false;
                    }
                    else
                    {
                        if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true;
                        panelBandGNRX2.Visible = false;
                    }
                    return Band.B17M;
                }
                else if (freq >= 21.0 && freq <= 21.45)
                {
                    if (A)
                    {
                        panelBandHF.Visible = true;
                        panelBandGN.Visible = false;
                    }
                    else
                    {
                        if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true;
                        panelBandGNRX2.Visible = false;
                    }
                    return Band.B15M;
                }
                else if (freq >= 24.89 && freq <= 24.99)
                {
                    if (A)
                    {
                        panelBandHF.Visible = true;
                        panelBandGN.Visible = false;
                    }
                    else
                    {
                        if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true;
                        panelBandGNRX2.Visible = false;
                    }
                    return Band.B12M;
                }
                else if (freq >= 28.0 && freq <= 29.7)
                {
                    if (A)
                    {
                        panelBandHF.Visible = true;
                        panelBandGN.Visible = false;
                    }
                    else
                    {
                        if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true;
                        panelBandGNRX2.Visible = false;
                    }
                    return Band.B10M;
                }
                else if (freq >= 50.0 && freq <= 54.0) // if (freq >= 50.03 && freq <= 51.0)
                {
                    if (A)
                    {
                        panelBandHF.Visible = true;
                        panelBandGN.Visible = false;
                    }
                    else
                    {
                        if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true;
                        panelBandGNRX2.Visible = false;
                    }
                    return Band.B6M;
                }
                else if (freq >= 134.0 && freq <= 163.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B2M;
                }
                else if (freq == 2.5 || freq == 5.0 || freq == 10.0 || freq == 15.0 ||
                        freq == 20.0 || freq == 25.0 || freq == 3.33 || freq == 7.85 || freq == 14.67)
                {
                    if (A)
                    {
                        panelBandHF.Visible = true;
                        panelBandGN.Visible = false;
                    }
                    else
                    {
                        if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true;
                        panelBandGNRX2.Visible = false;
                    }
                    return Band.WWV;
                }

                // ke9ns add
                else if (freq >= 0.20 && freq < 1.80)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.BLMF;
                }

                else if (freq >= 2.00 && freq < 3.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B120M;
                }

                else if (freq >= 3.0 && freq < 3.50)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B90M;
                }

                else if (freq > 3.8 && freq < 5.25)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B61M;
                }

                else if (freq >= 5.45 && freq < 7.20)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B49M;
                }

                else if (freq >= 7.20 && freq < 9.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B41M;
                }

                else if (freq >= 9.0 && freq < 10.1)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B31M;
                }

                else if (freq > 10.15 && freq < 13.57)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B25M;
                }

                else if (freq >= 13.57 && freq < 14.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B22M;
                }

                else if (freq >= 14.350 && freq < 17.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B19M;
                }

                else if (freq >= 17.0 && freq < 18.0)
                {

                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B16M;
                }

                else if (freq >= 18.0 && freq < 21.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B14M;
                }
                else if (freq >= 21.00 && freq < 25.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B13M;
                }

                else if (freq >= 25.0 && freq < 28.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B11M;
                }

                else
                    return Band.GEN;
            }
            else if (region == FRSRegion.UK_Plus)
            {
                if (freq >= 1.80 && freq <= 2.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B160M;
                }
                else if (freq >= 3.5 && freq <= 4.0) //3.80
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B80M;
                }
                else if (freq >= 5.250 && freq < 5.450) // ke9ns was else if (freq >= 5.3305 && freq < 7.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B60M;
                }
                else if (freq >= 7.0 && freq <= 7.3)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B40M;
                }
                else if (freq >= 10.1 && freq <= 10.15)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B30M;
                }
                else if (freq >= 14.0 && freq <= 14.35)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B20M;
                }
                else if (freq >= 18.068 && freq <= 18.168)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B17M;
                }
                else if (freq >= 21.0 && freq <= 21.45)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B15M;
                }
                else if (freq >= 24.89 && freq <= 24.99)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B12M;
                }
                else if (freq >= 28.0 && freq <= 29.7)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B10M;
                }
                else if (freq >= 50.0 && freq <= 54.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B6M;
                }
                else if (freq >= 134.0 && freq <= 163.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B2M;
                }
                else if (freq == 2.5 || freq == 5.0 || freq == 10.0 || freq == 15.0 ||
                        freq == 20.0 || freq == 25.0 || freq == 3.33 || freq == 7.85 || freq == 14.67)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.WWV;
                }

                // ke9ns add
                else if (freq >= 0.20 && freq < 1.80)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.BLMF;
                }

                else if (freq >= 2.00 && freq < 3.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B120M;
                }

                else if (freq >= 3.0 && freq < 3.50)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B90M;
                }

                else if (freq > 3.80 && freq < 5.25)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B61M;
                }

                else if (freq >= 5.45 && freq < 7.20)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B49M;
                }

                else if (freq >= 7.20 && freq < 9.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B41M;
                }

                else if (freq >= 9.0 && freq < 10.1)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B31M;
                }

                else if (freq > 10.15 && freq < 13.57)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B25M;
                }

                else if (freq >= 13.57 && freq < 14.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B22M;
                }

                else if (freq >= 14.350 && freq < 17.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B19M;
                }

                else if (freq >= 17.0 && freq < 18.0)
                {

                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B16M;
                }

                else if (freq >= 18.0 && freq < 21.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B14M;
                }
                else if (freq >= 21.00 && freq < 25.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B13M;
                }

                else if (freq >= 25.0 && freq < 28.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B11M;
                }


                else
                    return Band.GEN;
            }
            else if (region == FRSRegion.Italy)
            {
                if (freq >= 1.80 && freq <= 2.00) // if (freq >= 1.83 && freq <= 1.85)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B160M;
                }
                else if (freq >= 3.5 && freq <= 4.0) // 3.8
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B80M;
                }
                else if (freq >= 5.250 && freq < 5.450) // ke9ns was else if (freq >= 5.3305 && freq < 7.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B60M;
                }
                else if (freq >= 6.975 && freq <= 7.3)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B40M;
                }
                else if (freq >= 10.1 && freq <= 10.15)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B30M;
                }
                else if (freq >= 14.0 && freq <= 14.35)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B20M;
                }
                else if (freq >= 18.068 && freq <= 18.168)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B17M;
                }
                else if (freq >= 21.0 && freq <= 21.45)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B15M;
                }
                else if (freq >= 24.89 && freq <= 24.99)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B12M;
                }
                else if (freq >= 28.0 && freq <= 29.7)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B10M;
                }
                else if (freq >= 50.00 && freq <= 51.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B6M;
                }
                else if (freq >= 134.0 && freq <= 163.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B2M;
                }
                else if (freq == 2.5 || freq == 5.0 || freq == 10.0 || freq == 15.0 ||
                        freq == 20.0 || freq == 25.0 || freq == 3.33 || freq == 7.85 || freq == 14.67)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.WWV;
                }

                // ke9ns add
                else if (freq >= 0.20 && freq < 1.83) // italy
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.BLMF;
                }

                else if (freq >= 1.85 && freq < 3.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B120M;
                }

                else if (freq >= 3.0 && freq < 3.50)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B90M;
                }

                else if (freq > 3.8 && freq < 5.25)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B61M;
                }

                else if (freq >= 5.45 && freq < 6.975) // italy
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B49M;
                }

                else if (freq >= 7.20 && freq < 9.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B41M;
                }

                else if (freq >= 9.0 && freq < 10.1)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B31M;
                }

                else if (freq > 10.15 && freq < 13.57)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B25M;
                }

                else if (freq >= 13.57 && freq < 14.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B22M;
                }

                else if (freq >= 14.350 && freq < 17.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B19M;
                }

                else if (freq >= 17.0 && freq < 18.0)
                {

                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B16M;
                }

                else if (freq >= 18.0 && freq < 21.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B14M;
                }
                else if (freq >= 21.00 && freq < 25.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B13M;
                }

                else if (freq >= 25.0 && freq < 28.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B11M;
                }


                else
                    return Band.GEN;
            } // italy
            else if (region == FRSRegion.Norway)
            {
                if (freq >= 1.80 && freq <= 2.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B160M;
                }
                else if (freq >= 3.5 && freq <= 4.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B80M;
                }
                else if (freq >= 5.250 && freq < 5.450) // ke9ns was else if (freq >= 5.3305 && freq < 7.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B60M;
                }
                else if (freq >= 7.0 && freq <= 7.3)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B40M;
                }
                else if (freq >= 10.1 && freq <= 10.15)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B30M;
                }
                else if (freq >= 14.0 && freq <= 14.35)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B20M;
                }
                else if (freq >= 18.068 && freq <= 18.168)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B17M;
                }
                else if (freq >= 21.0 && freq <= 21.45)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B15M;
                }
                else if (freq >= 24.74 && freq <= 24.99) // was 24.89
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B12M;
                }
                else if (freq >= 28.0 && freq <= 29.7)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B10M;
                }
                else if (freq >= 50.0 && freq <= 54.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B6M;
                }
                else if (freq >= 134.0 && freq <= 163.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B2M;
                }
                else if (freq == 2.5 || freq == 5.0 || freq == 10.0 || freq == 15.0 ||
                        freq == 20.0 || freq == 25.0 || freq == 3.33 || freq == 7.85 || freq == 14.67)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.WWV;
                }

                // ke9ns add
                else if (freq >= 0.20 && freq < 1.81) // norway
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.BLMF;
                }

                else if (freq >= 2.0 && freq < 3.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B120M;
                }

                else if (freq >= 3.0 && freq < 3.50)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B90M;
                }

                else if (freq > 3.80 && freq < 5.25)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B61M;
                }

                else if (freq >= 5.45 && freq < 7.20)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B49M;
                }

                else if (freq >= 7.20 && freq < 9.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B41M;
                }

                else if (freq >= 9.0 && freq < 10.1)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B31M;
                }

                else if (freq > 10.15 && freq < 13.57)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B25M;
                }

                else if (freq >= 13.57 && freq < 14.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B22M;
                }

                else if (freq >= 14.350 && freq < 17.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B19M;
                }

                else if (freq >= 17.0 && freq < 18.0)
                {

                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B16M;
                }

                else if (freq >= 18.0 && freq < 21.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B14M;
                }
                else if (freq >= 21.00 && freq < 25.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B13M;
                }

                else if (freq >= 25.0 && freq < 28.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B11M;
                }

                else
                    return Band.GEN;
            }
            else if (region == FRSRegion.Denmark)
            {
                if (freq >= 1.80 && freq <= 2.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B160M;
                }
                else if (freq >= 3.5 && freq <= 4.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B80M;
                }
                else if (freq >= 5.250 && freq < 5.450) // ke9ns was else if (freq >= 5.3305 && freq < 7.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B60M;
                }
                else if (freq >= 7.0 && freq <= 7.3)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B40M;
                }
                else if (freq >= 10.1 && freq <= 10.15)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B30M;
                }
                else if (freq >= 14.0 && freq <= 14.35)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B20M;
                }
                else if (freq >= 18.068 && freq <= 18.168)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B17M;
                }
                else if (freq >= 21.0 && freq <= 21.45)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B15M;
                }
                else if (freq >= 24.89 && freq <= 24.99)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B12M;
                }
                else if (freq >= 28.0 && freq <= 29.7)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B10M;
                }
                else if (freq >= 50.0 && freq <= 54.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B6M;
                }
                else if (freq >= 134.0 && freq <= 163.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B2M;
                }
                else if (freq == 2.5 || freq == 5.0 || freq == 10.0 || freq == 15.0 ||
                        freq == 20.0 || freq == 25.0 || freq == 3.33 || freq == 7.85 || freq == 14.67)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.WWV;
                }

                // ke9ns add
                else if (freq >= 0.20 && freq < 1.81)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.BLMF;
                }

                else if (freq >= 2.00 && freq < 3.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B120M;
                }

                else if (freq >= 3.0 && freq < 3.50)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B90M;
                }

                else if (freq > 3.80 && freq < 5.25)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B61M;
                }

                else if (freq >= 5.45 && freq < 7.20)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B49M;
                }

                else if (freq >= 7.20 && freq < 9.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B41M;
                }

                else if (freq >= 9.0 && freq < 10.1)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B31M;
                }

                else if (freq > 10.15 && freq < 13.57)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B25M;
                }

                else if (freq >= 13.57 && freq < 14.00)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B22M;
                }

                else if (freq >= 14.350 && freq < 17.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B19M;
                }

                else if (freq >= 17.0 && freq < 18.0)
                {

                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B16M;
                }

                else if (freq >= 18.0 && freq < 21.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B14M;
                }
                else if (freq >= 21.00 && freq < 25.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B13M;
                }

                else if (freq >= 25.0 && freq < 28.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B11M;
                }

                else
                    return Band.GEN;
            }
            else if (region == FRSRegion.Latvia)
            {
                if (freq >= 1.80 && freq <= 2.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B160M;
                }
                else if (freq >= 3.5 && freq <= 4.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B80M;
                }
                else if (freq >= 5.250 && freq < 5.450) // ke9ns was else if (freq >= 5.3305 && freq < 7.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B60M;
                }
                else if (freq >= 7.0 && freq <= 7.3)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B40M;
                }
                else if (freq >= 10.1 && freq <= 10.15)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B30M;
                }
                else if (freq >= 14.0 && freq <= 14.35)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B20M;
                }
                else if (freq >= 18.068 && freq <= 18.168)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B17M;
                }
                else if (freq >= 21.0 && freq <= 21.45)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B15M;
                }
                else if (freq >= 24.89 && freq <= 24.99)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B12M;
                }
                else if (freq >= 28.0 && freq <= 29.7)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B10M;
                }
                else if (freq >= 50.0 && freq <= 51.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B6M;
                }
                else if (freq >= 134.0 && freq <= 163.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B2M;
                }
                else if (freq == 2.5 || freq == 5.0 || freq == 10.0 || freq == 15.0 ||
                        freq == 20.0 || freq == 25.0 || freq == 3.33 || freq == 7.85 || freq == 14.67)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.WWV;
                }
                // ke9ns add
                else if (freq >= 0.20 && freq < 1.81)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.BLMF;
                }

                else if (freq >= 2.00 && freq < 3.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B120M;
                }

                else if (freq >= 3.0 && freq < 3.50)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B90M;
                }

                else if (freq > 3.80 && freq < 5.25)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B61M;
                }

                else if (freq >= 5.45 && freq < 7.20)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B49M;
                }

                else if (freq >= 7.20 && freq < 9.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B41M;
                }

                else if (freq >= 9.0 && freq < 10.1)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B31M;
                }

                else if (freq > 10.15 && freq < 13.57)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B25M;
                }

                else if (freq >= 13.57 && freq < 14.00)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B22M;
                }

                else if (freq >= 14.350 && freq < 17.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B19M;
                }

                else if (freq >= 17.0 && freq < 18.0)
                {

                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B16M;
                }

                else if (freq >= 18.0 && freq < 21.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B14M;
                }
                else if (freq >= 21.00 && freq < 25.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B13M;
                }

                else if (freq >= 25.0 && freq < 28.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B11M;
                }


                else
                    return Band.GEN;
            } // Latvia
            else if (region == FRSRegion.Slovakia)
            {
                if (freq >= 1.80 && freq <= 2.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B160M;
                }
                else if (freq >= 3.5 && freq <= 4.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B80M;
                }
                else if (freq >= 5.250 && freq < 5.450) // ke9ns was else if (freq >= 5.3305 && freq < 7.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B60M;
                }
                else if (freq >= 7.0 && freq <= 7.3)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B40M;
                }
                else if (freq >= 10.1 && freq <= 10.15)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B30M;
                }
                else if (freq >= 14.0 && freq <= 14.35)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B20M;
                }
                else if (freq >= 18.068 && freq <= 18.168)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B17M;
                }
                else if (freq >= 21.0 && freq <= 21.45)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B15M;
                }
                else if (freq >= 24.89 && freq <= 24.99)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B12M;
                }
                else if (freq >= 28.0 && freq <= 29.7)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B10M;
                }
                else if (freq >= 50.0 && freq <= 54.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B6M;
                }
                else if (freq >= 134.0 && freq <= 163.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B2M;
                }
                else if (freq == 2.5 || freq == 5.0 || freq == 10.0 || freq == 15.0 ||
                        freq == 20.0 || freq == 25.0 || freq == 3.33 || freq == 7.85 || freq == 14.67)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.WWV;
                }

                // ke9ns add
                else if (freq >= 0.20 && freq < 1.81)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.BLMF;
                }

                else if (freq >= 2.00 && freq < 3.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B120M;
                }

                else if (freq >= 3.0 && freq < 3.50)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B90M;
                }

                else if (freq > 3.80 && freq < 5.25)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B61M;
                }

                else if (freq >= 5.45 && freq < 7.20)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B49M;
                }

                else if (freq >= 7.20 && freq < 9.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B41M;
                }

                else if (freq >= 9.0 && freq < 10.1)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B31M;
                }

                else if (freq > 10.15 && freq < 13.57)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B25M;
                }

                else if (freq >= 13.57 && freq < 14.00)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B22M;
                }

                else if (freq >= 14.350 && freq < 17.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B19M;
                }

                else if (freq >= 17.0 && freq < 18.0)
                {

                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B16M;
                }

                else if (freq >= 18.0 && freq < 21.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B14M;
                }
                else if (freq >= 21.00 && freq < 25.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B13M;
                }

                else if (freq >= 25.0 && freq < 28.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B11M;
                }

                else
                    return Band.GEN;
            } // Slovakia
            else if (region == FRSRegion.Bulgaria)
            {
                if (freq >= 1.80 && freq <= 2.0) //1.85
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B160M;
                }
                else if (freq >= 3.5 && freq <= 4.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B80M;
                }
                else if (freq >= 5.250 && freq < 5.450) // ke9ns was else if (freq >= 5.3305 && freq < 7.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B60M;
                }
                else if (freq >= 7.0 && freq <= 7.3)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B40M;
                }
                else if (freq >= 10.1 && freq <= 10.15)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B30M;
                }
                else if (freq >= 14.0 && freq <= 14.35)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B20M;
                }
                else if (freq >= 18.068 && freq <= 18.168)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B17M;
                }
                else if (freq >= 21.0 && freq <= 21.45)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B15M;
                }
                else if (freq >= 24.89 && freq <= 24.99)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B12M;
                }
                else if (freq >= 28.0 && freq <= 29.7)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B10M;
                }
                else if (freq >= 50.05 && freq <= 50.2)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B6M;
                }
                else if (freq >= 134.0 && freq <= 163.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B2M;
                }
                else if (freq == 2.5 || freq == 5.0 || freq == 10.0 || freq == 15.0 ||
                        freq == 20.0 || freq == 25.0 || freq == 3.33 || freq == 7.85 || freq == 14.67)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.WWV;
                }
                // ke9ns add
                else if (freq >= 0.20 && freq < 1.81)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.BLMF;
                }

                else if (freq >= 1.85 && freq < 3.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B120M;
                }

                else if (freq >= 3.0 && freq < 3.50)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B90M;
                }

                else if (freq > 3.80 && freq < 5.25)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B61M;
                }

                else if (freq >= 5.45 && freq < 7.20)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B49M;
                }

                else if (freq >= 7.20 && freq < 9.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B41M;
                }

                else if (freq >= 9.0 && freq < 10.1)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B31M;
                }

                else if (freq > 10.15 && freq < 13.57)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B25M;
                }

                else if (freq >= 13.57 && freq < 14.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B22M;
                }

                else if (freq >= 14.350 && freq < 17.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B19M;
                }

                else if (freq >= 17.0 && freq < 18.0)
                {

                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B16M;
                }

                else if (freq >= 18.0 && freq < 21.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B14M;
                }
                else if (freq >= 21.00 && freq < 25.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B13M;
                }

                else if (freq >= 25.0 && freq < 28.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B11M;
                }

                else
                    return Band.GEN;
            } // Bulgaria
            else if (region == FRSRegion.Greece)
            {
                if (freq >= 1.80 && freq <= 2.0) //1.85
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B160M;
                }
                else if (freq >= 3.5 && freq <= 4.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B80M;
                }
                else if (freq >= 5.250 && freq < 5.450) // ke9ns was else if (freq >= 5.3305 && freq < 7.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B60M;
                }
                else if (freq >= 7.0 && freq <= 7.3)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B40M;
                }
                else if (freq >= 10.1 && freq <= 10.15)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B30M;
                }
                else if (freq >= 14.0 && freq <= 14.35)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B20M;
                }
                else if (freq >= 18.068 && freq <= 18.168)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B17M;
                }
                else if (freq >= 21.0 && freq <= 21.45)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B15M;
                }
                else if (freq >= 24.89 && freq <= 24.99)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B12M;
                }
                else if (freq >= 28.0 && freq <= 29.7)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B10M;
                }
                else if (freq >= 134.0 && freq <= 163.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B2M;
                }
                else if (freq == 2.5 || freq == 5.0 || freq == 10.0 || freq == 15.0 ||
                        freq == 20.0 || freq == 25.0 || freq == 3.33 || freq == 7.85 || freq == 14.67)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.WWV;
                }

                // ke9ns add
                else if (freq >= 0.20 && freq < 1.81)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.BLMF;
                }

                else if (freq >= 1.850 && freq < 3.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B120M;
                }

                else if (freq >= 3.0 && freq < 3.50)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B90M;
                }

                else if (freq > 3.80 && freq < 5.25)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B61M;
                }

                else if (freq >= 5.45 && freq < 7.20)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B49M;
                }

                else if (freq >= 7.20 && freq < 9.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B41M;
                }

                else if (freq >= 9.0 && freq < 10.1)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B31M;
                }

                else if (freq > 10.15 && freq < 13.57)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B25M;
                }

                else if (freq >= 13.57 && freq < 14.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B22M;
                }

                else if (freq >= 14.350 && freq < 17.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B19M;
                }

                else if (freq >= 17.0 && freq < 18.0)
                {

                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B16M;
                }

                else if (freq >= 18.0 && freq < 21.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B14M;
                }
                else if (freq >= 21.00 && freq < 25.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B13M;
                }

                else if (freq >= 25.0 && freq < 28.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B11M;
                }


                else
                    return Band.GEN;
            } // Greece
            else if (region == FRSRegion.Hungary)
            {
                if (freq >= 1.80 && freq <= 2.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B160M;
                }
                else if (freq >= 3.5 && freq <= 4.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B80M;
                }
                else if (freq >= 5.250 && freq < 5.450) // ke9ns was else if (freq >= 5.3305 && freq < 7.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B60M;
                }
                else if (freq >= 7.0 && freq <= 7.3)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B40M;
                }
                else if (freq >= 10.1 && freq <= 10.15)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B30M;
                }
                else if (freq >= 14.0 && freq <= 14.35)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B20M;
                }
                else if (freq >= 18.068 && freq <= 18.168)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B17M;
                }
                else if (freq >= 21.0 && freq <= 21.45)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B15M;
                }
                else if (freq >= 24.89 && freq <= 24.99)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B12M;
                }
                else if (freq >= 28.0 && freq <= 29.7)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B10M;
                }
                else if (freq >= 50.0 && freq <= 54.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B10M;
                }
                else if (freq >= 134.0 && freq <= 163.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B2M;
                }
                else if (freq == 2.5 || freq == 5.0 || freq == 10.0 || freq == 15.0 ||
                        freq == 20.0 || freq == 25.0 || freq == 3.33 || freq == 7.85 || freq == 14.67)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.WWV;
                }


                // ke9ns add
                else if (freq >= 0.20 && freq < 1.81)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.BLMF;
                }

                else if (freq >= 2.0 && freq < 3.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B120M;
                }

                else if (freq >= 3.0 && freq < 3.50)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B90M;
                }

                else if (freq >= 3.8 && freq < 5.25)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B61M;
                }

                else if (freq >= 5.45 && freq < 7.00)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B49M;
                }

                else if (freq >= 7.10 && freq < 9.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B41M;
                }

                else if (freq >= 9.0 && freq < 10.1)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B31M;
                }

                else if (freq > 10.15 && freq < 13.57)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B25M;
                }

                else if (freq >= 13.57 && freq < 14.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B22M;
                }

                else if (freq >= 14.350 && freq < 17.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B19M;
                }

                else if (freq >= 17.0 && freq < 18.0)
                {

                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B16M;
                }

                else if (freq >= 18.0 && freq < 21.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B14M;
                }
                else if (freq >= 21.00 && freq < 25.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B13M;
                }

                else if (freq >= 25.0 && freq < 28.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B11M;
                }

                else
                    return Band.GEN;
            } // Hungary
            else if (region == FRSRegion.Belgium)
            {
                if (freq >= 1.80 && freq <= 2.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B160M;
                }
                else if (freq >= 3.5 && freq <= 4.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B80M;
                }
                else if (freq >= 5.250 && freq < 5.450) // ke9ns was else if (freq >= 5.3305 && freq < 7.0) // Tim wanted     else if (freq >= 5.350 && freq < 5.450)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B60M;
                }
                else if (freq >= 7.0 && freq <= 7.3)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B40M;
                }
                else if (freq >= 10.1 && freq <= 10.15)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B30M;
                }
                else if (freq >= 14.0 && freq <= 14.35)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B20M;
                }
                else if (freq >= 18.068 && freq <= 18.168)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B17M;
                }
                else if (freq >= 21.0 && freq <= 21.45)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B15M;
                }
                else if (freq >= 24.89 && freq <= 24.99)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B12M;
                }
                else if (freq >= 28.0 && freq <= 29.7)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B10M;
                }
                else if (freq >= 50.0 && freq <= 54.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B6M;
                }
                else if (freq >= 134.0 && freq <= 163.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B2M;
                }
                else if (freq == 2.5 || freq == 5.0 || freq == 10.0 || freq == 15.0 ||
                        freq == 20.0 || freq == 25.0 || freq == 3.33 || freq == 7.85 || freq == 14.67)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.WWV;
                }

                // ke9ns add
                else if (freq >= 0.20 && freq < 1.81) // Belgium
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.BLMF;
                }

                else if (freq >= 2.0 && freq < 3.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B120M;
                }

                else if (freq >= 3.0 && freq < 3.50)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B90M;
                }

                else if (freq >= 3.8 && freq < 5.25)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B61M;
                }

                else if (freq >= 5.45 && freq < 7.00)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B49M;
                }

                else if (freq >= 7.20 && freq < 9.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B41M;
                }

                else if (freq >= 9.0 && freq < 10.1)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B31M;
                }

                else if (freq > 10.15 && freq < 13.57)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B25M;
                }

                else if (freq >= 13.57 && freq < 14.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B22M;
                }

                else if (freq >= 14.350 && freq < 17.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B19M;
                }

                else if (freq >= 17.0 && freq < 18.0)
                {

                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B16M;
                }

                else if (freq >= 18.0 && freq < 21.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B14M;
                }
                else if (freq >= 21.00 && freq < 25.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B13M;
                }

                else if (freq >= 25.0 && freq < 28.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B11M;
                }

                else
                    return Band.GEN;
            } // Belgium
            else if (region == FRSRegion.France)
            {
                if (freq >= 1.80 && freq <= 2.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B160M;
                }
                else if (freq >= 3.5 && freq <= 4.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B80M;
                }
                else if (freq >= 5.250 && freq < 5.450) // ke9ns was else if (freq >= 5.3305 && freq < 7.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B60M;
                }
                else if (freq >= 7.0 && freq <= 7.3)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B40M;
                }
                else if (freq >= 10.1 && freq <= 10.15)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B30M;
                }
                else if (freq >= 14.0 && freq <= 14.35)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B20M;
                }
                else if (freq >= 18.068 && freq <= 18.168)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B17M;
                }
                else if (freq >= 21.0 && freq <= 21.45)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B15M;
                }
                else if (freq >= 24.89 && freq <= 24.99)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B12M;
                }
                else if (freq >= 28.0 && freq <= 29.7)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B10M;
                }
                else if (freq >= 50.0 && freq <= 54.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B6M;
                }
                else if (freq >= 134.0 && freq <= 163.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B2M;
                }
                else if (freq == 2.5 || freq == 5.0 || freq == 10.0 || freq == 15.0 ||
                        freq == 20.0 || freq == 25.0 || freq == 3.33 || freq == 7.85 || freq == 14.67)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.WWV;
                }

                // ke9ns add
                else if (freq >= 0.20 && freq < 1.81)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.BLMF;
                }

                else if (freq >= 2.0 && freq < 3.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B120M;
                }

                else if (freq >= 3.0 && freq < 3.50)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B90M;
                }

                else if (freq >= 3.8 && freq < 5.25)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B61M;
                }

                else if (freq >= 5.45 && freq < 7.00)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B49M;
                }

                else if (freq >= 7.20 && freq < 9.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B41M;
                }

                else if (freq >= 9.0 && freq < 10.1)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B31M;
                }

                else if (freq > 10.15 && freq < 13.57)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B25M;
                }

                else if (freq >= 13.57 && freq < 14.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B22M;
                }

                else if (freq >= 14.350 && freq < 17.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B19M;
                }

                else if (freq >= 17.0 && freq < 18.0)
                {

                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B16M;
                }

                else if (freq >= 18.0 && freq < 21.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B14M;
                }
                else if (freq >= 21.00 && freq < 25.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B13M;
                }

                else if (freq >= 25.0 && freq < 28.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B11M;
                }

                else
                    return Band.GEN;
            } // France
            else if (region == FRSRegion.Russia)
            {
                if (freq >= 1.80 && freq <= 2.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B160M;
                }
                else if (freq >= 3.5 && freq <= 4.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B80M;
                }
                else if (freq >= 5.250 && freq < 5.450) // ke9ns was else if (freq >= 5.3305 && freq < 7.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B60M;
                }
                else if (freq >= 7.0 && freq <= 7.3)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B40M;
                }
                else if (freq >= 10.1 && freq <= 10.15)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B30M;
                }
                else if (freq >= 14.0 && freq <= 14.35)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B20M;
                }
                else if (freq >= 18.068 && freq <= 18.168)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B17M;
                }
                else if (freq >= 21.0 && freq <= 21.45)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B15M;
                }
                else if (freq >= 24.89 && freq <= 25.14)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B12M;
                }
                else if (freq >= 26.97 && freq <= 27.86)
                {
                    if (A) panelBandHF.Visible = false; if (A) panelBandGN.Visible = true; return Band.B11M; // ke9ns add  return Band.B11M;
                }
                else if (freq >= 28.00 && freq <= 29.7)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B10M;
                }
                else if (freq >= 134.0 && freq <= 163.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B2M;
                }
                else if (freq == 2.5 || freq == 5.0 || freq == 10.0 || freq == 15.0 ||
                        freq == 20.0 || freq == 25.0 || freq == 3.33 || freq == 7.85 || freq == 14.67)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.WWV;
                }

                // ke9ns add
                else if (freq >= 0.20 && freq < 1.81)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.BLMF;
                }

                else if (freq >= 2.00 && freq < 3.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B120M;
                }

                else if (freq >= 3.0 && freq < 3.50)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B90M;
                }

                else if (freq >= 3.8 && freq < 5.25)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B61M;
                }

                else if (freq >= 5.45 && freq < 7.00)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B49M;
                }

                else if (freq >= 7.20 && freq < 9.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B41M;
                }

                else if (freq >= 9.0 && freq < 10.1)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B31M;
                }

                else if (freq > 10.15 && freq < 13.57)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B25M;
                }

                else if (freq >= 13.57 && freq < 14.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B22M;
                }

                else if (freq >= 14.350 && freq < 17.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B19M;
                }

                else if (freq >= 17.0 && freq < 18.0)
                {

                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B16M;
                }

                else if (freq >= 18.0 && freq < 21.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B14M;
                }
                else if (freq >= 21.00 && freq < 25.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B13M;
                }

                else if (freq >= 25.0 && freq < 28.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B11M;
                }

                else
                    return Band.GEN;
            } // Russia
            else if (region == FRSRegion.Sweden)
            {
                if (freq >= 1.80 && freq <= 2.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B160M;
                }
                else if (freq >= 3.5 && freq <= 4.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B80M;
                }
                else if (freq >= 5.250 && freq < 5.450) // ke9ns was else if (freq >= 5.3305 && freq < 7.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B60M;
                }
                else if (freq >= 7.0 && freq <= 7.3)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B40M;
                }
                else if (freq >= 10.1 && freq <= 10.15)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B30M;
                }
                else if (freq >= 14.0 && freq <= 14.35)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B20M;
                }
                else if (freq >= 18.068 && freq <= 18.168)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B17M;
                }
                else if (freq >= 21.0 && freq <= 21.45)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B15M;
                }
                else if (freq >= 24.89 && freq <= 24.99)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B12M;
                }
                else if (freq >= 28.0 && freq <= 29.7)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B10M;
                }
                else if (freq >= 50.0 && freq <= 54.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B6M;
                }
                else if (freq >= 134.0 && freq <= 163.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B2M;
                }
                else if (freq == 2.5 || freq == 5.0 || freq == 10.0 || freq == 15.0 ||
                        freq == 20.0 || freq == 25.0 || freq == 3.33 || freq == 7.85 || freq == 14.67)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.WWV;
                }
                // ke9ns add
                else if (freq >= 0.20 && freq < 1.81) // sweden
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.BLMF;
                }

                else if (freq >= 2.0 && freq < 3.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B120M;
                }

                else if (freq >= 3.0 && freq < 3.50)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B90M;
                }

                else if (freq >= 3.8 && freq < 5.25)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B61M;
                }

                else if (freq >= 5.45 && freq < 7.00)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B49M;
                }

                else if (freq >= 7.20 && freq < 9.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B41M;
                }

                else if (freq >= 9.0 && freq < 10.1)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B31M;
                }

                else if (freq > 10.15 && freq < 13.57)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B25M;
                }

                else if (freq >= 13.57 && freq < 14.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B22M;
                }

                else if (freq >= 14.350 && freq < 17.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B19M;
                }

                else if (freq >= 17.0 && freq < 18.0)
                {

                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B16M;
                }

                else if (freq >= 18.0 && freq < 21.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B14M;
                }
                else if (freq >= 21.00 && freq < 25.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B13M;
                }

                else if (freq >= 25.0 && freq < 28.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B11M;
                }

                else
                    return Band.GEN;
            } // Sweden
            else if (region == FRSRegion.IARU3)
            {
                if (freq >= 1.8 && freq <= 2.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B160M;
                }
                else if (freq >= 3.5 && freq <= 3.9)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B80M;
                }
                else if (freq >= 5.250 && freq < 5.450) // ke9ns was else if (freq >= 5.3305 && freq < 7.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B60M; // ke9ns add An interim bandplan was adopted by IARU Region 1 in April 2016, for the WRC-15 allocation (5351.5 - 5366.5 kHz)
                }
                else if (freq >= 7.0 && freq <= 7.3)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B40M;
                }
                else if (freq >= 10.1 && freq <= 10.15)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B30M;
                }
                else if (freq >= 14.0 && freq <= 14.35)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B20M;
                }
                else if (freq >= 18.068 && freq <= 18.168)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B17M;
                }
                else if (freq >= 21.0 && freq <= 21.45)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B15M;
                }
                else if (freq >= 24.89 && freq <= 24.99)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B12M;
                }
                else if (freq >= 28.0 && freq <= 29.7)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B10M;
                }
                else if (freq >= 50.0 && freq <= 54.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B6M;
                }
                else if (freq >= 134.0 && freq <= 163.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B2M;
                }
                else if (freq == 2.5 || freq == 5.0 || freq == 10.0 || freq == 15.0 ||
                        freq == 20.0 || freq == 25.0 || freq == 3.33 || freq == 7.85 || freq == 14.67)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.WWV;
                }

                // ke9ns add
                else if (freq >= 0.20 && freq < 1.80) // IARU3
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.BLMF;
                }

                else if (freq >= 2.0 && freq < 3.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B120M;
                }

                else if (freq >= 3.0 && freq < 3.50)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B90M;
                }

                else if (freq >= 3.9 && freq < 5.25)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B61M;
                }

                else if (freq >= 5.45 && freq < 7.00)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B49M;
                }

                else if (freq >= 7.30 && freq < 9.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B41M;
                }

                else if (freq >= 9.0 && freq < 10.1)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B31M;
                }

                else if (freq > 10.15 && freq < 13.57)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B25M;
                }

                else if (freq >= 13.57 && freq < 14.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B22M;
                }

                else if (freq >= 14.350 && freq < 17.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B19M;
                }

                else if (freq >= 17.0 && freq < 18.0)
                {

                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B16M;
                }

                else if (freq >= 18.0 && freq < 21.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B14M;
                }
                else if (freq >= 21.00 && freq < 25.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B13M;
                }

                else if (freq >= 25.0 && freq < 28.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B11M;
                }

                else
                    return Band.GEN;
            } // IARU3
            else if (region == FRSRegion.Japan)
            {
                if (freq >= 1.80 && freq <= 2.0) //1.9125
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B160M;
                }
                else if (freq >= 3.5 && freq <= 3.805)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B80M;
                }
                else if (freq >= 5.250 && freq < 5.450) // ke9ns was else if (freq >= 5.3305 && freq < 7.0) //else if (freq >= 4.629995 && freq <= 4.630005)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B60M;
                }
                else if (freq >= 7.0 && freq <= 7.3)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B40M;
                }
                else if (freq >= 10.1 && freq <= 10.15)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B30M;
                }
                else if (freq >= 14.0 && freq <= 14.35)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B20M;
                }
                else if (freq >= 18.068 && freq <= 18.168)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B17M;
                }
                else if (freq >= 21.0 && freq <= 21.45)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B15M;
                }
                else if (freq >= 24.89 && freq <= 24.99)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B12M;
                }
                else if (freq >= 28.0 && freq <= 29.7)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B10M;
                }
                else if (freq >= 50.0 && freq <= 54.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B6M;
                }
                else if (freq >= 134.0 && freq <= 163.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B2M;
                }
                else if (freq == 2.5 || freq == 5.0 || freq == 10.0 || freq == 15.0 ||
                        freq == 20.0 || freq == 25.0 || freq == 3.33 || freq == 7.85 || freq == 14.67)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.WWV;
                }

                // ke9ns add
                else if (freq >= 0.20 && freq < 1.81)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.BLMF;
                }

                else if (freq >= 1.912 && freq < 3.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B120M;
                }

                else if (freq >= 3.0 && freq < 3.50)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B90M;
                }

                else if (freq >= 3.805 && freq < 5.25)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B61M;
                }

                else if (freq >= 5.45 && freq < 7.00)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B49M;
                }

                else if (freq >= 7.20 && freq < 9.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B41M;
                }

                else if (freq >= 9.0 && freq < 10.1)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B31M;
                }

                else if (freq > 10.15 && freq < 13.57)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B25M;
                }

                else if (freq >= 13.57 && freq < 14.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B22M;
                }

                else if (freq >= 14.350 && freq < 17.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B19M;
                }

                else if (freq >= 17.0 && freq < 18.0)
                {

                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B16M;
                }

                else if (freq >= 18.0 && freq < 21.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B14M;
                }
                else if (freq >= 21.00 && freq < 25.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B13M;
                }

                else if (freq >= 25.0 && freq < 28.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B11M;
                }

                else
                    return Band.GEN;
            } // Japan
            else if (region == FRSRegion.Italy_Plus)
            {
                if (freq >= 1.80 && freq <= 2.0) //1.85
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B160M;
                }
                else if (freq >= 3.5 && freq <= 4.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B80M;
                }
                else if (freq >= 5.250 && freq < 5.450) // ke9ns was else if (freq >= 5.3305 && freq < 7.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B60M;
                }
                else if (freq >= 6.975 && freq <= 7.3) //6.975
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B40M;
                }
                else if (freq >= 10.1 && freq <= 10.15)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B30M;
                }
                else if (freq >= 14.0 && freq <= 14.35)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B20M;
                }
                else if (freq >= 18.068 && freq <= 18.168)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B17M;
                }
                else if (freq >= 21.0 && freq <= 21.45)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B15M;
                }
                else if (freq >= 24.89 && freq <= 24.99)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B12M;
                }
                else if (freq >= 28.0 && freq <= 29.7)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B10M;
                }
                else if (freq >= 50.00 && freq <= 51.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B6M;
                }
                else if (freq >= 134.0 && freq <= 163.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B2M;
                }
                else if (freq == 2.5 || freq == 5.0 || freq == 10.0 || freq == 15.0 ||
                        freq == 20.0 || freq == 25.0 || freq == 3.33 || freq == 7.85 || freq == 14.67)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.WWV;
                }
                // ke9ns add
                else if (freq >= 0.20 && freq < 1.83)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.BLMF;
                }

                else if (freq >= 2.0 && freq < 3.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B120M;
                }

                else if (freq >= 3.0 && freq < 3.50)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B90M;
                }

                else if (freq >= 3.8 && freq < 5.25)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B61M;
                }

                else if (freq >= 5.45 && freq < 6.975) // italy+
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B49M;
                }

                else if (freq >= 7.20 && freq < 9.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B41M;
                }

                else if (freq >= 9.0 && freq < 10.1)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B31M;
                }

                else if (freq > 10.15 && freq < 13.57)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B25M;
                }

                else if (freq >= 13.57 && freq < 14.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B22M;
                }

                else if (freq >= 14.350 && freq < 17.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B19M;
                }

                else if (freq >= 17.0 && freq < 18.0)
                {

                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B16M;
                }

                else if (freq >= 18.0 && freq < 21.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B14M;
                }
                else if (freq >= 21.00 && freq < 25.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B13M;
                }

                else if (freq >= 25.0 && freq < 28.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B11M;
                }

                else
                    return Band.GEN;

            }// italy+
            else if (region == FRSRegion.ES_CH_FIN) // Spain switz and finland
            {
                if (freq >= 1.80 && freq <= 2.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B160M;
                }
                else if (freq >= 3.5 && freq <= 4.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B80M;
                }
                else if (freq >= 5.250 && freq < 5.450) // w4tme - matches region allocation else if (freq >= 5.3515 && freq < 5.3665) 
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B60M;
                }
                else if (freq >= 7.0 && freq <= 7.3)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B40M;
                }
                else if (freq >= 10.1 && freq <= 10.15)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B30M;
                }
                else if (freq >= 14.0 && freq <= 14.35)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B20M;
                }
                else if (freq >= 18.068 && freq <= 18.168)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B17M;
                }
                else if (freq >= 21.0 && freq <= 21.45)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B15M;
                }
                else if (freq >= 24.89 && freq <= 24.99)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B12M;
                }
                else if (freq >= 28.0 && freq <= 29.7)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B10M;
                }
                else if (freq >= 50.0 && freq <= 54.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B6M;
                }
                else if (freq >= 134.0 && freq <= 163.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B2M;
                }
                else if (freq == 2.5 || freq == 5.0 || freq == 10.0 || freq == 15.0 ||
                        freq == 20.0 || freq == 25.0 || freq == 3.33 || freq == 7.85 || freq == 14.67)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.WWV;
                }
                // ke9ns add
                else if (freq >= 0.20 && freq < 1.80)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.BLMF;
                }

                else if (freq >= 2.00 && freq < 3.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B120M;
                }

                else if (freq >= 3.0 && freq < 3.50)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B90M;
                }

                else if (freq >= 3.80 && freq < 5.25)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B61M;
                }

                else if (freq >= 5.45 && freq < 7.00)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B49M;
                }

                else if (freq >= 7.20 && freq < 9.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B41M;
                }

                else if (freq >= 9.0 && freq < 10.1)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B31M;
                }

                else if (freq > 10.15 && freq < 13.57)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B25M;
                }

                else if (freq >= 13.57 && freq < 14.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B22M;
                }

                else if (freq >= 14.350 && freq < 17.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B19M;
                }

                else if (freq >= 17.0 && freq < 18.0)
                {

                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B16M;
                }

                else if (freq >= 18.0 && freq < 21.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B14M;
                }
                else if (freq >= 21.00 && freq < 25.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B13M;
                }

                else if (freq >= 25.0 && freq < 28.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B11M;
                }

                else
                    return Band.GEN;
            } // Spain, Switz, Finland
            else if (region == FRSRegion.Netherlands)
            {
                if (freq >= 1.80 && freq <= 2.0) //1.88
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B160M;
                }
                else if (freq >= 3.5 && freq <= 4.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B80M;
                }
                else if (freq >= 5.250 && freq < 5.450) // ke9ns was else if (freq >= 5.3305 && freq < 7.0), w4tme changed lower freq to 5.350
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B60M; // ke9ns
                }
                else if (freq >= 7.0 && freq <= 7.3)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B40M;
                }
                else if (freq >= 10.1 && freq <= 10.15)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B30M;
                }
                else if (freq >= 14.0 && freq <= 14.35)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B20M;
                }
                else if (freq >= 18.068 && freq <= 18.168)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B17M;
                }
                else if (freq >= 21.0 && freq <= 21.45)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B15M;
                }
                else if (freq >= 24.89 && freq <= 24.99)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B12M;
                }
                else if (freq >= 28.0 && freq <= 29.7)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B10M;
                }
                else if (freq >= 50.0 && freq <= 54.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B6M;
                }
                else if (freq >= 134.0 && freq <= 163.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B2M;
                }
                else if (freq == 2.5 || freq == 5.0 || freq == 10.0 || freq == 15.0 ||
                        freq == 20.0 || freq == 25.0 || freq == 3.33 || freq == 7.85 || freq == 14.67)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.WWV;
                }

                // ke9ns add
                else if (freq >= 0.20 && freq < 1.80)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.BLMF;
                }

                else if (freq >= 1.88 && freq < 3.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B120M;
                }

                else if (freq >= 3.0 && freq < 3.50)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B90M;
                }

                else if (freq >= 3.8 && freq < 5.25)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B61M;
                }

                else if (freq >= 5.45 && freq < 7.00)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B49M;
                }

                else if (freq >= 7.20 && freq < 9.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B41M;
                }

                else if (freq >= 9.0 && freq < 10.1)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B31M;
                }

                else if (freq > 10.15 && freq < 13.57)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B25M;
                }

                else if (freq >= 13.57 && freq < 14.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B22M;
                }

                else if (freq >= 14.350 && freq < 17.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B19M;
                }

                else if (freq >= 17.0 && freq < 18.0)
                {

                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B16M;
                }

                else if (freq >= 18.0 && freq < 21.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B14M;
                }
                else if (freq >= 21.00 && freq < 25.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B13M;
                }

                else if (freq >= 25.0 && freq < 28.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B11M;
                }

                else
                    return Band.GEN;
            } // Netherlands
            else if (region == FRSRegion.EU_Travel)
            {
                if (freq >= 1.80 && freq <= 2.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B160M;
                }
                else if (freq >= 3.5 && freq <= 4.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B80M;
                }
                else if (freq >= 5.250 && freq < 5.450) // ke9ns was else if (freq >= 5.3305 && freq < 7.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B60M;
                }
                else if (freq >= 7.0 && freq <= 7.3)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B40M;
                }
                else if (freq >= 10.1 && freq <= 10.15)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B30M;
                }
                else if (freq >= 14.0 && freq <= 14.35)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B20M;
                }
                else if (freq >= 18.068 && freq <= 18.168)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B17M;
                }
                else if (freq >= 21.0 && freq <= 21.45)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B15M;
                }
                else if (freq >= 24.89 && freq <= 24.99)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B12M;
                }
                else if (freq >= 28.0 && freq <= 29.7)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B10M;
                }
                else if (freq >= 50.0 && freq <= 54.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B6M;
                }
                else if (freq >= 134.0 && freq <= 163.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B2M;
                }
                else if (freq == 2.5 || freq == 5.0 || freq == 10.0 || freq == 15.0 ||
                        freq == 20.0 || freq == 25.0 || freq == 3.33 || freq == 7.85 || freq == 14.67)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.WWV;
                }

                // ke9ns add
                else if (freq >= 0.20 && freq < 1.80) // EU travel
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.BLMF;
                }

                else if (freq >= 2.0 && freq < 3.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B120M;
                }

                else if (freq >= 3.0 && freq < 3.50)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B90M;
                }

                else if (freq >= 3.8 && freq < 5.25)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B61M;
                }

                else if (freq >= 5.45 && freq < 7.00)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B49M;
                }

                else if (freq >= 7.20 && freq < 9.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B41M;
                }

                else if (freq >= 9.0 && freq < 10.1)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B31M;
                }

                else if (freq > 10.15 && freq < 13.57)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B25M;
                }

                else if (freq >= 13.57 && freq < 14.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B22M;
                }

                else if (freq >= 14.350 && freq < 17.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B19M;
                }

                else if (freq >= 17.0 && freq < 18.0)
                {

                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B16M;
                }

                else if (freq >= 18.0 && freq < 21.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B14M;
                }
                else if (freq >= 21.00 && freq < 25.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B13M;
                }

                else if (freq >= 25.0 && freq < 28.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B11M;
                }

                else
                    return Band.GEN;
            } // EU travel
            else if (region == FRSRegion.Luxembourg)
            {
                if (freq >= 1.80 && freq <= 2.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B160M;
                }
                else if (freq >= 3.5 && freq <= 4.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B80M;
                }
                else if (freq >= 5.3515 && freq < 5.3665) // w4tme - matches region allocation
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B60M;
                }
                else if (freq >= 7.0 && freq <= 7.3)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B40M;
                }
                else if (freq >= 10.1 && freq <= 10.15)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B30M;
                }
                else if (freq >= 14.0 && freq <= 14.35)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B20M;
                }
                else if (freq >= 18.068 && freq <= 18.168)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B17M;
                }
                else if (freq >= 21.0 && freq <= 21.45)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B15M;
                }
                else if (freq >= 24.89 && freq <= 24.99)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B12M;
                }
                else if (freq >= 28.0 && freq <= 29.7)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B10M;
                }
                else if (freq >= 50.0 && freq <= 54.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B6M;
                }
                else if (freq >= 134.0 && freq <= 163.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B2M;
                }
                else if (freq == 2.5 || freq == 5.0 || freq == 10.0 || freq == 15.0 ||
                        freq == 20.0 || freq == 25.0 || freq == 3.33 || freq == 7.85 || freq == 14.67)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.WWV;
                }
                // ke9ns add
                else if (freq >= 0.20 && freq < 1.81)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.BLMF;
                }

                else if (freq >= 2.0 && freq < 3.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B120M;
                }

                else if (freq >= 3.0 && freq < 3.50)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B90M;
                }

                else if (freq >= 3.8 && freq < 5.25)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B61M;
                }

                else if (freq >= 5.45 && freq < 7.00)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B49M;
                }

                else if (freq >= 7.20 && freq < 9.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B41M;
                }

                else if (freq >= 9.0 && freq < 10.1)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B31M;
                }

                else if (freq > 10.15 && freq < 13.57)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B25M;
                }

                else if (freq >= 13.57 && freq < 14.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B22M;
                }

                else if (freq >= 14.350 && freq < 17.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B19M;
                }

                else if (freq >= 17.0 && freq < 18.0)
                {

                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B16M;
                }

                else if (freq >= 18.0 && freq < 21.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B14M;
                }
                else if (freq >= 21.00 && freq < 25.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B13M;
                }

                else if (freq >= 25.0 && freq < 28.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B11M;
                }

                else
                    return Band.GEN;
            }
            else if (region == FRSRegion.IARU2) // 
            {
                if (freq >= 1.8 && freq <= 2.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B160M;
                }
                else if (freq >= 3.5 && freq <= 4.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B80M;
                }
                else if (freq >= 5.25 && freq <= 5.45) // else if (freq >= 5.1 && freq <= 5.5)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B60M;
                }
                else if (freq >= 7.0 && freq <= 7.3)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B40M;
                }
                else if (freq >= 10.1 && freq <= 10.15)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B30M;
                }
                else if (freq >= 14.0 && freq <= 14.35)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B20M;
                }
                else if (freq >= 18.068 && freq <= 18.168)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B17M;
                }
                else if (freq >= 21.0 && freq <= 21.450)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B15M;
                }
                else if (freq >= 24.89 && freq <= 24.99)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B12M;
                }
                else if (freq >= 28.0 && freq <= 29.7)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B10M;
                }
                else if (freq >= 50.0 && freq <= 54.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B6M;
                }
                else if (freq >= 134.0 && freq <= 163.0) // ke9ns test was 144.0 148.0
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B2M;
                }
                else if (freq == 2.5 || freq == 5.0 || freq == 10.0 || freq == 15.0 ||
                        freq == 20.0 || freq == 25.0 || freq == 3.33 || freq == 7.85 || freq == 14.67)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.WWV;
                }
                // ke9ns add
                else if (freq >= 0.20 && freq < 1.80)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.BLMF;
                }

                else if (freq >= 2.00 && freq < 3.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B120M;
                }

                else if (freq >= 3.0 && freq < 3.50)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B90M;
                }

                else if (freq >= 4.00 && freq < 5.25)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B61M;
                }

                else if (freq >= 5.45 && freq < 7.00)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B49M;
                }

                else if (freq >= 7.30 && freq < 9.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B41M;
                }

                else if (freq >= 9.0 && freq < 10.1)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B31M;
                }

                else if (freq > 10.15 && freq < 13.57)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B25M;
                }

                else if (freq >= 13.57 && freq < 14.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B22M;
                }

                else if (freq >= 14.350 && freq < 17.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B19M;
                }

                else if (freq >= 17.0 && freq < 18.0)
                {

                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B16M;
                }

                else if (freq >= 18.0 && freq < 21.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B14M;
                }
                else if (freq >= 21.00 && freq < 25.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B13M;
                }

                else if (freq >= 25.0 && freq < 28.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B11M;
                }

                else
                    return Band.GEN;
            } // region_2
            else if (region == FRSRegion.Australia) // ke9ns add
            {
                if (freq >= 1.8 && freq <= 2.0) //1.875
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B160M;
                }
                else if (freq >= 3.5 && freq <= 4.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B80M;
                }
                else if (freq >= 5.25 && freq <= 5.45) // else if (freq >= 5.1 && freq <= 5.5)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B60M;
                }
                else if (freq >= 7.0 && freq <= 7.3)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B40M;
                }
                else if (freq >= 10.1 && freq <= 10.15)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B30M;
                }
                else if (freq >= 14.0 && freq <= 14.35)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B20M;
                }
                else if (freq >= 18.068 && freq <= 18.168)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B17M;
                }
                else if (freq >= 21.0 && freq <= 21.450)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B15M;
                }
                else if (freq >= 24.89 && freq <= 24.99)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B12M;
                }
                else if (freq >= 28.0 && freq <= 29.7)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B10M;
                }
                else if (freq >= 50.0 && freq <= 54.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B6M;
                }
                else if (freq >= 134.0 && freq <= 163.0) // ke9ns 
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B2M;
                }
                else if (freq == 2.5 || freq == 5.0 || freq == 10.0 || freq == 15.0 ||
                        freq == 20.0 || freq == 25.0 || freq == 3.33 || freq == 7.85 || freq == 14.67)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.WWV;
                }
                // ke9ns add
                else if (freq >= 0.20 && freq < 1.80)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.BLMF;
                }

                else if (freq >= 1.875 && freq < 3.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B120M;
                }

                else if (freq >= 3.0 && freq < 3.50)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B90M;
                }

                else if (freq > 3.8 && freq < 5.25)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B61M;
                }

                else if (freq >= 5.45 && freq < 7.00)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B49M;
                }

                else if (freq >= 7.30 && freq < 9.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B41M;
                }

                else if (freq >= 9.0 && freq < 10.1)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B31M;
                }

                else if (freq > 10.15 && freq < 13.57)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B25M;
                }

                else if (freq >= 13.57 && freq < 14.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B22M;
                }

                else if (freq >= 14.350 && freq < 17.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B19M;
                }

                else if (freq >= 17.0 && freq < 18.0)
                {

                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B16M;
                }

                else if (freq >= 18.0 && freq < 21.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B14M;
                }
                else if (freq >= 21.00 && freq < 25.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B13M;
                }

                else if (freq >= 25.0 && freq < 28.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B11M;
                }

                else
                    return Band.GEN;
            } // Australia
            else if (region == FRSRegion.China)
            {
                if (freq >= 1.8 && freq <= 2.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B160M;
                }
                else if (freq >= 3.5 && freq <= 3.9)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B80M;
                }
                else if (freq >= 5.250 && freq < 5.450)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B60M;
                }
                else if (freq >= 7.0 && freq <= 7.3)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B40M;
                }
                else if (freq >= 10.1 && freq <= 10.15)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B30M;
                }
                else if (freq >= 14.0 && freq <= 14.35)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B20M;
                }
                else if (freq >= 18.068 && freq <= 18.168)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B17M;
                }
                else if (freq >= 21.0 && freq <= 21.45)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B15M;
                }
                else if (freq >= 24.89 && freq <= 24.99)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B12M;
                }
                else if (freq >= 28.0 && freq <= 29.7)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B10M;
                }
                else if (freq >= 50.0 && freq <= 54.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B6M;
                }
                else if (freq >= 134.0 && freq <= 163.0)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.B2M;
                }
                else if (freq == 2.5 || freq == 5.0 || freq == 10.0 || freq == 15.0 ||
                        freq == 20.0 || freq == 25.0 || freq == 3.33 || freq == 7.85 || freq == 14.67)
                {
                    if (A) { panelBandHF.Visible = true; panelBandGN.Visible = false; } else { if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; }
                    return Band.WWV;
                }

                // ke9ns add
                else if (freq >= 0.20 && freq < 1.80) // china
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.BLMF;
                }

                else if (freq >= 2.0 && freq < 3.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B120M;
                }

                else if (freq >= 3.0 && freq < 3.50)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B90M;
                }

                else if (freq >= 3.9 && freq < 5.25)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B61M;
                }

                else if (freq >= 5.45 && freq < 7.00)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B49M;
                }

                else if (freq >= 7.30 && freq < 9.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B41M;
                }

                else if (freq >= 9.0 && freq < 10.1)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B31M;
                }

                else if (freq > 10.15 && freq < 13.57)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B25M;
                }

                else if (freq >= 13.57 && freq < 14.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B22M;
                }

                else if (freq >= 14.350 && freq < 17.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B19M;
                }

                else if (freq >= 17.0 && freq < 18.0)
                {

                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B16M;
                }

                else if (freq >= 18.0 && freq < 21.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B14M;
                }
                else if (freq >= 21.00 && freq < 25.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B13M;
                }

                else if (freq >= 25.0 && freq < 28.0)
                {
                    if (A) panelBandHF.Visible = false;
                    if (A) panelBandGN.Visible = true;
                    return Band.B11M;
                }

                else
                    return Band.GEN;
            } // China





            // if nothing matched to this point, just put it in the GEN band
            return Band.GEN;


        } // bandbyfreq


        //==================================================================================
        private void SetRX1Band(Band b)
        {

            //   panelBandHF.Invalidate(); // ke9ns add
            //  panelBandVHF.Invalidate(); // ke9ns add
            // panelBandGN.Invalidate(); // ke9ns add


            if (disable_split_on_bandchange)
            {
                if (RX1Band != b && !tuning)
                {
                    if (chkVFOSplit.Checked)
                        chkVFOSplit.Checked = false;
                }
            }

            Band old_band = rx1_band;
            RX1Band = b;
            if (old_band != b)
            {
                UpdateBandButtonColors();
                UpdateWaterfallLevelValues();

                if (current_model == Model.FLEX3000 && chkFWCATU.Checked && flex3000ATUForm.chkAutoMode.Checked) //band change atu
                {
                    flex3000ATUForm.autoMode = true;
                    flex3000ATUForm.DoTune();   //make sure autoMode=true is passed
                }

                if (current_model == Model.FLEX5000 && chkFWCATU.Checked && fwcAtuForm.ATUEnabledOnBandChange()) // atu tune on band change
                {
                    switch (b)
                    {
                        case Band.B160M:
                        case Band.B80M:
                        case Band.B60M:
                        case Band.B40M:
                        case Band.B30M:
                        case Band.B20M:
                        case Band.B17M:
                        case Band.B15M:
                        case Band.B12M:
                        case Band.B10M:
                        case Band.B6M:
                            {
                                fwcAtuForm.DoTuneMemory();
                                FWCATUTuned();
                                break;
                            }
                        default: break;
                    }
                }

                if (setupForm != null) // ke9ns add: Force UPDATE of ANT Display .119
                {
                    if (current_model == Model.FLEX5000)
                    {
                        if (fwcAntForm.radModeExpert.Checked)
                        {
                            CurrentAntMode = AntMode.Expert;
                            fwcAntForm.CurrentAntMode = current_ant_mode;
                            fwcAntForm.RX1Ant = rx1_ant;
                            fwcAntForm.RX1Loop = rx1_loop;
                            fwcAntForm.RX2Ant = rx2_ant;
                            fwcAntForm.TXAnt = tx_ant;
                            fwcAntForm.TXAnt2 = tx_ant2; // ke9ns add .205
                        }
                        else CurrentAntMode = AntMode.Simple;
                    }
                }

            }

            if (rx1_xvtr_index >= 0)
            {
                panelBandHF.Visible = false;
                panelBandGN.Visible = false; // ke9ns add

                panelBandVHF.Visible = true;

            }
            else
            {
                panelBandGN.Visible = true; //ke9ns add
                                            //   Debug.WriteLine("bandchange");
                                            //  panelBandHF.Visible = true;

                panelBandVHF.Visible = false;
            }

        } //SETRX1BAND

        private void SetRX2Band(Band b)
        {
            Band old_band = rx2_band;
            RX2Band = b;
            if (old_band != b)
                UpdateBandButtonColors();

            if (setupForm != null) // ke9ns add: Force UPDATE of ANT Display .119
            {
                if (current_model == Model.FLEX5000)
                {
                    if (fwcAntForm.radModeExpert.Checked)
                    {
                        CurrentAntMode = AntMode.Expert;
                        fwcAntForm.CurrentAntMode = current_ant_mode;
                        fwcAntForm.RX1Ant = rx1_ant;
                        fwcAntForm.RX1Loop = rx1_loop;
                        fwcAntForm.RX2Ant = rx2_ant;
                        fwcAntForm.TXAnt = tx_ant;
                        fwcAntForm.TXAnt2 = tx_ant2; // ke9ns add .205
                    }
                    else CurrentAntMode = AntMode.Simple;
                }

            }

        } //  SetRX2Band(Band b)

        private void SetTXBand(Band b)
        {
            // panelBandHF.Invalidate(); // ke9ns add
            // panelBandVHF.Invalidate(); // ke9ns add
            // panelBandGN.Invalidate(); // ke9ns add


            if (disable_split_on_bandchange)
            {
                if (TXBand != b && !tuning)
                {
                    if (chkVFOSplit.Checked) chkVFOSplit.Checked = false;
                }
            }

            Band old_band = tx_band;

            //  Debug.WriteLine("HIGH-LOW " + " Tband: " + tx_band + " new tx band " + b);

            TXBand = b;

            if (old_band != b) UpdateBandButtonColors();

            if (!(fwc_init && (current_model == Model.FLEX5000 || current_model == Model.FLEX3000)))
            {
                if (atu_present && xvtr_present)
                {
                    if (b == Band.B2M) comboTuneMode.Enabled = false;
                    else
                        comboTuneMode.Enabled = true;
                }

                if (xvtr_present)
                {
                    if (atu_present &&
                        comboTuneMode.SelectedIndex > 0 &&
                        (ATUTuneMode)comboTuneMode.SelectedIndex != ATUTuneMode.BYPASS &&
                        (tuned_band != b) &&
                        tuned_band != Band.FIRST)
                    {
                        Hdw.PA_ATUTune(ATUTuneMode.BYPASS);
                        tuned_band = Band.FIRST;
                        chkTUN.BackColor = SystemColors.Control;
                    }

                    if (b == Band.B2M)
                    {
                        if (comboPreamp.Items.Contains("Off"))
                            comboPreamp.Items.Remove("Off");
                        if (comboPreamp.Items.Contains("Med"))
                            comboPreamp.Items.Remove("Med");
                        if (comboPreamp.SelectedIndex < 0)
                            comboPreamp.Text = "High";
                    }
                    else
                    {
                        if (!comboPreamp.Items.Contains("Off"))
                            comboPreamp.Items.Insert(0, "Off");
                        if (!comboPreamp.Items.Contains("Med"))
                            comboPreamp.Items.Insert(2, "Med");
                    }
                }
            }
        } //settxband

        private float GainByBand(Band b) // 
        {
            float retval = 0;
            switch (b)
            {
                case Band.B160M:
                    retval = setupForm.PAGain160;
                    break;
                case Band.B80M:
                    retval = setupForm.PAGain80;
                    break;
                case Band.B60M:
                    retval = setupForm.PAGain60;
                    break;
                case Band.B40M:
                    retval = setupForm.PAGain40;
                    break;
                case Band.B30M:
                    retval = setupForm.PAGain30;
                    break;
                case Band.B20M:
                    retval = setupForm.PAGain20;
                    break;
                case Band.B17M:
                    retval = setupForm.PAGain17;
                    break;
                case Band.B15M:
                    retval = setupForm.PAGain15;
                    break;
                case Band.B12M:
                    retval = setupForm.PAGain12;
                    break;
                case Band.B10M:
                    retval = setupForm.PAGain10;
                    break;
                case Band.B6M:
                    if (current_model == Model.FLEX5000 || current_model == Model.FLEX3000)
                        retval = setupForm.PAGain10;
                    else retval = 1000;
                    break;
                default:
                    retval = 1000;
                    break;
            }

            return retval;
        }

        public void CheckSelectedButtonColor()
        {
            // used when changing the background color of selected buttons
            foreach (Control c in this.Controls)
            {
                if (c.GetType() == typeof(GroupBoxTS))
                {
                    foreach (Control c2 in ((GroupBoxTS)c).Controls)
                    {
                        if (c2.GetType() == typeof(RadioButtonTS))
                        {
                            RadioButtonTS r = (RadioButtonTS)c2;
                            if (r.Checked && r.BackColor != SystemColors.Control)
                            {
                                c2.BackColor = button_selected_color;
                            }
                        }
                        else if (c2.GetType() == typeof(CheckBoxTS))
                        {
                            CheckBoxTS chk = (CheckBoxTS)c2;
                            if (chk.Checked && chk.BackColor != SystemColors.Control)
                            {
                                c2.BackColor = button_selected_color;
                            }
                        }
                        else if (c2.GetType() == typeof(NumericUpDownTS))
                        {
                            NumericUpDownTS ud = (NumericUpDownTS)c2;
                            if (ud.BackColor != SystemColors.Window)
                            {
                                c2.BackColor = button_selected_color;
                            }
                        }
                        else if (c2.GetType() == typeof(ButtonTS))
                        {
                            ButtonTS b = (ButtonTS)c2;
                            if (b.BackColor != SystemColors.Control)
                            {
                                c2.BackColor = button_selected_color;
                            }
                        }
                    }
                }
                else if (c.GetType() == typeof(RadioButtonTS))
                {
                    RadioButtonTS r = (RadioButtonTS)c;
                    if (r.Checked && r.BackColor != SystemColors.Control)
                        c.BackColor = button_selected_color;
                }
                else if (c.GetType() == typeof(CheckBoxTS))
                {
                    CheckBoxTS chk = (CheckBoxTS)c;
                    if (chk.Checked && chk.BackColor != SystemColors.Control)
                        c.BackColor = button_selected_color;
                }
                else if (c.GetType() == typeof(NumericUpDownTS))
                {
                    NumericUpDownTS ud = (NumericUpDownTS)c;
                    if (ud.BackColor != SystemColors.Window)
                        c.BackColor = button_selected_color;
                }
                else if (c.GetType() == typeof(ButtonTS))
                {
                    ButtonTS b = (ButtonTS)c;
                    if (b.BackColor != SystemColors.Control)
                        c.BackColor = button_selected_color;
                }
            }
        }

        private double PABandOffset(Band b)
        {
            double num = 0;
            switch (b)
            {
                case Band.B160M:
                    num = setupForm.PAADC160;
                    break;
                case Band.B80M:
                    num = setupForm.PAADC80;
                    break;
                case Band.B60M:
                    num = setupForm.PAADC60;
                    break;
                case Band.B40M:
                    num = setupForm.PAADC40;
                    break;
                case Band.B30M:
                    num = setupForm.PAADC30;
                    break;
                case Band.B20M:
                    num = setupForm.PAADC20;
                    break;
                case Band.B17M:
                    num = setupForm.PAADC17;
                    break;
                case Band.B15M:
                    num = setupForm.PAADC15;
                    break;
                case Band.B12M:
                    num = setupForm.PAADC12;
                    break;
                case Band.B10M:
                    num = setupForm.PAADC10;
                    break;
            }

            if (num == 0) return 0;
            //return 100000 / Math.Pow(num, 2);
            return (double)108 / num;
        }

        private double SWR(int adc_fwd, int adc_rev)
        {
            if (adc_fwd == 0 && adc_rev == 0) return 1.0;
            else if (adc_rev > adc_fwd) return 50.0;

            double Ef = ScaledVoltage(adc_fwd);
            double Er = ScaledVoltage(adc_rev);

            double swr = (Ef + Er) / (Ef - Er);

            if (swr >= 19) // try 1 more time before displaying SWR
            {
                for (int q = 0; q < 5; q++) // ke9ns copy from .184 to .191
                {
                    Thread.Sleep(10);
                    swr = FWCSWR(pa_fwd_power, pa_rev_power);
                    if (swr < 19) break;
                } // for loop

            } // if SWR >=19
            return swr;
        }

        //=====================================================================
        // ke9ns mod

        int swrF = 0;
        double lastswr = 0.0;
        double lastfwdpower = 0.0;
        double lastrevpower = 0.0;
        double lastalc = 0.0;
        double lastmic = 0.0;
        double lasteq = 0.0;


        int swrcount = 0;

        public double FWCSWR(int adc_fwd, int adc_rev)
        {

            //  double f = FWCPAPower(adc_fwd);   // ke9ns using this line allows r to get bigger then f and therefore produce neg swr readings????? very strange, but Flex Radio does not remember why?
            double f = FWCPAPower(adc_fwd) * swr_table[(int)tx_band]; // ke9ns version
            double r = FWCPAPower(adc_rev) * swr_table[(int)tx_band]; // swr_table[(int)tx_band] = 2.10=3mhz  1.64=7mhz  1.095=10mhz

            //   Debug.Write("FWCSWR: fwd:" + adc_fwd+" rev:"+adc_rev+" f:"+f.ToString("f2")+" r:"+r.ToString("f2") + " === "  + swr_table[(int)tx_band].ToString());

            if ((adc_fwd == 0 && adc_rev == 0) || (f <= 1.0 && r <= 1.0))  //(f <= 0.0002 && r <= 0.0002))
            {
                swrF = 0;
                return 0.0001;
            }


            //  if ((f < 1.0 && r < 1.0)) return 1.0;
            if ((adc_rev == adc_fwd) || (r >= f))
            {

                if (swrF > 1) // prevent jumpy swr operation on switchover from RX to TX and back
                {
                    lastswr = 0.0001;
                    //  return 25.0;
                    return 0.0001;
                }
                else
                {
                    swrF++;
                    return lastswr;
                }

            }
            else
            {
                swrF = 0;
            }

            double sqrt_r_over_f = Math.Sqrt(r / f); // ke9ns: standard SWR routine
            double temp = (1.0 + sqrt_r_over_f) / (1.0 - sqrt_r_over_f); // ke9ns: standard SWR routine

            if (temp > 25)
            {
                temp = 25; // ke9ns if SWR over 25:1 then just make it 25:1
            }

            if (temp < 0) temp = temp * -1.0; // ke9ns: if SWR neg then make it positive

            lastswr = temp;

            //  Debug.WriteLine("swr temp" + temp);
            return temp;

        } // FWCSWR(int adc_fwd, int adc_rev)




        private double ScaledVoltage(int adc)
        {
            double v_det = adc * 0.062963;          // scale factor in V/bit including pot ratio
            double v_out = v_det * 10.39853;        // scale factor in V/V for bridge output to detector voltage
            return v_out * PABandOffset(tx_band);
            //double v_det = adc * 0.0304;
            //			double v_out = 0;
            //			if(v_det >= 1.6)
            //				v_out = (-0.241259304*v_det+12.07915098)*v_det*PABandOffset(CurrentBand);
            //			else if(v_det > 0.35)
            //				v_out = (1/Math.Pow(v_det, 2)+11.3025111)*v_det*PABandOffset(CurrentBand);
            //return v_out;
        }

        private double ADCtodBm(int adc_data)
        {
            if (adc_data == 0)
                return 0;

            double mult = 100000 / Math.Pow(225 / PABandOffset(tx_band), 2);
            return 10 * Math.Log10(mult * Math.Pow(adc_data, 2));
        }

        private double PAPower(int adc)
        {
            double v_out = ScaledVoltage(adc);
            double pow = Math.Pow(v_out, 2) / 50;
            pow = Math.Max(pow, 0.0);
            return pow;
        }

        private double WattsTodBm(double watts)
        {
            return 10 * Math.Log10(watts / 0.001);
        }

        private double dBmToWatts(double dBm)
        {
            return Math.Pow(10, dBm / 10) * 0.001;
        }

        public double FWCPAPower(int adc) // adc in, watts out
        {
            if (adc < 2) return 0.0;

            double[] table = { 1.0, 2.0, 5.0, 10.0, 20.0, 90.0 };

            double watts = 0.0;
            double volts = (double)adc / 4096 * 2.5;
            double v2 = Math.Pow(volts, 2);

            int high_index = 0;
            for (int i = 0; i < 6; i++)
            {
                if (volts < pa_bridge_table[(int)tx_band][i])
                {
                    high_index = i;
                    break;
                }
                if (i == 5) high_index = 6;
            }
         //   Debug.WriteLine("PAPOWER: " + high_index + " , " + volts + " , " + tx_band); // + " , " + pa_bridge_table[(int)tx_band][high_index]); //.248


            if (high_index != 6)
            {
                double v_low = 0.0, v_high = 0.0;
                double p_low = 0.0, p_high = 0.0;

                if (high_index != 0) v_low = pa_bridge_table[(int)tx_band][high_index - 1];

                v_high = pa_bridge_table[(int)tx_band][high_index];

                if (high_index != 0) p_low = table[high_index - 1];

                p_high = table[high_index];

                Debug.Assert(v_low <= volts && v_high >= volts);

                double v_low_2 = Math.Pow(v_low, 2.0);
                double v_high_2 = Math.Pow(v_high, 2.0);

                watts = p_low + (p_high - p_low) * ((v2 - v_low_2) / (v_high_2 - v_low_2));
            }
            else
            {
                double v_low_2 = Math.Pow(pa_bridge_table[(int)tx_band][4], 2.0);
                double v_high_2 = Math.Pow(pa_bridge_table[(int)tx_band][5], 2.0);

                if (v_low_2 != v_high_2)
                {
                    double a = 70.0 / (v_high_2 - v_low_2);
                    double b = 90.0 / (a * v_high_2);

                    watts = a * v2 + b;
                }
            }

            return watts;
        }

        private static bool CheckForOpenProcesses()
        {
            // find all open PowerSDR processes
            Process[] p = Process.GetProcessesByName("PowerSDR");
            if (p.Length > 1)
            {
                DialogResult dr = MessageBox.Show(new Form { TopMost = true }, "There are other PowerSDR instances running.\n" +
                    "Are you sure you want to continue?",
                    "Continue?",
                    MessageBoxButtons.YesNo,
                    MessageBoxIcon.Question);
                if (dr == DialogResult.No)
                {
                    return false;
                }
            }
            return true;
        }

        public int VersionTextToInt(string version) // takes a version string like "1.0.6" 
        {                                           // and converts it to an int like 010006.
            string[] nums = version.Split('.');
            if (nums.Length < 3 || nums.Length > 4) return -1;

            int num1 = Int32.Parse(nums[0]);
            int num2 = Int32.Parse(nums[1]);
            int num3 = Int32.Parse(nums[2]);
            int num4 = 0;
            if (nums.Length == 4) num4 = Int32.Parse(nums[3]);

            return num1 * 1000000 + num2 * 10000 + num3 * 100 + num4;
        } // versiontextotint

        // ==============================================================================================
        //  PUBLIC Face of freq check
        // ==============================================================================================
        public bool CheckValidTXFreq(FRSRegion r, double f, DSPMode mode)
        {
            bool retval = false;

            if (extended || (tx_xvtr_index > -1 && (current_model != Model.FLEX1500)) ||
                (current_model == Model.FLEX1500 && tx_ant_1500 != HIDAnt.PA))
                return true;

            if (chkTUN.Checked) mode = DSPMode.CWU;

            switch (mode)
            {
                case DSPMode.LSB:
                case DSPMode.DIGL:
                case DSPMode.USB:
                case DSPMode.DIGU:
                case DSPMode.DSB:
                case DSPMode.AM:
                case DSPMode.SAM:
                case DSPMode.FM:
                    retval = (CheckValidTXFreq_Private(r, f + Display.TXFilterLow * 1e-6) &&
                        CheckValidTXFreq_Private(r, f + Display.TXFilterHigh * 1e-6));
                    break;
                case DSPMode.CWL:
                case DSPMode.CWU:
                    retval = CheckValidTXFreq_Private(r, f);
                    break;
                case DSPMode.DRM:
                    retval = (CheckValidTXFreq_Private(r, f - 0.012 + Display.TXFilterLow * 1e-6) &&
                        CheckValidTXFreq_Private(r, f - 0.012 + Display.TXFilterHigh * 1e-6));
                    break;
            }

            return retval;
        } // CheckValidTXFreq


        // ==============================================================================================
        // INTERNAL (PRIVATE) part of freq check (in cannot override firmware in Flex radio)
        // ==============================================================================================

        private bool CheckValidTXFreq_Private(FRSRegion r, double f)
        {
            if ((extended) || ((tx_xvtr_index > -1) && (current_model != Model.FLEX1500))) return true;

            bool ret_val = false;

            f = Math.Round(f, 6);

            switch (r)
            {
                case FRSRegion.US: // 0
                    if (f >= 1.8 && f <= 2.0) ret_val = true;
                    else if (f >= 3.5 && f <= 4.0) ret_val = true;

                    else if (f >= 5.3305 && f <= 5.3335) ret_val = true; // allow for max 2.8 kHz
                    else if (f >= 5.3465 && f <= 5.3495) ret_val = true;
                    else if (f >= 5.3570 && f <= 5.3600) ret_val = true;
                    else if (f >= 5.3715 && f <= 5.3745) ret_val = true;
                    else if (f >= 5.4035 && f <= 5.4065) ret_val = true;

                    else if (f >= 7.0 && f <= 7.3) ret_val = true;
                    else if (f >= 10.1 && f <= 10.15) ret_val = true;
                    else if (f >= 14.0 && f <= 14.35) ret_val = true;
                    else if (f >= 18.068 && f <= 18.168) ret_val = true;
                    else if (f >= 21.0 && f <= 21.45) ret_val = true;
                    else if (f >= 24.89 && f <= 24.99) ret_val = true;
                    else if (f >= 25.0 && f <= 29.7) ret_val = true;     // change
                    else if (f >= 50.0 && f <= 54.0) ret_val = true;

                    else if (FWCEEPROM.VUOK && f >= 134.0 && f <= 163.0) ret_val = true;  // ke9ns test was 144.0 and 148.0  .217
                    else if (FWCEEPROM.VUOK && f >= 430.0 && f <= 470.0) ret_val = true;  // ke9ns was 450 .224
                    // {
                    //     if (xvtr_present)
                    //         ret_val = true;
                    //     else
                    //         ret_val = false;
                    // }
                    else ret_val = false;
                    break;
                case FRSRegion.UK: // 1
                    if (f >= 1.81 && f <= 2.0) ret_val = true;
                    else if (f >= 3.5 && f <= 3.8) ret_val = true;

                    else if (f >= 7.0 && f <= 7.2) ret_val = true;
                    else if (f >= 10.1 && f <= 10.15) ret_val = true;
                    else if (f >= 14.0 && f <= 14.35) ret_val = true;
                    else if (f >= 18.068 && f <= 18.168) ret_val = true;
                    else if (f >= 21.0 && f <= 21.45) ret_val = true;
                    else if (f >= 24.89 && f <= 24.99) ret_val = true;
                    else if (f >= 28.0 && f <= 29.7) ret_val = true;
                    else if (f >= 50.0 && f <= 52.0) ret_val = true;
                    else ret_val = false;
                    break;
                case FRSRegion.Europe: // 2
                    if (f >= 1.81 && f <= 2.0) ret_val = true;
                    else if (f >= 3.5 && f <= 3.8) ret_val = true;

                    else if (f >= 5.3515 && f <= 5.3665) ret_val = true; // New IARU 1 60m band

                    else if (f >= 7.0 && f <= 7.2) ret_val = true;
                    else if (f >= 10.1 && f <= 10.15) ret_val = true;
                    else if (f >= 14.0 && f <= 14.35) ret_val = true;
                    else if (f >= 18.068 && f <= 18.168) ret_val = true;
                    else if (f >= 21.0 && f <= 21.45) ret_val = true;
                    else if (f >= 24.89 && f <= 24.99) ret_val = true;
                    else if (f >= 28.0 && f <= 29.7) ret_val = true;
                    else if (f >= 50.03 && f <= 51.0) ret_val = true;
                    else ret_val = false;
                    break;
                case FRSRegion.UK_Plus: // 3
                    if (f >= 1.81 && f <= 2.0) ret_val = true;
                    else if (f >= 3.5 && f <= 3.8) ret_val = true;

                    else if (f >= 5.2585 && f <= 5.264) ret_val = true;
                    else if (f >= 5.276 && f <= 5.284) ret_val = true;
                    else if (f >= 5.2885 && f <= 5.292) ret_val = true;
                    else if (f >= 5.298 && f <= 5.307) ret_val = true;
                    else if (f >= 5.313 && f <= 5.323) ret_val = true;
                    else if (f >= 5.333 && f <= 5.338) ret_val = true;
                    else if (f >= 5.354 && f <= 5.358) ret_val = true;
                    else if (f >= 5.362 && f <= 5.3745) ret_val = true;
                    else if (f >= 5.378 && f <= 5.382) ret_val = true;
                    else if (f >= 5.395 && f <= 5.4015) ret_val = true;
                    else if (f >= 5.4035 && f <= 5.4065) ret_val = true;

                    else if (f >= 7.0 && f <= 7.2) ret_val = true;
                    else if (f >= 10.1 && f <= 10.15) ret_val = true;
                    else if (f >= 14.0 && f <= 14.35) ret_val = true;
                    else if (f >= 18.068 && f <= 18.168) ret_val = true;
                    else if (f >= 21.0 && f <= 21.45) ret_val = true;
                    else if (f >= 24.89 && f <= 24.99) ret_val = true;
                    else if (f >= 28.0 && f <= 29.7) ret_val = true;
                    else if (f >= 50.0 && f <= 52.0) ret_val = true;


                    else ret_val = false;
                    break;
                case FRSRegion.Italy: // 4
                    if (f >= 1.83 && f <= 1.85) ret_val = true;
                    else if (f >= 3.5 && f <= 3.8) ret_val = true;
                    else if (f >= 5.3515 && f <= 5.3665) ret_val = true; // New IARU 1 60m band
                    else if (f >= 6.975 && f <= 7.2) ret_val = true;
                    else if (f >= 10.1 && f <= 10.15) ret_val = true;
                    else if (f >= 14.0 && f <= 14.35) ret_val = true;
                    else if (f >= 18.068 && f <= 18.168) ret_val = true;
                    else if (f >= 21.0 && f <= 21.45) ret_val = true;
                    else if (f >= 24.89 && f <= 24.99) ret_val = true;
                    else if (f >= 28.0 && f <= 29.7) ret_val = true;
                    else if (f >= 50.0 && f <= 51.0) ret_val = true;
                    else ret_val = false;
                    break;
                case FRSRegion.Norway: // 5
                    if (f >= 1.81 && f <= 2.0) ret_val = true;
                    else if (f >= 3.5 && f <= 3.8) ret_val = true;

                    else if (f >= 5.25 && f <= 5.45) ret_val = true;

                    else if (f >= 7.0 && f <= 7.2) ret_val = true;
                    else if (f >= 10.1 && f <= 10.15) ret_val = true;
                    else if (f >= 14.0 && f <= 14.35) ret_val = true;
                    else if (f >= 18.068 && f <= 18.168) ret_val = true;
                    else if (f >= 21.0 && f <= 21.45) ret_val = true;
                    else if (f >= 24.74 && f <= 24.99) ret_val = true; // was 24.89
                    else if (f >= 28.0 && f <= 29.7) ret_val = true;
                    else if (f >= 50.0 && f <= 52.0) ret_val = true;
                    else ret_val = false;
                    break;
                case FRSRegion.Denmark: // 6
                    if (f >= 1.81 && f <= 2.0) ret_val = true;
                    else if (f >= 3.5 && f <= 3.8) ret_val = true;

                    else if (f >= 5.25 && f <= 5.45) ret_val = true;

                    else if (f >= 7.0 && f <= 7.2) ret_val = true;
                    else if (f >= 10.1 && f <= 10.15) ret_val = true;
                    else if (f >= 14.0 && f <= 14.35) ret_val = true;
                    else if (f >= 18.068 && f <= 18.168) ret_val = true;
                    else if (f >= 21.0 && f <= 21.45) ret_val = true;
                    else if (f >= 24.89 && f <= 24.99) ret_val = true;
                    else if (f >= 28.0 && f <= 29.7) ret_val = true;
                    else if (f >= 50.0 && f <= 52.0) ret_val = true;
                    else ret_val = false;
                    break;
                case FRSRegion.Latvia: // 7
                    if (f >= 1.81 && f <= 2.0) ret_val = true;
                    else if (f >= 3.5 && f <= 3.8) ret_val = true;

                    else if (f >= 7.0 && f <= 7.2) ret_val = true;
                    else if (f >= 10.1 && f <= 10.15) ret_val = true;
                    else if (f >= 14.0 && f <= 14.35) ret_val = true;
                    else if (f >= 18.068 && f <= 18.168) ret_val = true;
                    else if (f >= 21.0 && f <= 21.45) ret_val = true;
                    else if (f >= 24.89 && f <= 24.99) ret_val = true;
                    else if (f >= 28.0 && f <= 29.7) ret_val = true;
                    else if (f >= 50.0 && f <= 51.0) ret_val = true;
                    else ret_val = false;
                    break;
                case FRSRegion.Slovakia: // 8
                    if (f >= 1.81 && f <= 2.0) ret_val = true;
                    else if (f >= 3.5 && f <= 3.8) ret_val = true;

                    else if (f >= 7.0 && f <= 7.2) ret_val = true;
                    else if (f >= 10.1 && f <= 10.15) ret_val = true;
                    else if (f >= 14.0 && f <= 14.35) ret_val = true;
                    else if (f >= 18.068 && f <= 18.168) ret_val = true;
                    else if (f >= 21.0 && f <= 21.45) ret_val = true;
                    else if (f >= 24.89 && f <= 24.99) ret_val = true;
                    else if (f >= 28.0 && f <= 29.7) ret_val = true;
                    else if (f >= 50.0 && f <= 52.0) ret_val = true;
                    else ret_val = false;
                    break;
                case FRSRegion.Bulgaria: // 9
                    if (f >= 1.81 && f <= 1.85) ret_val = true;
                    else if (f >= 3.5 && f <= 3.8) ret_val = true;

                    else if (f >= 7.0 && f <= 7.2) ret_val = true;
                    else if (f >= 10.1 && f <= 10.15) ret_val = true;
                    else if (f >= 14.0 && f <= 14.35) ret_val = true;
                    else if (f >= 18.068 && f <= 18.168) ret_val = true;
                    else if (f >= 21.0 && f <= 21.45) ret_val = true;
                    else if (f >= 24.89 && f <= 24.99) ret_val = true;
                    else if (f >= 28.0 && f <= 29.7) ret_val = true;
                    else if (f >= 50.05 && f <= 50.2) ret_val = true;
                    else ret_val = false;
                    break;
                case FRSRegion.Greece: // 10
                    if (f >= 1.81 && f <= 1.85) ret_val = true;
                    else if (f >= 3.5 && f <= 3.8) ret_val = true;
                    else if (f >= 5.3515 && f <= 5.3665) ret_val = true; // New IARU 1 60m band
                    else if (f >= 7.0 && f <= 7.2) ret_val = true;
                    else if (f >= 10.1 && f <= 10.15) ret_val = true;
                    else if (f >= 14.0 && f <= 14.35) ret_val = true;
                    else if (f >= 18.068 && f <= 18.168) ret_val = true;
                    else if (f >= 21.0 && f <= 21.45) ret_val = true;
                    else if (f >= 24.89 && f <= 24.99) ret_val = true;
                    else if (f >= 28.0 && f <= 29.7) ret_val = true;
                    else ret_val = false;
                    break;
                case FRSRegion.Hungary: // 11
                    if (f >= 1.81 && f <= 2.0) ret_val = true;
                    else if (f >= 3.5 && f <= 3.8) ret_val = true;
                    else if (f >= 5.3515 && f <= 5.3665) ret_val = true; // New IARU 1 60m band
                    else if (f >= 7.0 && f <= 7.201) ret_val = true;
                    else if (f >= 10.1 && f <= 10.15) ret_val = true;
                    else if (f >= 14.0 && f <= 14.35) ret_val = true;
                    else if (f >= 18.068 && f <= 18.168) ret_val = true;
                    else if (f >= 21.0 && f <= 21.45) ret_val = true;
                    else if (f >= 24.89 && f <= 24.99) ret_val = true;
                    else if (f >= 28.0 && f <= 29.7) ret_val = true;
                    else if (f >= 50.0 && f <= 52.0) ret_val = true;
                    else ret_val = false;
                    break;
                case FRSRegion.Belgium: // 12
                    if (f >= 1.81 && f <= 2.0) ret_val = true;
                    else if (f >= 3.5 && f <= 3.8) ret_val = true;

                    else if (f >= 5.3515 && f <= 5.3665) ret_val = true; // New IARU 1 60m band

                    else if (f >= 7.0 && f <= 7.2) ret_val = true;
                    else if (f >= 10.1 && f <= 10.15) ret_val = true;
                    else if (f >= 14.0 && f <= 14.35) ret_val = true;
                    else if (f >= 18.068 && f <= 18.168) ret_val = true;
                    else if (f >= 21.0 && f <= 21.45) ret_val = true;
                    else if (f >= 24.89 && f <= 24.99) ret_val = true;
                    else if (f >= 28.0 && f <= 29.7) ret_val = true;
                    else if (f >= 50.0 && f <= 52.0) ret_val = true;
                    else ret_val = false;
                    break;
                case FRSRegion.France: // 13
                    if (f >= 1.81 && f <= 2.0) ret_val = true;
                    else if (f >= 3.5 && f <= 3.8) ret_val = true;
                    else if (f >= 5.3515 && f <= 5.3665) ret_val = true; // New IARU 1 60m band
                    else if (f >= 7.0 && f <= 7.2) ret_val = true;
                    else if (f >= 10.1 && f <= 10.15) ret_val = true;
                    else if (f >= 14.0 && f <= 14.35) ret_val = true;
                    else if (f >= 18.068 && f <= 18.168) ret_val = true;
                    else if (f >= 21.0 && f <= 21.45) ret_val = true;
                    else if (f >= 24.89 && f <= 24.99) ret_val = true;
                    else if (f >= 28.0 && f <= 29.7) ret_val = true;
                    else if (f >= 50.0 && f <= 52.0) ret_val = true;
                    else ret_val = false;
                    break;
                case FRSRegion.Russia: // 14
                    if (f >= 1.81 && f <= 2.0) ret_val = true;
                    else if (f >= 3.5 && f <= 3.8) ret_val = true;

                    else if (f >= 7.0 && f <= 7.2) ret_val = true;
                    else if (f >= 10.1 && f <= 10.15) ret_val = true;
                    else if (f >= 14.0 && f <= 14.35) ret_val = true;
                    else if (f >= 18.068 && f <= 18.168) ret_val = true;
                    else if (f >= 21.0 && f <= 21.45) ret_val = true;
                    else if (f >= 24.89 && f <= 25.14) ret_val = true;
                    else if (f >= 26.97 && f <= 27.86) ret_val = true;
                    else if (f >= 28.0 && f <= 29.7) ret_val = true;
                    else ret_val = false;
                    break;
                case FRSRegion.Sweden: // 15
                    if (f >= 1.81 && f <= 2.0) ret_val = true;
                    else if (f >= 3.5 && f <= 3.8) ret_val = true;

                    else if (f >= 5.3515 && f <= 5.3665) ret_val = true; // New IARU 1 60m band

                    else if (f >= 5.31 && f <= 5.313) ret_val = true;
                    else if (f >= 5.32 && f <= 5.323) ret_val = true;
                    else if (f >= 5.38 && f <= 5.383) ret_val = true;
                    else if (f >= 5.39 && f <= 5.393) ret_val = true;
                    else if (f >= 7.0 && f <= 7.2) ret_val = true;
                    else if (f >= 10.1 && f <= 10.15) ret_val = true;
                    else if (f >= 14.0 && f <= 14.35) ret_val = true;
                    else if (f >= 18.068 && f <= 18.168) ret_val = true;
                    else if (f >= 21.0 && f <= 21.45) ret_val = true;
                    else if (f >= 24.89 && f <= 24.99) ret_val = true;
                    else if (f >= 28.0 && f <= 29.7) ret_val = true;
                    else if (f >= 50.0 && f <= 52.0) ret_val = true;
                    else ret_val = false;
                    break;
                case FRSRegion.IARU3: // 16
                    if (f >= 1.8 && f <= 2.0) ret_val = true;
                    else if (f >= 3.5 && f <= 3.9) ret_val = true;
                    else if (f >= 7.0 && f <= 7.3) ret_val = true;
                    else if (f >= 10.1 && f <= 10.15) ret_val = true;
                    else if (f >= 14.0 && f <= 14.35) ret_val = true;
                    else if (f >= 18.068 && f <= 18.168) ret_val = true;
                    else if (f >= 21.0 && f <= 21.45) ret_val = true;
                    else if (f >= 24.89 && f <= 24.99) ret_val = true;
                    else if (f >= 28.0 && f <= 29.7) ret_val = true;
                    else if (f >= 50.0 && f <= 54.0) ret_val = true;
                    else ret_val = false;
                    break;

                case FRSRegion.Japan: // 17
                    if (f >= 1.81 && f <= 1.9125) ret_val = true;
                    else if (f >= 3.5 && f <= 3.805) ret_val = true;
                    else if (f >= 4.629995 && f <= 4.630005) ret_val = true;    // Japan national emergency frequency 4.630 +/- 5 Hz
                    else if (f >= 7.0 && f <= 7.2) ret_val = true;
                    else if (f >= 10.1 && f <= 10.15) ret_val = true;
                    else if (f >= 14.0 && f <= 14.35) ret_val = true;
                    else if (f >= 18.068 && f <= 18.168) ret_val = true;
                    else if (f >= 21.0 && f <= 21.45) ret_val = true;
                    else if (f >= 24.89 && f <= 24.99) ret_val = true;
                    else if (f >= 28.0 && f <= 29.7) ret_val = true;
                    else if (f >= 50.0 && f <= 54.0) ret_val = true;
                    else ret_val = false;
                    break;
                case FRSRegion.Italy_Plus: //18
                    if (f >= 1.83 && f <= 1.85) ret_val = true;
                    else if (f >= 3.5 && f <= 3.8) ret_val = true;
                    else if (f >= 5.3515 && f <= 5.3665) ret_val = true; // New IARU 1 60m band
                    else if (f >= 6.975 && f <= 7.2) ret_val = true;
                    else if (f >= 10.1 && f <= 10.15) ret_val = true;
                    else if (f >= 14.0 && f <= 14.35) ret_val = true;
                    else if (f >= 18.068 && f <= 18.168) ret_val = true;
                    else if (f >= 21.0 && f <= 21.45) ret_val = true;
                    else if (f >= 24.89 && f <= 24.99) ret_val = true;
                    else if (f >= 28.0 && f <= 29.7) ret_val = true;
                    else if (f >= 50.0 && f <= 51.0) ret_val = true;
                    else ret_val = false;
                    break;
                case FRSRegion.ES_CH_FIN: // 19
                    if (f >= 1.81 && f <= 2.0) ret_val = true;
                    else if (f >= 3.5 && f <= 3.8) ret_val = true;
                    else if (f >= 5.3515 && f <= 5.3665) ret_val = true; // New IARU 1 60m band
                    else if (f >= 7.0 && f <= 7.2) ret_val = true;
                    else if (f >= 10.1 && f <= 10.15) ret_val = true;
                    else if (f >= 14.0 && f <= 14.35) ret_val = true;
                    else if (f >= 18.068 && f <= 18.168) ret_val = true;
                    else if (f >= 21.0 && f <= 21.45) ret_val = true;
                    else if (f >= 24.89 && f <= 24.99) ret_val = true;
                    else if (f >= 28.0 && f <= 29.7) ret_val = true;
                    else if (f >= 50.00 && f <= 52.0) ret_val = true;
                    else ret_val = false;
                    break;
                case FRSRegion.Netherlands: // 20
                    if (f >= 1.81 && f <= 1.88) ret_val = true;
                    else if (f >= 3.5 && f <= 3.8) ret_val = true;
                    else if (f >= 5.3515 && f <= 5.3665) ret_val = true; // New IARU 1 60m band
                                                                         //  else if (f >= 5.35 && f <= 5.45) ret_val = true; // New IARU 1 60m band
                    else if (f >= 7.0 && f <= 7.2) ret_val = true;
                    else if (f >= 10.1 && f <= 10.15) ret_val = true;
                    else if (f >= 14.0 && f <= 14.35) ret_val = true;
                    else if (f >= 18.068 && f <= 18.168) ret_val = true;
                    else if (f >= 21.0 && f <= 21.45) ret_val = true;
                    else if (f >= 24.89 && f <= 24.99) ret_val = true;
                    else if (f >= 28.0 && f <= 29.7) ret_val = true;
                    else if (f >= 50.0 && f <= 52.0) ret_val = true;
                    else ret_val = false;
                    break;
                case FRSRegion.EU_Travel: // 21
                    if (f >= 1.80 && f <= 2.0) ret_val = true;
                    else if (f >= 3.5 && f <= 3.8) ret_val = true;
                    else if (f >= 5.250 && f <= 5.450) ret_val = true;
                    else if (f >= 7.0 && f <= 7.2) ret_val = true;
                    else if (f >= 10.1 && f <= 10.15) ret_val = true;
                    else if (f >= 14.0 && f <= 14.35) ret_val = true;
                    else if (f >= 18.068 && f <= 18.168) ret_val = true;
                    else if (f >= 21.0 && f <= 21.45) ret_val = true;
                    else if (f >= 24.89 && f <= 24.99) ret_val = true;
                    else if (f >= 28.0 && f <= 29.7) ret_val = true;
                    else if (f >= 50.00 && f <= 52.0) ret_val = true;
                    else ret_val = false;
                    break;
                case FRSRegion.Luxembourg: // 22
                    if (f >= 1.81 && f <= 2.0) ret_val = true;
                    else if (f >= 3.5 && f <= 3.8) ret_val = true;
                    else if (f >= 5.3515 && f <= 5.3665) ret_val = true; // New IARU 1 60m band
                    else if (f >= 7.0 && f <= 7.2) ret_val = true;
                    else if (f >= 10.1 && f <= 10.15) ret_val = true;
                    else if (f >= 14.0 && f <= 14.35) ret_val = true;
                    else if (f >= 18.068 && f <= 18.168) ret_val = true;
                    else if (f >= 21.0 && f <= 21.45) ret_val = true;
                    else if (f >= 24.89 && f <= 24.99) ret_val = true;
                    else if (f >= 28.0 && f <= 29.7) ret_val = true;
                    else if (f >= 50.00 && f <= 52.0) ret_val = true;
                    else ret_val = false;
                    break;
                case FRSRegion.IARU2: // 23
                    if (f >= 1.8 && f <= 2.0) ret_val = true;
                    else if (f >= 3.5 && f <= 4.0) ret_val = true;
                    else if (f >= 5.3515 && f <= 5.3665) ret_val = true; // New IARU 2 60m band
                    else if (f >= 7.0 && f <= 7.3) ret_val = true;

                    else if (f >= 7.4535 && f <= 7.4565) ret_val = true; // ke9ns USB CDEMA Caribbean Disaster Emergency Response Agency
                    else if (f >= 7.850 && f <= 7.853) ret_val = true; // ke9ns USB CDEMA Caribbean Disaster Emergency Response Agency

                    else if (f >= 10.1 && f <= 10.15) ret_val = true;

                    else if (f >= 13.998 && f <= 14.0) ret_val = true; // ke9ns USB USB Caribbean Red Cross

                    else if (f >= 14.0 && f <= 14.35) ret_val = true;

                    else if (f >= 14.415 && f <= 14.418) ret_val = true; // ke9ns USB CDEMA Caribbean Disaster Emergency Response Agency


                    else if (f >= 18.068 && f <= 18.168) ret_val = true;
                    else if (f >= 21.0 && f <= 21.45) ret_val = true;
                    else if (f >= 24.89 && f <= 24.99) ret_val = true;
                    else if (f >= 27.0 && f <= 29.7) ret_val = true;
                    else if (f >= 50.0 && f <= 54.0) ret_val = true;
                    else if (FWCEEPROM.VUOK && f >= 144.0 && f <= 148.0) ret_val = true;
                    else if (FWCEEPROM.VUOK && f >= 430.0 && f <= 450.0) ret_val = true;
                    else ret_val = false;
                    break;

                case FRSRegion.Australia: // 24  (no 60m transmit)
                    if (f >= 1.8 && f <= 1.875) ret_val = true;
                    else if (f >= 3.5 && f <= 3.8) ret_val = true;
                    else if (f >= 7.0 && f <= 7.3) ret_val = true;
                    else if (f >= 10.1 && f <= 10.15) ret_val = true;
                    else if (f >= 14.0 && f <= 14.35) ret_val = true;
                    else if (f >= 18.068 && f <= 18.168) ret_val = true;
                    else if (f >= 21.0 && f <= 21.45) ret_val = true;
                    else if (f >= 24.89 && f <= 24.99) ret_val = true;
                    else if (f >= 27.0 && f <= 29.7) ret_val = true;
                    else if (f >= 50.0 && f <= 54.0) ret_val = true;
                    else if (FWCEEPROM.VUOK && f >= 144.0 && f <= 147.975) ret_val = true;
                    else if (FWCEEPROM.VUOK && f >= 430.0 && f <= 450.0) ret_val = true;
                    else ret_val = false;
                    break;
                case FRSRegion.China: // 25
                    if (f >= 1.8 && f <= 2.0) ret_val = true;
                    else if (f >= 3.5 && f <= 3.9) ret_val = true;
                    else if (f >= 5.3515 && f <= 5.3665) ret_val = true; // New IARU 1 60m band
                    else if (f >= 7.0 && f <= 7.3) ret_val = true;
                    else if (f >= 10.1 && f <= 10.15) ret_val = true;
                    else if (f >= 14.0 && f <= 14.35) ret_val = true;
                    else if (f >= 18.068 && f <= 18.168) ret_val = true;
                    else if (f >= 21.0 && f <= 21.45) ret_val = true;
                    else if (f >= 24.89 && f <= 24.99) ret_val = true;
                    else if (f >= 28.0 && f <= 29.7) ret_val = true;
                    else if (f >= 50.0 && f <= 54.0) ret_val = true;
                    else ret_val = false;
                    break;

                default:
                    ret_val = false;
                    break;
            }

            return ret_val;
        }

        public void SetHWFilters(double freq)
        {
            //Use shift registers on RFE to control BPF and LPF banks
            if (freq <= 2.5)                    // DC to 2.5MHz
            {
                if (pa_present)
                    Hdw.PA_LPF = PAFBand.B160;

                if (!mox && chkBCI.Checked) //rx & BCI
                    Hdw.BPFRelay = BPFBand.B60;     //sets next higher BPF for improved 160M operation
                else
                    Hdw.BPFRelay = BPFBand.B160;

                if (freq <= 0.3 && enable_LPF0)
                    Hdw.RFE_LPF = RFELPFBand.AUX;
                else
                    Hdw.RFE_LPF = RFELPFBand.B160;
            }
            else if (freq <= 4)             // 2.5MHz to 4MHz
            {
                if (pa_present)
                    Hdw.PA_LPF = PAFBand.B80;

                Hdw.BPFRelay = BPFBand.B60;
                Hdw.RFE_LPF = RFELPFBand.B80;
            }
            else if (freq <= 6)             // 4MHz to 6MHz
            {
                if (pa_present)
                    Hdw.PA_LPF = PAFBand.B6040;

                Hdw.BPFRelay = BPFBand.B60;
                Hdw.RFE_LPF = RFELPFBand.B60;
            }
            else if (freq <= 7.3)           // 6MHz to 7.3MHz
            {
                if (pa_present)
                    Hdw.PA_LPF = PAFBand.B6040;

                Hdw.BPFRelay = BPFBand.B40;
                Hdw.RFE_LPF = RFELPFBand.B40;
            }
            else if (freq <= 10.2)          // 7.3MHz to 10.2MHz
            {
                if (pa_present)
                    Hdw.PA_LPF = PAFBand.B3020;

                Hdw.BPFRelay = BPFBand.B40;
                Hdw.RFE_LPF = RFELPFBand.B30;
            }
            else if (freq <= 12)                // 10.2MHz to 12MHz
            {
                if (pa_present)
                    Hdw.PA_LPF = PAFBand.NONE;

                Hdw.BPFRelay = BPFBand.B40;
                Hdw.RFE_LPF = RFELPFBand.B30;
            }
            else if (freq <= 14.5)          // 12MHz to 14.5MHz
            {
                if (pa_present)
                    Hdw.PA_LPF = PAFBand.B3020;

                Hdw.BPFRelay = BPFBand.B20;
                Hdw.RFE_LPF = RFELPFBand.B20;
            }
            else if (freq <= 21.5)          // 14.5MHz to 21.5MHz
            {
                if (pa_present)
                    Hdw.PA_LPF = PAFBand.B1715;

                Hdw.BPFRelay = BPFBand.B20;
                Hdw.RFE_LPF = RFELPFBand.B1715;
            }
            else if (freq <= 24)                // 21.5MHz to 24MHz
            {
                if (pa_present)
                    Hdw.PA_LPF = PAFBand.B1210;

                Hdw.BPFRelay = BPFBand.B20;
                Hdw.RFE_LPF = RFELPFBand.B1210;
            }
            else if (freq <= 30)                // 24MHz to 30MHz
            {
                if (pa_present)
                    Hdw.PA_LPF = PAFBand.B1210;

                Hdw.BPFRelay = BPFBand.B10;
                Hdw.RFE_LPF = RFELPFBand.B1210;
            }
            else if (freq <= 36)                // 30MHz to 36MHz
            {
                if (pa_present)
                    Hdw.PA_LPF = PAFBand.NONE;

                Hdw.BPFRelay = BPFBand.B10;
                Hdw.RFE_LPF = RFELPFBand.B6;
            }
            else if (freq <= 65)                // 36MHz to 65Mhz
            {
                if (pa_present)
                    Hdw.PA_LPF = PAFBand.NONE;

                Hdw.BPFRelay = BPFBand.B6;
                Hdw.RFE_LPF = RFELPFBand.B6;
            }
            else if (xvtr_present && freq >= 134 && freq <= 146)            //28MHz IF for transverter // ke9ns test was 144 and 146 .217
            {
                if (pa_present)
                    Hdw.PA_LPF = PAFBand.NONE;

                Hdw.BPFRelay = BPFBand.B10;
                Hdw.RFE_LPF = RFELPFBand.B1210;
                Hdw.XVTR_RF = true;
            }
            //  if (xvtr_present && freq < 144) Hdw.XVTR_RF = false; // ke9ns test this was not commented out .217

            if (rx1_xvtr_index >= 0)
            {
                Hdw.XVTR_RF = xvtrForm.GetXVTRRF(rx1_xvtr_index);
            }

        } // SetHwFilters

        // kb9yig sr40 mod 		
        // check and see if the band data includes alias data -- if so 
        // zero out (very negative) the portions of the data that are 
        // aliased 
        public void AdjustDisplayDataForBandEdge(ref float[] display_data)
        {

            return;

            /*	if ( current_model != Model.SOFTROCK40)  // -- no aliasing going on 
                    return;   

                if ( rx1_dsp_mode == DSPMode.DRM )  // for now don't worry about aliasing in DRM land 
                {
                    return; 
                }

                double hz_per_bin = sample_rate1/Display.BUFFER_SIZE; 
                double data_center_freq = tuned_freq; 
                if ( data_center_freq == 0 ) 
                { 
                    return; 
                } 
                double data_low_edge_hz = (1e6 * data_center_freq) - sample_rate1/2; 
                double data_high_edge_hz = (1e6 * data_center_freq) + sample_rate1/2; 
                double alias_free_low_edge_hz = (1e6 * soft_rock_center_freq) - sample_rate1/2; 
                double alias_free_high_edge_hz = (1e6 * soft_rock_center_freq) + sample_rate1/2; 
                if ( data_low_edge_hz < alias_free_low_edge_hz )   // data we have goes below alias free region -- zero it 
                {				
                    double hz_this_bin = data_low_edge_hz; 
                    int bin_num = 0; 
                    while ( hz_this_bin < alias_free_low_edge_hz ) 
                    {
                        display_data[bin_num] = -200.0f; 
                        ++bin_num; 
                        hz_this_bin += hz_per_bin; 
                    }
                    // Debug.WriteLine("data_low: " + bin_num); 
                } 
                else if ( data_high_edge_hz > alias_free_high_edge_hz ) 
                { 				
                    double hz_this_bin = data_high_edge_hz; 
                    int bin_num = Display.BUFFER_SIZE - 1; 
                    while ( hz_this_bin > alias_free_high_edge_hz ) 
                    {
                        display_data[bin_num] = -200.0f; 
                        --bin_num; 
                        hz_this_bin -= hz_per_bin; 
                    }					
                    // Debug.WriteLine("data_high: " + bin_num); 
                }
                return;		
                */
        }
        // end kb9yig sr40 mod 

        public void SelectRX1VarFilter()
        {
            if (rx1_filter == Filter.VAR1) return;
            if (rx1_filter == Filter.VAR2) return;

            // save current filter bounds, reset to var, set filter bounds 
            int high = (int)udFilterHigh.Value;
            int low = (int)udFilterLow.Value;
            radFilterVar1.Checked = true;
            //SetFilter(Filter.VAR1); 
            UpdateRX1Filters(low, high);
        }

        public void SelectRX2VarFilter()
        {
            if (rx2_filter == Filter.VAR1) return;
            if (rx2_filter == Filter.VAR2) return;

            // save current filter bounds, reset to var, set filter bounds 
            int high = (int)udRX2FilterHigh.Value;
            int low = (int)udRX2FilterLow.Value;
            radRX2FilterVar1.Checked = true;
            //SetFilter(Filter.VAR1); 
            UpdateRX2Filters(low, high);
        }

        private void UpdateExtCtrl()
        {
            return;

            /*  if (current_model != Model.SDR1000) return;

              switch(TXBand)
              {
                  case Band.B160M:
                      if(!mox)
                          Hdw.X2 = (byte)((Hdw.X2 & 0xC0) | x2_160_rx);
                      else
                          Hdw.X2 = (byte)((Hdw.X2 & 0xC0) | x2_160_tx);
                      break;
                  case Band.B80M:
                      if(!mox)
                          Hdw.X2 = (byte)((Hdw.X2 & 0xC0) | x2_80_rx);
                      else
                          Hdw.X2 = (byte)((Hdw.X2 & 0xC0) | x2_80_tx);
                      break;
                  case Band.B60M:
                      if(!mox)
                          Hdw.X2 = (byte)((Hdw.X2 & 0xC0) | x2_60_rx);
                      else
                          Hdw.X2 = (byte)((Hdw.X2 & 0xC0) | x2_60_tx);
                      break;
                  case Band.B40M:
                      if(!mox)
                          Hdw.X2 = (byte)((Hdw.X2 & 0xC0) | x2_40_rx);
                      else
                          Hdw.X2 = (byte)((Hdw.X2 & 0xC0) | x2_40_tx);
                      break;
                  case Band.B30M:
                      if(!mox)
                          Hdw.X2 = (byte)((Hdw.X2 & 0xC0) | x2_30_rx);
                      else
                          Hdw.X2 = (byte)((Hdw.X2 & 0xC0) | x2_30_tx);
                      break;
                  case Band.B20M:
                      if(!mox)
                          Hdw.X2 = (byte)((Hdw.X2 & 0xC0) | x2_20_rx);
                      else
                          Hdw.X2 = (byte)((Hdw.X2 & 0xC0) | x2_20_tx);
                      break;
                  case Band.B17M:
                      if(!mox)
                          Hdw.X2 = (byte)((Hdw.X2 & 0xC0) | x2_17_rx);
                      else
                          Hdw.X2 = (byte)((Hdw.X2 & 0xC0) | x2_17_tx);
                      break;
                  case Band.B15M:
                      if(!mox)
                          Hdw.X2 = (byte)((Hdw.X2 & 0xC0) | x2_15_rx);
                      else
                          Hdw.X2 = (byte)((Hdw.X2 & 0xC0) | x2_15_tx);
                      break;
                  case Band.B12M:
                      if(!mox)
                          Hdw.X2 = (byte)((Hdw.X2 & 0xC0) | x2_12_rx);
                      else
                          Hdw.X2 = (byte)((Hdw.X2 & 0xC0) | x2_12_tx);
                      break;
                  case Band.B10M:
                      if(!mox)
                          Hdw.X2 = (byte)((Hdw.X2 & 0xC0) | x2_10_rx);
                      else
                          Hdw.X2 = (byte)((Hdw.X2 & 0xC0) | x2_10_tx);
                      break;
                  case Band.B6M:
                      if(!mox)
                          Hdw.X2 = (byte)((Hdw.X2 & 0xC0) | x2_6_rx);
                      else
                          Hdw.X2 = (byte)((Hdw.X2 & 0xC0) | x2_6_tx);
                      break;
                  case Band.B2M:
                      if(!mox)
                          Hdw.X2 = (byte)((Hdw.X2 & 0xC0) | x2_2_rx);
                      else
                          Hdw.X2 = (byte)((Hdw.X2 & 0xC0) | x2_2_tx);
                      break;
              }
  */
        } // UpdateExtCtrl()

        // Added 06/24/05 BT for CAT commands
        public void CATMemoryQS()
        {
            btnMemoryQuickSave_Click(this.btnMemoryQuickSave, EventArgs.Empty);
        }

        // Added 06/25/05 BT for CAT commands
        public void CATMemoryQR()
        {
            btnMemoryQuickRestore_Click(this.btnMemoryQuickRestore, EventArgs.Empty);
        }

        // BT 06/30/05 Added for CAT commands
        public int CATBandGroup
        {
            get
            {
                if (panelBandHF.Visible)
                    return 0;
                else
                    return 1;
            }
            set
            {
                if (value == 0)
                    btnBandHF_Click(btnBandHF, EventArgs.Empty);
                else if (value == 1)
                    btnBandVHF_Click(btnBandVHF, EventArgs.Empty);
            }
        }

        //BT 06/17/05 added for CAT commands
        public void SetCATBand(Band pBand)
        {
            Band b = pBand;
            switch (b)
            {
                case Band.B160M:
                    radBand160_Click(this, EventArgs.Empty);
                    break;
                case Band.B80M:
                    radBand80_Click(this, EventArgs.Empty);
                    break;
                case Band.B60M:
                    radBand60_Click(this, EventArgs.Empty);
                    break;
                case Band.B40M:
                    radBand40_Click(this, EventArgs.Empty);
                    break;
                case Band.B30M:
                    radBand30_Click(this, EventArgs.Empty);
                    break;
                case Band.B20M:
                    radBand20_Click(this, EventArgs.Empty);
                    break;
                case Band.B17M:
                    radBand17_Click(this, EventArgs.Empty);
                    break;
                case Band.B15M:
                    radBand15_Click(this, EventArgs.Empty);
                    break;
                case Band.B12M:
                    radBand12_Click(this, EventArgs.Empty);
                    break;
                case Band.B10M:
                    radBand10_Click(this, EventArgs.Empty);
                    break;
                case Band.B6M:
                    radBand6_Click(this, EventArgs.Empty);
                    break;
                case Band.B2M:
                    radBand2_Click(this, EventArgs.Empty);
                    break;
                case Band.GEN:
                    radBandGEN_Click(this, EventArgs.Empty);
                    break;
                case Band.WWV:
                    radBandWWV_Click(this, EventArgs.Empty);
                    break;
                case Band.VHF0:
                    radBandVHF0.PerformClick();
                    break;
                case Band.VHF1:
                    radBandVHF1.PerformClick();
                    break;
                case Band.VHF2:
                    radBandVHF2.PerformClick();
                    break;
                case Band.VHF3:
                    radBandVHF3.PerformClick();
                    break;
                case Band.VHF4:
                    radBandVHF4.PerformClick();
                    break;
                case Band.VHF5:
                    radBandVHF5.PerformClick();
                    break;
                case Band.VHF6:
                    radBandVHF6.PerformClick();
                    break;
                case Band.VHF7:
                    radBandVHF7.PerformClick();
                    break;
                case Band.VHF8:
                    radBandVHF8.PerformClick();
                    break;
                case Band.VHF9:
                    radBandVHF9.PerformClick();
                    break;
                case Band.VHF10:
                    radBandVHF10.PerformClick();
                    break;
                case Band.VHF11:
                    radBandVHF11.PerformClick();
                    break;
                case Band.VHF12:
                    radBandVHF12.PerformClick();
                    break;
                case Band.VHF13:
                    radBandVHF13.PerformClick();
                    break;
                case Band.BLMF:
                    radBandGEN0_Click(this, EventArgs.Empty);
                    break;
                case Band.B120M:
                    radBandGEN1_Click(this, EventArgs.Empty);
                    break;
                case Band.B90M:
                    radBandGEN2_Click(this, EventArgs.Empty);
                    break;
                case Band.B61M:
                    radBandGEN3_Click(this, EventArgs.Empty);
                    break;
                case Band.B49M:
                    radBandGEN4_Click(this, EventArgs.Empty);
                    break;
                case Band.B41M:
                    radBandGEN5_Click(this, EventArgs.Empty);
                    break;
                case Band.B31M:
                    radBandGEN6_Click(this, EventArgs.Empty);
                    break;
                case Band.B25M:
                    radBandGEN7_CheckedChanged(this, EventArgs.Empty);
                    break;
                case Band.B22M:
                    radBandGEN8_Click(this, EventArgs.Empty);
                    break;
                case Band.B19M:
                    radBandGEN9_Click(this, EventArgs.Empty);
                    break;
                case Band.B16M:
                    radBandGEN10_Click(this, EventArgs.Empty);
                    break;
                case Band.B14M:
                    radBandGEN11_Click(this, EventArgs.Empty);
                    break;
                case Band.B13M:
                    radBandGEN12_Click(this, EventArgs.Empty);
                    break;
                case Band.B11M:
                    radBandGEN13_Click(this, EventArgs.Empty);
                    break;

                default:
                    radBandGEN_Click(this, EventArgs.Empty);
                    break;
            }
        } // setcatband


        public void SetVHFText(int index, string text)
        {
            vhf_text[index].Text = text;
            vhf_text2[index].Text = text;


        }

        public void SetVHFEnabled(int index, bool b)
        {
            vhf_text[index].Enabled = b;

            //   if (index < 2)  vhf_text2[index].Enabled = b; // .213 
            vhf_text2[index].Enabled = b; // .217 but xtvr on rx2 can only use RX2 input (RX ONLY)
        }



        //=============================================================================
        // ke9ns mod add GEN SWL bands
        public int[] band_stacks; // ke9ns add each entry contains the # of bandstack entries for each band listed below 
        public int[] band_sort; // ke9ns add lowest to highest sorted freq list of the current bandstack  

        public void UpdateBandStackRegisters()
        {
            band_stacks = DB.GetBandStackNum(); // ke9ns mod

            band_160m_register = band_stacks[0];
            band_80m_register = band_stacks[1];
            band_60m_register = band_stacks[2];
            band_40m_register = band_stacks[3];
            band_30m_register = band_stacks[4];
            band_20m_register = band_stacks[5];
            band_17m_register = band_stacks[6];
            band_15m_register = band_stacks[7];
            band_12m_register = band_stacks[8];
            band_10m_register = band_stacks[9];
            band_6m_register = band_stacks[10];
            band_2m_register = band_stacks[11];
            band_wwv_register = band_stacks[12];
            band_gen_register = band_stacks[13];

            band_LMF_register = band_stacks[14]; // ke9ns add
            band_120m_register = band_stacks[15];
            band_90m_register = band_stacks[16];
            band_61m_register = band_stacks[17];
            band_49m_register = band_stacks[18];
            band_41m_register = band_stacks[19];
            band_31m_register = band_stacks[20];
            band_25m_register = band_stacks[21];
            band_22m_register = band_stacks[22];
            band_19m_register = band_stacks[23];
            band_16m_register = band_stacks[24];
            band_14m_register = band_stacks[25];
            band_13m_register = band_stacks[26];
            band_11m_register = band_stacks[27];

            band_vhf0_register = band_stacks[28];
            band_vhf1_register = band_stacks[29];
            band_vhf2_register = band_stacks[30];
            band_vhf3_register = band_stacks[31];
            band_vhf4_register = band_stacks[32];
            band_vhf5_register = band_stacks[33];
            band_vhf6_register = band_stacks[34];
            band_vhf7_register = band_stacks[35];
            band_vhf8_register = band_stacks[36];
            band_vhf9_register = band_stacks[37];
            band_vhf10_register = band_stacks[38];
            band_vhf11_register = band_stacks[39];
            band_vhf12_register = band_stacks[40];
            band_vhf13_register = band_stacks[41];




        } // UpdateBandStackRegisters()



        public void UpdateRX1Filters(int low, int high)
        {
            // System.Console.WriteLine("updf lo: " + low + " hi: " + high); 
            // qualify settings
            //if(low > high) return;

            switch (rx1_dsp_mode)
            {
                case DSPMode.LSB:
                case DSPMode.DIGL:
                case DSPMode.CWL:
                    if (low > high - 10) low = high - 10;
                    break;
                case DSPMode.USB:
                case DSPMode.DIGU:
                case DSPMode.CWU:
                    if (high < low + 10) high = low + 10;
                    break;
                case DSPMode.AM:
                case DSPMode.SAM:
                case DSPMode.DSB:
                    if (high < low + 20)
                    {
                        if (Math.Abs(high) < Math.Abs(low))
                            high = low + 20;
                        else
                            low = high - 20;
                    }
                    break;
                case DSPMode.FM:

                    if (dsp.GetDSPTX(0).TXFMDeviation == FMDataDeviation) // ke9ns add FMData == true  WFM
                    {
                        low = -FMDataLowHigh; // -11000 (now 20k .218)
                        high = FMDataLowHigh; // 11000
                    }
                    else if (dsp.GetDSPTX(0).TXFMDeviation == 5000)
                    {
                        low = -8000;
                        high = 8000;
                    }
                    else if (dsp.GetDSPTX(0).TXFMDeviation == 2500)
                    {
                        low = -4000;
                        high = 4000;
                    }
                    break;
            }

            if (current_model == Model.FLEX1500) // .217
            {
                if (low < -14999) low = -14999; // ke9ns add
                if (high > 14999) high = 14999;
            }
            else
            {
                if (low < -52000) low = -52000; // ke9ns .217
                if (high > 52000) high = 52000;
            }

            //	if(low < -9999)	low = -9999;
            //	if(high > 9999)	high = 9999; // ke9ns test. this was original


            // send the settings to the DSP
            dsp.GetDSPRX(0, 0).SetRXFilter(low, high);
            dsp.GetDSPRX(0, 1).SetRXFilter(low, high);

            // send the setting to the display
            Display.RX1FilterLow = low;
            Display.RX1FilterHigh = high;

            // update var filter controls
            udFilterLow.Value = low;
            udFilterHigh.Value = high;

            // update Filter Shift
            ptbFilterShift_Update(low, high);

            // update Filter Width
            ptbFilterWidth_Update(low, high);

            // Update Display data if not in panadapter mode
            if (!dsp.GetDSPRX(0, 0).SpectrumPreFilter)
                UpdateRXDisplayVars(low, high);

            // update display
            if (!chkPower.Checked)
                Display.DrawBackground();

            // reset average and peak
            switch (Display.CurrentDisplayMode)
            {
                case DisplayMode.SPECTRUM:
                case DisplayMode.HISTOGRAM:
                case DisplayMode.WATERFALL:
                    if (chkDisplayAVG.Checked) Display.ResetRX1DisplayAverage();
                    if (chkDisplayPeak.Checked) Display.ResetRX1DisplayPeak();
                    break;
                case DisplayMode.PANADAPTER:
                    break;
            }

            // set XIT step rate
            if ((high - low) > 250)
            {
                udXIT.Increment = 10;
                udRIT.Increment = 10;
            }
            else
            {
                udXIT.Increment = 5;
                udRIT.Increment = 5;
            }

            if (filterRX1Form != null && !filterRX1Form.IsDisposed)
            {
                if (filterRX1Form.DSPMode == rx1_dsp_mode)
                    filterRX1Form.CurrentFilter = rx1_filter;
            }
        } // updaterx1fitlers

        public void UpdateRX2Filters(int low, int high)
        {
            switch (rx2_dsp_mode)
            {
                case DSPMode.LSB:
                case DSPMode.DIGL:
                case DSPMode.CWL:
                    if (low > high - 10) low = high - 10;
                    break;
                case DSPMode.USB:
                case DSPMode.DIGU:
                case DSPMode.CWU:
                    if (high < low + 10) high = low + 10;
                    break;
                case DSPMode.AM:
                case DSPMode.SAM:
                case DSPMode.DSB:
                    if (high < low + 20)
                    {
                        if (Math.Abs(high) < Math.Abs(low))
                            high = low + 20;
                        else
                            low = high - 20;
                    }
                    break;
                case DSPMode.FM:

                    if (dsp.GetDSPTX(0).TXFMDeviation == FMDataDeviation)  // FMData == true) 9khz dev WFM
                    {
                        low = -FMDataLowHigh; // -11000
                        high = FMDataLowHigh; // +11000
                    }
                    else if (dsp.GetDSPTX(0).TXFMDeviation == 5000)
                    {
                        low = -8000;
                        high = 8000;
                    }
                    else if (dsp.GetDSPTX(0).TXFMDeviation == 2500)
                    {
                        low = -4000;
                        high = 4000;
                    }
                    break;


            }

            if (current_model == Model.FLEX1500) // .217
            {
                if (low < -14999) low = -14999; // ke9ns add
                if (high > 14999) high = 14999;
            }
            else
            {
                if (low < -52000) low = -52000; // ke9ns .217
                if (high > 52000) high = 52000;
            }


            //  if (low < -9999)
            //		low = -9999;
            //	if(high > 9999) 
            //	high = 9999;

            // send the settings to the DSP
            dsp.GetDSPRX(1, 0).SetRXFilter(low, high);
            dsp.GetDSPRX(1, 1).SetRXFilter(low, high);

            // send the setting to the display
            Display.RX2FilterLow = low;
            Display.RX2FilterHigh = high;

            // update var filter controls
            udRX2FilterLow.Value = low;
            udRX2FilterHigh.Value = high;

            // update display
            if (!chkPower.Checked) Display.DrawBackground();

            if (filterRX2Form != null && !filterRX2Form.IsDisposed)
            {
                if (filterRX2Form.DSPMode == rx2_dsp_mode)
                    filterRX2Form.CurrentFilter = rx2_filter;
            }
        } //update RX2 Filters

        public void UpdateRX1FilterNames(Filter f)
        {
            switch (f)
            {
                case Filter.F1:
                    radFilter1.Text = rx1_filters[(int)rx1_dsp_mode].GetName(Filter.F1);
                    break;
                case Filter.F2:
                    radFilter2.Text = rx1_filters[(int)rx1_dsp_mode].GetName(Filter.F2);
                    break;
                case Filter.F3:
                    radFilter3.Text = rx1_filters[(int)rx1_dsp_mode].GetName(Filter.F3);
                    break;
                case Filter.F4:
                    radFilter4.Text = rx1_filters[(int)rx1_dsp_mode].GetName(Filter.F4);
                    break;
                case Filter.F5:
                    radFilter5.Text = rx1_filters[(int)rx1_dsp_mode].GetName(Filter.F5);
                    break;
                case Filter.F6:
                    radFilter6.Text = rx1_filters[(int)rx1_dsp_mode].GetName(Filter.F6);
                    break;
                case Filter.F7:
                    radFilter7.Text = rx1_filters[(int)rx1_dsp_mode].GetName(Filter.F7);
                    break;
                case Filter.F8:
                    radFilter8.Text = rx1_filters[(int)rx1_dsp_mode].GetName(Filter.F8);
                    break;
                case Filter.F9:
                    radFilter9.Text = rx1_filters[(int)rx1_dsp_mode].GetName(Filter.F9);
                    break;
                case Filter.F10:
                    radFilter10.Text = rx1_filters[(int)rx1_dsp_mode].GetName(Filter.F10);
                    break;
                case Filter.VAR1:
                    radFilterVar1.Text = rx1_filters[(int)rx1_dsp_mode].GetName(Filter.VAR1);
                    break;
                case Filter.VAR2:
                    radFilterVar2.Text = rx1_filters[(int)rx1_dsp_mode].GetName(Filter.VAR2);
                    break;
            }

            if (f == rx1_filter)
                panelFilter.Text = "Filter - " + rx1_filters[(int)rx1_dsp_mode].GetName(f);
        }

        public void UpdateRX1FilterPresetLow(int val)
        {
            UpdateRX1Filters(val, (int)udFilterHigh.Value);
        }

        public void UpdateRX1FilterPresetHigh(int val)
        {
            UpdateRX1Filters((int)udFilterLow.Value, val);
        }

        public void UpdateRX2FilterNames(Filter f)
        {
            switch (f)
            {
                case Filter.F1:
                    radRX2Filter1.Text = rx2_filters[(int)rx2_dsp_mode].GetName(Filter.F1);
                    break;
                case Filter.F2:
                    radRX2Filter2.Text = rx2_filters[(int)rx2_dsp_mode].GetName(Filter.F2);
                    break;
                case Filter.F3:
                    radRX2Filter3.Text = rx2_filters[(int)rx2_dsp_mode].GetName(Filter.F3);
                    break;
                case Filter.F4:
                    radRX2Filter4.Text = rx2_filters[(int)rx2_dsp_mode].GetName(Filter.F4);
                    break;
                case Filter.F5:
                    radRX2Filter5.Text = rx2_filters[(int)rx2_dsp_mode].GetName(Filter.F5);
                    break;
                case Filter.F6:
                    radRX2Filter6.Text = rx2_filters[(int)rx2_dsp_mode].GetName(Filter.F6);
                    break;
                case Filter.F7:
                    radRX2Filter7.Text = rx2_filters[(int)rx2_dsp_mode].GetName(Filter.F7);
                    break;
                case Filter.VAR1:
                    radRX2FilterVar1.Text = rx2_filters[(int)rx2_dsp_mode].GetName(Filter.VAR1);
                    break;
                case Filter.VAR2:
                    radRX2FilterVar2.Text = rx2_filters[(int)rx2_dsp_mode].GetName(Filter.VAR2);
                    break;
            }

            if (f == rx2_filter)
                panelRX2Filter.Text = "RX2 Filter - " + rx2_filters[(int)rx2_dsp_mode].GetName(f);
        }

        public void UpdateRX2FilterPresetLow(int val)
        {
            UpdateRX2Filters(val, (int)udRX2FilterHigh.Value);
        }

        public void UpdateRX2FilterPresetHigh(int val)
        {
            UpdateRX2Filters((int)udRX2FilterLow.Value, val);
        }


        public void UpdateVFOAFreq(string freq)
        {   // only do this routine if there are six digits after the decimal point. or decimal comma

            Debug.WriteLine("VFOA=============" + freq);

          //  freq = freq.ToString(CultureInfo.CurrentCulture.NumberFormat); // .253
          
         //   Debug.WriteLine("VFOA=============" + freq);

            dialcheckA = true;  // update DIAL if active

            //   if (VFOAFreq > 9999.999999)
            //  {
            //   txtVFOALSD.Visible = false;
            //   txtVFOAMSD.Visible = false;

            // }
            //  else
            //  {
            txtVFOALSD.Visible = SmallLSD;
            txtVFOAMSD.Visible = SmallLSD;
            //  }

            txtVFOAFreq.Text = freq;
            txtVFOAMSD.Text = freq;


            string temp = freq;
            int index = temp.IndexOf(separator) + 4; //


            index = temp.IndexOf(separator) + 4; // 3 digits
            txtVFOALSD.Width = 75; // default is 73
                                   //   txtVFOALSD.Location = new Point(184, 17); // default is 184,17 .228


            txtVFOALSD.Text = temp.Remove(0, index);  // 3 small orange digits (remove digits xxx.xxx)

            if (KWAutoInformation) BroadcastFreqChange("A", freq); // kenwood auto info AI CAT command for each CAT port
            if (KWAutoInformation2) BroadcastFreqChange2("A", freq);  //.214
            if (KWAutoInformation3) BroadcastFreqChange3("A", freq);
            if (KWAutoInformation4) BroadcastFreqChange4("A", freq);
            if (KWAutoInformation5) BroadcastFreqChange5("A", freq);
            if (KWAutoInformation6) BroadcastFreqChange6("A", freq);
            
            if (KWAutoInformation7) BroadcastFreqChange7("A", freq); // TCP/IP CAT



        } // update vfoA freq


        public bool SpoofAB = false; // ke9ns: add .200 use special CAT port to spoof VFOB data as VFOA (to run 2 instances of a digitial mode program and use RX2 VFOB as VFOA
        public bool LastVFOBTX = false; // ke9ns add .200  true = SpoofAB caused the TX on VFOB, so return TX to VFOA after TX is over.
        public bool SpoofTX = false; // ke9ns add .200 true=TX in spoof mode, false=not in TX with spoof

        private void BroadcastFreqChange(string vfo, string freq)
        {
            if (siolisten.SIO == null) return;

            try
            {
                freq = "F" + vfo + freq.Replace(separator, "").PadLeft(11, '0') + ";";
                siolisten.SIO.put(freq);

            }
            catch { }
        } // BroadcastFreqChange

        private void BroadcastFreqChange2(string vfo, string freq) // ke9ns add .214
        {
            if (siolisten2.SIO2 == null) return;

            try
            {
                freq = "F" + vfo + freq.Replace(separator, "").PadLeft(11, '0') + ";";

                siolisten2.SIO2.put(freq); // ke9ns .180 port2
            }
            catch { }
        } //BroadcastFreqChange2

        private void BroadcastFreqChange3(string vfo, string freq) // ke9ns add .214
        {

            if (siolisten3.SIO3 == null) return;

            try
            {
                freq = "F" + vfo + freq.Replace(separator, "").PadLeft(11, '0') + ";";

                siolisten3.SIO3.put(freq); // ke9ns .180 port2
            }
            catch { }
        } //BroadcastFreqChange3

        private void BroadcastFreqChange4(string vfo, string freq) // ke9ns add .214
        {
            if (siolisten4.SIO4 == null) return;

            try
            {
                freq = "F" + vfo + freq.Replace(separator, "").PadLeft(11, '0') + ";";

                siolisten4.SIO4.put(freq); // ke9ns .180 port2
            }
            catch { }
        } //BroadcastFreqChange4

        private void BroadcastFreqChange5(string vfo, string freq) // ke9ns add .214
        {
            if (siolisten5.SIO5 == null) return;

            try
            {
                freq = "F" + vfo + freq.Replace(separator, "").PadLeft(11, '0') + ";";

                siolisten5.SIO5.put(freq); // ke9ns .180 port2
            }
            catch { }
        } //BroadcastFreqChange5

        private void BroadcastFreqChange6(string vfo, string freq) // ke9ns add .214
        {

            if (siolisten6.SIO6 == null) return;
            
                try
                {
                    freq = "F" + vfo + freq.Replace(separator, "").PadLeft(11, '0') + ";";
                    siolisten6.SIO6.put(freq); // ke9ns .180 port2
                    
                }
                catch (Exception x)
                {
                    Debug.WriteLine("BroadcastFreqChange65 " + x);
                }
            
        } //BroadcastFreqChange6

        private void BroadcastFreqChange7(string vfo, string freq) // ke9ns add .214
        {
            try
            {
                freq = "F" + vfo + freq.Replace(separator, "").PadLeft(11, '0') + ";";

                KWAI7 = true; //ke9ns: CATURL() should detect this
                CATURLFREQ = freq; //                           
            }
            catch { }
        } //BroadcastFreqChange7

        //=========================================================================
        public void UpdateVFOBFreq(string freq)
        {   // only do this routine if there are six digits after the decimal point.


            dialcheckB = true; // there was a update to the VFOB freq, so notify DIALB

            //   if (VFOBFreq > 9999.999999)
            //  {
            //    txtVFOBLSD.Visible = false;
            //   txtVFOBMSD.Visible = false;

            //  }
            //  else
            //  {
            txtVFOBLSD.Visible = SmallLSD;
            txtVFOBMSD.Visible = SmallLSD;
            //   }


            txtVFOBFreq.Text = freq;
            txtVFOBMSD.Text = freq;

            string temp = freq;
            int index = temp.IndexOf(separator) + 4;



            index = temp.IndexOf(separator) + 4; // 3 digits
            txtVFOBLSD.Width = 75;
            //  txtVFOBLSD.Location = new Point(184, 17); //.228



            txtVFOBLSD.Text = temp.Remove(0, index);
            if (KWAutoInformation) BroadcastFreqChange("B", freq);
            if (KWAutoInformation2) BroadcastFreqChange2("B", freq); // .214
            if (KWAutoInformation3) BroadcastFreqChange3("B", freq);
            if (KWAutoInformation4) BroadcastFreqChange4("B", freq);
            if (KWAutoInformation5) BroadcastFreqChange5("B", freq);
            if (KWAutoInformation6) BroadcastFreqChange6("B", freq);
          
            if (KWAutoInformation7) BroadcastFreqChange7("B", freq); // TCP/IP CAT




        }

        //===============================================================================
        //ke9ns: comes here when you change zoom levels or anything that would change your viewing left/right frequency limits
        public void CalcDisplayFreq()
        {

            if (Display.CurrentDisplayMode != DisplayMode.PANADAPTER &&
                Display.CurrentDisplayMode != DisplayMode.WATERFALL &&
                Display.CurrentDisplayMode != DisplayMode.PANAFALL &&
                Display.CurrentDisplayMode != DisplayMode.PANASCOPE)
                return;


            //double edge_alias = 7200.0;
            //double if_freq = 11025.0;

            double spur_tune_width = 0;
            switch (current_model)
            {
                case Model.SDR1000:
                    spur_tune_width = 200e6 / Math.Pow(2, 16);
                    break;
                case Model.FLEX5000:
                    spur_tune_width = 7629.39453125;   // 500e6 / Math.Pow(2, 16); // ke9ns 500mhz / 65536 = 7629.39453125
                    break;
                case Model.FLEX3000:
                    spur_tune_width = 7617.20275879; //  499.201e6 / Math.Pow(2, 16);
                    break;
                case Model.FLEX1500:
                    double clock = 384e6;
                    if (flex_1500_xref) clock = 400e6;

                    spur_tune_width = clock / Math.Pow(2, 16);
                    if (!chkSR.Checked) spur_tune_width = 2000;

                    break;
            } // switch current_model

            double zoom_factor = (ptbDisplayZoom.Maximum + ptbDisplayZoom.Minimum - ptbDisplayZoom.Value) * 0.01; // (260+1-value)*.01    range from LEFT= 2.6 RIGHT = .01

            int low = (int)(-10000.0 * sample_rate1 / 48000.0 * zoom_factor); //-40000 with zoom =1 or -96000 with zoom=.5
            int high = -low;
            int width = high - low; // ke9ns: in hz    40000- -40000 = +80000 at 192k SR and Zoom = 1x

            if (width > sample_rate1 - 2 * spur_tune_width) width = (int)(sample_rate1 - 2 * spur_tune_width);

            // ke9ns: below calculates the +/- hz of the full absolute widest the display could be (with no zoom at all)
            int abs_low = (int)(-(double)sample_rate1 * 0.5 - if_freq * 1e6 + spur_tune_width); // (-192000 * .5) - (0.009000 * 1000000) + 7629.39453125 = -96000 - 9000 + 7629.39453125  = -97373
            int abs_high = (int)((double)sample_rate1 * 0.5 - if_freq * 1e6 - spur_tune_width); // +97373 

            if (high > abs_high)
            {
                //Debug.WriteLine("high: "+high+"  abs_high: "+abs_high);
                high = abs_high;
                low = high - width;
            }

            if (low < abs_low)
            {
                //Debug.WriteLine("low: "+low+"  abs_low: "+abs_low);
                low = abs_low;
                high = low + width;
            }

            // ke9ns: this would get you 192k across the pan, but signals drop off on the edges.
            //  high = abs_high+8000;
            //  low = abs_low-8000;
            //  width = high - low;

            // ke9ns Factor in the PAN slider (which allows you to slide around within the absolute limits)
            int max_pan_width = (int)(sample_rate1 - 2 * spur_tune_width - width); // ke9ns  192000 - (2 * 7629.39453125) - 80000 = 96741

            int pan_freq = max_pan_width * ptbDisplayPan.Value / ptbDisplayPan.Maximum; // ke9ns 96741 * 593 / 1000 = 57367

            low = abs_low + pan_freq; // ke9ns: -97373 + 57367 = -40000

            low = low - (int)CTUN1_HZ; // ke9ns add: CTUN (adjust display so it appears as if the VFOA bandpass is moving but not the panadapter and not the waterfall 

            high = low + width; // -4000 + 8000 = 40000

            //   if (CTUN == true) CTUN3 = 1; // ke9ns add: dont allow rundisplay() thread from updating display while in CTUN mode

            Display.RXDisplayLow = Display.TXDisplayLow = low; // ke9ns at 192k SR  low = -96000 with zoom =.5 (different for Spectrum display)
            Display.RXDisplayHigh = Display.TXDisplayHigh = high;

            //  Debug.WriteLine("Display Limits: " + low + ", " + high);


            if (CTUN == true) // ke9ns add
            {
                VFOAFreq = tempVFOAFreq; // CTUN operation changed freq
            }

            //-------------------------------------------------------
            // ke9ns for RX2

            if (current_model == Model.FLEX5000 && FWCEEPROM.RX2OK)  //.220 corrected
            {
                double zoom_factor2 = (ptbDisplayZoom2.Maximum + ptbDisplayZoom2.Minimum - ptbDisplayZoom2.Value) * 0.01; // (260+1-value)*.01    range from LEFT= 2.6 RIGHT = .01

                int low2 = (int)(-10000.0 * sample_rate1 / 48000.0 * zoom_factor2); //-40000 with zoom =1 or -96000 with zoom=.5
                int high2 = -low2;
                int width2 = high2 - low2; // ke9ns: in hz    40000- -40000 = +80000 at 192k SR and Zoom = 1x

                if (width2 > sample_rate1 - 2 * spur_tune_width) width2 = (int)(sample_rate1 - 2 * spur_tune_width);

                // ke9ns: below calculates the +/- hz of the full absolute widest the display could be (with no zoom at all)
                int abs_low2 = (int)(-(double)sample_rate1 * 0.5 - if_freq * 1e6 + spur_tune_width); // (-192000 * .5) - (0.009000 * 1000000) + 7629.39453125 = -96000 - 9000 + 7629.39453125  = -97373
                int abs_high2 = (int)((double)sample_rate1 * 0.5 - if_freq * 1e6 - spur_tune_width); // +97373 

                if (high2 > abs_high2)
                {
                    //Debug.WriteLine("high: "+high+"  abs_high: "+abs_high);
                    high2 = abs_high2;
                    low2 = high - width2;
                }

                if (low2 < abs_low2)
                {
                    //Debug.WriteLine("low: "+low+"  abs_low: "+abs_low);
                    low2 = abs_low2;
                    high2 = low2 + width2;
                }

                // ke9ns: this would get you 192k across the pan, but signals drop off on the edges.
                //  high = abs_high+8000;
                //  low = abs_low-8000;
                //  width = high - low;

                // ke9ns Factor in the PAN slider (which allows you to slide around within the absolute limits)
                int max_pan_width2 = (int)(sample_rate1 - 2 * spur_tune_width - width2); // ke9ns  192000 - (2 * 7629.39453125) - 80000 = 96741

                int pan_freq2 = max_pan_width2 * ptbDisplayPan2.Value / ptbDisplayPan2.Maximum; // ke9ns 96741 * 593 / 1000 = 57367

                low2 = abs_low2 + pan_freq2; // ke9ns: -97373 + 57367 = -40000

                low2 = low2 - (int)CTUN1_HZ; // ke9ns add: CTUN (adjust display so it appears as if the VFOB bandpass is moving but not the panadapter and not the waterfall 

                high2 = low2 + width2; // -4000 + 8000 = 40000

                //   if (CTUN == true) CTUN3 = 1; // ke9ns add: dont allow rundisplay() thread from updating display while in CTUN mode

                Display.RXDisplayLow2 = Display.TXDisplayLow2 = low2; // ke9ns at 192k SR  low = -96000 with zoom =.5 (different for Spectrum display)
                Display.RXDisplayHigh2 = Display.TXDisplayHigh2 = high2;

            } // rx2 //.219


            //  Debug.WriteLine("Display Limits: " + low + ", " + high);

            UpdateDisplay(); // force a redraw of the picDisplay since you have new freq edges based on new zoom level


            //  CTUN3 = 0;

        } //CalcDisplayFreq()



        private void UpdateRXDisplayVars(int l, int h)
        {
            int low = 0, high = 0;
            if (l < 0 && h <= 0)
            {
                high = 0;
                if (l >= -910)
                    low = -1000;
                else
                    low = (int)(l * 1.1);
            }
            else if (l >= 0 && h > 0)
            {
                low = 0;
                if (h <= 910)
                    high = 1000;
                else
                    high = (int)(h * 1.1);
            }
            else if (l < 0 && h > 0)
            {
                int max_edge = Math.Max(-l, h);
                low = (int)(max_edge * -1.1);
                high = (int)(max_edge * 1.1);
            }
            Display.RXDisplayLow = low;
            Display.RXDisplayHigh = high;
        } // UpdateRXDisplayVars

        private void UpdateRXDisplayVars2(int l, int h) //.219
        {
            int low = 0, high = 0;
            if (l < 0 && h <= 0)
            {
                high = 0;
                if (l >= -910)
                    low = -1000;
                else
                    low = (int)(l * 1.1);
            }
            else if (l >= 0 && h > 0)
            {
                low = 0;
                if (h <= 910)
                    high = 1000;
                else
                    high = (int)(h * 1.1);
            }
            else if (l < 0 && h > 0)
            {
                int max_edge = Math.Max(-l, h);
                low = (int)(max_edge * -1.1);
                high = (int)(max_edge * 1.1);
            }
            Display.RXDisplayLow2 = low;
            Display.RXDisplayHigh2 = high;
        } // UPdatedisplayvars


        public static void UpdateTXDisplayVars(int l, int h)
        {
            int low = 0, high = 0;
            if (l < 0 && h <= 0)
            {
                high = 0;
                if (l >= -910)
                    low = -1000;
                else
                    low = (int)(l * 1.1);
            }
            else if (l >= 0 && h > 0)
            {
                low = 0;
                if (h <= 910)
                    high = 1000;
                else
                    high = (int)(h * 1.1);
            }
            else if (l < 0 && h > 0)
            {
                int max_edge = Math.Max(-l, h);
                low = (int)(max_edge * -1.1);
                high = (int)(max_edge * 1.1);
            }

            Display.TXDisplayLow = low;
            Display.TXDisplayHigh = high;


        } //UpdateTXDisplayVars

        public static void UpdateTXDisplayVars2(int l, int h) //.219 add
        {
            int low = 0, high = 0;
            if (l < 0 && h <= 0)
            {
                high = 0;
                if (l >= -910)
                    low = -1000;
                else
                    low = (int)(l * 1.1);
            }
            else if (l >= 0 && h > 0)
            {
                low = 0;
                if (h <= 910)
                    high = 1000;
                else
                    high = (int)(h * 1.1);
            }
            else if (l < 0 && h > 0)
            {
                int max_edge = Math.Max(-l, h);
                low = (int)(max_edge * -1.1);
                high = (int)(max_edge * 1.1);
            }

            Display.TXDisplayLow2 = low;
            Display.TXDisplayHigh2 = high;


        } //UpdateTXDisplayVars2

        // ke9ns modify for ISB  LSB-AM and USB-AM
        public void SetTXFilters(DSPMode mode, int low, int high)
        {
            //  Debug.WriteLine("... HIGH-LOW: " + high + " , " + low + " mode: " + mode + " band: " + rx1_band + " Tband: " + tx_band);

            int l = 0, h = 0;

            low = (int)Math.Max(low, 15);  // ke9ns mod:  was 50  I guess this is the lowest of the low  50hz

            switch (mode)
            {
                case DSPMode.CWL: // ke9ns moved (to allow smaller tx window)
                    l = -high;
                    h = -low;

                    break;
                case DSPMode.CWU: // ke9ns moved (to allow smaller tx window)
                    l = low;
                    h = high;

                    break;
                case DSPMode.LSB:
                case DSPMode.DIGL:
                    l = -high;
                    h = -low;
                    break;
                case DSPMode.USB:
                case DSPMode.DIGU:
                    l = low;
                    h = high;
                    break;
                case DSPMode.DSB:
                    l = -high;
                    h = high;
                    break;
                case DSPMode.AM:

                    if (AMMODE == DSPISB.AML) // ke9ns add
                    {
                        l = -high;
                        h = 130; //  needs 130 to allow full power of carrier
                    }
                    else if (AMMODE == DSPISB.AMU)
                    {
                        l = -130; // needs -130 to allow full power of carrier
                        h = high;
                    }
                    else
                    {
                        l = -high;  // ke9ns normal AM mode
                        h = high;
                    }


                    break; // AM

                case DSPMode.SAM:

                    if (SAMMODE == DSPISB.AML) // ke9ns add
                    {
                        l = -high;
                        h = 130; //  needs 130 to allow full power of carrier
                    }
                    else if (SAMMODE == DSPISB.AMU)
                    {
                        l = -130; // needs -130 to allow full power of carrier
                        h = high;
                    }
                    else
                    {
                        l = -high;  // ke9ns normal AM mode
                        h = high;
                    }

                    break; // SAM

                case DSPMode.FM:
                    if (dsp.GetDSPTX(0).TXFMDeviation == FMDataDeviation)     //FMData == true) // ke9ns add (FM data mode with larger freq window) WFM
                    {
                        l = -FMDataLowHigh; // -11000 (change to 20k .218)
                        h = FMDataLowHigh;  // 11000
                    }
                    else if (dsp.GetDSPTX(0).TXFMDeviation == 5000)
                    {
                        l = -8000;
                        h = 8000;
                    }
                    else if (dsp.GetDSPTX(0).TXFMDeviation == 2500)
                    {
                        l = -4000;
                        h = 4000;
                    }
                    break;
                case DSPMode.DRM:
                    l = 7000;
                    h = 17000;
                    break;
            }

            switch (Display.CurrentDisplayMode)
            {
                case DisplayMode.PANADAPTER:
                case DisplayMode.WATERFALL:
                case DisplayMode.PANAFALL:
                case DisplayMode.PANASCOPE:
                    break;
                default:
                    UpdateTXDisplayVars(l, h);
                    UpdateTXDisplayVars2(l, h); //.219 add
                    break;
            }

            dsp.GetDSPTX(0).SetTXFilter(l, h);

            //  dsp.GetDSPTX(0).SetTXFilter(-90000, 0); // ke9ns testdsp limited to about 90khz


            if (fwc_init && (current_model == Model.FLEX5000 || current_model == Model.FLEX3000))
            {
                FWC.SetTXDSPFilter(l, h);
            }

            Display.TXFilterLow = l;
            Display.TXFilterHigh = h;

            //   Debug.WriteLine("SET HIGH-LOW: " + h + " , " + l + " mode: " + mode + " band: " + rx1_band + " Tband: " + tx_band);


            if (chkVFOSplit.Checked == true)
            {
                Display.SplitEnabled = true; // ke9ns reset the SPLIT TX for AM-U and AM-L 

            }

        } // set txfilters


        public void UpdateTXProfile(string name)
        {
            if (setupForm == null) return;

            //string old = comboTXProfile.Text;
            comboTXProfile.Items.Clear();
            comboDigTXProfile.Items.Clear();
            comboFMTXProfile.Items.Clear();
            comboCWTXProfile.Items.Clear(); // ke9ns
            string[] s = setupForm.GetTXProfileStrings();

            comboTXProfile.Items.AddRange(s);
            comboDigTXProfile.Items.AddRange(s);
            comboFMTXProfile.Items.AddRange(s);
            comboCWTXProfile.Items.AddRange(s); // ke9ns add

            if (name != "") comboTXProfile.Text = name;
        }



        //=================================================================================================
        public void UpdateWaterfallLevelValues()
        {

            if (!initializing)
            {

                UpdateBandButtonColors(); // ke9ns add to update the regBOX bandstack values on screen

                if (StackForm != null)
                {
                    int value;
                    StackForm.textBox1.Focus();

                    if (int.TryParse(regBox1.Text, out value))
                    {

                        if (value > 0)
                        {
                            StackForm.textBox1.SelectionStart = (value - 1) * StackForm.BSLength;       // start of each bandstack line
                            StackForm.textBox1.SelectionLength = StackForm.BSLength;                    // length of each bandstack line

                            textBox1.SelectionStart = (value - 1) * StackForm.BSLength;       // start of each bandstack line
                            textBox1.SelectionLength = StackForm.BSLength;                    // length of each bandstack line

                        }
                        else
                        {
                            StackForm.textBox1.SelectionStart = 0;
                            StackForm.textBox1.SelectionLength = StackForm.BSLength;

                            textBox1.SelectionStart = 0;
                            textBox1.SelectionLength = StackForm.BSLength;

                        }

                    }
                    else
                    {
                        Debug.WriteLine("no value");
                        StackForm.textBox1.SelectionStart = 0;
                        StackForm.textBox1.SelectionLength = StackForm.BSLength;

                        textBox1.SelectionStart = 0;
                        textBox1.SelectionLength = StackForm.BSLength;

                    }
                }

                //
                switch (RX1Band)
                {
                    case Band.B160M:
                        setupForm.WaterfallLowThreshold = WaterfallLowThreshold160m;
                        setupForm.WaterfallHighThreshold = WaterfallHighThreshold160m;
                        Display.WaterfallLowThreshold = WaterfallLowThreshold160m;
                        Display.WaterfallHighThreshold = WaterfallHighThreshold160m;


                        break;
                    case Band.B80M:
                        setupForm.WaterfallLowThreshold = WaterfallLowThreshold80m;
                        setupForm.WaterfallHighThreshold = WaterfallHighThreshold80m;
                        Display.WaterfallLowThreshold = WaterfallLowThreshold80m;
                        Display.WaterfallHighThreshold = WaterfallHighThreshold80m;



                        break;
                    case Band.B60M:
                        setupForm.WaterfallLowThreshold = WaterfallLowThreshold60m;
                        setupForm.WaterfallHighThreshold = WaterfallHighThreshold60m;
                        Display.WaterfallLowThreshold = WaterfallLowThreshold60m;
                        Display.WaterfallHighThreshold = WaterfallHighThreshold60m;


                        break;
                    case Band.B40M:
                        setupForm.WaterfallLowThreshold = WaterfallLowThreshold40m;
                        setupForm.WaterfallHighThreshold = WaterfallHighThreshold40m;
                        Display.WaterfallLowThreshold = WaterfallLowThreshold40m;
                        Display.WaterfallHighThreshold = WaterfallHighThreshold40m;


                        break;
                    case Band.B30M:
                        setupForm.WaterfallLowThreshold = WaterfallLowThreshold30m;
                        setupForm.WaterfallHighThreshold = WaterfallHighThreshold30m;
                        Display.WaterfallLowThreshold = WaterfallLowThreshold30m;
                        Display.WaterfallHighThreshold = WaterfallHighThreshold30m;


                        break;
                    case Band.B20M:
                        setupForm.WaterfallLowThreshold = WaterfallLowThreshold20m;
                        setupForm.WaterfallHighThreshold = WaterfallHighThreshold20m;
                        Display.WaterfallLowThreshold = WaterfallLowThreshold20m;
                        Display.WaterfallHighThreshold = WaterfallHighThreshold20m;
                        break;

                    // ----------------------
                    // ke9ns add
                    case Band.BLMF:
                        setupForm.WaterfallLowThreshold = WaterfallLowThresholdLMF;
                        setupForm.WaterfallHighThreshold = WaterfallHighThresholdLMF;
                        Display.WaterfallLowThreshold = WaterfallLowThresholdLMF;
                        Display.WaterfallHighThreshold = WaterfallHighThresholdLMF;
                        break;
                    case Band.B120M:
                        setupForm.WaterfallLowThreshold = WaterfallLowThreshold120m;
                        setupForm.WaterfallHighThreshold = WaterfallHighThreshold120m;
                        Display.WaterfallLowThreshold = WaterfallLowThreshold120m;
                        Display.WaterfallHighThreshold = WaterfallHighThreshold120m;
                        break;
                    case Band.B90M:
                        setupForm.WaterfallLowThreshold = WaterfallLowThreshold90m;
                        setupForm.WaterfallHighThreshold = WaterfallHighThreshold90m;
                        Display.WaterfallLowThreshold = WaterfallLowThreshold90m;
                        Display.WaterfallHighThreshold = WaterfallHighThreshold90m;
                        break;
                    case Band.B61M:
                        setupForm.WaterfallLowThreshold = WaterfallLowThreshold61m;
                        setupForm.WaterfallHighThreshold = WaterfallHighThreshold61m;
                        Display.WaterfallLowThreshold = WaterfallLowThreshold61m;
                        Display.WaterfallHighThreshold = WaterfallHighThreshold61m;
                        break;
                    case Band.B49M:
                        setupForm.WaterfallLowThreshold = WaterfallLowThreshold49m;
                        setupForm.WaterfallHighThreshold = WaterfallHighThreshold49m;
                        Display.WaterfallLowThreshold = WaterfallLowThreshold49m;
                        Display.WaterfallHighThreshold = WaterfallHighThreshold49m;
                        break;
                    case Band.B41M:
                        setupForm.WaterfallLowThreshold = WaterfallLowThreshold41m;
                        setupForm.WaterfallHighThreshold = WaterfallHighThreshold41m;
                        Display.WaterfallLowThreshold = WaterfallLowThreshold41m;
                        Display.WaterfallHighThreshold = WaterfallHighThreshold41m;
                        break;
                    case Band.B31M:
                        setupForm.WaterfallLowThreshold = WaterfallLowThreshold31m;
                        setupForm.WaterfallHighThreshold = WaterfallHighThreshold31m;
                        Display.WaterfallLowThreshold = WaterfallLowThreshold31m;
                        Display.WaterfallHighThreshold = WaterfallHighThreshold31m;
                        break;
                    case Band.B25M:
                        setupForm.WaterfallLowThreshold = WaterfallLowThreshold25m;
                        setupForm.WaterfallHighThreshold = WaterfallHighThreshold25m;
                        Display.WaterfallLowThreshold = WaterfallLowThreshold25m;
                        Display.WaterfallHighThreshold = WaterfallHighThreshold25m;
                        break;
                    case Band.B22M:
                        setupForm.WaterfallLowThreshold = WaterfallLowThreshold22m;
                        setupForm.WaterfallHighThreshold = WaterfallHighThreshold22m;
                        Display.WaterfallLowThreshold = WaterfallLowThreshold22m;
                        Display.WaterfallHighThreshold = WaterfallHighThreshold22m;
                        break;
                    case Band.B19M:
                        setupForm.WaterfallLowThreshold = WaterfallLowThreshold19m;
                        setupForm.WaterfallHighThreshold = WaterfallHighThreshold19m;
                        Display.WaterfallLowThreshold = WaterfallLowThreshold19m;
                        Display.WaterfallHighThreshold = WaterfallHighThreshold19m;
                        break;
                    case Band.B16M:
                        setupForm.WaterfallLowThreshold = WaterfallLowThreshold16m;
                        setupForm.WaterfallHighThreshold = WaterfallHighThreshold16m;
                        Display.WaterfallLowThreshold = WaterfallLowThreshold16m;
                        Display.WaterfallHighThreshold = WaterfallHighThreshold16m;
                        break;
                    case Band.B14M:
                        setupForm.WaterfallLowThreshold = WaterfallLowThreshold14m;
                        setupForm.WaterfallHighThreshold = WaterfallHighThreshold14m;
                        Display.WaterfallLowThreshold = WaterfallLowThreshold14m;
                        Display.WaterfallHighThreshold = WaterfallHighThreshold14m;
                        break;
                    case Band.B13M:
                        setupForm.WaterfallLowThreshold = WaterfallLowThreshold13m;
                        setupForm.WaterfallHighThreshold = WaterfallHighThreshold13m;
                        Display.WaterfallLowThreshold = WaterfallLowThreshold13m;
                        Display.WaterfallHighThreshold = WaterfallHighThreshold13m;
                        break;
                    case Band.B11M:
                        setupForm.WaterfallLowThreshold = WaterfallLowThreshold11m;
                        setupForm.WaterfallHighThreshold = WaterfallHighThreshold11m;
                        Display.WaterfallLowThreshold = WaterfallLowThreshold11m;
                        Display.WaterfallHighThreshold = WaterfallHighThreshold11m;

                        //----------------------


                        break;
                    case Band.B17M:
                        setupForm.WaterfallLowThreshold = WaterfallLowThreshold17m;
                        setupForm.WaterfallHighThreshold = WaterfallHighThreshold17m;
                        Display.WaterfallLowThreshold = WaterfallLowThreshold17m;
                        Display.WaterfallHighThreshold = WaterfallHighThreshold17m;


                        break;
                    case Band.B15M:
                        setupForm.WaterfallLowThreshold = WaterfallLowThreshold15m;
                        setupForm.WaterfallHighThreshold = WaterfallHighThreshold15m;
                        Display.WaterfallLowThreshold = WaterfallLowThreshold15m;
                        Display.WaterfallHighThreshold = WaterfallHighThreshold15m;


                        break;
                    case Band.B12M:
                        setupForm.WaterfallLowThreshold = WaterfallLowThreshold12m;
                        setupForm.WaterfallHighThreshold = WaterfallHighThreshold12m;
                        Display.WaterfallLowThreshold = WaterfallLowThreshold12m;
                        Display.WaterfallHighThreshold = WaterfallHighThreshold12m;


                        break;
                    case Band.B10M:
                        setupForm.WaterfallLowThreshold = WaterfallLowThreshold10m;
                        setupForm.WaterfallHighThreshold = WaterfallHighThreshold10m;
                        Display.WaterfallLowThreshold = WaterfallLowThreshold10m;
                        Display.WaterfallHighThreshold = WaterfallHighThreshold10m;



                        break;
                    case Band.B6M:
                        setupForm.WaterfallLowThreshold = WaterfallLowThreshold6m;
                        setupForm.WaterfallHighThreshold = WaterfallHighThreshold6m;
                        Display.WaterfallLowThreshold = WaterfallLowThreshold6m;
                        Display.WaterfallHighThreshold = WaterfallHighThreshold6m;


                        break;
                    case Band.WWV:
                        setupForm.WaterfallLowThreshold = WaterfallLowThresholdWWV;
                        setupForm.WaterfallHighThreshold = WaterfallHighThresholdWWV;
                        Display.WaterfallLowThreshold = WaterfallLowThresholdWWV;
                        Display.WaterfallHighThreshold = WaterfallHighThresholdWWV;


                        break;
                    case Band.GEN:
                        setupForm.WaterfallLowThreshold = WaterfallLowThresholdGEN;
                        setupForm.WaterfallHighThreshold = WaterfallHighThresholdGEN;
                        Display.WaterfallLowThreshold = WaterfallLowThresholdGEN;
                        Display.WaterfallHighThreshold = WaterfallHighThresholdGEN;


                        break;
                    default:
                        setupForm.WaterfallLowThreshold = WaterfallLowThresholdXVTR;
                        setupForm.WaterfallHighThreshold = WaterfallHighThresholdXVTR;
                        Display.WaterfallLowThreshold = WaterfallLowThresholdXVTR;
                        Display.WaterfallHighThreshold = WaterfallHighThresholdXVTR;

                        break;

                } // RX1Band

                //   UpdateBandButtonColors(); // ke9ns add to update the regBOX bandstack values on screen

                //================================================================
                //================================================================
                // ke9ns add: copy low waterfall value from standard RX1 position into RX2 low 
                //================================================================
                //================================================================

                int value2;
                // StackForm.textBox2.Focus();

                if (int.TryParse(regBox12, out value2))
                {

                    if (value2 > 0)
                    {
                        //  StackForm.textBox2.SelectionStart = (value - 1) * StackForm.BSLength;       // start of each bandstack line
                        //   StackForm.textBox2.SelectionLength = StackForm.BSLength;                    // length of each bandstack line

                        textBox2.SelectionStart = (value2 - 1) * StackForm.BSLength;       // start of each bandstack line
                        textBox2.SelectionLength = StackForm.BSLength;                    // length of each bandstack line

                    }
                    else
                    {
                        //  StackForm.textBox2.SelectionStart = 0;
                        //  StackForm.textBox2.SelectionLength = StackForm.BSLength;

                        textBox2.SelectionStart = 0;
                        textBox2.SelectionLength = StackForm.BSLength;

                    }

                }
                else
                {
                    Debug.WriteLine("no value");
                    //  StackForm.textBox1.SelectionStart = 0;
                    // StackForm.textBox1.SelectionLength = StackForm.BSLength;

                    textBox2.SelectionStart = 0;
                    textBox2.SelectionLength = StackForm.BSLength;

                }



                rx2_band = StringToBand(comboRX2Band.Text);  // ke9ns add  get band even if OFF, just in case you turn it on later

                switch (RX2Band)  // ke9ns ADD (not reading correctly here when RX2 is off)
                {

                    case Band.B160M:
                        setupForm.WaterfallLowRX2Threshold = WaterfallLowThreshold160m;  // ke9ns ADD rx2
                        Display.WaterfallLowRX2Threshold = WaterfallLowThreshold160m;
                        break;
                    case Band.B80M:
                        setupForm.WaterfallLowRX2Threshold = WaterfallLowThreshold80m;
                        Display.WaterfallLowRX2Threshold = WaterfallLowThreshold80m;
                        break;
                    case Band.B60M:
                        setupForm.WaterfallLowRX2Threshold = WaterfallLowThreshold60m;
                        Display.WaterfallLowRX2Threshold = WaterfallLowThreshold60m;
                        break;
                    case Band.B40M:
                        setupForm.WaterfallLowRX2Threshold = WaterfallLowThreshold40m;
                        Display.WaterfallLowRX2Threshold = WaterfallLowThreshold40m;
                        break;
                    case Band.B30M:
                        setupForm.WaterfallLowRX2Threshold = WaterfallLowThreshold30m;
                        Display.WaterfallLowRX2Threshold = WaterfallLowThreshold30m;
                        break;
                    case Band.B20M:
                        setupForm.WaterfallLowRX2Threshold = WaterfallLowThreshold20m;
                        Display.WaterfallLowRX2Threshold = WaterfallLowThreshold20m;
                        break;


                    //--------------------------
                    // ke9ns add

                    case Band.BLMF:
                        setupForm.WaterfallLowRX2Threshold = WaterfallLowThresholdLMF;
                        Display.WaterfallLowRX2Threshold = WaterfallLowThresholdLMF;
                        break;
                    case Band.B120M:
                        setupForm.WaterfallLowRX2Threshold = WaterfallLowThreshold120m;
                        Display.WaterfallLowRX2Threshold = WaterfallLowThreshold120m;
                        break;

                    case Band.B90M:
                        setupForm.WaterfallLowRX2Threshold = WaterfallLowThreshold90m;
                        Display.WaterfallLowRX2Threshold = WaterfallLowThreshold90m;
                        break;
                    case Band.B61M:
                        setupForm.WaterfallLowRX2Threshold = WaterfallLowThreshold61m;
                        Display.WaterfallLowRX2Threshold = WaterfallLowThreshold61m;
                        break;

                    case Band.B49M:
                        setupForm.WaterfallLowRX2Threshold = WaterfallLowThreshold49m;
                        Display.WaterfallLowRX2Threshold = WaterfallLowThreshold49m;
                        break;

                    case Band.B41M:
                        setupForm.WaterfallLowRX2Threshold = WaterfallLowThreshold41m;
                        Display.WaterfallLowRX2Threshold = WaterfallLowThreshold41m;
                        break;
                    case Band.B31M:
                        setupForm.WaterfallLowRX2Threshold = WaterfallLowThreshold31m;
                        Display.WaterfallLowRX2Threshold = WaterfallLowThreshold31m;
                        break;

                    case Band.B25M:
                        setupForm.WaterfallLowRX2Threshold = WaterfallLowThreshold25m;
                        Display.WaterfallLowRX2Threshold = WaterfallLowThreshold25m;
                        break;

                    case Band.B22M:
                        setupForm.WaterfallLowRX2Threshold = WaterfallLowThreshold22m;
                        Display.WaterfallLowRX2Threshold = WaterfallLowThreshold22m;
                        break;

                    case Band.B19M:
                        setupForm.WaterfallLowRX2Threshold = WaterfallLowThreshold19m;
                        Display.WaterfallLowRX2Threshold = WaterfallLowThreshold19m;
                        break;

                    case Band.B16M:
                        setupForm.WaterfallLowRX2Threshold = WaterfallLowThreshold16m;
                        Display.WaterfallLowRX2Threshold = WaterfallLowThreshold16m;
                        break;

                    case Band.B14M:
                        setupForm.WaterfallLowRX2Threshold = WaterfallLowThreshold14m;
                        Display.WaterfallLowRX2Threshold = WaterfallLowThreshold14m;
                        break;

                    case Band.B13M:
                        setupForm.WaterfallLowRX2Threshold = WaterfallLowThreshold13m;
                        Display.WaterfallLowRX2Threshold = WaterfallLowThreshold13m;
                        break;

                    case Band.B11M:
                        setupForm.WaterfallLowRX2Threshold = WaterfallLowThreshold11m;
                        Display.WaterfallLowRX2Threshold = WaterfallLowThreshold11m;
                        break;

                    //-----------------------

                    case Band.B17M:
                        setupForm.WaterfallLowRX2Threshold = WaterfallLowThreshold17m;
                        Display.WaterfallLowRX2Threshold = WaterfallLowThreshold17m;
                        break;
                    case Band.B15M:
                        setupForm.WaterfallLowRX2Threshold = WaterfallLowThreshold15m;
                        Display.WaterfallLowRX2Threshold = WaterfallLowThreshold15m;
                        break;
                    case Band.B12M:
                        setupForm.WaterfallLowRX2Threshold = WaterfallLowThreshold12m;
                        Display.WaterfallLowRX2Threshold = WaterfallLowThreshold12m;
                        break;
                    case Band.B10M:
                        setupForm.WaterfallLowRX2Threshold = WaterfallLowThreshold10m;
                        Display.WaterfallLowRX2Threshold = WaterfallLowThreshold10m;
                        break;
                    case Band.B6M:
                        setupForm.WaterfallLowRX2Threshold = WaterfallLowThreshold6m;
                        Display.WaterfallLowRX2Threshold = WaterfallLowThreshold6m;
                        break;
                    case Band.WWV:
                        setupForm.WaterfallLowRX2Threshold = WaterfallLowThresholdWWV;
                        Display.WaterfallLowRX2Threshold = WaterfallLowThresholdWWV;
                        break;
                    case Band.GEN:
                        setupForm.WaterfallLowRX2Threshold = WaterfallLowThresholdGEN;
                        Display.WaterfallLowRX2Threshold = WaterfallLowThresholdGEN;
                        break;
                    default:
                        setupForm.WaterfallLowRX2Threshold = WaterfallLowThresholdXVTR;
                        Display.WaterfallLowRX2Threshold = WaterfallLowThresholdXVTR;
                        break;
                } // RX2Band

                //    Debug.WriteLine("rX2 low upateband " + RX2Band);
                //    Debug.WriteLine("rX2 low upatevalue " + Display.WaterfallLowRX2Threshold);

                setupForm.UpdateWaterfallBandInfo();

                AA.Restart(); // ke9ns
                autoadjust1 = true; // ke9ns add for automatic water and pan level updates

            } // !initializing



        } // UpdateWaterfallLevelValues()



        public void ShowRemoteProfileMenu(bool action)
        {
            remoteProfilesToolStripMenuItem.Visible = action;
        }

        public string CATGetXVTRBandNames()
        {
            string names = "";
            for (int n = 0; n < 14; n++)
            {
                if (xvtrForm.GetEnabled(n) == true)
                    names += vhf_text[n].Text.ToString().PadLeft(5, ' ');

                else
                    names += "     ";
            }
            return names;
        }

        public string GetFilterPresets(int mode_ndx)
        {
            string mode_info = "";
            for (Filter f = Filter.F1; f < Filter.NONE; f++)
            {

                mode_info += rx1_filters[mode_ndx].GetName(f).PadLeft(5, ' ').Substring(0, 5);
                mode_info += rx1_filters[mode_ndx].GetHigh(f).ToString().PadLeft(5, ' ');
                mode_info += rx1_filters[mode_ndx].GetLow(f).ToString().PadLeft(5, ' ');
            }
            return mode_info;
        }

        private void Set1500Filters(double freq)
        {
            // set TRX Filter
            int trx_filter = 0;
            if (freq < 0.48) // bypass
                trx_filter = 0;
            else if (freq < 0.88)
                trx_filter = 11; // AM 1
            else if (freq < 1.6)
                trx_filter = 10; // AM 2
            else if (freq < 2.3)
                trx_filter = 9;  // 160m
            else if (freq < 3.5)
                trx_filter = 8;  // 80m
            else if (freq < 5.2)
                trx_filter = 7;  // ??
            else if (freq < 7.7)
                trx_filter = 6;  // 60/40m
            else if (freq < 11.4)
                trx_filter = 5;  // 30m
            else if (freq < 17.0)
                trx_filter = 4;  // 20m
            else if (freq < 25.3)
                trx_filter = 3;  // 15/12m
            else if (freq < 37.6)
                trx_filter = 2;  // 10m
            else if (freq < 56.0)
                trx_filter = 1;  // 6m

            HIDTRXFilter = trx_filter;

            if (tx_ant_1500 == HIDAnt.PA)
            {
                int pa_filter = 0;
                if (freq < 0.0)
                    pa_filter = 0; // bypass
                else if (freq < 2.5)
                    pa_filter = 7; // 160m
                else if (freq < 5.0)
                    pa_filter = 6; // 80m
                else if (freq < 8.8)
                    pa_filter = 5; // 60/40m
                else if (freq < 17.5)
                    pa_filter = 4; // 30/20m
                else if (freq < 24.0)
                    pa_filter = 3; // 17/15m
                else if (freq < 35.0)
                    pa_filter = 2; // 12/10m
                else
                    pa_filter = 1; // 6m

                HIDPAFilter = pa_filter;
            }
        }

        private int SetVURXPath()
        {
            /*				Von		Uon		VRX2	URX2
            0   VU not used	0		0		0		0
            1	URX1		0		1		0		0
            2	URX2		0		1		0		1
            3	VRX1*		1		0		0		0
            4	VRX2		1		0		1		0
            5	VRX1, URX2*	1		1		0		1
            6	VRX2, URX1	1		1		1		0
            -  Invalid     1       1       1       1
            -  Invalid     1       1       0       0 (Split)
            */
            if (swapping) return 0;
            int rx2_xvtr_index_local = rx2_xvtr_index;
            if (!rx2_enabled)
                rx2_xvtr_index_local = -1;

            if (rx1_xvtr_index == 0)
            {
                if (rx2_xvtr_index_local == 0)
                {
                    //MessageBox.Show(new Form { TopMost = true }, "ERROR 15489",
                    //                "VU Error",
                    //                MessageBoxButtons.OK,
                    //                MessageBoxIcon.Error);
                    return 0;                  //Invalid
                }
                else if (rx2_xvtr_index_local == 1)   //URX2
                {
                    FWC.SetVU_RXPath(5);        //VRX1, URX2
                }
                else
                {
                    FWC.SetVU_RXPath(3);        //VRX1
                }
            }
            else if (rx1_xvtr_index == 1)
            {
                if (rx2_xvtr_index_local == 1)
                {
                    //MessageBox.Show(new Form { TopMost = true }, "ERROR 15488",
                    //                "VU Error",
                    //                MessageBoxButtons.OK,
                    //                MessageBoxIcon.Error);
                    return 0;                   //Invalid
                }
                else if (rx2_xvtr_index_local == 0)   //VRX2
                {
                    FWC.SetVU_RXPath(6);        //VRX2, URX1
                }
                else
                {
                    FWC.SetVU_RXPath(1);        //URX1
                }
            }
            else
            {
                if (rx2_xvtr_index_local == 0)
                {
                    FWC.SetVU_RXPath(4);        //VRX2
                }
                else if (rx2_xvtr_index_local == 1)
                {
                    FWC.SetVU_RXPath(2);        //URX2
                }
                else
                {
                    FWC.SetVU_RXPath(0);        //VU not used
                }
            }
            return 1;   //successful state
        }

        public bool FindNearestKey<T>(double f, SortedDictionary<double, T> dict, out double key)
        {
            if (dict == null || dict.Count == 0)
            {
                key = f;
                return false;
            }

            if (dict.ContainsKey(f))
            {
                key = f;
                return true;
            }

            double low = double.MinValue;
            double high = double.MaxValue;

            foreach (double next_key in dict.Keys)
            {
                if (next_key < f && next_key > low)
                    low = next_key;

                if (next_key > f && next_key < high)
                    high = next_key;
            }

            double low_delta = Math.Abs(low - f);
            double high_delta = Math.Abs(high - f);

            if (low_delta < high_delta)
                key = low;
            else key = high;
            return true;
        }

        public int CurrentTuneStepHz
        {
            get { return tune_step_list[tune_step_index].StepHz; }
        }

        //==============================================================
        // ke9ns add for PowerMate
        public int CurrentTuneStepHz2
        {
            get { return tune_step_list[setupForm.tune_step_index4].StepHz; } // ke9ns was index2
        }


        public double CurrentTuneStepMHz
        {
            get { return tune_step_list[tune_step_index].StepHz * 1e-6; }
        }

        #endregion

        #region Test and Calibration Routines

        private Progress p;
        public bool CalibratePABias(Progress progress, float driver_target, float final_target, float tol, int index)
        {
            bool ret_val = false;
            float driver_limit = 10.0f;
            float final_limit = 10.0f;

            if (!(fwc_init && (current_model == Model.FLEX5000 || current_model == Model.FLEX3000)))
            {
                progress.Text = "";
                progress.Hide();
                return false;
            }

            if (rx_only)
            {
                progress.Text = "";
                progress.Hide();
                MessageBox.Show(new Form { TopMost = true }, "Cannot run this calibration while RX Only is selected\n(Setup Form -> General Tab)",
                    "Error: RX Only is active",
                    MessageBoxButtons.OK, MessageBoxIcon.Error);
                return false;
            }

            if (chkPower.Checked && (rx1_dsp_mode == DSPMode.CWL || rx1_dsp_mode == DSPMode.CWU))
                RX1DSPMode = DSPMode.DSB;

            int val = 0;
            float volts = 0.0f;
            float current = 0.0f;
            int counter = 0;

            // read 13.8V for a sanity check of the ADC
            FWC.ReadPAADC(2, out val);
            volts = (float)val / 4096 * 2.5f;
            float v138 = volts * 11;

            if (v138 < 13.0 || v138 > 14.5)
            {
                progress.Hide();
                MessageBox.Show(new Form { TopMost = true }, "13.8V not within tolerance [13.0, 14.5] -- (read " + v138.ToString("f1") + ")",
                    "ADC/Power Problem",
                    MessageBoxButtons.OK, MessageBoxIcon.Error);
                calibration_running = false;
                return false;
            }

            Thread.Sleep(100);

            int chan = 4;
            switch (current_model)
            {
                case Model.FLEX5000:
                    chan = 4;
                    break;
                case Model.FLEX3000:
                    chan = 3;
                    break;
            }
            FWC.ReadPAADC(chan, out val);
            volts = (float)val / 4096 * 2.5f;
            double temp_c = 301 - volts * 1000 / 2.2;
            if (temp_c > 50 || temp_c < 18)
            {
                progress.Hide();
                MessageBox.Show(new Form { TopMost = true }, "Temperature (" + temp_c.ToString("f0") + "°C) is outside of normal range (18-50°C).",
                    "PA Bias Cal Error: Temp",
                    MessageBoxButtons.OK,
                    MessageBoxIcon.Error);
                calibration_running = false;
                return false;
            }

            for (int i = 0; i < 8; i++)
                flex5000DebugForm.SetPAPot(i, 0);

            FWC.SetPABias(true);
            tx_cal = true;

            byte Q2 = 128, Q3 = 128;
            // find point where Q2 and Q3 just tickle the driver bias current
            float baseline = 0.0f;
            Thread.Sleep(50);
            baseline = ReadDriverBias(3);
            /*if(baseline > 0.020)
			{
				Thread.Sleep(50);
				baseline = ReadDriverBias(3);
			}
			if(baseline > 0.020) goto error;*/
            //MessageBox.Show(new Form { TopMost = true }, "Driver Baseline: "+baseline.ToString("f3"));
            Debug.WriteLine("baseline: " + baseline.ToString("f3"));

            for (int i = 0; i < 4; i++)
                flex5000DebugForm.SetPAPot(i, 128);

            do
            {
                if (!progress.Visible) goto end;
                flex5000DebugForm.SetPAPot(0, Q2 += 10);
                if (Q2 < 128)
                {
                    FWC.SetPABias(false);
                    progress.Hide();
                    MessageBox.Show(new Form { TopMost = true }, "PA Bias Error: Unable to hit target bias on Q2.  Likely hardware problem.",
                        "PA Bias Error",
                        MessageBoxButtons.OK,
                        MessageBoxIcon.Error);
                    calibration_running = false;
                    return false;
                }
                Thread.Sleep(50);
                current = ReadDriverBias(3);
                if (current > driver_limit) goto high_current;
                if (Q2 == 255) goto error;
            }
            while (current < baseline + 0.002);
            progress.SetPercent(++counter / (float)16);
            flex5000DebugForm.SetPAPot(0, 0);
            Q2 -= 10;

            do
            {
                if (!progress.Visible) goto end;
                flex5000DebugForm.SetPAPot(2, Q3 += 10);
                if (Q3 < 128)
                {
                    FWC.SetPABias(false);
                    progress.Hide();
                    MessageBox.Show(new Form { TopMost = true }, "PA Bias Error: Unable to hit target bias on Q3.  Likely hardware problem.",
                        "PA Bias Error",
                        MessageBoxButtons.OK,
                        MessageBoxIcon.Error);
                    calibration_running = false;
                    return false;
                }
                Thread.Sleep(50);
                current = ReadDriverBias(3);
                if (current > driver_limit) goto high_current;
                if (Q3 == 255) goto error;
            }
            while (current < baseline + 0.002);
            progress.SetPercent(++counter / (float)16);
            flex5000DebugForm.SetPAPot(2, 0);
            Q3 -= 10;
            Debug.WriteLine("Starting points  Q2:" + Q2 + "  Q3:" + Q3);
            //MessageBox.Show(new Form { TopMost = true }, "Starting points  Q2:"+Q2.ToString()+"  Q3:"+Q3.ToString());

            // add half of one driver's target current to Q2
            do
            {
                if (!progress.Visible) goto end;
                flex5000DebugForm.SetPAPot(0, Q2 += 5);
                if (Q2 < 128)
                {
                    FWC.SetPABias(false);
                    progress.Hide();
                    MessageBox.Show(new Form { TopMost = true }, "PA Bias Error: Unable to hit target bias on Q2.  Likely hardware problem.",
                        "PA Bias Error",
                        MessageBoxButtons.OK,
                        MessageBoxIcon.Error);
                    calibration_running = false;
                    return false;
                }
                Thread.Sleep(50);
                current = ReadDriverBias(3);
                if (current > driver_limit) goto high_current;
                if (Q2 == 255) goto error;
            }
            while (current < baseline + driver_target / 4);

            Q2 -= 5;
            do
            {
                if (!progress.Visible) goto end;
                flex5000DebugForm.SetPAPot(0, Q2 += 1);
                if (Q2 < 128)
                {
                    FWC.SetPABias(false);
                    progress.Hide();
                    MessageBox.Show(new Form { TopMost = true }, "PA Bias Error: Unable to hit target bias on Q2.  Likely hardware problem.",
                        "PA Bias Error",
                        MessageBoxButtons.OK,
                        MessageBoxIcon.Error);
                    calibration_running = false;
                    return false;
                }
                Thread.Sleep(50);
                current = ReadDriverBias(3);
                if (current > driver_limit) goto high_current;
                if (Q2 == 255) goto error;
            }
            while (current < baseline + driver_target / 4);
            progress.SetPercent(++counter / (float)16);

            float q2_current = current - baseline;
            Debug.WriteLine("Q2 Current: " + q2_current.ToString("f3") + "  Q2:" + Q2);
            //MessageBox.Show(new Form { TopMost = true }, "Q2 Current: "+q2_current.ToString("f3")+"  Q2:"+Q2.ToString());

            // add half of one driver's target current to Q3
            do
            {
                if (!progress.Visible) goto end;
                flex5000DebugForm.SetPAPot(2, Q3 += 5);
                Thread.Sleep(50);
                current = ReadDriverBias(3);
                if (current > driver_limit) goto high_current;
                if (Q3 == 255) goto error;
            }
            while (current < baseline + q2_current + driver_target / 4);
            Q3 -= 5;

            do
            {
                if (!progress.Visible) goto end;
                flex5000DebugForm.SetPAPot(2, Q3 += 1);
                Thread.Sleep(50);
                current = ReadDriverBias(3);
                if (current > driver_limit) goto high_current;
                if (Q3 == 255) goto error;
            }
            while (current < baseline + q2_current + driver_target / 4);
            progress.SetPercent(++counter / (float)16);

            float q3_current = current - baseline - q2_current;
            Debug.WriteLine("Q3 Current: " + q3_current.ToString("f3") + "  Q3:" + Q3);
            //MessageBox.Show(new Form { TopMost = true }, "Q3 Current: "+q3_current.ToString("f3")+"  Q3:"+Q3.ToString());

            // add another half of one driver's target current to Q2
            do
            {
                if (!progress.Visible) goto end;
                flex5000DebugForm.SetPAPot(0, ++Q2);
                Thread.Sleep(50);
                current = ReadDriverBias(3);
                if (current > driver_limit) goto high_current;
                if (Q2 == 255) goto error;
            }
            while (current < baseline + q3_current + driver_target / 2);

            // tweak for just above target
            do
            {
                if (!progress.Visible) goto end;
                flex5000DebugForm.SetPAPot(0, --Q2);
                Thread.Sleep(100);
                current = ReadDriverBias(5);
                if (current > driver_limit) goto high_current;
            }
            while (current > baseline + q3_current + driver_target / 2);
            progress.SetPercent(++counter / (float)16);
            flex5000DebugForm.SetPAPot(0, ++Q2);
            current = ReadDriverBias(5);
            q2_current = current - q3_current - baseline;
            Debug.WriteLine("Q2 Current: " + q2_current.ToString("f3") + "  Q2:" + Q2);
            //MessageBox.Show(new Form { TopMost = true }, "Q2 Current: "+q2_current.ToString("f3")+"  Q2:"+Q2.ToString());

            // add another half of one driver's target current to Q3
            do
            {
                if (!progress.Visible) goto end;
                flex5000DebugForm.SetPAPot(2, ++Q3);
                Thread.Sleep(50);
                current = ReadDriverBias(3);
                if (current > driver_limit) goto high_current;
                if (Q3 == 255) goto error;
            }
            while (current < baseline + q2_current + driver_target / 2);

            // tweak for just above target
            do
            {
                if (!progress.Visible) goto end;
                flex5000DebugForm.SetPAPot(2, --Q3);
                Thread.Sleep(100);
                current = ReadDriverBias(5);
                if (current > driver_limit) goto high_current;
            }
            while (current > baseline + q2_current + driver_target / 2);
            progress.SetPercent(++counter / (float)16);
            flex5000DebugForm.SetPAPot(2, ++Q3);
            current = ReadDriverBias(5);
            q3_current = current - q2_current - baseline;
            Debug.WriteLine("Q3 Current: " + q3_current.ToString("f3") + "  Q3:" + Q3);
            //MessageBox.Show(new Form { TopMost = true }, "Q3 Current: "+q3_current.ToString("f3")+"  Q3:"+Q3.ToString());

            // tweak fine controls if available
            uint pa_rev;
            FWC.GetPARev(out pa_rev);

            byte Q2_fine = 128, Q3_fine = 128;
            if ((byte)(pa_rev >> 8) != 0) // not a beta radio
            {
                while (Math.Abs(q2_current - driver_target / 2) > 0.005)
                {
                    if (!progress.Visible) goto end;
                    if (q2_current > driver_target / 2) Q2_fine--;
                    else Q2_fine++;
                    flex5000DebugForm.SetPAPot(1, Q2_fine);
                    Thread.Sleep(50);
                    current = ReadDriverBias(5);
                    q2_current = current - q3_current - baseline;
                    if (current > driver_limit) goto high_current;
                    if (Q2_fine == 255 || Q2_fine == 0) goto error;
                }

                progress.SetPercent(++counter / (float)16);
                Debug.WriteLine("Q2 Current: " + q2_current.ToString("f3") + "  Q2_fine:" + Q2_fine);
                //MessageBox.Show(new Form { TopMost = true }, "Q2 Current: "+q2_current.ToString("f3")+"  Q2_fine:"+Q2_fine.ToString());

                while (Math.Abs(q3_current - driver_target / 2) > 0.005)
                {
                    if (!progress.Visible) goto end;
                    if (q3_current > driver_target / 2) Q3_fine--;
                    else Q3_fine++;
                    flex5000DebugForm.SetPAPot(3, Q3_fine);
                    Thread.Sleep(50);
                    current = ReadDriverBias(5);
                    q3_current = current - q2_current - baseline;
                    if (current > driver_limit) goto high_current;
                    if (Q3_fine == 255 || Q3_fine == 0) goto error;
                }

                progress.SetPercent(++counter / (float)16);
                Debug.WriteLine("Q3 Current: " + q3_current.ToString("f3") + "  Q3_fine:" + Q3_fine);
                //MessageBox.Show(new Form { TopMost = true }, "Q3 Current: "+q3_current.ToString("f3")+"  Q3_fine:"+Q3_fine.ToString());
            }
            else counter += 2;

            byte Q4 = 128, Q1 = 128;
            // find point where Q4 and Q1 just tickle the final bias current
            Thread.Sleep(50);
            baseline = ReadFinalBias(3, true);
            /*if(baseline > 0.100) 
			{
				Thread.Sleep(50);
				baseline = ReadFinalBias(3);
			}
			if(baseline > 0.100) goto error;*/
            //MessageBox.Show(new Form { TopMost = true }, "Final baseline: "+baseline.ToString("f3"));
            Debug.WriteLine("baseline: " + baseline.ToString("f3"));
            for (int i = 4; i < 8; i++)
                flex5000DebugForm.SetPAPot(i, 128);

            do
            {
                if (!progress.Visible) goto end;
                flex5000DebugForm.SetPAPot(4, Q4 += 10);
                if (Q4 < 128)
                {
                    FWC.SetPABias(false);
                    progress.Hide();
                    MessageBox.Show(new Form { TopMost = true }, "PA Bias Error: Unable to hit target bias on Q4.  Likely hardware problem.",
                        "PA Bias Error",
                        MessageBoxButtons.OK,
                        MessageBoxIcon.Error);
                    calibration_running = false;
                    return false;
                }
                Thread.Sleep(50);
                current = ReadFinalBias(3, true);
                if (current > final_limit) goto high_current;
                if (Q4 == 255) goto error;
            }
            while (current < baseline + 0.005);
            progress.SetPercent(++counter / (float)16);
            flex5000DebugForm.SetPAPot(4, Q4 -= 10);

            do
            {
                if (!progress.Visible) goto end;
                flex5000DebugForm.SetPAPot(6, Q1 += 10);
                if (Q1 < 128)
                {
                    FWC.SetPABias(false);
                    progress.Hide();
                    MessageBox.Show(new Form { TopMost = true }, "PA Bias Error: Unable to hit target bias on Q1.  Likely hardware problem.",
                        "PA Bias Error",
                        MessageBoxButtons.OK,
                        MessageBoxIcon.Error);
                    calibration_running = false;
                    return false;
                }
                Thread.Sleep(50);
                current = ReadFinalBias(3, true);
                if (current > final_limit) goto high_current;
                if (Q1 == 255) goto error;
            }
            while (current < baseline + 0.005);
            progress.SetPercent(++counter / (float)16);
            flex5000DebugForm.SetPAPot(6, Q1 -= 10);
            Debug.WriteLine("Starting points  Q4:" + Q4 + "  Q1:" + Q1);
            //MessageBox.Show(new Form { TopMost = true }, "Starting points  Q4:"+Q4.ToString()+"  Q1:"+Q1.ToString());

            // add half of one finals target current to Q4
            do
            {
                if (!progress.Visible) goto end;
                flex5000DebugForm.SetPAPot(4, Q4 += 5);
                if (Q4 < 128)
                {
                    FWC.SetPABias(false);
                    progress.Hide();
                    MessageBox.Show(new Form { TopMost = true }, "PA Bias Error: Unable to hit target bias on Q4.  Likely hardware problem.",
                        "PA Bias Error",
                        MessageBoxButtons.OK,
                        MessageBoxIcon.Error);
                    calibration_running = false;
                    return false;
                }
                Thread.Sleep(50);
                current = ReadFinalBias(3, true);
                if (current > final_limit) goto high_current;
                if (Q4 == 255) goto error;
            }
            while (current < baseline + final_target / 4);
            Q4 -= 5;

            do
            {
                if (!progress.Visible) goto end;
                flex5000DebugForm.SetPAPot(4, Q4 += 1);
                if (Q4 < 128)
                {
                    FWC.SetPABias(false);
                    progress.Hide();
                    MessageBox.Show(new Form { TopMost = true }, "PA Bias Error: Unable to hit target bias on Q4.  Likely hardware problem.",
                        "PA Bias Error",
                        MessageBoxButtons.OK,
                        MessageBoxIcon.Error);
                    calibration_running = false;
                    return false;
                }
                Thread.Sleep(50);
                current = ReadFinalBias(3, true);
                if (current > final_limit) goto high_current;
                if (Q4 == 255) goto error;
            }
            while (current < baseline + final_target / 4);
            progress.SetPercent(++counter / (float)16);

            float q4_current = current - baseline;
            Debug.WriteLine("Q4 Current: " + q4_current.ToString("f3") + "  Q4:" + Q4);
            //MessageBox.Show(new Form { TopMost = true }, "Q4 Current: "+q4_current.ToString("f3")+"  Q4:"+Q4.ToString());

            // add half of one finals target current to Q1
            do
            {
                if (!progress.Visible) goto end;
                flex5000DebugForm.SetPAPot(6, Q1 += 5);
                if (Q1 < 128)
                {
                    FWC.SetPABias(false);
                    progress.Hide();
                    MessageBox.Show(new Form { TopMost = true }, "PA Bias Error: Unable to hit target bias on Q1.  Likely hardware problem.",
                        "PA Bias Error",
                        MessageBoxButtons.OK,
                        MessageBoxIcon.Error);
                    calibration_running = false;
                    return false;
                }
                Thread.Sleep(50);
                current = ReadFinalBias(3, true);
                if (current > final_limit) goto high_current;
                if (Q1 == 255) goto error;
            }
            while (current < baseline + q4_current + final_target / 4);
            Q1 -= 5;

            do
            {
                if (!progress.Visible) goto end;
                flex5000DebugForm.SetPAPot(6, Q1 += 1);
                if (Q1 < 128)
                {
                    FWC.SetPABias(false);
                    progress.Hide();
                    MessageBox.Show(new Form { TopMost = true }, "PA Bias Error: Unable to hit target bias on Q1.  Likely hardware problem.",
                        "PA Bias Error",
                        MessageBoxButtons.OK,
                        MessageBoxIcon.Error);
                    calibration_running = false;
                    return false;
                }
                Thread.Sleep(50);
                current = ReadFinalBias(3, true);
                if (current > final_limit) goto high_current;
                if (Q1 == 255) goto error;
            }
            while (current < baseline + q4_current + final_target / 4);
            progress.SetPercent(++counter / (float)16);

            float q1_current = current - baseline - q4_current;
            Debug.WriteLine("Q1 Current: " + q1_current.ToString("f3") + "  Q1:" + Q1);
            //MessageBox.Show(new Form { TopMost = true }, "Q1 Current: "+q1_current.ToString("f3")+"  Q1:"+Q1.ToString());

            // add another half of one finals target current to Q4
            do
            {
                if (!progress.Visible) goto end;
                flex5000DebugForm.SetPAPot(4, ++Q4);
                Thread.Sleep(50);
                current = ReadFinalBias(3, true);
                if (current > final_limit) goto high_current;
                if (Q4 == 255) goto error;
            }
            while (current < baseline + q1_current + final_target / 2);

            // tweak for just above target
            do
            {
                if (!progress.Visible) goto end;
                flex5000DebugForm.SetPAPot(4, --Q4);
                Thread.Sleep(100);
                current = ReadFinalBias(5, true);
                if (current > final_limit) goto high_current;
            }
            while (current > baseline + q1_current + final_target / 2);
            progress.SetPercent(++counter / (float)16);
            flex5000DebugForm.SetPAPot(4, ++Q4);
            current = ReadFinalBias(5, true);
            q4_current = current - q1_current - baseline;
            Debug.WriteLine("Q4 Current: " + q4_current.ToString("f3") + "  Q4:" + Q4);
            //MessageBox.Show(new Form { TopMost = true }, "Q4 Current: "+q4_current.ToString("f3")+"  Q4:"+Q4.ToString());

            // add another half of one finals target current to Q1
            do
            {
                if (!progress.Visible) goto end;
                flex5000DebugForm.SetPAPot(6, ++Q1);
                Thread.Sleep(50);
                current = ReadFinalBias(3, true);
                if (current > final_limit) goto high_current;
                if (Q1 == 255) goto error;
            }
            while (current < baseline + q4_current + final_target / 2);

            // tweak for just above target
            do
            {
                if (!progress.Visible) goto end;
                flex5000DebugForm.SetPAPot(6, --Q1);
                Thread.Sleep(100);
                current = ReadFinalBias(5, true);
                if (current > final_limit) goto high_current;
            }
            while (current > baseline + q4_current + final_target / 2);
            progress.SetPercent(++counter / (float)16);
            flex5000DebugForm.SetPAPot(6, ++Q1);
            current = ReadFinalBias(5, true);
            q1_current = current - q4_current - baseline;
            Debug.WriteLine("Q1 Current: " + q1_current.ToString("f3") + "  Q1:" + Q1);
            //MessageBox.Show(new Form { TopMost = true }, "Q1 Current: "+q1_current.ToString("f3")+"  Q1:"+Q1.ToString());

            // tweak fine controls if available
            byte Q4_fine = 128, Q1_fine = 128;
            if ((byte)(pa_rev >> 8) != 0) // not a beta radio
            {
                while (Math.Abs(q4_current - final_target / 2) > tol)
                {
                    if (!progress.Visible) goto end;
                    if (q4_current > final_target / 2) Q4_fine--;
                    else Q4_fine++;
                    flex5000DebugForm.SetPAPot(5, Q4_fine);
                    Thread.Sleep(50);
                    current = ReadFinalBias(5, true);
                    q4_current = current - q1_current - baseline;
                    if (current > final_limit) goto high_current;
                    if (Q4_fine == 255 || Q4_fine == 0) goto error;
                }

                progress.SetPercent(++counter / (float)16);
                Debug.WriteLine("Q4 Current: " + q4_current.ToString("f3") + "  Q4_fine:" + Q4_fine);
                //MessageBox.Show(new Form { TopMost = true }, "Q4 Current: "+q4_current.ToString("f3")+"  Q4_fine:"+Q4_fine.ToString());

                while (Math.Abs(q1_current - final_target / 2) > tol)
                {
                    if (!progress.Visible) goto end;
                    if (q1_current > final_target / 2) Q1_fine--;
                    else Q1_fine++;
                    flex5000DebugForm.SetPAPot(7, Q1_fine);
                    Thread.Sleep(50);
                    current = ReadFinalBias(5, true);
                    q1_current = current - q4_current - baseline;
                    if (current > final_limit) goto high_current;
                    if (Q1_fine == 255 || Q1_fine == 0) goto error;
                }

                progress.SetPercent(++counter / (float)16);
                Debug.WriteLine("Q1 Current: " + q1_current.ToString("f3") + "  Q1_fine:" + Q1_fine);
                //MessageBox.Show(new Form { TopMost = true }, "Q1 Current: "+q1_current.ToString("f3")+"  Q1_fine:"+Q1_fine.ToString());
            }
            else counter += 2;

            ret_val = true;
        end:
            FWC.SetPABias(false);
            tx_cal = false;
            progress.Hide();
            if (progress.Text != "")
            {
                for (int i = 0; i < 8; i++)
                    pa_bias_table[index][i] = flex5000DebugForm.GetPAPot(i);
            }
            return ret_val;
        high_current:
            FWC.SetPABias(false);
            tx_cal = false;
            progress.Hide();
            MessageBox.Show(new Form { TopMost = true }, "Error in PA Bias Calibration: High Current Detected.",
                "PA Bias: High Current Detected",
                MessageBoxButtons.OK,
                MessageBoxIcon.Error);
            return false;
        error:
            FWC.SetPABias(false);
            tx_cal = false;
            progress.Hide();
            MessageBox.Show(new Form { TopMost = true }, "Error in PA Bias Calibration: Unable to reach current.",
                "PA Bias: Current Error",
                MessageBoxButtons.OK,
                MessageBoxIcon.Error);
            return false;
        }

        public float ReadDriverBias(int num_avg)
        {
            int val;
            int sum = 0;
            for (int i = 0; i < num_avg; i++)
            {
                FWC.ReadPAADC(1, out val);
                sum += val;
                if (i != num_avg - 1) Thread.Sleep(100);
            }
            sum /= num_avg;
            float current = (float)sum / 4096 * 2.5f; // 50 milliohm
            if (((byte)(FWCEEPROM.PARev >> 8)) == 0) current /= 2; // 100 milliohm
            flex5000DebugForm.SetADCText(current.ToString("f3") + " A");
            if (flex5000FinalTestForm != null)
                flex5000FinalTestForm.UpdateDriverBiasDebug(current);
            return current;
        }

        public float ReadFinalBias(int num_avg, bool show_debug)
        {
            int val;
            int sum = 0;
            for (int i = 0; i < num_avg; i++)
            {
                FWC.ReadPAADC(0, out val);
                sum += val;
                if (i != num_avg - 1) Thread.Sleep(100);
            }
            sum /= num_avg;
            float current = (float)sum / 4096 * 2.5f * 10;
            flex5000DebugForm.SetADCText(current.ToString("f3") + " A");
            if (flex5000FinalTestForm != null && show_debug)
                flex5000FinalTestForm.UpdateFinalBiasDebug(current);
            return current;
        }

        public double ReadFwdPower(int num_avg)
        {
            if (current_model != Model.FLEX5000 && current_model != Model.FLEX3000) return 0.0;
            int val;
            int sum = 0;
            int chan = 0;
            switch (current_model)
            {
                case Model.FLEX5000:
                    chan = 7;
                    break;
                case Model.FLEX3000:
                    chan = 5;
                    break;
            }

            for (int i = 0; i < num_avg; i++)
            {
                FWC.ReadPAADC(chan, out val);
                sum += val;
                if (i != num_avg - 1) Thread.Sleep(200);
            }
            sum /= num_avg;

            return FWCPAPower(sum);

        } //  ReadFwdPower(int num_avg)

        public float ReadFwdPowerVolts(int num_avg)
        {
            if (current_model != Model.FLEX5000 && current_model != Model.FLEX3000) return 0.0f;
            int val;
            int sum = 0;
            int chan = 0;
            switch (current_model)
            {
                case Model.FLEX5000:
                    chan = 7;
                    break;
                case Model.FLEX3000:
                    chan = 5;
                    break;
            }

            for (int i = 0; i < num_avg; i++)
            {
                FWC.ReadPAADC(chan, out val);
                sum += val;
                if (i != num_avg - 1) Thread.Sleep(100);
            }
            sum /= num_avg;
            float volts = (float)sum / 4096 * 2.5f;
            return volts;
        }

        public float ReadRefPowerVolts(int num_avg)
        {
            if (current_model != Model.FLEX5000 && current_model != Model.FLEX3000) return 0.0f;
            int val;
            int sum = 0;
            int chan = 0;
            switch (current_model)
            {
                case Model.FLEX5000:
                    chan = 6;
                    break;
                case Model.FLEX3000:
                    chan = 4;
                    break;
            }

            for (int i = 0; i < num_avg; i++)
            {
                FWC.ReadPAADC(chan, out val);
                sum += val;
                if (i != num_avg - 1) Thread.Sleep(100);
            }
            sum /= num_avg;
            float volts = (float)sum / 4096 * 2.5f;
            return volts;
        }

        public double ReadRefPower(int num_avg)
        {
            if (current_model != Model.FLEX5000 && current_model != Model.FLEX3000) return 0.0;
            int val;
            int sum = 0;
            int chan = 0;
            switch (current_model)
            {
                case Model.FLEX5000:
                    chan = 6;
                    break;
                case Model.FLEX3000:
                    chan = 4;
                    break;
            }

            for (int i = 0; i < num_avg; i++)
            {
                FWC.ReadPAADC(chan, out val);
                sum += val;
                if (i != num_avg - 1) Thread.Sleep(200);
            }
            sum /= num_avg;

            return FWCPAPower(sum) * swr_table[(int)tx_band];

        } // ReadRefPower(int num_avg)

        public float tx_carrier_min = float.MaxValue;
        public float[] min_tx_carrier = new float[(int)Band.LAST];
        public bool CalibrateTXCarrier(double freq, Progress progress, bool suppress_errors)
        {
            if (!(fwc_init && (current_model == Model.FLEX5000 || current_model == Model.FLEX3000)))
            {
                progress.Text = "";
                progress.Hide();
                return false;
            }

            if (!chkPower.Checked)
            {
                MessageBox.Show(new Form { TopMost = true }, "Power must be on in order to calibrate TX Carrier.", "Power Is Off",
                    MessageBoxButtons.OK, MessageBoxIcon.Stop);
                calibration_running = false;
                progress.Text = "";
                return false;
            }

            HiPerfTimer t1 = new HiPerfTimer();
            t1.Start();
            HiPerfTimer t2 = new HiPerfTimer();

            bool ret_val = false;
            calibration_running = true;
            progress.SetPercent(0.0f);

            // Setup hardware
            FWC.SetQSD(true);
            //Thread.Sleep(50);
            FWC.SetQSE(true);
            //Thread.Sleep(50);
            FWC.SetTR(true);
            //Thread.Sleep(50);
            FWC.SetSig(true);
            //Thread.Sleep(50);
            FWC.SetGen(false);
            //Thread.Sleep(50);
            FWC.SetTest(true);
            //Thread.Sleep(50);
            FWC.SetTXMon(false);
            //Thread.Sleep(50);
            FWC.SetPDrvMon(true);

            bool duplex = full_duplex;
            FullDuplex = true;

            bool spur_red = chkSR.Checked;                  // save current spur reduction setting
            chkSR.Checked = false;                          // turn spur reduction off

            bool polyphase = setupForm.Polyphase;           // save current polyphase setting
            setupForm.Polyphase = false;                    // disable polyphase

            int dsp_buf_size = setupForm.DSPPhoneRXBuffer;      // save current DSP buffer size
            setupForm.DSPPhoneRXBuffer = 4096;					// set DSP Buffer Size to 4096

            bool rx2_on = chkRX2.Checked;
            chkRX2.Checked = false;

            // setup display mode
            string display = comboDisplayMode.Text;
            comboDisplayMode.Text = "Spectrum";

            // setup dsp mode
            DSPMode dsp_mode = RX1DSPMode;
            RX1DSPMode = DSPMode.DSB;

            /*bool rx1_preamp = chkRX1Preamp.Checked;
            chkRX1Preamp.Checked = true;*/
            PreampMode preamp = rx1_preamp_mode;
            switch (current_model)
            {
                case Model.FLEX5000:
                    RX1PreampMode = PreampMode.HIGH;
                    break;
                case Model.FLEX3000:
                    if (BandByFreq(freq, -1, true, current_region) == Band.B160M)
                        RX1PreampMode = PreampMode.LOW;
                    else RX1PreampMode = PreampMode.HIGH;
                    break;
            }

            // setup filter
            Filter filter = RX1Filter;
            UpdateRX1Filters(-1000, 1000);

            double vfoa = VFOAFreq;
            VFOAFreq = freq;

            double vfob = VFOBFreq;
            VFOBFreq = freq;

            // setup transmit to be carrier only
            Audio.TXInputSignal = Audio.SignalSource.SILENCE;

            // default pots to force carrier to show
            Thread.Sleep(100);
            FWC.SetTRXPot(0x00FF00FF);
            Thread.Sleep(100);
            FWC.SetTRXPot(0x00FF00FF);
            Thread.Sleep(100);
            /*for(int i=1; i<4; i++)
				FWC.TRXPotSetRDAC(i, 0);*/

            // find carrier peak
            float[] a = new float[Display.BUFFER_SIZE];
            for (int i = 0; i < 5; i++)
            {

                calibration_mutex.WaitOne();
                fixed (float* ptr = &a[0])
                    DttSP.GetSpectrum(0, ptr);// get the spectrum values
                calibration_mutex.ReleaseMutex();
                Thread.Sleep(50);
            }

            // find peak bin
            int peak_bin = 2048 + (int)(0.0 / sample_rate1 * 4096.0);
            float max_signal = float.MinValue;
            float sum = 0.0f;
            int filt_low_bin = 2048 + (int)(-1000.0 / sample_rate1 * 4096.0);
            int filt_high_bin = 2048 + (int)(1000.0 / sample_rate1 * 4096.0);
            for (int i = 0; i < 20; i++)
            {
                calibration_mutex.WaitOne();
                fixed (float* ptr = &a[0])
                    DttSP.GetSpectrum(0, ptr);// get the spectrum values
                calibration_mutex.ReleaseMutex();

                if (i == 19)
                {
                    for (int j = 0; j < Display.BUFFER_SIZE; j++)
                    {
                        if (a[j] > max_signal)
                        {
                            max_signal = a[j];
                            peak_bin = j;
                        }
                    }
                }
                for (int j = filt_low_bin; j < filt_high_bin; j++)
                {
                    if (j < peak_bin - 8 || j > peak_bin + 8)
                        sum += a[j];
                }
                Thread.Sleep(100);
            }
            float noise_floor = (sum / (float)(((filt_high_bin - filt_low_bin) - 17) * 20));
            Debug.WriteLine("noise_floor: " + (noise_floor + Display.RX1DisplayCalOffset + Display.RX1PreampOffset).ToString("f1") + " peak_bin:" + peak_bin);

            //int c0_step=1, c1_step=1, c2_step=1, c3_step=1;  //old
            int c0_step = 4, c1_step = 4, c2_step = 4, c3_step = 4;  //new
            int c0_global_min = 128, c1_global_min = 128, c2_global_min = 128, c3_global_min = 128;
            int c0_index = 128, c1_index = 128, c2_index = 128, c3_index = 128;
            int c0_dir = 1, c1_dir = 1, c2_dir = 1, c3_dir = 1;
            int c0_count = 1, c1_count = 1, c2_count = 1, c3_count = 1;
            float global_min_value = float.MaxValue;
            float start = 0.0f;
            int wrong_direction_count;
            int switch_direction_count;

            if (max_signal < noise_floor + 5.0)
            {
                if (!suppress_errors)
                {
                    MessageBox.Show(new Form { TopMost = true }, "Carrier not found (max signal < noise floor + 5dB).  Please try again.\n" +
                        DateTime.Now.ToShortTimeString(),
                        "Carrier Not Found",
                        MessageBoxButtons.OK, MessageBoxIcon.Stop);
                }
                calibration_running = false;
                //progress.Text = "";

                goto end2;
            }

            for (int i = 0; i < 4; i++)
            {
                flex5000DebugForm.SetTRXPot(i, 128);
                FWC.TRXPotSetRDAC(i, 128);
            }

            float tol = 10.0f;
            bool first_time;
            // null 3 of 4 pots (leave first pot alone...pot index 0)
            bool progressing = true;
            while (progressing)
            {
                //find minimum of the peak signal over the range of C1 settings
                float min_signal = float.MaxValue;
                max_signal = float.MinValue;
                wrong_direction_count = switch_direction_count = 0;
                first_time = true;
                t2.Start();
                for (int i = c1_global_min; i >= 0 && i <= 255; i += (c1_step * c1_dir))
                {
                    flex5000DebugForm.SetTRXPot(1, (byte)i);
                    FWC.TRXPotSetRDAC(1, i);
                    Thread.Sleep(200);

                    sum = 0.0f;
                    int num_avg = (int)Math.Min(4, (1.0 / (c1_step / 8.0)));
                    for (int j = 0; j < num_avg; j++)
                    {
                        calibration_mutex.WaitOne();
                        fixed (float* ptr = &a[0])
                            DttSP.GetSpectrum(0, ptr);
                        calibration_mutex.ReleaseMutex();
                        sum += a[peak_bin];
                        if (j < num_avg - 1) Thread.Sleep(50);
                    }
                    sum /= num_avg;
                    a[peak_bin] = sum;

                    if (a[peak_bin] < min_signal)           // if carrier is less than minimum
                    {
                        min_signal = a[peak_bin];
                        c1_index = i;
                        if (min_signal < global_min_value)
                        {
                            global_min_value = a[peak_bin];
                            c1_global_min = c1_index;
                        }
                    }

                    if (first_time)
                    {
                        first_time = false;
                        start = a[peak_bin];
                        max_signal = a[peak_bin];
                    }
                    else
                    {
                        if (a[peak_bin] > max_signal && a[peak_bin] > start + 1.0)
                        {
                            max_signal = a[peak_bin];
                            wrong_direction_count++; Debug.Write("W");
                            if (wrong_direction_count > 1)
                            {
                                wrong_direction_count = 0;
                                if (++switch_direction_count > 1)
                                {
                                    // handle switched direction twice
                                    c1_step /= 2;
                                    if (c1_step < 1) c1_step = 1;
                                    c1_dir *= -1;
                                    Debug.WriteLine("c1 exit dir - c1_step:" + c1_step.ToString("f4") + "  distance:" + (global_min_value - noise_floor).ToString("f1"));
                                    break;
                                }

                                min_signal = start;
                                max_signal = start;
                                c1_dir *= -1;
                                i = c1_global_min;
                            }
                        }
                        else
                        {
                            if (min_signal > noise_floor + 20.0) tol = 3.0f;
                            else tol = 5.0f;
                            if (min_signal < start - 3.0 && a[peak_bin] > min_signal + tol)
                            {
                                c1_step /= 2;
                                if (c1_step < 1) c1_step = 1;
                                c1_dir *= -1;
                                Debug.WriteLine("c1 thresh - c1_step:" + c1_step.ToString("f4") + "  distance:" + (global_min_value - noise_floor).ToString("f1"));
                                break;
                            }
                        }
                    }

                    if (!progress.Visible) goto end;
                    else
                    {
                        t1.Stop();
                        if (t1.Duration > 120.0)
                        {
                            /*MessageBox.Show(new Form { TopMost = true }, "TX Carrier Calibration Failed.  Values have been returned to previous settings.\n"+
								DateTime.Now.ToShortTimeString(),
								"TX Carrier Failed",
								MessageBoxButtons.OK,
								MessageBoxIcon.Error);*/
                            goto end;
                        }
                        else progress.SetPercent((float)(t1.Duration / 45.0));
                    }
                }

                t2.Stop();
                c1_count++;
                Debug.WriteLine("t2 c1(" + c1_count + "): " + t2.Duration);

                flex5000DebugForm.SetTRXPot(1, (byte)c1_global_min);
                FWC.TRXPotSetRDAC(1, c1_global_min);

                if (!progressing) break;

                //find minimum of the peak signal over the range of C2 settings
                min_signal = float.MaxValue;
                max_signal = float.MinValue;
                wrong_direction_count = switch_direction_count = 0;
                first_time = true;
                t2.Start();
                for (int i = c2_global_min; i >= 0 && i <= 255; i += (c2_step * c2_dir))
                {
                    flex5000DebugForm.SetTRXPot(2, (byte)i);
                    FWC.TRXPotSetRDAC(2, i);
                    Thread.Sleep(200);

                    sum = 0.0f;
                    int num_avg = (int)Math.Max(4, (1.0 / (c2_step / 8.0)));
                    for (int j = 0; j < num_avg; j++)
                    {
                        calibration_mutex.WaitOne();
                        fixed (float* ptr = &a[0])
                            DttSP.GetSpectrum(0, ptr);
                        calibration_mutex.ReleaseMutex();
                        sum += a[peak_bin];
                        if (j < num_avg - 1) Thread.Sleep(50);
                    }
                    sum /= num_avg;
                    a[peak_bin] = sum;

                    if (a[peak_bin] < min_signal)           // if carrier is less than minimum
                    {
                        min_signal = a[peak_bin];
                        c2_index = i;
                        if (min_signal < global_min_value)
                        {
                            global_min_value = a[peak_bin];
                            c2_global_min = c2_index;
                        }
                    }

                    if (first_time)
                    {
                        first_time = false;
                        start = a[peak_bin];
                        max_signal = a[peak_bin];
                    }
                    else
                    {
                        if (a[peak_bin] > max_signal && a[peak_bin] > start + 1.0)
                        {
                            max_signal = a[peak_bin];
                            wrong_direction_count++; Debug.Write("W");
                            if (wrong_direction_count > 1)
                            {
                                wrong_direction_count = 0;
                                if (++switch_direction_count > 1)
                                {
                                    // handle switched direction twice
                                    c2_step /= 2;
                                    if (c2_step < 1) c2_step = 1;
                                    c2_dir *= -1;
                                    Debug.WriteLine("c2 exit dir - c2_step:" + c2_step.ToString("f4") + "  distance:" + (global_min_value - noise_floor).ToString("f1"));
                                    break;
                                }

                                min_signal = start;
                                max_signal = start;
                                c2_dir *= -1;
                                i = c2_global_min;
                            }
                        }
                        else
                        {
                            if (min_signal > noise_floor + 20.0) tol = 3.0f;
                            else tol = 5.0f;
                            if (min_signal < start - 3.0 && a[peak_bin] > min_signal + tol)
                            {
                                c2_step /= 2;
                                if (c2_step < 1) c2_step = 1;
                                c2_dir *= -1;
                                Debug.WriteLine("c2 thresh - c2_step:" + c2_step.ToString("f4") + "  distance:" + (global_min_value - noise_floor).ToString("f1"));
                                break;
                            }
                        }
                    }

                    if (!progress.Visible) goto end;
                    else
                    {
                        t1.Stop();
                        if (t1.Duration > 120.0)
                        {
                            /*MessageBox.Show(new Form { TopMost = true }, "TX Carrier Calibration Failed.  Values have been returned to previous settings.\n"+
								DateTime.Now.ToShortTimeString(),
								"TX Carrier Failed",
								MessageBoxButtons.OK,
								MessageBoxIcon.Error);*/
                            goto end;
                        }
                        else progress.SetPercent((float)(t1.Duration / 45.0));
                    }
                }

                t2.Stop();
                c2_count++;
                Debug.WriteLine("t2 c2(" + c2_count + "): " + t2.Duration);

                flex5000DebugForm.SetTRXPot(2, (byte)c2_global_min);
                FWC.TRXPotSetRDAC(2, c2_global_min);

                if (!progressing) break;

                //find minimum of the peak signal over the range of C3 settings
                min_signal = float.MaxValue;
                max_signal = float.MinValue;
                wrong_direction_count = switch_direction_count = 0;
                first_time = true;
                t2.Start();
                for (int i = c3_global_min; i >= 0 && i <= 255; i += (c3_step * c3_dir))
                {
                    flex5000DebugForm.SetTRXPot(3, (byte)i);
                    FWC.TRXPotSetRDAC(3, i);
                    Thread.Sleep(200);

                    sum = 0.0f;
                    int num_avg = (int)Math.Min(4, (1.0 / (c3_step / 8.0)));
                    for (int j = 0; j < num_avg; j++)
                    {
                        calibration_mutex.WaitOne();
                        fixed (float* ptr = &a[0])
                            DttSP.GetSpectrum(0, ptr);
                        calibration_mutex.ReleaseMutex();
                        sum += a[peak_bin];
                        if (j < num_avg - 1) Thread.Sleep(50);
                    }
                    sum /= num_avg;
                    a[peak_bin] = sum;

                    if (a[peak_bin] < min_signal)           // if carrier is less than minimum
                    {
                        min_signal = a[peak_bin];
                        c3_index = i;
                        if (min_signal < global_min_value)
                        {
                            global_min_value = a[peak_bin];
                            c3_global_min = c3_index;
                        }
                    }

                    if (first_time)
                    {
                        first_time = false;
                        start = a[peak_bin];
                        max_signal = a[peak_bin];
                    }
                    else
                    {
                        if (a[peak_bin] > max_signal && a[peak_bin] > start + 1.0)
                        {
                            max_signal = a[peak_bin];
                            wrong_direction_count++; Debug.Write("W");
                            if (wrong_direction_count > 1)
                            {
                                wrong_direction_count = 0;
                                if (++switch_direction_count > 1)
                                {
                                    // handle switched direction twice
                                    c3_step /= 2;
                                    if (c3_step < 1) c3_step = 1;
                                    c3_dir *= -1;
                                    Debug.WriteLine("c3 exit dir - c3_step:" + c3_step.ToString("f4") + "  distance:" + (global_min_value - noise_floor).ToString("f1"));
                                    break;
                                }

                                min_signal = start;
                                max_signal = start;
                                c3_dir *= -1;
                                i = c3_global_min;
                            }
                        }
                        else
                        {
                            if (min_signal > noise_floor + 20.0) tol = 3.0f;
                            else tol = 5.0f;
                            if (min_signal < start - 3.0 && a[peak_bin] > min_signal + tol)
                            {
                                c3_step /= 2;
                                if (c3_step < 1) c3_step = 1;
                                c3_dir *= -1;
                                Debug.WriteLine("c3 thresh - c3_step:" + c3_step.ToString("f4") + "  distance:" + (global_min_value - noise_floor).ToString("f1"));
                                break;
                            }
                        }
                    }

                    if (!progress.Visible) goto end;
                    else
                    {
                        t1.Stop();
                        if (t1.Duration > 120.0)
                        {
                            /*MessageBox.Show(new Form { TopMost = true }, "TX Carrier Calibration Failed.  Values have been returned to previous settings.\n"+
								DateTime.Now.ToShortTimeString(),
								"TX Carrier Failed",
								MessageBoxButtons.OK,
								MessageBoxIcon.Error);*/
                            goto end;
                        }
                        else progress.SetPercent((float)(t1.Duration / 45.0));
                    }
                }

                t2.Stop();
                c3_count++;
                Debug.WriteLine("t2 c3(" + c3_count + "): " + t2.Duration);

                flex5000DebugForm.SetTRXPot(3, (byte)c3_global_min);
                FWC.TRXPotSetRDAC(3, c3_global_min);

                if (!progressing) break;

                //find minimum of the peak signal over the range of C1 settings
                min_signal = float.MaxValue;
                max_signal = float.MinValue;
                wrong_direction_count = switch_direction_count = 0;
                first_time = true;
                t2.Start();
                for (int i = c0_global_min; i >= 0 && i <= 255; i += (c0_step * c0_dir))
                {
                    flex5000DebugForm.SetTRXPot(0, (byte)i);
                    FWC.TRXPotSetRDAC(0, i);
                    Thread.Sleep(200);

                    sum = 0.0f;
                    int num_avg = (int)Math.Min(4, (1.0 / (c0_step / 8.0)));
                    for (int j = 0; j < num_avg; j++)
                    {
                        calibration_mutex.WaitOne();
                        fixed (float* ptr = &a[0])
                            DttSP.GetSpectrum(0, ptr);
                        calibration_mutex.ReleaseMutex();
                        sum += a[peak_bin];
                        if (j < num_avg - 1) Thread.Sleep(50);
                    }
                    sum /= num_avg;
                    a[peak_bin] = sum;

                    if (a[peak_bin] < min_signal)           // if carrier is less than minimum
                    {
                        min_signal = a[peak_bin];
                        c0_index = i;
                        if (min_signal < global_min_value)
                        {
                            global_min_value = a[peak_bin];
                            c0_global_min = c0_index;
                        }
                    }

                    if (first_time)
                    {
                        first_time = false;
                        start = a[peak_bin];
                        max_signal = a[peak_bin];
                    }
                    else
                    {
                        if (a[peak_bin] > max_signal && a[peak_bin] > start + 1.0)
                        {
                            max_signal = a[peak_bin];
                            wrong_direction_count++; Debug.Write("W");
                            if (wrong_direction_count > 1)
                            {
                                wrong_direction_count = 0;
                                if (++switch_direction_count > 1)
                                {
                                    // handle switched direction twice
                                    c0_step /= 2;
                                    if (c0_step < 1) c0_step = 1;
                                    c0_dir *= -1;
                                    Debug.WriteLine("c0 exit dir - c0_step:" + c0_step.ToString("f4") + "  distance:" + (global_min_value - noise_floor).ToString("f1"));
                                    break;
                                }

                                min_signal = start;
                                max_signal = start;
                                c0_dir *= -1;
                                i = c0_global_min;
                            }
                        }
                        else
                        {
                            if (min_signal > noise_floor + 20.0) tol = 3.0f;
                            else tol = 5.0f;
                            if (min_signal < start - 3.0 && a[peak_bin] > min_signal + tol)
                            {
                                c0_step /= 2;
                                if (c0_step < 1) c0_step = 1;
                                c0_dir *= -1;
                                Debug.WriteLine("c0 thresh - c0_step:" + c0_step.ToString("f4") + "  distance:" + (global_min_value - noise_floor).ToString("f1"));
                                break;
                            }
                        }
                    }

                    if (!progress.Visible) goto end;
                    else
                    {
                        t1.Stop();
                        if (t1.Duration > 120.0)
                        {
                            /*MessageBox.Show(new Form { TopMost = true }, "TX Carrier Calibration Failed.  Values have been returned to previous settings.\n"+
								DateTime.Now.ToShortTimeString(),
								"TX Carrier Failed",
								MessageBoxButtons.OK,
								MessageBoxIcon.Error);*/
                            goto end;
                        }
                        else progress.SetPercent((float)(t1.Duration / 45.0));
                    }
                }

                t2.Stop();
                c0_count++;
                Debug.WriteLine("t2 c0(" + c0_count + "): " + t2.Duration);

                flex5000DebugForm.SetTRXPot(0, (byte)c0_global_min);
                FWC.TRXPotSetRDAC(0, c0_global_min);

                if (!progressing) break;

                //if(c0_count > 2 && c1_count > 2 && c2_count > 2 && c3_count > 2)//old
                if (c0_count > 4 && c1_count > 4 && c2_count > 4 && c3_count > 4)//new
                    progressing = false;
            }
            ret_val = true;
            Debug.WriteLine("Carrier Null: [" + c0_global_min + ", " + c1_global_min + ", " + c2_global_min + ", " + c3_global_min + "]");

        end:
            if (!progress.Visible) progress.Text = "";
            else
            {
                /*flex5000DebugForm.SetTRXPot(0, (byte)c0_global_min);
                flex5000DebugForm.SetTRXPot(1, (byte)c1_global_min);
                flex5000DebugForm.SetTRXPot(2, (byte)c2_global_min);
                flex5000DebugForm.SetTRXPot(3, (byte)c3_global_min);*/

                uint val = (uint)((c0_global_min & 0xFF) << 24 |
                    (c1_global_min & 0xFF) << 16 |
                    (c2_global_min & 0xFF) << 8 |
                    (c3_global_min & 0xFF) << 0);

                FWC.SetTRXPot(val);

                double f = 0.0;
                if (tx_xvtr_index < 0)
                    f = Math.Round(freq, 3);
                else
                    f = Math.Round(xvtrForm.TranslateFreq(freq), 3);

                double f2 = 0.0;
                FindNearestKey<uint>(f, tx_carrier_cal, out f2);
                if (Math.Abs(f2 - f) < 0.001)
                    f = f2;

                tx_carrier_cal[f] = val;
            }
        end2:
            progress.Hide();
            // return output tone
            Audio.TXInputSignal = Audio.SignalSource.RADIO;

            tx_carrier_min = global_min_value + Display.RX1DisplayCalOffset + Display.RX1PreampOffset;
            min_tx_carrier[(int)tx_band] = global_min_value + Display.RX1DisplayCalOffset + Display.RX1PreampOffset;

            // return hardware to normal operation
            //Thread.Sleep(50);
            FWC.SetQSD(true);
            //Thread.Sleep(50);
            FWC.SetQSE(false);
            //Thread.Sleep(50);
            FWC.SetTR(false);
            //Thread.Sleep(50);
            FWC.SetSig(false);
            //Thread.Sleep(50);
            FWC.SetGen(false);
            //Thread.Sleep(50);
            FWC.SetTest(false);
            //Thread.Sleep(50);
            FWC.SetTXMon(false);
            //Thread.Sleep(50);
            FWC.SetPDrvMon(false);
            //Thread.Sleep(50);

            if (current_model == Model.FLEX3000)
                FWC.SetFan(false);

            setupForm.Polyphase = polyphase;
            setupForm.DSPPhoneRXBuffer = dsp_buf_size;
            chkSR.Checked = spur_red;
            FullDuplex = duplex;

            VFOAFreq = vfoa;
            VFOBFreq = vfob;

            comboDisplayMode.Text = display;

            RX1DSPMode = dsp_mode;
            RX1Filter = filter;
            RX1PreampMode = preamp;

            chkRX2.Checked = rx2_on;

            calibration_running = false;
            return ret_val;
        }

        public void CallCalSigGen()
        {
            p = new Progress("Calibrate Signal Generator");
            Thread t = new Thread(new ThreadStart(CalSigGen));
            t.Name = "Calibrate Signal Generator Thread";
            t.IsBackground = true;
            t.Priority = ThreadPriority.Normal;
            t.Start();
            p.Show();
        }

        private void CalSigGen()
        {
            if (!(fwc_init && current_model == Model.FLEX5000))
            {
                p.Hide();
                return;
            }

            double low = 1.0;
            double high = 65.0;
            double step = 0.1;
            int num_steps = (int)((high - low) / step);
            int count = 0;
            StreamWriter sw = new StreamWriter(app_data_path + "sig_gen.csv"); // "\\sig_gen.csv"

            FullDuplex = true;
            FWC.SetSig(true);
            FWC.SetGen(true);
            FWC.SetTest(true);
            RX1DSPMode = DSPMode.USB;
            RX1Filter = Filter.VAR2;
            UpdateRX1Filters(480, 520);

            for (double i = low; i <= high; i += step)
            {
                VFOAFreq = i;
                //Thread.Sleep(20);
                VFOBFreq = i + 0.0005;
                Thread.Sleep(200);
                float sum = 0.0f;
                for (int j = 0; j < 10; j++)
                {
                    sum += DttSP.CalculateRXMeter(0, 0, DttSP.MeterType.SIGNAL_STRENGTH);
                    sum = sum +
                        rx1_meter_cal_offset +
                        rx1_preamp_offset[(int)rx1_preamp_mode] +
                        rx1_filter_size_cal_offset;
                    Thread.Sleep(50);
                }
                sum /= 10;

                sw.WriteLine(i.ToString("f6" ) + "," + sum.ToString("f3"));
                p.SetPercent(count++ / (float)num_steps);
                if (!p.Visible) break;
            }
            sw.Close();
            FWC.SetSig(false);
            FWC.SetGen(false);
            FWC.SetTest(false);
            p.Hide();
        }


        //====================================================================================
        // ke9ns  setup->general->calibration->freq cal->START (comes here as a thread in setup.cs)
        public bool CalibrateFreq(float freq, Progress progress, bool suppress_errors)
        {
            bool retval = false;

            calibration_running = true;

            if (!chkPower.Checked)
            {
                if (!suppress_errors)
                {
                    MessageBox.Show(new Form { TopMost = true }, "Power must be on in order to calibrate Frequency.", "Power Is Off",
                        MessageBoxButtons.OK, MessageBoxIcon.Stop);
                }
                calibration_running = false;
                return false;
            }
            string Lastcombo = comboDisplayMode.Text;

            comboDisplayMode.Text = "Spectrum";
            comboDisplayMode_SelectedIndexChanged(this, EventArgs.Empty);  // .201


            string vfo_freq_text = txtVFOAFreq.Text;		// save current frequency

            bool polyphase = setupForm.Polyphase;			// save current polyphase setting
            setupForm.Polyphase = false;					// disable polyphase

            int dsp_buf_size = setupForm.DSPPhoneRXBuffer;	// save current DSP buffer size
            setupForm.DSPPhoneRXBuffer = 4096;				// set DSP Buffer Size to 4096

            Filter filter = RX1Filter;						// save current filter

            DSPMode dsp_mode = rx1_dsp_mode;				// save current demod mode
            RX1DSPMode = DSPMode.SAM;						// set DSP to AM

            bool rit_on = chkRIT.Checked;					// save current RIT state
            chkRIT.Checked = false;							// set RIT to Off

            int rit_value = (int)udRIT.Value;				// save current RIT value
            udRIT.Value = 0;								// set RIT Value to 0

            Filter am_filter = RX1Filter;					// save am filter
            //RX1Filter = Filter.F5;						// set filter to 6600Hz
            RX1Filter = Filter.F10;							// set filter to 2400Hz

            VFOAFreq = freq;								// set frequency to passed value (in mhz  10.000000)

            progress.SetPercent(0.0f);

            double old_clock = FWCDDSClockCorrection;
            setupForm.ClockOffset = 0;
            FWCDDSClockCorrection = 0;

            Thread.Sleep(200);
            //int ret = 0;


            //------------------------------------------------------------
            // ke9ns: First find the peak carrier signal (in case your offset is way off) based on the peak signal spot in the spectrum, this will get you in the ballpark, then use DSP PLL to find the real offset freq (lock onto the carrier)

            float[] buf = new float[Display.BUFFER_SIZE];
            float[] sum = new float[Display.BUFFER_SIZE];

            for (int i = 0; i < 10; i++)
            {
                calibration_mutex.WaitOne();

                fixed (float* ptr = &buf[0])            // ke9ns: (fixed) prevent garbage collecion from moving this pointer data
                {
                    DttSP.GetSpectrum(0, ptr);      // get the spectrum values and dump in buf[]

                }

                for (int j = 0; j < Display.BUFFER_SIZE; j++) // sum up 10 lines of spectrum data (4096 points each line or 16384 if using hi-res option)
                {
                    sum[j] += buf[j];
                }

                calibration_mutex.ReleaseMutex();

                Thread.Sleep(50);
            }

            float max = float.MinValue;

            int max_index = 0;

            for (int i = 0; i < Display.BUFFER_SIZE; i++)						// find the maximum signal
            {

                if (sum[i] > max)
                {
                    max = sum[i]; // ke9ns: find index of the highest signal found
                    max_index = i;
                }
            }

            /*avg -= max;
            avg /= (high - low - 1);

            if(max < (avg + 30))
            {
                MessageBox.Show(new Form { TopMost = true }, "Peak is less than 30dB from the noise floor.  " +
                    "Please use a larger signal for frequency calibration.",
                    "Calibration Error - Weak Signal",
                    MessageBoxButtons.OK,
                    MessageBoxIcon.Error);
                retval = false;
                goto end;
            }*/


            // Calculate the difference between the known signal and the measured signal
            float diff = (float)((double)sample_rate1 / Display.BUFFER_SIZE * (Display.BUFFER_SIZE / 2 - max_index)); // sample_rate1 is your current SR (ie. 192k, 96k, 48k)

            Debug.WriteLine("SR: " + sample_rate1 + " , " + Display.BUFFER_SIZE + " , " + max_index + " , " + diff);

            // Calculate the DDS offset
            int offset = 0;
            switch (current_model)
            {
                case Model.FLEX5000:
                    offset = (int)(500.0 / freq * diff);

                    break;
                case Model.FLEX3000:
                    offset = (int)(499.201 / freq * diff);
                    break;
                case Model.FLEX1500:
                    if (flex_1500_xref)
                        offset = (int)(400.0 / freq * diff);
                    else offset = (int)(384.0 / freq * diff);
                    break;
                default:
                    offset = (int)(200.0 / freq * diff);
                    break;
            }

            Debug.WriteLine("offset1: " + offset + " , freq: " + freq + " , diff: " + diff); // course offset

            if (Math.Abs(offset) > 40000)
            {
                if (!suppress_errors)
                {
                    MessageBox.Show(new Form { TopMost = true }, "Peak is outside valid range.",
                        "Calibration Error - Range",
                        MessageBoxButtons.OK,
                        MessageBoxIcon.Error);
                }
                retval = false;
                goto end;
            }

            if (Math.Abs(offset) > 20000)
            {
                if (!suppress_errors)
                {
                    DialogResult dr = MessageBox.Show(new Form { TopMost = true }, "This value is outside the specifications of the oscillator.",
                        "Outside Specifications",
                        MessageBoxButtons.OK,
                        MessageBoxIcon.Error);
                }
                retval = false;
                goto end;
            }

            setupForm.ClockOffset = offset;				// Offset the clock based on the difference. ke9ns: This will get you in the ballpark in case your offset was way off. Use PLL routine below to lock onto carrier
            Thread.Sleep(200);


            //--------------------------------------------------------------------------------------------------
            // ke9ns: SECOND   Narrow up the software PLL (am_demod.c) to allow the PLL to lock onto the carrier used to calibrate freq

            float a, b;
            DttSP.GetSAMPLLvals(0, 0, &a, &b);     // ke9ns: save original a and b values to put back after you getfreq


            Debug.WriteLine("before CalibrateFreq a=alpha, b=beta " + a + " , " + b + ", freq: " + freq); // ke9ns: 0.002945243 , 2.168614E-06 (FOR FLEX-5000)
            // ke9ns: alpha = PLL Bandwidth, beta=2nd order alpha term

            float a1 = a * 0.10f;               // ke9ns: take 10% of original value  0.0002945243  (i.e. shift 1 decimal point smaller) NARROW up the PLL BANDWIDTH
            float b1 = 0.25f * a1 * a1;         // ke9ns: take 25% of new a^2 value   2.168614e-8  (i.e. 0.0000000216) 2nd order term is always (alpha^2)*.25

            DttSP.SetSAMPLLvals(0, 0, a1, b1);     // ke9ns: Narrow up PLL Loop filter constants: to get better accuracy

            Debug.WriteLine("after CalibrateFreq alpha, beta " + a1 + " , " + b1);


            Thread.Sleep(200);

            int counter = 0;
            int samples = 200; // 200 samples to allow time to find a PLL Lock on carrier (or should I say, to find how far from a LOCK we are (offset)
            float sum1 = 0.0f;

            for (int i = 0; i < samples; i++)                     // ke9ns loop 200 times
            {
                float temp;

                DttSP.GetSAMFreq(0, 0, &temp);                   // ke9ns: update.c & am_demod.c PLL routine returns a frequency where a LOCK would occur (offset for the CLOCK). The smaller the freq, the closer to PLL LOCK
                                                                 // temp = rx[thread][subrx].am.gen -> pll.freq.f;    static void pll (AMD am, COMPLEX sig)

                Debug.WriteLine("CalibrateFreq temp " + i + " , " + temp);

                sum1 += temp;
                Thread.Sleep(50);
                progress.SetPercent((float)((float)++counter / samples));
            }

            Debug.WriteLine("CalibrateFreq sum1 " + sum1);

            diff = -(float)((sum1 / samples) * sample_rate1 / (2 * Math.PI));  //ke9ns: - getSAMFreq * 192k / 6.28 = (for close LOCK signal) = - -.0000648 * 192000 / 6.28 = 1.98
                                                                               // 2PI = 1 full phase rotation


            DttSP.SetSAMPLLvals(0, 0, a, b);                    // reset PLL values back when done (keep the PLL Loop filter widers for use with SAM syncronous carrier detection lock

            // Calculate the DDS offset
            offset = 0;
            switch (current_model)
            {
                case Model.FLEX5000:
                    offset = (int)(500.0 / freq * diff); // ke9ns: 500/10 * -1.98 = -99         (500/MHZ) * ((getSAMFreq * 192000) /  6.28)
                    break;
                case Model.FLEX3000:
                    offset = (int)(499.201 / freq * diff);
                    break;
                case Model.FLEX1500:
                    if (flex_1500_xref)
                        offset = (int)(400.0 / freq * diff);
                    else offset = (int)(384.0 / freq * diff);
                    break;
                default:
                    offset = (int)(200.0 / freq * diff);
                    break;
            }

            Debug.WriteLine("  offset2: " + offset);

            int current_clock = setupForm.ClockOffset;

            if (Math.Abs(current_clock + offset) > 40000 || Math.Abs(current_clock - offset) > 40000)
            {
                if (!suppress_errors)
                {
                    MessageBox.Show(new Form { TopMost = true }, "Peak is outside valid range.",
                        "Calibration Error - Range",
                        MessageBoxButtons.OK,
                        MessageBoxIcon.Error);
                }
                retval = false;
                goto end;
            }

            if (Math.Abs(current_clock + offset) > 20000 || Math.Abs(current_clock - offset) > 20000)
            {
                if (!suppress_errors)
                {
                    DialogResult dr = MessageBox.Show(new Form { TopMost = true }, "This value is outside the specifications of the oscillator.",
                        "Outside Specifications",
                        MessageBoxButtons.OK,
                        MessageBoxIcon.Error);
                }
                retval = false;
                goto end;
            }

            setupForm.ClockOffset += offset;				// Offset the clock based on the difference            
            retval = true;

        //----------------------------------------------------------

        end:

            comboDisplayMode.Text = Lastcombo;
            comboDisplayMode_SelectedIndexChanged(this, EventArgs.Empty);  // .201

            //SetupForm.RXOnly = rx_only;					// restore RX Only setting
            RX1Filter = am_filter;							// restore AM filter
            RX1DSPMode = dsp_mode;							// restore DSP mode
            RX1Filter = filter;								// restore filter
            chkRIT.Checked = rit_on;						// restore RIT state
            RITValue = rit_value;							// restore RIT value
            VFOAFreq = double.Parse(vfo_freq_text);			// restore frequency ke9ns was float
            setupForm.DSPPhoneRXBuffer = dsp_buf_size;		// restore DSP buffer size
            setupForm.Polyphase = polyphase;				// restore polyphase
            calibration_running = false;
            progress.Hide();
            return retval;

        } //CalibrateFreq




        public bool CalibrateLevel(float level, float freq, Progress progress, bool suppress_errors)
        {
            // Calibration routine called by Setup Form.
            bool ret_val = false;
            calibration_running = true;
            if (!chkPower.Checked)
            {
                if (!suppress_errors)
                {
                    MessageBox.Show(new Form { TopMost = true }, "Power must be on in order to calibrate RX Level.", "Power Is Off",
                        MessageBoxButtons.OK, MessageBoxIcon.Stop);
                }
                calibration_running = false;
                return false;
            }
            float[] a = new float[Display.BUFFER_SIZE];
            switch (current_model)
            {
                case Model.SDR1000:
                case Model.DEMO:
                    //  case Model.SOFTROCK40:
                    //bool rx_only = SetupForm.RXOnly;					// Save RX Only Setting
                    //SetupForm.RXOnly = true;

                    double vfoa = VFOAFreq;								// save current VFOA

                    bool rit_on = chkRIT.Checked;						// save current RIT On
                    chkRIT.Checked = false;								// turn RIT off
                    int rit_val = (int)udRIT.Value;	    				// save current RIT value

                    string display = comboDisplayMode.Text;
                    comboDisplayMode.Text = "Spectrum";

                    bool polyphase = setupForm.Polyphase;				// save current polyphase setting
                    setupForm.Polyphase = false;						// disable polyphase

                    int dsp_buf_size = setupForm.DSPPhoneRXBuffer;		// save current DSP buffer size
                    setupForm.DSPPhoneRXBuffer = 4096;					// set DSP Buffer Size to 2048

                    Filter filter = RX1Filter;							// save current filter

                    DSPMode dsp_mode = rx1_dsp_mode;					// save current DSP demod mode
                    RX1DSPMode = DSPMode.AM;							// set mode to CWU

                    VFOAFreq = freq;									// set VFOA frequency

                    Filter am_filter = RX1Filter;						// save current AM filter
                    RX1Filter = Filter.F1;								// set filter to 500Hz

                    PreampMode preamp = RX1PreampMode;					// save current preamp mode
                    RX1PreampMode = PreampMode.HIGH;					// set to high

                    MeterRXMode rx_meter = CurrentMeterRXMode;			// save current RX Meter mode
                    CurrentMeterRXMode = MeterRXMode.OFF;				// turn RX Meter off

                    bool display_avg = chkDisplayAVG.Checked;			// save current average state
                    chkDisplayAVG.Checked = false;
                    chkDisplayAVG.Checked = true;						// set average state to off

                    float old_multimeter_cal = rx1_meter_cal_offset;
                    float old_display_cal = rx1_display_cal_offset;

                    comboPreamp.Enabled = false;
                    comboDisplayMode.Enabled = false;
                    comboMeterRXMode.Enabled = false;

                    progress.SetPercent(0.0f);
                    int counter = 0;

                    Thread.Sleep(2000);
                    btnZeroBeat_Click(this, EventArgs.Empty);
                    RX1Filter = Filter.F6;
                    chkDisplayAVG.Checked = false;
                    Thread.Sleep(200);

                    DisableAllFilters();
                    DisableAllModes();
                    VFOLock = true;

                    calibration_mutex.WaitOne();

                    fixed (float* ptr = &a[0])
                        DttSP.GetSpectrum(0, ptr);		// get the spectrum values
                    calibration_mutex.ReleaseMutex();
                    float max = float.MinValue;
                    float avg = 0;
                    int max_index = 0;

                    for (int i = 0; i < 4095; i++)						// find the maximum signal
                    {
                        avg += a[i];
                        if (a[i] > max)
                        {
                            max = a[i];
                            max_index = i;
                        }
                    }
                    avg -= max;
                    avg /= 4095;

                    if (max < (avg + 30))
                    {
                        if (!suppress_errors)
                        {
                            MessageBox.Show(new Form { TopMost = true }, "Peak is less than 30dB from the noise floor.  " +
                                "Please use a larger signal for frequency calibration.",
                                "Calibration Error - Weak Signal",
                                MessageBoxButtons.OK,
                                MessageBoxIcon.Error);
                        }
                        ret_val = false;
                        goto end;
                    }

                    rx1_meter_cal_offset = 0.0f;
                    rx1_display_cal_offset = 0.0f;
                    float num = 0.0f, num2 = 0.0f, avg2 = 0.0f;
                    avg = 0.0f;
                    // get the value of the signal strength meter
                    for (int i = 0; i < 50; i++)
                    {
                        num += DttSP.CalculateRXMeter(0, 0, DttSP.MeterType.SIGNAL_STRENGTH);
                        Thread.Sleep(50);
                        if (!progress.Visible)
                            goto end;
                        else progress.SetPercent((float)((float)++counter / 170));
                    }
                    avg = num / 50.0f;

                    RX1PreampMode = PreampMode.MED;
                    Thread.Sleep(100);

                    // get the value of the signal strength meter
                    num2 = 0.0f;
                    for (int i = 0; i < 50; i++)
                    {
                        num2 += DttSP.CalculateRXMeter(0, 0, DttSP.MeterType.SIGNAL_STRENGTH);
                        Thread.Sleep(50);
                        if (!progress.Visible)
                            goto end;
                        else progress.SetPercent((float)((float)++counter / 170));
                    }
                    avg2 = num2 / 50.0f;

                    float att_offset = avg2 - avg;

                    RX1PreampMode = PreampMode.LOW;
                    Thread.Sleep(100);

                    // get the value of the signal strength meter
                    num2 = 0.0f;
                    for (int i = 0; i < 50; i++)
                    {
                        num2 += DttSP.CalculateRXMeter(0, 0, DttSP.MeterType.SIGNAL_STRENGTH);
                        Thread.Sleep(50);
                        if (!progress.Visible)
                            goto end;
                        else progress.SetPercent((float)((float)++counter / 170));
                    }
                    avg2 = num2 / 50.0f;

                    float gain_offset = avg2 - avg;

                    rx1_preamp_offset[(int)PreampMode.OFF] = -gain_offset - att_offset;
                    rx1_preamp_offset[(int)PreampMode.LOW] = -gain_offset;
                    rx1_preamp_offset[(int)PreampMode.MED] = -att_offset;
                    rx1_preamp_offset[(int)PreampMode.HIGH] = 0.0f;

                    RX1PreampMode = PreampMode.HIGH;
                    Thread.Sleep(100);

                    num2 = 0.0f;
                    for (int i = 0; i < 20; i++)
                    {
                        calibration_mutex.WaitOne();
                        fixed (float* ptr = &a[0])
                            DttSP.GetSpectrum(0, ptr);		// read again to clear out changed DSP
                        calibration_mutex.ReleaseMutex();
                        max = float.MinValue;						// find the max spectrum value
                        for (int j = 0; j < Display.BUFFER_SIZE; j++)
                            if (a[j] > max) max = a[j];

                        num2 += max;

                        Thread.Sleep(100);

                        if (!progress.Visible)
                            goto end;
                        else progress.SetPercent((float)((float)++counter / 170));
                    }
                    avg2 = num2 / 20.0f;

                    // calculate the difference between the current value and the correct multimeter value
                    float diff = level - (avg + rx1_meter_cal_offset + rx1_preamp_offset[(int)rx1_preamp_mode]);
                    rx1_meter_cal_offset += diff;

                    // calculate the difference between the current value and the correct spectrum value
                    diff = level - (avg2 + rx1_display_cal_offset + rx1_preamp_offset[(int)rx1_preamp_mode]);
                    for (int i = 0; i < (int)Band.LAST; i++)
                    {
                        rx1_level_table[i][0] = (float)Math.Round(diff, 3);
                        //rx1_level_table[i][1] = rx1_preamp_offset((int)PreampMode.MED
                        rx1_level_table[i][2] = (float)Math.Round(rx1_meter_cal_offset, 3);
                    }
                    RX1DisplayCalOffset += diff;

                    ret_val = true;

                end:
                    if (!progress.Visible) progress.Text = "";
                    progress.Hide();
                    EnableAllFilters();
                    EnableAllModes();
                    VFOLock = false;
                    comboPreamp.Enabled = true;
                    comboDisplayMode.Enabled = true;
                    comboMeterRXMode.Enabled = true;

                    if (ret_val == false)
                    {
                        rx1_meter_cal_offset = old_multimeter_cal;
                        rx1_display_cal_offset = old_display_cal;
                    }

                    comboDisplayMode.Text = display;
                    chkRIT.Checked = rit_on;							// restore RIT on
                    udRIT.Value = rit_val;								// restore RIT value
                    //SetupForm.RXOnly = rx_only;						// restore RX Only			
                    DisplayAVG = display_avg;							// restore AVG value
                    //RX1PreampMode = preamp;						// restore preamp value
                    RX1Filter = am_filter;							// restore AM filter
                    RX1DSPMode = dsp_mode;							// restore DSP mode
                    RX1Filter = filter;								// restore filter
                    if (dsp_buf_size != 4096)
                        chkPower.Checked = false;						// go to standby
                    setupForm.DSPPhoneRXBuffer = dsp_buf_size;				// restore DSP Buffer Size
                    VFOAFreq = vfoa;									// restore vfo frequency
                    if (dsp_buf_size != 4096)
                    {
                        Thread.Sleep(100);
                        chkPower.Checked = true;
                    }
                    CurrentMeterRXMode = rx_meter;						// restore RX Meter mode
                    setupForm.Polyphase = polyphase;					// restore polyphase

                    //			Debug.WriteLine("rx1_meter_cal_offset: "+rx1_meter_cal_offset);
                    //			Debug.WriteLine("display_cal_offset: "+display_cal_offset);
                    //			MessageBox.Show(new Form { TopMost = true }, "rx1_meter_cal_offset: "+rx1_meter_cal_offset.ToString()+"\n"+
                    //				"display_cal_offset: "+display_cal_offset.ToString());
                    break;
                #region SDRX
                /*case Model.SDRX:
			
						if(!fwc_init) return false;
						rx_only = SetupForm.RXOnly;					// Save RX Only Setting
						SetupForm.RXOnly = true;

						rit_on = chkRIT.Checked;						// save current RIT On
						chkRIT.Checked = false;								// turn RIT off
						rit_val = (int)udRIT.Value;						// save current RIT value

						vfoa = VFOAFreq;								// save current VFOA

						polyphase = SetupForm.Polyphase;				// save current polyphase setting
						SetupForm.Polyphase = false;						// disable polyphase

						dsp_buf_size = SetupForm.DSPBufferSize;			// save current DSP buffer size
						SetupForm.DSPBufferSize = 4096;						// set DSP Buffer Size to 2048

						filter = RX1Filter;						// save current filter

						dsp_mode = current_dsp_mode;				// save current DSP demod mode
						CurrentDSPMode = DSPMode.AM;						// set mode to AM

						VFOAFreq = freq;									// set VFOA frequency
				
						am_filter = RX1Filter;					// save current AM filter
						RX1Filter = Filter.F1;							// set filter to 500Hz

						bool fwc_preamp = fwc_preamp_on;						// save current preamp mode
						FWCPreampOn = false;								// turn preamp off

						bool att_on = fwc_att_on;							// save current atten on
						FWCATTOn = false;									// turn atten off

						int att_val = fwc_att_val;							// save current atten val
						FWCATTVal = 0;										// set atten val to 0dB

						rx_meter = CurrentMeterRXMode;			// save current RX Meter mode
						CurrentMeterRXMode = MeterRXMode.OFF;				// turn RX Meter off

						display_avg = chkDisplayAVG.Checked;			// save current average state
						chkDisplayAVG.Checked = false;
						chkDisplayAVG.Checked = true;						// set average state to off

						old_multimeter_cal = rx1_meter_cal_offset;
						old_display_cal = display_cal_offset;

						comboPreamp.Enabled = false;
						comboDisplayMode.Enabled = false;
						comboMeterRXMode.Enabled = false;

						progress.SetPercent(0.0f);
						counter = 0;

						Thread.Sleep(2000);
						btnZeroBeat_Click(this, EventArgs.Empty);
						RX1Filter = Filter.F6;
						chkDisplayAVG.Checked = false;
						Thread.Sleep(200);

						DisableAllFilters();
						DisableAllModes();
						VFOLock = true;

						fixed(float* ptr = &a[0])
							DttSP.GetSpectrum(0, ptr);		// get the spectrum values

						max = float.MinValue;
						avg = 0;
						max_index = 0;

						for(int i=0; i<4095; i++)						// find the maximum signal
						{
							avg += a[i];
							if(a[i] > max)
							{
								max = a[i];
								max_index = i;
							}
						}
						avg -= max;
						avg /= 4095;

						if(max < (avg + 30))
						{
							MessageBox.Show(new Form { TopMost = true }, "Peak is less than 30dB from the noise floor.  " +
								"Please use a larger signal for frequency calibration.",
								"Calibration Error - Weak Signal",
								MessageBoxButtons.OK,
								MessageBoxIcon.Error);
							ret_val = false;
							goto end;
						}

						rx1_meter_cal_offset = 0.0f;
						DisplayCalOffset = 0.0f;
						num=0.0f; num2=0.0f; avg2=0.0f;
						avg=0.0f;
						// get the value of the signal strength meter
						for(int i=0; i<50; i++)
						{
							num += DttSP.CalculateRXMeter(0, 0, DttSP.MeterType.SIGNAL_STRENGTH);
							Thread.Sleep(50);
							if(!progress.Visible)
								goto end;
							else progress.SetPercent((float)((float)++counter/760));
						}
						avg = num / 50.0f;

						FWCPreampOn = true;
						Thread.Sleep(100);
									
						// get the value of the signal strength meter
						num2=0.0f;
						for(int i=0; i<50; i++)
						{
							num2 += DttSP.CalculateRXMeter(0, 0, DttSP.MeterType.SIGNAL_STRENGTH);
							Thread.Sleep(50);
							if(!progress.Visible)
								goto end3;
							else progress.SetPercent((float)((float)++counter/760));
						}
						avg2 = num2 / 50.0f;

						fwc_preamp_offset = avg2 - avg;

						FWCPreampOn = false;
						FWCATTOn = true;
						for(int j=0; j<32; j++)
						{
							FWCATTVal = j;
							Thread.Sleep(100);

							// get the value of the signal strength meter
							num2=0.0f;
							for(int i=0; i<20; i++)
							{
								num2 += DttSP.CalculateRXMeter(0, 0, DttSP.MeterType.SIGNAL_STRENGTH);
								Thread.Sleep(50);
								if(!progress.Visible)
									goto end3;
								else progress.SetPercent((float)((float)++counter/760));
							}
							avg2 = num2 / 20.0f;
							fwc_att_offset[j] = avg2 - avg;
						}
						FWCATTOn = false;

						num2 = 0.0f;
						for(int i=0; i<20; i++)
						{
							fixed(float* ptr = &a[0])
								DttSP.GetSpectrum(0, ptr);		// read again to clear out changed DSP

							max = float.MinValue;						// find the max spectrum value
							for(int j=0; j<Display.BUFFER_SIZE; j++)
								if(a[j] > max) max = a[j];

							num2 += max;

							Thread.Sleep(100);

							if(!progress.Visible)
								goto end3;
							else progress.SetPercent((float)((float)++counter/760));
						}
						avg2 = num2 / 20.0f;

						// calculate the difference between the current value and the correct multimeter value
						diff = level - (avg + rx1_meter_cal_offset);
						rx1_meter_cal_offset = diff;

						// calculate the difference between the current value and the correct spectrum value
						diff = level - (avg2 + DisplayCalOffset);
						DisplayCalOffset = diff - 1.6f;

						UpdateDisplayOffset();

						ret_val = true;

					end3:
						progress.Hide();
						EnableAllFilters();
						EnableAllModes();
						VFOLock = false;
						comboPreamp.Enabled = true;
						comboDisplayMode.Enabled = true;
						comboMeterRXMode.Enabled = true;

						if(ret_val == false)
						{
							rx1_meter_cal_offset = old_multimeter_cal;
							display_cal_offset = old_display_cal;
						}

						chkRIT.Checked = rit_on;							// restore RIT on
						udRIT.Value = rit_val;								// restore RIT value
						SetupForm.RXOnly = rx_only;							// restore RX Only			
						DisplayAVG = display_avg;							// restore AVG value
						FWCPreampOn = fwc_preamp;							// restore preamp value
						FWCATTOn = att_on;									// restore ATT on
						FWCATTVal = att_val;								// restore ATT val
						RX1Filter = am_filter;							// restore AM filter
						CurrentDSPMode = dsp_mode;							// restore DSP mode
						RX1Filter = filter;								// restore filter
						if(dsp_buf_size != 4096)
							chkPower.Checked = false;						// go to standby
						SetupForm.DSPBufferSize = dsp_buf_size;				// restore DSP Buffer Size
						VFOAFreq = vfoa;									// restore vfo frequency
						if(dsp_buf_size != 4096)
						{
							Thread.Sleep(100);
							chkPower.Checked = true;
						}
						CurrentMeterRXMode = rx_meter;						// restore RX Meter mode
						SetupForm.Polyphase = polyphase;					// restore polyphase

						//			Debug.WriteLine("rx1_meter_cal_offset: "+rx1_meter_cal_offset);
						//			Debug.WriteLine("display_cal_offset: "+display_cal_offset);
						//			MessageBox.Show(new Form { TopMost = true }, "rx1_meter_cal_offset: "+rx1_meter_cal_offset.ToString()+"\n"+
						//				"display_cal_offset: "+display_cal_offset.ToString());
						break;*/
                #endregion
                case Model.FLEX5000:
                    //rx_only = SetupForm.RXOnly;						// Save RX Only Setting
                    //SetupForm.RXOnly = true;

                    bool rx2 = rx2_enabled;
                    RX2Enabled = false;

                    vfoa = VFOAFreq;									// save current VFOA

                    rit_on = chkRIT.Checked;							// save current RIT On
                    chkRIT.Checked = false;								// turn RIT off
                    rit_val = (int)udRIT.Value;							// save current RIT value					

                    display = comboDisplayMode.Text;
                    comboDisplayMode.Text = "Spectrum";

                    polyphase = setupForm.Polyphase;					// save current polyphase setting
                    setupForm.Polyphase = false;						// disable polyphase

                    dsp_buf_size = setupForm.DSPPhoneRXBuffer;			// save current DSP buffer size
                    setupForm.DSPPhoneRXBuffer = 4096;					// set DSP Buffer Size to 2048

                    filter = RX1Filter;									// save current filter

                    preamp = rx1_preamp_mode;

                    dsp_mode = rx1_dsp_mode;							// save current DSP demod mode
                    RX1DSPMode = DSPMode.DSB;							// set mode to DSB

                    VFOAFreq = freq;									// set VFOA frequency
                    VFOBFreq = freq;

                    bool duplex = full_duplex;
                    FullDuplex = true;
                    Thread.Sleep(50);
                    FWC.SetGen(true);
                    Thread.Sleep(50);
                    FWC.SetTest(true);
                    Thread.Sleep(50);
                    FWC.SetSig(true);
                    Thread.Sleep(50);

                    am_filter = RX1Filter;								// save current AM filter
                    RX1Filter = Filter.F1;								// set filter to 500Hz

                    /*bool p_amp = chkRX1Preamp.Checked;					// save current preamp mode
                    chkRX1Preamp.Checked = false;						// turn preamp off*/

                    rx_meter = CurrentMeterRXMode;						// save current RX Meter mode
                    CurrentMeterRXMode = MeterRXMode.OFF;				// turn RX Meter off

                    display_avg = chkDisplayAVG.Checked;				// save current average state
                    chkDisplayAVG.Checked = false;
                    chkDisplayAVG.Checked = true;						// set average state to off

                    old_multimeter_cal = rx1_meter_cal_offset;
                    old_display_cal = rx1_display_cal_offset;

                    chkRX1Preamp.Enabled = false;
                    comboDisplayMode.Enabled = false;
                    comboMeterRXMode.Enabled = false;

                    progress.SetPercent(0.0f);
                    counter = 0;

                    RX1Filter = Filter.F6;
                    chkDisplayAVG.Checked = false;

                    FWC.SetTRXPreamp(false);
                    Thread.Sleep(200);

                    DisableAllFilters();
                    DisableAllModes();
                    VFOLock = true;

                    calibration_mutex.WaitOne();
                    fixed (float* ptr = &a[0])
                        DttSP.GetSpectrum(0, ptr);		// get the spectrum values
                    calibration_mutex.ReleaseMutex();

                    max = float.MinValue;
                    avg = 0;
                    max_index = 0;

                    for (int i = 0; i < 4095; i++)						// find the maximum signal
                    {
                        avg += a[i];
                        if (a[i] > max)
                        {
                            max = a[i];
                            max_index = i;
                        }
                    }
                    avg -= max;
                    avg /= 4095;

                    if (max < (avg + 30))
                    {
                        if (!suppress_errors)
                        {
                            MessageBox.Show(new Form { TopMost = true }, "Peak is less than 30dB from the noise floor.  " +
                                "Please use a larger signal for frequency calibration.",
                                "Calibration Error - Weak Signal",
                                MessageBoxButtons.OK,
                                MessageBoxIcon.Error);
                        }
                        ret_val = false;
                        goto end2;
                    }

                    rx1_meter_cal_offset = 0.0f;
                    RX1DisplayCalOffset = 0.0f;
                    num = 0.0f; num2 = 0.0f; avg2 = 0.0f;
                    avg = 0.0f;
                    // get the value of the signal strength meter
                    for (int i = 0; i < 50; i++)
                    {
                        num += DttSP.CalculateRXMeter(0, 0, DttSP.MeterType.SIGNAL_STRENGTH);
                        Thread.Sleep(50);
                        if (!progress.Visible)
                            goto end2;
                        else progress.SetPercent((float)((float)++counter / 120));
                    }
                    avg = num / 50.0f;

                    FWC.SetTRXPreamp(true);
                    Thread.Sleep(200);

                    // get the value of the signal strength meter
                    num2 = 0.0f;
                    for (int i = 0; i < 50; i++)
                    {
                        num2 += DttSP.CalculateRXMeter(0, 0, DttSP.MeterType.SIGNAL_STRENGTH);
                        Thread.Sleep(50);
                        if (!progress.Visible)
                            goto end2;
                        else progress.SetPercent((float)((float)++counter / 120));
                    }
                    avg2 = num2 / 50.0f;

                    fwc_preamp_offset = avg2 - avg;
                    rx1_preamp_offset[(int)PreampMode.OFF] = 0.0f;
                    rx1_preamp_offset[(int)PreampMode.HIGH] = -fwc_preamp_offset;

                    Debug.WriteLine("fwc_preamp_offset: " + fwc_preamp_offset.ToString("f6" ));

                    FWC.SetTRXPreamp(false);
                    Thread.Sleep(200);

                    num2 = 0.0f;
                    for (int i = 0; i < 20; i++)
                    {
                        calibration_mutex.WaitOne();
                        fixed (float* ptr = &a[0])
                            DttSP.GetSpectrum(0, ptr);		// read again to clear out changed DSP
                        calibration_mutex.ReleaseMutex();

                        /*max = float.MinValue;						// find the max spectrum value
                        for(int j=0; j<Display.BUFFER_SIZE; j++)
                            if(a[j] > max) max = a[j];*/

                        //num2 += max;
                        num2 += a[max_index];
                        Thread.Sleep(100);

                        if (!progress.Visible)
                            goto end2;
                        else progress.SetPercent((float)((float)++counter / 120));
                    }
                    avg2 = num2 / 20.0f;

                    // calculate the difference between the current value and the correct multimeter value
                    diff = level - (avg + rx1_meter_cal_offset);
                    rx1_meter_cal_offset = diff;

                    // calculate the difference between the current value and the correct spectrum value
                    diff = level - (avg2 + RX1DisplayCalOffset);
                    RX1DisplayCalOffset = diff;

                    UpdateDisplayOffsets();

                    rx1_level_table[(int)rx1_band][0] = (float)Math.Round(rx1_display_cal_offset, 3);
                    rx1_level_table[(int)rx1_band][1] = (float)Math.Round(-fwc_preamp_offset, 3);
                    rx1_level_table[(int)rx1_band][2] = (float)Math.Round(rx1_meter_cal_offset, 3);

                    ret_val = true;

                end2:
                    if (!progress.Visible) progress.Text = "";
                    progress.Hide();
                    EnableAllFilters();
                    EnableAllModes();
                    VFOLock = false;

                    FullDuplex = duplex;
                    Thread.Sleep(50);
                    FWC.SetGen(false);
                    Thread.Sleep(50);
                    FWC.SetTest(false);
                    Thread.Sleep(50);
                    FWC.SetSig(false);
                    Thread.Sleep(50);

                    fwc_rx1_preamp = false;
                    chkRX1Preamp.Enabled = true;
                    RX1PreampMode = preamp;
                    chkRX1Preamp_CheckedChanged(this, EventArgs.Empty);
                    comboDisplayMode.Enabled = true;
                    comboMeterRXMode.Enabled = true;

                    if (ret_val == false)
                    {
                        rx1_meter_cal_offset = old_multimeter_cal;
                        rx1_display_cal_offset = old_display_cal;
                    }

                    //RX2Enabled = rx2;
                    comboDisplayMode.Text = display;
                    chkRIT.Checked = rit_on;						// restore RIT on
                    udRIT.Value = rit_val;							// restore RIT value
                    //SetupForm.RXOnly = rx_only					// restore RX Only			
                    DisplayAVG = display_avg;						// restore AVG value
                    RX1Filter = am_filter;							// restore AM filter
                    RX1DSPMode = dsp_mode;							// restore DSP mode
                    RX1Filter = filter;								// restore filter
                    if (dsp_buf_size != 4096)
                        chkPower.Checked = false;					// go to standby
                    setupForm.DSPPhoneRXBuffer = dsp_buf_size;		// restore DSP Buffer Size
                    VFOAFreq = vfoa;								// restore vfo frequency
                    if (dsp_buf_size != 4096)
                    {
                        Thread.Sleep(100);
                        chkPower.Checked = true;
                    }
                    CurrentMeterRXMode = rx_meter;					// restore RX Meter mode
                    setupForm.Polyphase = polyphase;				// restore polyphase

                    UpdateDisplayOffsets();

                    //			Debug.WriteLine("rx1_meter_cal_offset: "+rx1_meter_cal_offset);
                    //			Debug.WriteLine("display_cal_offset: "+display_cal_offset);
                    //			MessageBox.Show(new Form { TopMost = true }, "rx1_meter_cal_offset: "+rx1_meter_cal_offset.ToString()+"\n"+
                    //				"display_cal_offset: "+display_cal_offset.ToString());
                    break;
                case Model.FLEX3000:
                    vfoa = VFOAFreq;									// save current VFOA

                    rit_on = chkRIT.Checked;							// save current RIT On
                    chkRIT.Checked = false;								// turn RIT off
                    rit_val = (int)udRIT.Value;							// save current RIT value					

                    display = comboDisplayMode.Text;
                    comboDisplayMode.Text = "Spectrum";

                    polyphase = setupForm.Polyphase;					// save current polyphase setting
                    setupForm.Polyphase = false;						// disable polyphase

                    dsp_buf_size = setupForm.DSPPhoneRXBuffer;			// save current DSP buffer size
                    setupForm.DSPPhoneRXBuffer = 4096;					// set DSP Buffer Size to 2048

                    filter = RX1Filter;									// save current filter

                    dsp_mode = rx1_dsp_mode;							// save current DSP demod mode
                    RX1DSPMode = DSPMode.DSB;							// set mode to DSB

                    VFOAFreq = freq;									// set VFOA frequency
                    VFOBFreq = freq;

                    duplex = full_duplex;
                    FullDuplex = true;
                    Thread.Sleep(50);
                    FWC.SetGen(true);
                    Thread.Sleep(50);
                    FWC.SetTest(true);
                    Thread.Sleep(50);
                    FWC.SetSig(true);
                    Thread.Sleep(50);

                    am_filter = RX1Filter;								// save current AM filter
                    RX1Filter = Filter.F1;								// set filter to 500Hz

                    preamp = RX1PreampMode;								// save current preamp mode
                    RX1PreampMode = PreampMode.LOW;						// set to Low (preamp off, attn off)

                    rx_meter = CurrentMeterRXMode;						// save current RX Meter mode
                    CurrentMeterRXMode = MeterRXMode.OFF;				// turn RX Meter off

                    display_avg = chkDisplayAVG.Checked;				// save current average state
                    chkDisplayAVG.Checked = false;
                    chkDisplayAVG.Checked = true;						// set average state to off

                    old_multimeter_cal = rx1_meter_cal_offset;
                    old_display_cal = rx1_display_cal_offset;

                    comboPreamp.Enabled = false;
                    comboDisplayMode.Enabled = false;
                    comboMeterRXMode.Enabled = false;

                    progress.SetPercent(0.0f);
                    counter = 0;

                    //RX1Filter = Filter.F6;					
                    UpdateRX1Filters(-500, 500);
                    chkDisplayAVG.Checked = false;

                    /*FWC.SetTRXPreamp(false);
                    FWC.SetRXAttn(false);*/
                    Thread.Sleep(200);

                    DisableAllFilters();
                    DisableAllModes();
                    VFOLock = true;

                    calibration_mutex.WaitOne();
                    fixed (float* ptr = &a[0])
                        DttSP.GetSpectrum(0, ptr);		// get the spectrum values
                    calibration_mutex.ReleaseMutex();

                    max = float.MinValue;
                    avg = 0;
                    max_index = 0;

                    for (int i = 0; i < 4095; i++)						// find the maximum signal
                    {
                        avg += a[i];
                        if (a[i] > max)
                        {
                            max = a[i];
                            max_index = i;
                        }
                    }
                    avg -= max;
                    avg /= 4095;

                    if (max < (avg + 30))
                    {
                        if (!suppress_errors)
                        {
                            MessageBox.Show(new Form { TopMost = true }, "Peak is less than 30dB from the noise floor.  " +
                                "Please use a larger signal for frequency calibration.",
                                "Calibration Error - Weak Signal",
                                MessageBoxButtons.OK,
                                MessageBoxIcon.Error);
                        }
                        ret_val = false;
                        goto end3;
                    }

                    rx1_meter_cal_offset = 0.0f;
                    RX1DisplayCalOffset = 0.0f;
                    num = 0.0f; num2 = 0.0f; avg2 = 0.0f;
                    avg = 0.0f;
                    float avg3 = 0.0f;
                    // get the value of the signal strength meter
                    for (int i = 0; i < 50; i++)
                    {
                        num += DttSP.CalculateRXMeter(0, 0, DttSP.MeterType.SIGNAL_STRENGTH);
                        Thread.Sleep(50);
                        if (!progress.Visible)
                            goto end3;
                        else progress.SetPercent((float)((float)++counter / 170));
                    }
                    avg = num / 50.0f;

                    FWC.SetTRXPreamp(true);
                    Thread.Sleep(200);

                    // get the value of the signal strength meter
                    num2 = 0.0f;
                    for (int i = 0; i < 50; i++)
                    {
                        num2 += DttSP.CalculateRXMeter(0, 0, DttSP.MeterType.SIGNAL_STRENGTH);
                        Thread.Sleep(50);
                        if (!progress.Visible)
                            goto end3;
                        else progress.SetPercent((float)((float)++counter / 170));
                    }
                    avg2 = num2 / 50.0f;

                    FWC.SetTRXPreamp(false);
                    FWC.SetRXAttn(true);
                    Thread.Sleep(200);

                    // get the value of the signal strength meter
                    num2 = 0.0f;
                    for (int i = 0; i < 50; i++)
                    {
                        num2 += DttSP.CalculateRXMeter(0, 0, DttSP.MeterType.SIGNAL_STRENGTH);
                        Thread.Sleep(50);
                        if (!progress.Visible)
                            goto end3;
                        else progress.SetPercent((float)((float)++counter / 170));
                    }
                    avg3 = num2 / 50.0f;

                    float pre = avg2 - avg;
                    float attn = avg3 - avg;

                    rx1_preamp_offset[(int)PreampMode.OFF] = -attn;
                    rx1_preamp_offset[(int)PreampMode.LOW] = 0.0f;
                    rx1_preamp_offset[(int)PreampMode.MED] = attn - pre;
                    rx1_preamp_offset[(int)PreampMode.HIGH] = -pre;

                    FWC.SetTRXPreamp(false);
                    FWC.SetRXAttn(false);
                    Thread.Sleep(200);

                    num2 = 0.0f;
                    for (int i = 0; i < 20; i++)
                    {
                        calibration_mutex.WaitOne();
                        fixed (float* ptr = &a[0])
                            DttSP.GetSpectrum(0, ptr);		// read again to clear out changed DSP
                        calibration_mutex.ReleaseMutex();

                        /*max = float.MinValue;						// find the max spectrum value
                        for(int j=0; j<Display.BUFFER_SIZE; j++)
                            if(a[j] > max) max = a[j];*/

                        //num2 += max;
                        num2 += a[max_index];
                        Thread.Sleep(100);

                        if (!progress.Visible)
                            goto end3;
                        else progress.SetPercent((float)((float)++counter / 170));
                    }
                    avg2 = num2 / 20.0f;

                    // calculate the difference between the current value and the correct multimeter value
                    diff = level - (avg + rx1_meter_cal_offset);
                    rx1_meter_cal_offset = diff;

                    // calculate the difference between the current value and the correct spectrum value
                    diff = level - (avg2 + RX1DisplayCalOffset);
                    RX1DisplayCalOffset = diff;

                    rx1_level_table[(int)rx1_band][0] = (float)Math.Round(rx1_display_cal_offset, 3);
                    rx1_level_table[(int)rx1_band][1] = (float)Math.Round(rx1_preamp_offset[(int)PreampMode.OFF], 3);
                    rx1_level_table[(int)rx1_band][2] = (float)Math.Round(rx1_preamp_offset[(int)PreampMode.HIGH], 3);

                    ret_val = true;

                end3:
                    if (!progress.Visible) progress.Text = "";
                    progress.Hide();
                    EnableAllFilters();
                    EnableAllModes();
                    VFOLock = false;

                    FullDuplex = duplex;
                    Thread.Sleep(50);
                    FWC.SetGen(false);
                    Thread.Sleep(50);
                    FWC.SetTest(false);
                    Thread.Sleep(50);
                    FWC.SetSig(false);
                    Thread.Sleep(50);

                    /*FWC.SetTRXPreamp(false);
                    FWC.SetRXAttn(true);*/
                    comboPreamp.Enabled = true;
                    RX1PreampMode = preamp;

                    comboDisplayMode.Enabled = true;
                    comboMeterRXMode.Enabled = true;

                    if (ret_val == false)
                    {
                        rx1_meter_cal_offset = old_multimeter_cal;
                        rx1_display_cal_offset = old_display_cal;
                    }

                    comboDisplayMode.Text = display;
                    chkRIT.Checked = rit_on;						// restore RIT on
                    udRIT.Value = rit_val;							// restore RIT value
                    //SetupForm.RXOnly = rx_only					// restore RX Only			
                    DisplayAVG = display_avg;						// restore AVG value
                    RX1Filter = am_filter;							// restore AM filter
                    RX1DSPMode = dsp_mode;							// restore DSP mode
                    RX1Filter = filter;								// restore filter
                    if (dsp_buf_size != 4096)
                        chkPower.Checked = false;					// go to standby
                    setupForm.DSPPhoneRXBuffer = dsp_buf_size;		// restore DSP Buffer Size
                    VFOAFreq = vfoa;								// restore vfo frequency
                    if (dsp_buf_size != 4096)
                    {
                        Thread.Sleep(100);
                        chkPower.Checked = true;
                    }
                    CurrentMeterRXMode = rx_meter;					// restore RX Meter mode
                    setupForm.Polyphase = polyphase;				// restore polyphase

                    UpdateDisplayOffsets();

                    //			Debug.WriteLine("rx1_meter_cal_offset: "+rx1_meter_cal_offset);
                    //			Debug.WriteLine("display_cal_offset: "+display_cal_offset);
                    //			MessageBox.Show(new Form { TopMost = true }, "rx1_meter_cal_offset: "+rx1_meter_cal_offset.ToString()+"\n"+
                    //				"display_cal_offset: "+display_cal_offset.ToString());
                    break;
                case Model.FLEX1500:
                    vfoa = VFOAFreq;									// save current VFOA

                    rit_on = chkRIT.Checked;							// save current RIT On
                    chkRIT.Checked = false;								// turn RIT off
                    rit_val = (int)udRIT.Value;							// save current RIT value					

                    display = comboDisplayMode.Text;
                    comboDisplayMode.Text = "Spectrum";

                    polyphase = setupForm.Polyphase;					// save current polyphase setting
                    setupForm.Polyphase = false;						// disable polyphase

                    /*dsp_buf_size = SetupForm.DSPPhoneRXBuffer;			// save current DSP buffer size
                    SetupForm.DSPPhoneRXBuffer = 2048;					// set DSP Buffer Size to 2048*/

                    filter = RX1Filter;									// save current filter

                    dsp_mode = rx1_dsp_mode;							// save current DSP demod mode
                    RX1DSPMode = DSPMode.DSB;							// set mode to DSB

                    VFOAFreq = freq;									// set VFOA frequency
                    Thread.Sleep(100);
                    VFOBFreq = freq;

                    bool sr = chkSR.Checked;
                    chkSR.Checked = false;

                    HIDAnt hid_ant = RXAnt1500;
                    RXAnt1500 = HIDAnt.BITE;
                    Thread.Sleep(100);

                    USBHID.SetGen(true);
                    Thread.Sleep(100);

                    USBHID.SetQSE(true);
                    Thread.Sleep(100);

                    USBHID.SetTest(true);
                    Thread.Sleep(100);

                    am_filter = RX1Filter;								// save current AM filter
                    RX1Filter = Filter.F1;								// set filter to 500Hz

                    preamp = RX1PreampMode;								// save current preamp mode
                    RX1PreampMode = (PreampMode)FLEX1500PreampMode.ZERO;// set to Off

                    rx_meter = CurrentMeterRXMode;						// save current RX Meter mode
                    CurrentMeterRXMode = MeterRXMode.OFF;				// turn RX Meter off

                    display_avg = chkDisplayAVG.Checked;				// save current average state
                    chkDisplayAVG.Checked = false;
                    chkDisplayAVG.Checked = true;						// set average state to off

                    old_multimeter_cal = rx1_meter_cal_offset;
                    old_display_cal = rx1_display_cal_offset;

                    comboPreamp.Enabled = false;
                    comboDisplayMode.Enabled = false;
                    //comboMeterRXMode.Enabled = false;

                    progress.SetPercent(0.0f);
                    counter = 0;

                    //RX1Filter = Filter.F6;					
                    UpdateRX1Filters(-(int)(if_freq * 1e6) + cw_pitch - 100, -(int)(if_freq * 1e6) + cw_pitch + 100);
                    chkDisplayAVG.Checked = false;

                    DisableAllFilters();
                    DisableAllModes();
                    VFOLock = true;

                    DttSP.SetCorrectIQEnable(0); // turn off I/Q correction
                    DttSP.SetCorrectRXIQw(0, 0, 0.0f, 0.0f, 0);
                    DttSP.SetCorrectRXIQw(0, 0, 0.0f, 0.0f, 1);

                    double scale = Audio.SourceScale;
                    Audio.SourceScale = 0.01;

                    Audio.RX1OutputSignal = Audio.SignalSource.SINE;

                    bool mute = chkMUT.Checked;
                    chkMUT.Checked = false;

                    Thread.Sleep(400);

                    calibration_mutex.WaitOne();
                    fixed (float* ptr = &a[0])
                        DttSP.GetSpectrum(0, ptr);		// get the spectrum values
                    calibration_mutex.ReleaseMutex();

                    calibration_mutex.WaitOne();
                    fixed (float* ptr = &a[0])
                        DttSP.GetSpectrum(0, ptr);		// get the spectrum values again to clear out the old ones
                    calibration_mutex.ReleaseMutex();

                    max = float.MinValue;
                    avg = 0;
                    max_index = 0;

                    for (int i = 0; i < 4095; i++)						// find the maximum signal
                    {
                        avg += a[i];
                        if (a[i] > max)
                        {
                            max = a[i];
                            max_index = i;
                        }
                    }
                    avg -= max;
                    avg /= 4095;

                    if (max < (avg + 30))
                    {
                        if (!suppress_errors)
                        {
                            MessageBox.Show(new Form { TopMost = true }, "Peak is less than 30dB from the noise floor.  " +
                                "Please use a larger signal for frequency calibration.",
                                "Calibration Error - Weak Signal",
                                MessageBoxButtons.OK,
                                MessageBoxIcon.Error);
                        }
                        ret_val = false;
                        goto end4;
                    }

                    rx1_meter_cal_offset = 0.0f;
                    RX1DisplayCalOffset = 0.0f;
                    num = 0.0f; num2 = 0.0f; avg2 = 0.0f;
                    avg = 0.0f;
                    avg3 = 0.0f;
                    // get the value of the signal strength meter
                    for (int i = 0; i < 50; i++)
                    {
                        num += DttSP.CalculateRXMeter(0, 0, DttSP.MeterType.SIGNAL_STRENGTH);
                        Thread.Sleep(50);
                        if (!progress.Visible)
                            goto end4;
                        else progress.SetPercent((float)((float)++counter / 170));
                    }
                    avg = num / 50.0f;

                    /*while (progress.Visible)
                    {
                        progress.SetPercent((float)((float)++counter / 170));
                        Thread.Sleep(100);
                    }
                    progress.Show();*/

                    RX1PreampMode = (PreampMode)FLEX1500PreampMode.PLUS_20;
                    Thread.Sleep(200);

                    // get the value of the signal strength meter
                    num2 = 0.0f;
                    for (int i = 0; i < 50; i++)
                    {
                        num2 += DttSP.CalculateRXMeter(0, 0, DttSP.MeterType.SIGNAL_STRENGTH);
                        Thread.Sleep(50);
                        if (!progress.Visible)
                            goto end4;
                        else progress.SetPercent((float)((float)++counter / 170));
                    }
                    avg2 = num2 / 50.0f;
                    attn = avg2 - avg;

                    /*while (progress.Visible)
                    {
                        progress.SetPercent((float)((float)++counter / 170));
                        Thread.Sleep(100);
                    }
                    progress.Show();*/

                    Debug.WriteLine("attn: " + attn.ToString("f1") + " max_index: " + max_index);

                    rx1_preamp_offset[(int)PreampMode.OFF] = attn + 10.0f; // -10
                    rx1_preamp_offset[(int)PreampMode.LOW] = attn; // 0
                    rx1_preamp_offset[(int)PreampMode.MED] = +10.0f; // +10
                    rx1_preamp_offset[(int)PreampMode.HIGH] = 0.0f; // +20
                    rx1_preamp_offset[(int)PreampMode.LAST] = -10.0f; // +30

                    /*RX1PreampMode = (PreampMode)FLEX1500PreampMode.PLUS_20;
                    Thread.Sleep(200); */

                    num = 0.0f;
                    for (int i = 0; i < 20; i++)
                    {
                        calibration_mutex.WaitOne();
                        fixed (float* ptr = &a[0])
                            DttSP.GetSpectrum(0, ptr);		// read again to clear out changed DSP
                        calibration_mutex.ReleaseMutex();

                        /*max = float.MinValue;						// find the max spectrum value
                        for(int j=0; j<Display.BUFFER_SIZE; j++)
                            if(a[j] > max) max = a[j];*/

                        //num2 += max;
                        num += a[max_index];
                        Thread.Sleep(100);

                        if (!progress.Visible)
                            goto end4;
                        else progress.SetPercent((float)((float)++counter / 170));
                    }
                    avg = num / 20.0f;

                    // calculate the difference between the current value and the correct multimeter value
                    diff = level - (avg2 + rx1_meter_cal_offset);
                    rx1_meter_cal_offset = diff;

                    // calculate the difference between the current value and the correct spectrum value
                    diff = level - (avg + RX1DisplayCalOffset);
                    RX1DisplayCalOffset = diff;

                    rx1_level_table[(int)rx1_band][0] = (float)Math.Round(rx1_display_cal_offset, 1);
                    rx1_level_table[(int)rx1_band][1] = (float)Math.Round(attn, 1);
                    rx1_level_table[(int)rx1_band][2] = (float)Math.Round(0.0f, 1);

                    ret_val = true;

                end4:
                    if (!progress.Visible) progress.Text = "";
                    progress.Hide();
                    EnableAllFilters();
                    EnableAllModes();
                    VFOLock = false;

                    USBHID.SetTest(false); Thread.Sleep(10);
                    USBHID.SetGen(false); Thread.Sleep(10);
                    USBHID.SetQSE(false); Thread.Sleep(10);
                    RXAnt1500 = hid_ant; Thread.Sleep(10);

                    Audio.SourceScale = scale;
                    Audio.RX1OutputSignal = Audio.SignalSource.RADIO;

                    RX1PreampMode = preamp;

                    DttSP.SetCorrectIQEnable(1); // turn on I/Q correction

                    comboDisplayMode.Enabled = true;
                    comboMeterRXMode.Enabled = true;
                    comboPreamp.Enabled = true;

                    if (ret_val == false)
                    {
                        rx1_meter_cal_offset = old_multimeter_cal;
                        rx1_display_cal_offset = old_display_cal;
                    }

                    chkMUT.Checked = mute;
                    comboDisplayMode.Text = display;
                    chkRIT.Checked = rit_on;						// restore RIT on
                    udRIT.Value = rit_val;							// restore RIT value
                    //SetupForm.RXOnly = rx_only					// restore RX Only			
                    DisplayAVG = display_avg;						// restore AVG value
                    RX1Filter = am_filter;							// restore AM filter
                    RX1DSPMode = dsp_mode;							// restore DSP mode
                    RX1Filter = filter;								// restore filter
                    /*if (dsp_buf_size != 4096)
                        chkPower.Checked = false;					// go to standby
                    SetupForm.DSPPhoneRXBuffer = dsp_buf_size;		// restore DSP Buffer Size*/
                    VFOAFreq = vfoa; Thread.Sleep(10);								// restore vfo frequency
                    /*if (dsp_buf_size != 4096)
                    {
                        Thread.Sleep(100);
                        chkPower.Checked = true;
                    }*/
                    CurrentMeterRXMode = rx_meter;					// restore RX Meter mode
                    setupForm.Polyphase = polyphase;				// restore polyphase

                    UpdateDisplayOffsets();
                    break;
            }
            calibration_running = false;
            return ret_val;
        }

        /*public void FLEX5000DetectTapResistor()
		{
			Thread t = new Thread(new ThreadStart(RunFLEX5000DetectTapResistor));
			t.Name = "Run FLEX5000 Detect Tap Resistor Thread";
			t.IsBackground = true;
			t.Priority = ThreadPriority.Normal;
			Application.DoEvents();
			Thread.Sleep(100);
			t.Start();
		}

		public void RunFLEX5000DetectTapResistor()
		{
			//bool ret_val = false;
			calibration_running = true;

			if(!chkPower.Checked || !fwc_init || current_model != Model.FLEX5000)
			{
				calibration_running = false;
				return;
			}

			bool rx1_sr = SpurReduction;
			SpurReduction = true;

			bool rx2_sr = RX2SpurReduction;
			RX2SpurReduction = true;

			bool rit_on = chkRIT.Checked;						// save current RIT On
			chkRIT.Checked = false;								// turn RIT off
			int rit_val = (int)udRIT.Value;						// save current RIT value

			double vfoa = VFOAFreq;								// save current VFOA

			int dsp_buf_size = SetupForm.DSPPhoneRXBuffer;		// save current DSP buffer size
			SetupForm.DSPPhoneRXBuffer = 4096;					// set DSP Buffer Size to 2048

			Filter filter = RX1Filter;						// save current filter

			DSPMode dsp_mode = rx1_dsp_mode;				// save current DSP demod mode
			DSPMode dsp2_mode = rx2_dsp_mode;				// save current DSP demod mode

			RX1DSPMode = DSPMode.DSB;						// set mode to DSB
			RX2DSPMode = DSPMode.DSB;						// set mode to DSB

			VFOAFreq = 14.2;								// set VFOA frequency
			VFOBFreq = 14.2;

			bool duplex = full_duplex;
			FullDuplex = true;
			Thread.Sleep(50);
			FWC.SetGen(true);
			Thread.Sleep(50);
			FWC.SetTest(true);
			Thread.Sleep(50);
			FWC.SetSig(true);
			Thread.Sleep(50);
				
			bool rx2 = rx2_enabled;
			RX2Enabled = true;

			FWCAnt rx2_antenna = rx2_ant;
			RX2Ant = FWCAnt.RX1TAP;

			Filter rx1_filter = RX1Filter;					// save current AM filter
			UpdateRX1Filters(-500, 500);
			
			Filter rx2_filter = RX2Filter;
			UpdateRX2Filters(-500, 500);

			//string preamp_s = comboPreamp.Text;					// save current preamp mode
			//comboPreamp.Text = "Off";							// turn preamp off
			bool preamp = chkRX1Preamp.Checked;
			chkRX1Preamp.Checked = false;

			MeterRXMode rx_meter = CurrentMeterRXMode;			// save current RX Meter mode
			CurrentMeterRXMode = MeterRXMode.OFF;				// turn RX Meter off

			MeterRXMode rx2_meter = RX2MeterMode;
			RX2MeterMode = MeterRXMode.OFF;

			chkRX1Preamp.Enabled = false;
			chkRX2Preamp.Enabled = false;
			comboMeterRXMode.Enabled = false;
			comboRX2MeterMode.Enabled = false;

			//progress.SetPercent(0.0f);
			//int counter = 0;

			FWC.SetRX2Preamp(false);
			Thread.Sleep(200);

			float num = 0.0f;
			// get the value of the signal strength meter
			for(int i=0; i<50; i++)
			{
				num += DttSP.CalculateRXMeter(2, 0, DttSP.MeterType.ADC_REAL);
				Thread.Sleep(50);
				//if(!progress.Visible)
				//	goto end2;
				//else progress.SetPercent((float)((float)++counter/120));
			}
			float avg = num / 50.0f;

			num = 0.0f;
			for(int i=0; i<50; i++)
			{
				num += DttSP.CalculateRXMeter(0, 0, DttSP.MeterType.ADC_REAL);
				Thread.Sleep(50);
				//if(!progress.Visible)
				//	goto end2;
				//else progress.SetPercent((float)((float)++counter/120));
			}
			float avg2 = num / 50.0f;

			rx2_res_offset = avg2-avg;
			rx2_trx_match_serial = FWCEEPROM.TRXSerial;

			//ret_val = true;

			//end2:
				//if(!progress.Visible) progress.Text = "";
			//progress.Hide();
			EnableAllFilters();
			EnableAllModes();
			VFOLock = false;

			FullDuplex = duplex;
			Thread.Sleep(50);
			FWC.SetGen(false);
			Thread.Sleep(50);
			FWC.SetTest(false);
			Thread.Sleep(50);
			FWC.SetSig(false);
			Thread.Sleep(50);

			chkRX1Preamp.Enabled = true;
			chkRX2Preamp.Enabled = true;
			comboMeterRXMode.Enabled = true;
			comboRX2MeterMode.Enabled = true;

			SpurReduction = rx1_sr;
			RX2SpurReduction = rx2_sr;
			RX2Enabled = rx2;
			RX2Ant = rx2_antenna;
			chkRIT.Checked = rit_on;							// restore RIT on
			udRIT.Value = rit_val;								// restore RIT value
			//SetupForm.RXOnly = rx_only;							// restore RX Only			
			chkRX1Preamp.Checked = preamp;						// restore preamp value
			RX1Filter = rx1_filter;							// restore AM filter
			RX1DSPMode = dsp_mode;							// restore DSP mode
			RX2DSPMode = dsp2_mode;							// restore DSP mode
			RX1Filter = filter;								// restore filter
			if(dsp_buf_size != 4096)
				chkPower.Checked = false;						// go to standby
			SetupForm.DSPPhoneRXBuffer = dsp_buf_size;				// restore DSP Buffer Size
			VFOAFreq = vfoa;									// restore vfo frequency
			if(dsp_buf_size != 4096)
			{
				Thread.Sleep(100);
				chkPower.Checked = true;
			}
			CurrentMeterRXMode = rx_meter;						// restore RX Meter mode
			RX2MeterMode = rx2_meter;

			calibration_running = false;
		}*/

        public bool CalibrateRX2Level(float level, float freq, Progress progress, bool suppress_errors)
        {
            // Calibration routine called by Setup Form.
            bool ret_val = false;
            calibration_running = true;
            if (!chkPower.Checked)
            {
                if (!suppress_errors)
                {
                    MessageBox.Show(new Form { TopMost = true }, "Power must be on in order to calibrate RX2 Level.", "Power Is Off",
                        MessageBoxButtons.OK, MessageBoxIcon.Stop);
                }
                calibration_running = false;
                return false;
            }

            if (!fwc_init || current_model != Model.FLEX5000)
            {
                calibration_running = false;
                return false;
            }

            float[] a = new float[Display.BUFFER_SIZE];

            bool rx1_sr = SpurReduction;
            SpurReduction = true;
            //Thread.Sleep(50);

            bool rx2_sr = RX2SpurReduction;
            RX2SpurReduction = true;
            //Thread.Sleep(50);

            bool rit_on = chkRIT.Checked;                       // save current RIT On
            chkRIT.Checked = false;                             // turn RIT off
            int rit_val = (int)udRIT.Value;                     // save current RIT value

            double vfoa = VFOAFreq;                             // save current VFOA

            string display = comboDisplayMode.Text;
            comboDisplayMode.Text = "Spectrum";

            bool polyphase = setupForm.Polyphase;               // save current polyphase setting
            setupForm.Polyphase = false;                        // disable polyphase

            int dsp_buf_size = setupForm.DSPPhoneRXBuffer;      // save current DSP buffer size
            setupForm.DSPPhoneRXBuffer = 4096;                  // set DSP Buffer Size to 2048

            Filter filter = RX1Filter;                      // save current filter

            DSPMode dsp_mode = rx1_dsp_mode;                // save current DSP demod mode
            DSPMode dsp2_mode = rx2_dsp_mode;               // save current DSP demod mode

            RX1DSPMode = DSPMode.DSB;                       // set mode to DSB
                                                            //Thread.Sleep(50);
            RX2DSPMode = DSPMode.DSB;                       // set mode to DSB

            VFOAFreq = freq;                                    // set VFOA frequency
                                                                //Thread.Sleep(100);
            VFOBFreq = freq;
            //Thread.Sleep(100);

            bool duplex = full_duplex;
            FullDuplex = true;
            //Thread.Sleep(50);
            FWC.SetGen(true);
            //Thread.Sleep(50);
            FWC.SetTest(true);
            //Thread.Sleep(50);
            FWC.SetSig(true);
            //Thread.Sleep(50);

            bool rx2 = rx2_enabled;
            RX2Enabled = true;

            FWCAnt rx2_antenna = rx2_ant;
            RX2Ant = FWCAnt.RX1TAP;
            //Thread.Sleep(50);

            Filter rx1_filter = RX1Filter;                  // save current AM filter
            UpdateRX1Filters(-500, 500);

            Filter rx2_filter = RX2Filter;
            UpdateRX2Filters(-500, 500);

            bool rx1_preamp = chkRX1Preamp.Checked;                 // save current preamp mode
            chkRX1Preamp.Checked = false;                           // turn preamp off
                                                                    //Thread.Sleep(50);

            bool rx2_preamp = chkRX2Preamp.Checked;                 // save current preamp mode
            chkRX2Preamp.Checked = false;                           // turn preamp off
                                                                    //Thread.Sleep(50);

            MeterRXMode rx_meter = CurrentMeterRXMode;          // save current RX Meter mode
            CurrentMeterRXMode = MeterRXMode.OFF;               // turn RX Meter off

            MeterRXMode rx2_meter = RX2MeterMode;
            RX2MeterMode = MeterRXMode.OFF;

            bool display_avg = chkDisplayAVG.Checked;           // save current average state
            chkDisplayAVG.Checked = false;
            chkDisplayAVG.Checked = true;                       // set average state to off

            float old_multimeter_cal = rx2_meter_cal_offset;
            float old_display_cal = rx2_display_cal_offset;

            chkRX1Preamp.Enabled = false;
            chkRX2Preamp.Enabled = false;
            comboDisplayMode.Enabled = false;
            comboMeterRXMode.Enabled = false;
            comboRX2MeterMode.Enabled = false;

            progress.SetPercent(0.0f);
            int counter = 0;

            Thread.Sleep(2000);
            btnZeroBeat_Click(this, EventArgs.Empty);
            RX1Filter = Filter.F6;
            chkDisplayAVG.Checked = false;

            FWC.SetRX2Preamp(false);
            Thread.Sleep(200);

            DisableAllFilters();
            DisableAllModes();
            VFOLock = true;

            calibration_mutex.WaitOne();
            fixed (float* ptr = &a[0])
                DttSP.GetSpectrum(2, ptr);      // get the spectrum values
            calibration_mutex.ReleaseMutex();

            float max = float.MinValue;
            float avg = 0;
            int max_index = 0;

            for (int i = 0; i < 4095; i++)                      // find the maximum signal
            {
                avg += a[i];
                if (a[i] > max)
                {
                    max = a[i];
                    max_index = i;
                }
            }
            avg -= max;
            avg /= 4095;

            if (max < (avg + 30))
            {
                if (!suppress_errors)
                {
                    MessageBox.Show(new Form { TopMost = true }, "Peak is less than 30dB from the noise floor.  " +
                        "Please use a larger signal for frequency calibration.",
                        "Calibration Error - Weak Signal",
                        MessageBoxButtons.OK,
                        MessageBoxIcon.Error);
                }
                ret_val = false;
                goto end2;
            }

            rx2_meter_cal_offset = 0.0f;
            RX2DisplayCalOffset = 0.0f;
            float num = 0.0f; float num2 = 0.0f; float avg2 = 0.0f;
            avg = 0.0f;
            // get the value of the signal strength meter
            for (int i = 0; i < 50; i++)
            {
                num += DttSP.CalculateRXMeter(2, 0, DttSP.MeterType.SIGNAL_STRENGTH);
                Thread.Sleep(50);
                if (!progress.Visible)
                    goto end2;
                else progress.SetPercent((float)((float)++counter / 120));
            }
            avg = num / 50.0f;

            FWC.SetRX2Preamp(true);
            Thread.Sleep(200);

            // get the value of the signal strength meter
            num2 = 0.0f;
            for (int i = 0; i < 50; i++)
            {
                num2 += DttSP.CalculateRXMeter(2, 0, DttSP.MeterType.SIGNAL_STRENGTH);
                Thread.Sleep(50);
                if (!progress.Visible)
                    goto end2;
                else progress.SetPercent((float)((float)++counter / 120));
            }
            avg2 = num2 / 50.0f;

            fwc_preamp_offset = avg2 - avg;
            rx2_preamp_offset[(int)PreampMode.OFF] = 0.0f;
            rx2_preamp_offset[(int)PreampMode.HIGH] = -fwc_preamp_offset;

            Debug.WriteLine("fwc_preamp_offset: " + fwc_preamp_offset.ToString("f6" ));

            FWC.SetRX2Preamp(false);
            Thread.Sleep(200);

            num2 = 0.0f;
            for (int i = 0; i < 20; i++)
            {
                calibration_mutex.WaitOne();
                fixed (float* ptr = &a[0])
                    DttSP.GetSpectrum(2, ptr);      // read again to clear out changed DSP
                calibration_mutex.ReleaseMutex();

                //max = float.MinValue;						// find the max spectrum value
                //		for(int j=0; j<Display.BUFFER_SIZE; j++)
                //			if(a[j] > max) max = a[j];

                //num2 += max;
                num2 += a[max_index];
                Thread.Sleep(100);

                if (!progress.Visible)
                    goto end2;
                else progress.SetPercent((float)((float)++counter / 120));
            }
            avg2 = num2 / 20.0f;

            // calculate the difference between the current value and the correct multimeter value
            float diff = level - (avg + rx2_meter_cal_offset);
            rx2_meter_cal_offset = diff;

            // calculate the difference between the current value and the correct spectrum value
            diff = level - (avg2 + RX2DisplayCalOffset);
            RX2DisplayCalOffset = diff;

            UpdateDisplayOffsets();

            rx2_level_table[(int)rx2_band][0] = (float)Math.Round(rx2_display_cal_offset, 3);
            rx2_level_table[(int)rx2_band][1] = (float)Math.Round(-fwc_preamp_offset, 3);
            rx2_level_table[(int)rx2_band][2] = (float)Math.Round(rx2_meter_cal_offset, 3);

            ret_val = true;

        end2:
            if (!progress.Visible) progress.Text = "";
            progress.Hide();
            EnableAllFilters();
            EnableAllModes();
            VFOLock = false;

            FullDuplex = duplex;
            //Thread.Sleep(50);
            FWC.SetGen(false);
            //Thread.Sleep(50);
            FWC.SetTest(false);
            //Thread.Sleep(50);
            FWC.SetSig(false);
            //Thread.Sleep(50);

            chkRX1Preamp.Enabled = true;
            chkRX2Preamp.Enabled = true;
            comboDisplayMode.Enabled = true;
            comboMeterRXMode.Enabled = true;
            comboRX2MeterMode.Enabled = true;

            if (ret_val == false)
            {
                rx2_meter_cal_offset = old_multimeter_cal;
                rx2_display_cal_offset = old_display_cal;
            }

            SpurReduction = rx1_sr;
            //Thread.Sleep(50);
            RX2SpurReduction = rx2_sr;
            //Thread.Sleep(50);
            RX2Enabled = rx2;
            RX2Ant = rx2_antenna;
            //Thread.Sleep(50);
            comboDisplayMode.Text = display;
            chkRIT.Checked = rit_on;                            // restore RIT on
            udRIT.Value = rit_val;                              // restore RIT value
                                                                //SetupForm.RXOnly = rx_only;						// restore RX Only			
            DisplayAVG = display_avg;                           // restore AVG value
            chkRX1Preamp.Checked = rx1_preamp;                  // restore preamp value
            chkRX2Preamp.Checked = rx2_preamp;
            FWC.SetRX2Preamp(rx2_preamp);
            RX1Filter = rx1_filter;                         // restore AM filter
            RX1DSPMode = dsp_mode;                          // restore DSP mode
                                                            //Thread.Sleep(50);
            RX2DSPMode = dsp2_mode;                         // restore DSP mode
            RX1Filter = filter;                             // restore filter
            if (dsp_buf_size != 4096)
                chkPower.Checked = false;                       // go to standby
            setupForm.DSPPhoneRXBuffer = dsp_buf_size;              // restore DSP Buffer Size
            VFOAFreq = vfoa;                                    // restore vfo frequency
                                                                //Thread.Sleep(100);
            if (dsp_buf_size != 4096)
            {
                Thread.Sleep(100);
                chkPower.Checked = true;
            }
            CurrentMeterRXMode = rx_meter;                      // restore RX Meter mode
            RX2MeterMode = rx2_meter;
            setupForm.Polyphase = polyphase;                    // restore polyphase

            //			Debug.WriteLine("rx1_meter_cal_offset: "+rx1_meter_cal_offset);
            //			Debug.WriteLine("display_cal_offset: "+display_cal_offset);
            //			MessageBox.Show(new Form { TopMost = true }, "rx1_meter_cal_offset: "+rx1_meter_cal_offset.ToString()+"\n"+
            //				"display_cal_offset: "+display_cal_offset.ToString());

            calibration_running = false;
            return ret_val;
        }

        public float[] rx_image_rejection = new float[(int)Band.LAST];
        public float[] rx_image_from_floor = new float[(int)Band.LAST];
        public bool CalibrateRXImage(float freq, Progress progress, bool suppress_errors)
        {
            HiPerfTimer t1 = new HiPerfTimer();
            t1.Start();
            HiPerfTimer t2 = new HiPerfTimer();

            // Setup Rig for Image Null Cal
            bool ret_val = false;
            calibration_running = true;

            if (!chkPower.Checked)
            {
                if (!suppress_errors)
                {
                    MessageBox.Show(new Form { TopMost = true }, "Power must be on in order to calibrate RX Image.", "Power Is Off",
                        MessageBoxButtons.OK, MessageBoxIcon.Stop);
                }
                calibration_running = false;
                progress.Text = "";
                return false;
            }

            if (hid_init && current_model == Model.FLEX1500)
            {
                if (!Flex1500.ProdTestPresent())
                {
                    MessageBox.Show(new Form { TopMost = true }, "Production Gen Unit not found.  Aborting Test.");
                    calibration_running = false;
                    progress.Text = "";
                    return false;
                }
            }

            bool spur_red = chkSR.Checked;					// save current spur reduction setting
            chkSR.Checked = false;							// turn spur reduction off

            //bool rx_only = SetupForm.RXOnly;				// save RX Only Setting
            //SetupForm.RXOnly = true;

            bool split = chkVFOSplit.Checked;
            chkVFOSplit.Checked = false;

            bool polyphase = setupForm.Polyphase;			// save current polyphase setting
            setupForm.Polyphase = false;					// disable polyphase

            int dsp_buf_size = setupForm.DSPPhoneRXBuffer;		// save current DSP buffer size
            setupForm.DSPPhoneRXBuffer = 4096;					// set DSP Buffer Size to 4096

            string display_mode = comboDisplayMode.Text;
            comboDisplayMode.Text = "Spectrum";

            bool avg = chkDisplayAVG.Checked;		// save current average state
            chkDisplayAVG.Checked = true;

            DSPMode dsp_mode = rx1_dsp_mode;			// save current dsp mode
            RX1DSPMode = DSPMode.DSB;					// set dsp mode to DSB

            int filt_low = RX1FilterLow;
            int filt_high = RX1FilterHigh;
            Filter filter = rx1_filter;					// save current filter
            RX1Filter = Filter.F1;						// set filter to 6kHz

            DttSP.SetCorrectIQEnable(0); // turn off I/Q correction
            DttSP.SetCorrectRXIQw(0, 0, 0.0f, 0.0f, 0);
            DttSP.SetCorrectRXIQw(0, 0, 0.0f, 0.0f, 1);

            PreampMode preamp = rx1_preamp_mode;		// save current preamp setting
            switch (current_model)
            {
                case Model.SDR1000:
                case Model.FLEX5000:
                    RX1PreampMode = PreampMode.HIGH;			// set preamp to high
                    break;
                case Model.FLEX3000:
                    if (FWCEEPROM.TRXRev >> 8 < 6) // before rev G
                    {
                        if (BandByFreq(freq, -1, true, current_region) == Band.B160M)
                            RX1PreampMode = PreampMode.LOW;
                        else RX1PreampMode = PreampMode.HIGH;
                    }
                    else // rev G+
                    {
                        switch (BandByFreq(freq, -1, true, current_region))
                        {
                            case Band.B160M:
                            case Band.B80M:
                            case Band.B60M:
                                RX1PreampMode = PreampMode.LOW;
                                break;
                            default:
                                RX1PreampMode = PreampMode.HIGH;
                                break;
                        }
                    }
                    break;
                case Model.FLEX1500:
                    RX1PreampMode = (PreampMode)FLEX1500PreampMode.PLUS_20;
                    break;
            }

            bool duplex = full_duplex;
            FullDuplex = true;

            bool rx2 = chkRX2.Checked;
            if (fwc_init && current_model == Model.FLEX5000 && FWCEEPROM.RX2OK)
                chkRX2.Checked = false;

            HIDAnt ant = RXAnt1500;

            switch (current_model)
            {
                case Model.FLEX5000:
                case Model.FLEX3000:
                    if (fwc_init)
                    {
                        VFOBFreq = freq;
                        //Thread.Sleep(50);
                        FWC.SetTest(true);
                        //Thread.Sleep(50);
                        FWC.SetGen(true);
                        //Thread.Sleep(50);
                        FWC.SetSig(true);
                        //Thread.Sleep(50);
                        FWC.SetQSE(false);
                        //Thread.Sleep(50);
                    }
                    break;
                case Model.FLEX1500:
                    if (hid_init)
                    {
                        Flex1500.ProdTestWriteOp(USBHID.Opcode.USB_OP_SET_RX1_FREQ_TW, (uint)Freq2TW(freq / 2), 0);
                        Thread.Sleep(20);
                        RXAnt1500 = HIDAnt.XVTX_COM;
                        Thread.Sleep(20);
                    }
                    break;
            }

            double vfo_freq = VFOAFreq;						    // save current frequency
            VFOAFreq = freq + 2 * (float)if_freq;				// was   VFOAFreq = freq + 2 * (float)if_freq;      set frequency to passed value + 2*IF

            DisableAllFilters();
            DisableAllModes();
            VFOLock = true;
            comboPreamp.Enabled = false;
            comboDisplayMode.Enabled = false;

            //int retval = 0;
            progress.SetPercent(0.0f);

            float[] a = new float[Display.BUFFER_SIZE];
            float[] init_max = new float[4];

            Thread.Sleep(200);
            float sum = 0.0f;
            int peak_bin = -1;
            float max_signal = float.MinValue;

            for (int i = 0; i < 5; i++)
            {
                calibration_mutex.WaitOne();
                fixed (float* ptr = &a[0])
                    DttSP.GetSpectrum(0, ptr);// get the spectrum values
                calibration_mutex.ReleaseMutex();
                Thread.Sleep(50);
            }

            for (int i = 0; i < 5; i++)
            {
                calibration_mutex.WaitOne();
                fixed (float* ptr = &a[0])
                    DttSP.GetSpectrum(0, ptr);// get the spectrum values
                calibration_mutex.ReleaseMutex();

                for (int j = 0; i == 4 && j < Display.BUFFER_SIZE; j++)
                {
                    if (a[j] > max_signal)
                    {
                        max_signal = a[j];
                        peak_bin = j;
                    }
                }

                for (int j = 1948; j < 2148; j++) // TODO: Fix limits for 48/96kHz
                {
                    if (j < 2040 || j > 2055)
                        sum += a[j];
                }
                Thread.Sleep(50);
            }

            float noise_floor = (sum / 925.0f);
            float worst_image = max_signal;
            Debug.WriteLine("noise_floor: " + (noise_floor + Display.RX1DisplayCalOffset + Display.RX1PreampOffset).ToString("f6" ) + " peak_bin: " + peak_bin);

            if (max_signal < noise_floor + 25.0)
            {
                if (!suppress_errors)
                {
                    MessageBox.Show(new Form { TopMost = true }, "Image not found (max signal < noise floor + 25dB).  Please try again.\n" +
                        DateTime.Now.ToShortTimeString(),
                        "Image Not Found",
                        MessageBoxButtons.OK, MessageBoxIcon.Stop);
                }
                calibration_running = false;
                DttSP.SetCorrectIQEnable(1); // turn on I/Q correction
                progress.Hide();
                goto end;
            }

            calibrating = true;
            DttSP.SetCorrectIQEnable(1); // turn on I/Q correction

            int count = 0;
            for (int i = 0; i < 15; i++)
            {
                if (i < 9) DttSP.SetCorrectIQMu(0, 0, 0.1 - i * 0.01);
                if (!progress.Visible) goto end;
                progress.SetPercent(count++ / 15.0f);
                Thread.Sleep(100);
            }

            //if (current_model == Model.FLEX1500)
            //    DttSP.SetCorrectIQMu(0, 0, 0.0);

            // Finish the algorithm and reset the values
            ret_val = true;
        end:

            if (!progress.Visible)
            {
                progress.Text = "";
                rx_image_rejection[(int)rx1_band] = 0.0f;
                rx_image_from_floor[(int)rx1_band] = 100.0f;
            }
            else
            {
                float real, imag;
                //DttSP.SetCorrectIQMu(0, 0, 0);
                DttSP.GetCorrectRXIQw(0, 0, &real, &imag, 1);
                DttSP.SetCorrectRXIQw(0, 0, real, imag, 0);
                DttSP.SetCorrectRXIQw(0, 0, 0.0f, 0.0f, 1);
                Debug.WriteLine("RX Image Real: " + real.ToString("f6" ) + "  Imag: " + imag.ToString("f6" ));
                rx1_image_gain_table[(int)rx1_band] = real;
                rx1_image_phase_table[(int)rx1_band] = imag;

                rx_image_rejection[(int)rx1_band] = (float)(-24.0 - (noise_floor + Display.RX1DisplayCalOffset + Display.RX1PreampOffset));
                rx_image_from_floor[(int)rx1_band] = 0.0f;
            }

            progress.Hide();
            calibration_running = false;
            calibrating = false;

            WBIRRX1Holdoff();

            switch (current_model)
            {
                case Model.FLEX5000:
                case Model.FLEX3000:
                    if (fwc_init)
                    {
                        VFOBFreq = vfo_freq;
                        //Thread.Sleep(50);
                        FWC.SetTest(false);
                        //Thread.Sleep(50);
                        FWC.SetGen(false);
                        //Thread.Sleep(50);
                        FWC.SetSig(false);
                        //Thread.Sleep(50);
                    }
                    break;
                case Model.FLEX1500:
                    if (hid_init)
                    {
                        RXAnt1500 = ant;
                        Flex1500.ProdTestWriteOp(USBHID.Opcode.USB_OP_SET_RX1_FREQ_TW, 0, 0);
                    }
                    break;
            }

            EnableAllFilters();
            EnableAllModes();
            VFOLock = false;
            FullDuplex = duplex;
            comboPreamp.Enabled = true;
            comboDisplayMode.Enabled = true;

            chkVFOSplit.Checked = split;
            chkSR.Checked = spur_red;							// restore spur reduction setting
            RX1PreampMode = preamp;							    // restore preamp mode
            comboDisplayMode.Text = display_mode;				// restore display mode
            //SetupForm.RXOnly = rx_only;						// restore RX Only setting
            RX1DSPMode = dsp_mode;							    // restore dsp mode
            RX1Filter = filter;								    // restore filter
            if (filter == Filter.VAR1 || filter == Filter.VAR2)
                UpdateRX1Filters(filt_low, filt_high);

            VFOAFreq = vfo_freq;								// restore frequency
            txtVFOAFreq_LostFocus(this, EventArgs.Empty);
            chkDisplayAVG.Checked = avg;						// restore average state
            setupForm.DSPPhoneRXBuffer = dsp_buf_size;	        // restore DSP Buffer Size
            setupForm.Polyphase = polyphase;					// restore polyphase

            if (fwc_init && current_model == Model.FLEX5000 && FWCEEPROM.RX2OK)
                chkRX2.Checked = rx2;

            t1.Stop();
            //MessageBox.Show(t1.Duration.ToString());
            Debug.WriteLine("timer: " + t1.Duration);
            return ret_val;
        }

        public bool CalibrateRX2Image(float freq, Progress progress, bool suppress_errors)
        {
            if (!fwc_init || current_model != Model.FLEX5000 || !FWCEEPROM.RX2OK) return false;

            HiPerfTimer t1 = new HiPerfTimer();
            t1.Start();
            HiPerfTimer t2 = new HiPerfTimer();

            //float global_min_value = float.MaxValue;

            // Setup Rig for Image Null Cal
            bool ret_val = false;
            calibration_running = true;

            if (!chkPower.Checked)
            {
                if (!suppress_errors)
                {
                    MessageBox.Show(new Form { TopMost = true }, "Power must be on in order to calibrate RX Image.", "Power Is Off",
                        MessageBoxButtons.OK, MessageBoxIcon.Stop);
                }
                calibration_running = false;
                progress.Text = "";
                return false;
            }

            double vfoa = VFOAFreq;
            double vfob = VFOBFreq;

            DttSP.SetCorrectIQEnable(0);					// turn off I/Q correction
            DttSP.SetCorrectRXIQw(2, 0, 0.0f, 0.0f, 0);
            DttSP.SetCorrectRXIQw(2, 0, 0.0f, 0.0f, 1);

            bool spur_red = chkSR.Checked;					// save current spur reduction setting
            chkSR.Checked = false;							// turn spur reduction off
            //Thread.Sleep(50);

            bool rx2_sr = chkRX2SR.Checked;
            chkRX2SR.Checked = false;
            //Thread.Sleep(50);

            //bool rx_only = SetupForm.RXOnly;				// save RX Only Setting
            //SetupForm.RXOnly = true;

            bool split = chkVFOSplit.Checked;
            chkVFOSplit.Checked = false;

            bool polyphase = setupForm.Polyphase;			// save current polyphase setting
            setupForm.Polyphase = false;					// disable polyphase

            int dsp_buf_size = setupForm.DSPPhoneRXBuffer;	// save current DSP buffer size
            setupForm.DSPPhoneRXBuffer = 4096;				// set DSP Buffer Size to 4096

            bool rx2 = rx2_enabled;
            RX2Enabled = true;

            string display_mode = comboDisplayMode.Text;
            comboDisplayMode.Text = "Spectrum";

            bool avg = chkDisplayAVG.Checked;				// save current average state
            chkDisplayAVG.Checked = true;

            DSPMode dsp_mode = rx1_dsp_mode;				// save current dsp mode
            DSPMode dsp2_mode = rx2_dsp_mode;				// save current dsp mode

            RX1DSPMode = DSPMode.DSB;						// set dsp mode to DSB
            //Thread.Sleep(50);
            RX2DSPMode = DSPMode.DSB;						// set dsp mode to DSB

            int filt1_low = RX1FilterLow;
            int filt1_high = RX1FilterHigh;
            Filter filter1 = rx1_filter;					// save current filter

            int filt2_low = RX1FilterLow;
            int filt2_high = RX1FilterHigh;
            Filter filter2 = rx1_filter;					// save current filter

            /*PreampMode preamp = rx1_preamp_mode;			// save current preamp setting
            RX1PreampMode = PreampMode.HIGH;				// set preamp to high*/
            bool preamp = fwc_rx2_preamp;
            FWC.SetRX2Preamp(true);
            //Thread.Sleep(50);

            bool duplex = full_duplex;
            FullDuplex = true;

            VFOAFreq = freq;
            //Thread.Sleep(50);
            FWC.SetTest(true);
            //Thread.Sleep(50);
            FWC.SetGen(true);
            //Thread.Sleep(50);
            FWC.SetSig(true);
            //Thread.Sleep(50);
            FWC.SetQSE(false);
            //Thread.Sleep(50);

            VFOBFreq = freq + 2 * (float)if_freq;				// set frequency to passed value + 2*IF
            //Thread.Sleep(100);

            UpdateRX1Filters(-5000, 5000);
            UpdateRX2Filters(-5000, 5000);

            FWCAnt rx2_antenna = RX2Ant;
            RX2Ant = FWCAnt.RX1TAP;
            //Thread.Sleep(50);

            DisableAllFilters();
            DisableAllModes();
            VFOLock = true;
            comboPreamp.Enabled = false;
            comboDisplayMode.Enabled = false;

            //int retval = 0;
            progress.SetPercent(0.0f);

            float[] a = new float[Display.BUFFER_SIZE];

            Thread.Sleep(200);
            float sum = 0.0f;
            int peak_bin = -1;
            float max_signal = float.MinValue;

            for (int i = 0; i < 5; i++)
            {
                calibration_mutex.WaitOne();
                fixed (float* ptr = &a[0])
                    DttSP.GetSpectrum(2, ptr);				// get the spectrum values
                calibration_mutex.ReleaseMutex();
                Thread.Sleep(50);
            }

            for (int i = 0; i < 5; i++)
            {
                calibration_mutex.WaitOne();
                fixed (float* ptr = &a[0])
                    DttSP.GetSpectrum(2, ptr);				// get the spectrum values
                calibration_mutex.ReleaseMutex();

                /*for(int j=0; i==4 && j<Display.BUFFER_SIZE; j++)
                {
                    if(a[j] > max_signal)
                    {
                        max_signal = a[j];
                        peak_bin = j;
                    }
                }*/
                max_signal = a[2048];
                peak_bin = 2048;

                for (int j = 1948; j < 2148; j++) // TODO: Fix limits for 48/96kHz
                {
                    if (j < 2040 || j > 2055)
                        sum += a[j];
                }
                Thread.Sleep(50);
            }

            float noise_floor = (sum / 925.0f);
            float worst_image = max_signal;
            Debug.WriteLine("noise_floor: " + noise_floor.ToString("f6" ) + " peak_bin: " + peak_bin);

            if (max_signal < noise_floor + 30.0)
            {
                if (!suppress_errors)
                {
                    MessageBox.Show(new Form { TopMost = true }, "Image not found (max signal < noise floor + 30dB).  Please try again.\n" +
                        DateTime.Now.ToShortTimeString(),
                        "Image Not Found",
                        MessageBoxButtons.OK, MessageBoxIcon.Stop);
                }
                calibration_running = false;
                DttSP.SetCorrectIQEnable(1); // turn on I/Q correction
                //progress.Text = "";
                goto end;
            }

            calibrating = true;
            DttSP.SetCorrectIQEnable(1); // turn on I/Q correction

            int count = 0;
            for (int i = 0; i < 15; i++)
            {
                if (i < 9) DttSP.SetCorrectIQMu(2, 0, 0.1 - i * 0.01);
                if (!progress.Visible) goto end;
                progress.SetPercent(count++ / 15.0f);
                Thread.Sleep(100);
            }

            // Finish the algorithm and reset the values
            ret_val = true;
        end:
            if (!progress.Visible) progress.Text = "";
            else
            {
                float real, imag;
                DttSP.SetCorrectIQMu(2, 0, 0);
                DttSP.GetCorrectRXIQw(2, 0, &real, &imag, 1);
                DttSP.SetCorrectRXIQw(2, 0, real, imag, 0);
                DttSP.SetCorrectRXIQw(2, 0, 0.0f, 0.0f, 1);
                rx2_image_gain_table[(int)rx2_band] = real;
                rx2_image_phase_table[(int)rx2_band] = imag;
            }
            progress.Hide();
            calibration_running = false;
            calibrating = false;

            WBIRRX1Holdoff();
            WBIRRX2Holdoff();

            rx_image_rejection[(int)rx2_band] = (float)(-24.0 - (noise_floor + Display.RX2DisplayCalOffset + Display.RX2PreampOffset));
            rx_image_from_floor[(int)rx2_band] = 0.0f;

            FWC.SetTest(false);
            //Thread.Sleep(50);
            FWC.SetGen(false);
            //Thread.Sleep(50);
            FWC.SetSig(false);
            //Thread.Sleep(50);

            EnableAllFilters();
            EnableAllModes();
            VFOLock = false;
            FullDuplex = duplex;
            FWC.SetRX2Preamp(preamp);
            //Thread.Sleep(50);
            comboDisplayMode.Enabled = true;

            chkVFOSplit.Checked = split;
            chkSR.Checked = spur_red;							// restore spur reduction setting
            //Thread.Sleep(50);
            chkRX2SR.Checked = rx2_sr;
            //Thread.Sleep(50);
            //RX1PreampMode = preamp;							// restore preamp mode
            comboDisplayMode.Text = display_mode;				// restore display mode
            //SetupForm.RXOnly = rx_only;						// restore RX Only setting
            RX1DSPMode = dsp_mode;								// restore dsp mode
            //Thread.Sleep(50);
            RX2DSPMode = dsp2_mode;								// restore dsp mode
            RX1Filter = filter1;								// restore filter
            if (filter1 == Filter.VAR1 || filter1 == Filter.VAR2)
                UpdateRX1Filters(filt1_low, filt1_high);
            RX2Filter = filter2;
            if (filter2 == Filter.VAR1 || filter2 == Filter.VAR2)
                UpdateRX2Filters(filt2_low, filt2_high);

            VFOAFreq = vfoa;									// restore frequency
            //Thread.Sleep(100);
            txtVFOAFreq_LostFocus(this, EventArgs.Empty);
            //Thread.Sleep(100);
            VFOBFreq = vfob;
            //Thread.Sleep(100);
            RX2Enabled = rx2;
            RX2Ant = rx2_antenna;
            //Thread.Sleep(50);
            chkDisplayAVG.Checked = avg;						// restore average state
            setupForm.DSPPhoneRXBuffer = dsp_buf_size;			// restore DSP Buffer Size
            setupForm.Polyphase = polyphase;					// restore polyphase

            t1.Stop();
            //MessageBox.Show(t1.Duration.ToString());
            Debug.WriteLine("timer: " + t1.Duration);
            return ret_val;
        }

        public float[] tx_image_rejection = new float[(int)Band.LAST];
        public bool CalibrateTXImage(float freq, Progress progress, bool suppress_errors)
        {
            if ((!fwc_init || (current_model != Model.FLEX5000 && current_model != Model.FLEX3000)) &&
                (!hid_init || current_model != Model.FLEX1500))
            {
                progress.Text = "";
                progress.Hide();
                return false;
            }

            if (!chkPower.Checked)
            {
                if (!suppress_errors)
                {
                    MessageBox.Show(new Form { TopMost = true }, "Power must be on in order to calibrate TX Image.", "Power Is Off",
                        MessageBoxButtons.OK, MessageBoxIcon.Stop);
                }
                calibration_running = false;
                progress.Text = "";
                tx_image_rejection[(int)tx_band] = 0.0f;
                return false;
            }

            calibrating = true;

            float tol = 10.0f;
            float phase_step = 2;
            float gain_step = 2;
            float global_min_phase = 0;
            float global_min_gain = 0;
            float gain_index = 0.0f, phase_index = 0.0f;
            float global_min_value = float.MaxValue;
            bool progressing = true;
            int gain_dir = -1;
            int phase_dir = 1;
            int gain_count = 1, phase_count = 1;
            int wrong_direction_count;
            int switch_direction_count;
            string index_string;
            string val_string;
            string gain_string = "";
            string phase_string = "";
            float fundamental = -200.0f;

            switch (current_model)
            {
                case Model.FLEX3000:
                    phase_step = 4;
                    gain_step = 4;
                    break;
            }

            HiPerfTimer t1 = new HiPerfTimer();
            t1.Start();
            HiPerfTimer t2 = new HiPerfTimer();

            // Setup Rig for TX Image Null Cal
            bool ret_val = false;
            calibration_running = true;

            //int retval = 0;
            progress.SetPercent(0.0f);

            bool spur_red = chkSR.Checked;					// save current spur reduction setting
            chkSR.Checked = false;							// turn spur reduction off

            bool polyphase = setupForm.Polyphase;			// save current polyphase setting
            setupForm.Polyphase = false;					// disable polyphase

            int dsp_buf_size = setupForm.DSPPhoneRXBuffer;	// save current DSP buffer size
            setupForm.DSPPhoneRXBuffer = 4096;				// set DSP Buffer Size to 4096

            DSPMode dsp_mode = rx1_dsp_mode;			    // save current dsp mode
            RX1DSPMode = DSPMode.USB;					    // set dsp mode to USB

            // Setting filters for TX calibration (optmized for SSB) and we need to fix the VAR filter setting
            // consequence of this action

            string display_mode = comboDisplayMode.Text;
            comboDisplayMode.Text = "Spectrum";

            bool avg = chkDisplayAVG.Checked;				// save current average state
            chkDisplayAVG.Checked = true;

            Filter filter = rx1_filter;					    // save current filter
            SetRX1Filter(Filter.VAR1);

            int filter_low = (int)udFilterLow.Value;
            int filter_high = (int)udFilterHigh.Value;

            UpdateRX1Filters(-3000, 3000);                  // set filter to -3k, -300 ... LSB for image

            int tx_filt_low = setupForm.TXFilterLow;		// save tx filter low cut
            setupForm.TXFilterLow = 300;					// set low cut to 300Hz

            int tx_filt_high = setupForm.TXFilterHigh;		// save tx filter high cut
            setupForm.TXFilterHigh = 3000;					// set high cut to 3kHz

            PreampMode preamp = rx1_preamp_mode;		    // save current preamp setting
            switch (current_model)
            {
                case Model.FLEX5000:
                    RX1PreampMode = PreampMode.HIGH;		// set preamp to high
                    break;
                case Model.FLEX3000:
                    if (BandByFreq(freq, -1, true, current_region) == Band.B160M)
                        RX1PreampMode = PreampMode.LOW;
                    else RX1PreampMode = PreampMode.HIGH;
                    break;
            }


            bool duplex = full_duplex;
            FullDuplex = true;

            bool mute = chkMUT.Checked;
            chkMUT.Checked = false;

            int af = ptbAF.Value;
            ptbAF.Value = 50;

            int tx_af = TXAF;

            TXAF = 50;

            double vfo_freq = VFOAFreq;						// save current frequency
            VFOAFreq = freq;								// set frequency to passed value
            VFOBFreq = freq;

            Audio.TXInputSignal = Audio.SignalSource.SINE;
            double last_scale = Audio.SourceScale;			// saved audio scale
            Audio.SourceScale = 1.0;
            double tone_freq = Audio.SineFreq1;				// save tone freq
            Audio.SineFreq1 = 1500.0;						// set freq

            int pwr = ptbPWR.Value;
            ptbPWR.Value = 100;
            Audio.RadioVolume = 0.500; // changed from 0.200 4/8/09

            HIDAnt hid_ant = RXAnt1500;
            bool iambic = CWIambic;
            CWIambic = false;

            bool ptt = disable_ptt;
            disable_ptt = true;

            double _if_freq = if_freq;
            int _cw_pitch = cw_pitch;
            HIDAnt _rx_ant_1500 = rx_ant_1500;

            bool xit = chkXIT.Checked;
            chkXIT.Checked = false;

            bool rit = chkRIT.Checked;
            chkRIT.Checked = false;

            switch (current_model)
            {
                case Model.FLEX5000:
                case Model.FLEX3000:
                    FWC.SetQSD(true);
                    FWC.SetQSE(true);
                    FWC.SetTR(true);
                    FWC.SetSig(true);
                    FWC.SetGen(false);
                    FWC.SetTest(true);
                    FWC.SetTXMon(false);
                    FWC.SetPDrvMon(true);
                    break;
                case Model.FLEX1500:
                    if (hid_init)
                    {
                        preamp = RX1PreampMode;								    // save current preamp mode
                        RX1PreampMode = (PreampMode)FLEX1500PreampMode.ZERO; // set to Off

                        RXAnt1500 = HIDAnt.XVTX_COM;

                        Thread.Sleep(20);

                        /*if (freq < 15.0)
                            IFFreq = 0.002;
                        else IFFreq = 0.005;*/
                        IFFreq = 0.0006;

                        // use sig gen to cal RX WBIR
                        if (production && Flex1500.ProdTestPresent())
                        {
                            Flex1500.ProdTestWriteOp(USBHID.Opcode.USB_OP_SET_RX1_FREQ_TW, (uint)Freq2TW((freq + if_freq) / 2), 0);
                            Thread.Sleep(20);


                            DttSP.SetCorrectIQMu(0, 0, 0.05);
                            Thread.Sleep(1000);

                            for (int i = 0; i < 30; i++)
                            {
                                if (i >= 5 && i < 15)
                                    DttSP.SetCorrectIQMu(0, 0, 0.05 - (i - 5) * 0.005);
                                Thread.Sleep(100);
                            }

                            Thread.Sleep(1000);
                        }
                        else
                        {
                            Thread.Sleep(1000);
                            float[] buf = new float[Display.BUFFER_SIZE];
                            for (int i = 0; i < 5; i++)
                            {
                                calibration_mutex.WaitOne();
                                fixed (float* ptr = &buf[0])
                                    DttSP.GetSpectrum(0, ptr);// get the spectrum values
                                calibration_mutex.ReleaseMutex();
                                Thread.Sleep(50);
                            }

                            float peak_val = float.MinValue;
                            int peak_index = 0;

                            for (int i = 0; i < Display.BUFFER_SIZE; i++)
                            {
                                if (buf[i] > peak_val)
                                {
                                    peak_val = buf[i];
                                    peak_index = i;
                                }
                            }

                            if (peak_val < 10.0) // low SNR
                            {
                                progress.Visible = false;
                                progress.Text = "";
                                MessageBox.Show(new Form { TopMost = true }, "Unable to find strong enough signal for calibration.\n" +
                                    "Please check the RTG connections and try again.");
                                goto end;
                            }

                            int ideal_bin = (int)((cw_pitch - if_freq * 1e6 + sample_rate1 / 2) / sample_rate1 * Display.BUFFER_SIZE);
                            double freq_adjust = ((peak_index - ideal_bin) * (double)sample_rate1 / (double)Display.BUFFER_SIZE) * 1e-6; // in MHz

                            VFOAFreq += freq_adjust;
                            Thread.Sleep(500);

                            DttSP.SetCorrectIQMu(0, 0, 0.05);
                            Thread.Sleep(1000);

                            for (int i = 0; i < 30; i++)
                            {
                                if (i >= 5 && i < 15)
                                    DttSP.SetCorrectIQMu(0, 0, 0.05 - (i - 5) * 0.005);
                                Thread.Sleep(100);
                            }

                            Thread.Sleep(1000);
                            USBHID.SetTXOut(true);
                        }

                        // lock RX WBIR where it is
                        calibrating = true;
                        DttSP.SetCorrectIQMu(0, 0, 0.0);
                        DttSP.SetCorrectIQMu(0, 1, 0.0);



                        RX1DSPMode = DSPMode.CWU;					// set dsp mode to CWU
                        CWKeyer.SensorEnqueue(new CWSensorItem(CWSensorItem.InputType.Dot, true));
                        //Keyer.HIDDot = true;  

                        RXAnt1500 = HIDAnt.BITE;
                        Thread.Sleep(100);

                        USBHID.SetGen(true);
                        Thread.Sleep(100);

                        USBHID.SetQSE(true);
                        Thread.Sleep(100);

                        USBHID.SetTest(true);
                        Thread.Sleep(100);

                        RX1PreampMode = (PreampMode)FLEX1500PreampMode.PLUS_20; // set to Off

                        CWPitch = 600;

                        //RX1Filter = Filter.F6;					
                        UpdateRX1Filters(-(int)(if_freq * 1e6) - cw_pitch - 200, -(int)(if_freq * 1e6) + cw_pitch + 1000);
                        chkDisplayAVG.Checked = false;

                        Audio.TX1500ImageCal = true;
                        Audio.SourceScale = 0.01;
                        //Audio.RX1OutputSignal = Audio.SignalSource.SINE;
                        //Audio.TXInputSignal = Audio.SignalSource.RADIO;                                                                                           

                        Thread.Sleep(1000);
                    }
                    break;
            }

            DisableAllFilters();
            DisableAllModes();
            VFOLock = true;
            comboPreamp.Enabled = false;
            comboDisplayMode.Enabled = false;

            setupForm.ImageGainTX = -200.0f;
            setupForm.ImagePhaseTX = -200.0f;

            float[] a = new float[Display.BUFFER_SIZE];
            for (int i = 0; i < 5; i++)
            {
                calibration_mutex.WaitOne();
                fixed (float* ptr = &a[0])
                    DttSP.GetSpectrum(0, ptr);// get the spectrum values
                calibration_mutex.ReleaseMutex();
                Thread.Sleep(50);
            }

            float max_signal = float.MinValue;
            int peak_bin;
            float sum = 0.0f;
            float noise_floor = float.MaxValue;

            if (current_model != Model.FLEX1500)
            {
                peak_bin = 2048 + (int)(1500.0 / sample_rate1 * 4096.0);
                Thread.Sleep(100);

                for (int i = 0; i < 20; i++)
                {
                    calibration_mutex.WaitOne();
                    fixed (float* ptr = &a[0])
                        DttSP.GetSpectrum(0, ptr);// get the spectrum values
                    calibration_mutex.ReleaseMutex();
                    for (int j = 0; i == 19 && j < Display.BUFFER_SIZE; j++)
                    {
                        if (a[j] > max_signal)
                        {
                            max_signal = a[j];
                            peak_bin = j;
                        }
                    }
                    Thread.Sleep(100);
                }
                fundamental = max_signal;
                UpdateRX1Filters(-3000, -300);
                Thread.Sleep(100);

                peak_bin = 2048 + (int)(-1500.0 / sample_rate1 * 4096.0);
                max_signal = float.MinValue;

                int filt_low_bin = 2048 + (int)(-3000.0 / sample_rate1 * 4096.0);
                int filt_high_bin = 2048 + (int)(-300.0 / sample_rate1 * 4096.0);

                for (int i = 0; i < 20; i++)
                {
                    calibration_mutex.WaitOne();
                    fixed (float* ptr = &a[0])
                        DttSP.GetSpectrum(0, ptr);// get the spectrum values
                    calibration_mutex.ReleaseMutex();
                    for (int j = 0; i == 19 && j < Display.BUFFER_SIZE; j++)
                    {
                        if (a[j] > max_signal)
                        {
                            max_signal = a[j];
                            peak_bin = j;
                        }
                    }
                    for (int j = filt_low_bin; j < filt_high_bin; j++)
                    {
                        if (j < peak_bin - 8 || j > peak_bin + 8)
                            sum += a[j];
                    }
                    Thread.Sleep(100);
                }

                noise_floor = (sum / (float)(((filt_high_bin - filt_low_bin) - 17) * 20));
            }
            else // FLEX-1500
            {
                peak_bin = 2048 + (int)((-if_freq * 1e6 + cw_pitch) / sample_rate1 * 4096.0);
                Thread.Sleep(100);

                int filt_low_bin = 2048 + (int)((-(if_freq * 1e6) + cw_pitch + 800) / sample_rate1 * 4096.0);
                int filt_high_bin = 2048 + (int)((-(if_freq * 1e6) + cw_pitch + 1000) / sample_rate1 * 4096.0);

                for (int i = 0; i < 20; i++) // calculate noise floor
                {
                    calibration_mutex.WaitOne();
                    fixed (float* ptr = &a[0])
                        DttSP.GetSpectrum(0, ptr);// get the spectrum values
                    calibration_mutex.ReleaseMutex();

                    for (int j = filt_low_bin; j < filt_high_bin; j++)
                        sum += a[j];

                    Thread.Sleep(100);
                }

                noise_floor = sum / (float)(20 * (filt_high_bin - filt_low_bin));
                Debug.WriteLine("noise floor: " + noise_floor.ToString("f1"));

                //UpdateRX1Filters((int)(-if_freq * 1e6 + cw_pitch - 200), (int)(-if_freq * 1e6 + cw_pitch + 200));
                filt_low_bin = 2048 + (int)((-(if_freq * 1e6) + cw_pitch - 200) / sample_rate1 * 4096.0);
                filt_high_bin = 2048 + (int)((-(if_freq * 1e6) + cw_pitch + 200) / sample_rate1 * 4096.0);

                max_signal = float.MinValue;
                for (int j = filt_low_bin; j < filt_high_bin; j++) // find peak value (fundamental)
                {
                    if (a[j] > max_signal)
                    {
                        max_signal = a[j];
                        peak_bin = j;
                    }
                }

                fundamental = max_signal;
                Debug.WriteLine("fundamental: " + fundamental.ToString("f1") + "  peak_bin: " + peak_bin);

                filt_low_bin = 2048 + (int)((-(if_freq * 1e6) - cw_pitch - 200) / sample_rate1 * 4096.0);
                filt_high_bin = 2048 + (int)((-(if_freq * 1e6) - cw_pitch + 200) / sample_rate1 * 4096.0);

                max_signal = float.MinValue;

                for (int j = filt_low_bin; j < filt_high_bin; j++)
                {
                    if (a[j] > max_signal)
                    {
                        max_signal = a[j];
                        peak_bin = j;
                    }
                }

                float image = max_signal;
                float rejection = fundamental - image;
                Debug.WriteLine("image: " + image.ToString("f1") + "  peak_bin: " + peak_bin + "  rejection: " + rejection.ToString("f1"));
            }

            Debug.WriteLine("noise_floor: " + noise_floor.ToString("f6" ) + " peak_bin:" + peak_bin);
            //MessageBox.Show(new Form { TopMost = true }, "Noise Floor: "+(noise_floor + Display.DisplayCalOffset + Display.PreampOffset).ToString("f1"));

            if (max_signal < noise_floor + 10.0)
            {
                if (!suppress_errors)
                {
                    MessageBox.Show(new Form { TopMost = true }, "Image not found (max signal < noise floor + 10dB).  Please try again.\n" +
                        DateTime.Now.ToShortTimeString(),
                        "Image Not Found",
                        MessageBoxButtons.OK, MessageBoxIcon.Stop);
                }
                calibration_running = false;
                //progress.Text = "";
                goto end;
            }

            setupForm.ImagePhaseTX = 0.0f;
            setupForm.ImageGainTX = 0.0f;

            double TIMEOUT = 90.0;
            if (current_model == Model.FLEX1500)
                TIMEOUT = 40.0;

            while (progressing)
            {
                // find minimum of the peak signal over 
                // the range of Gain settings

                float start = 0.0f;
                float min_signal = float.MaxValue;
                max_signal = float.MinValue;
                wrong_direction_count = switch_direction_count = 0;
                bool first_time = true;

                Debug.WriteLine("gain_dir:" + gain_dir + " gain_step: " + gain_step.ToString("f3"));
                t2.Start();
                index_string = "";
                val_string = "";
                gain_string += (gain_count + "," + gain_dir + "," + gain_step.ToString("f6" ) + "\n");
                for (float i = global_min_gain; i >= -500.0 && i <= 500.0; i += (gain_step * gain_dir))
                {
                    setupForm.ImageGainTX = i;				//set gain slider
                    Thread.Sleep(200);

                    int num_avg = gain_count;
                    //if(gain_step <= 0.01) num_avg = 4;
                    sum = 0.0f;
                    for (int j = 0; j < num_avg; j++)
                    {
                        calibration_mutex.WaitOne();
                        fixed (float* ptr = &a[0])
                            DttSP.GetSpectrum(0, ptr);// get the spectrum values
                        sum += a[peak_bin];
                        calibration_mutex.ReleaseMutex();
                        if (j < num_avg - 1) Thread.Sleep(50);
                    }
                    sum /= num_avg;
                    a[peak_bin] = sum;

                    index_string += i.ToString("f4") + ",";
                    val_string += a[peak_bin].ToString("f4") + ",";

                    if (a[peak_bin] < min_signal)			// if image is less than minimum
                    {
                        min_signal = a[peak_bin];
                        gain_index = i;
                        if (min_signal < global_min_value)
                        {
                            global_min_value = min_signal;
                            global_min_gain = gain_index;
                        }
                    }

                    // cal complete condition
                    float tol2 = 12.0f;
                    if (current_model == Model.FLEX1500)
                        tol2 = 9.0f;
                    if (min_signal < noise_floor + tol2)
                    {
                        progressing = false;
                        break;
                    }

                    if (first_time)
                    {
                        first_time = false;
                        start = a[peak_bin];
                        max_signal = a[peak_bin];
                    }
                    else
                    {
                        if (a[peak_bin] > max_signal && a[peak_bin] > start + 1.0)
                        {
                            max_signal = a[peak_bin];
                            wrong_direction_count++; Debug.Write("W");
                            if (wrong_direction_count > 1)
                            {
                                wrong_direction_count = 0;
                                if (++switch_direction_count > 1)
                                {
                                    // handle switched direction twice
                                    if (gain_step >= 0.1) gain_step /= 2.0f;
                                    else gain_step /= 2.0f;
                                    gain_dir *= -1;
                                    Debug.WriteLine("gain exit dir - gain_step:" + gain_step.ToString("f4") + "  distance:" + (global_min_value - noise_floor).ToString("f1"));
                                    break;
                                }

                                min_signal = start;
                                max_signal = start;
                                gain_dir *= -1;
                                i = global_min_gain;
                            }
                        }
                        else
                        {
                            if (min_signal > noise_floor + 20.0) tol = 3.0f;
                            else tol = 3.0f;
                            if (a[peak_bin] > min_signal + tol)
                            {
                                if (gain_step > 0.1) gain_step /= 2.0f;
                                else gain_step /= 2.0f;
                                gain_dir *= -1;
                                Debug.WriteLine("exit gain thresh - gain_step:" + gain_step.ToString("f4") + "  distance:" + (global_min_value - noise_floor).ToString("f1"));
                                break;
                            }
                        }
                    }

                    if (!progress.Visible) goto end;
                    else
                    {
                        t1.Stop();
                        if (t1.Duration > TIMEOUT)
                        {
                            /*MessageBox.Show(new Form { TopMost = true }, "TX Image Reject Calibration Failed.  Values have been returned to previous settings.\n"+
                                DateTime.Now.ToShortTimeString(),
                                "TX Image Failed",
                                MessageBoxButtons.OK,
                                MessageBoxIcon.Error);*/
                            goto end;
                        }
                        else progress.SetPercent((float)(t1.Duration / TIMEOUT));
                    }
                }

                t2.Stop();
                Debug.WriteLine("t2 gain(" + gain_count++ + "): " + t2.Duration);
                if (gain_count < 10)
                {
                    gain_string += (index_string + "\n");
                    gain_string += (val_string + "\n\n");
                }

                setupForm.ImageGainTX = global_min_gain;			//set gain slider to min found
                Debug.WriteLine("Global_Min_Gain: " + global_min_gain.ToString("f2"));

                if (!progressing) break;

                // find minimum of the peak signal over 
                // the range of Phase settings
                min_signal = float.MaxValue;
                max_signal = float.MinValue;
                wrong_direction_count = switch_direction_count = 0;
                first_time = true;

                t2.Start();
                index_string = "";
                val_string = "";
                phase_string += (phase_count + "," + phase_dir + "," + phase_step.ToString("f3") + "\n");
                for (float i = global_min_phase; i >= -400.0 && i <= 400.0; i += (phase_step * phase_dir))
                {
                    setupForm.ImagePhaseTX = i;				// phase slider
                    Thread.Sleep(200);

                    sum = 0.0f;
                    int num_avg = phase_count;
                    //if(phase_step <= 0.01) num_avg = 4;
                    for (int j = 0; j < num_avg; j++)
                    {
                        calibration_mutex.WaitOne();
                        fixed (float* ptr = &a[0])
                            DttSP.GetSpectrum(0, ptr);// get the spectrum values
                        sum += a[peak_bin];
                        calibration_mutex.ReleaseMutex();
                        if (j < num_avg - 1) Thread.Sleep(50);
                    }
                    sum /= num_avg;
                    a[peak_bin] = sum;

                    index_string += i.ToString("f4") + ",";
                    val_string += a[peak_bin].ToString("f4") + ",";

                    if (a[peak_bin] < min_signal)			// if image is less than minimum
                    {
                        min_signal = a[peak_bin];
                        phase_index = i;
                        if (min_signal < global_min_value)
                        {
                            global_min_value = min_signal;
                            global_min_phase = phase_index;
                        }
                    }

                    // cal complete condition
                    float tol2 = 12.0f;
                    if (current_model == Model.FLEX1500)
                        tol2 = 9.0f;
                    if (min_signal < noise_floor + tol2)
                    {
                        progressing = false;
                        break;
                    }

                    if (first_time)
                    {
                        first_time = false;
                        start = a[peak_bin];
                        max_signal = a[peak_bin];
                    }
                    else
                    {
                        if (a[peak_bin] > max_signal && a[peak_bin] > start + 1.0)
                        {
                            max_signal = a[peak_bin];
                            wrong_direction_count++; Debug.Write("W");
                            if (wrong_direction_count > 1)
                            {
                                wrong_direction_count = 0;
                                if (++switch_direction_count > 1)
                                {
                                    // handle switched direction twice
                                    if (phase_step >= 0.1) phase_step /= 2.0f;
                                    else phase_step /= 2.0f;
                                    phase_dir *= -1;
                                    Debug.WriteLine("phase exit dir - phase_step:" + phase_step.ToString("f4") + "  distance:" + (global_min_value - noise_floor).ToString("f1"));
                                    break;
                                }

                                min_signal = start;
                                max_signal = start;
                                phase_dir *= -1;
                                i = global_min_phase;
                            }
                        }
                        else
                        {
                            if (min_signal > noise_floor + 20.0) tol = 3.0f;
                            else tol = 3.0f;
                            if (a[peak_bin] > min_signal + tol)
                            {
                                if (phase_step >= 0.1) phase_step /= 2.0f;
                                else phase_step /= 2.0f;
                                phase_dir *= -1;
                                Debug.WriteLine("phase exit thresh - phase_step:" + phase_step.ToString("f4") + "  distance:" + (global_min_value - noise_floor).ToString("f1"));
                                break;
                            }
                        }
                    }

                    if (!progress.Visible) goto end;
                    else
                    {
                        t1.Stop();
                        if (t1.Duration > TIMEOUT)
                        {
                            /*MessageBox.Show(new Form { TopMost = true }, "TX Image Reject Calibration Failed.  Values have been returned to previous settings.\n"+
                                DateTime.Now.ToShortTimeString(),
                                "TX Image Failed",
                                MessageBoxButtons.OK,
                                MessageBoxIcon.Error);*/
                            goto end;
                        }
                        else progress.SetPercent((float)(t1.Duration / TIMEOUT));
                    }
                }

                t2.Stop();
                Debug.WriteLine("t2 phase(" + phase_count++ + "): " + t2.Duration);

                setupForm.ImagePhaseTX = global_min_phase;			//set phase slider to min found
                Debug.WriteLine("Global_Min_Phase: " + global_min_phase.ToString("f2"));
                if (!progressing) break;
            }

            // Finish the algorithm and reset the values
            ret_val = true;
        end:
            if (!progress.Visible) progress.Text = "";
            else
            {
                setupForm.ImageGainTX = global_min_gain;
                setupForm.ImagePhaseTX = global_min_phase;

                tx_image_gain_table[(int)tx_band] = setupForm.ImageGainTX;
                tx_image_phase_table[(int)tx_band] = setupForm.ImagePhaseTX;
            }
            progress.Hide();

            tx_image_rejection[(int)tx_band] = global_min_value - fundamental;

            Audio.TXInputSignal = Audio.SignalSource.RADIO;
            Audio.SourceScale = last_scale;						// recall tone scale
            Audio.SineFreq1 = tone_freq;						// recall tone freq
            ptbPWR.Value = pwr;
            CWIambic = iambic;
            disable_ptt = ptt;

            switch (current_model)
            {
                case Model.FLEX5000:
                case Model.FLEX3000:
                    FullDuplex = duplex;
                    FWC.SetQSD(true);
                    FWC.SetQSE(false);
                    FWC.SetTR(false);
                    FWC.SetSig(false);
                    FWC.SetGen(false);
                    FWC.SetTest(false);
                    FWC.SetTXMon(false);
                    FWC.SetPDrvMon(false);
                    break;
                case Model.FLEX1500:
                    FullDuplex = duplex;
                    CWKeyer.SensorEnqueue(new CWSensorItem(CWSensorItem.InputType.Dot, false));
                    Audio.TX1500ImageCal = false;

                    IFFreq = _if_freq;
                    CWPitch = _cw_pitch;
                    RXAnt1500 = _rx_ant_1500;

                    USBHID.SetTest(false); Thread.Sleep(10);
                    USBHID.SetQSE(false); Thread.Sleep(10);
                    USBHID.SetGen(false); Thread.Sleep(10);

                    RXAnt1500 = hid_ant; Thread.Sleep(10);


                    RX1DSPMode = DSPMode.USB;
                    MOX = true; Thread.Sleep(100);
                    MOX = false; Thread.Sleep(100);

                    Audio.RX1OutputSignal = Audio.SignalSource.RADIO;

                    DttSP.SetCorrectIQEnable(1); // turn on I/Q correction

                    WBIRRX1Holdoff();

                    ptbAF_Scroll(this, EventArgs.Empty);

                    USBHID.SetTXOut(false);
                    break;
            }

            if (current_model == Model.FLEX3000)
                FWC.SetFan(false);

            EnableAllFilters();
            EnableAllModes();
            VFOLock = false;
            comboPreamp.Enabled = true;
            comboDisplayMode.Enabled = true;

            chkXIT.Checked = xit;
            chkRIT.Checked = rit;
            setupForm.TXFilterHigh = tx_filt_high;				// restore TX filter settings
            setupForm.TXFilterLow = tx_filt_low;
            chkSR.Checked = spur_red;							// restore spur reduction setting
            RX1PreampMode = preamp;							    // restore preamp mode
            comboDisplayMode.Text = display_mode;				// restore display mode
            //SetupForm.RXOnly = rx_only;						// restore RX Only setting
            RX1DSPMode = dsp_mode;							    // restore dsp mode
            UpdateRX1Filters(filter_low, filter_high);
            RX1Filter = filter;								    // restore filter
            VFOAFreq = vfo_freq;								// restore frequency
            txtVFOAFreq_LostFocus(this, EventArgs.Empty);
            chkDisplayAVG.Checked = avg;						// restore average state
            setupForm.DSPPhoneRXBuffer = dsp_buf_size;			// restore DSP Buffer Size
            setupForm.Polyphase = polyphase;					// restore polyphase

            chkMUT.Checked = mute;
            ptbAF.Value = af;
            TXAF = tx_af;

            t1.Stop();
            //MessageBox.Show(t1.Duration.ToString());
            Debug.WriteLine("timer: " + t1.Duration);

            calibration_running = false;
            calibrating = false;

            return ret_val;
        }



        public bool CalibratePAGain(Progress progress, bool[] run, int target_watts) // calibrate PA Gain values
        {
            //			HiPerfTimer t1 = new HiPerfTimer();
            //			t1.Start();

            bool ret_val = false;

            if (!chkPower.Checked)
            {
                MessageBox.Show(new Form { TopMost = true }, "Power must be on in order to calibrate PA Gain.", "Power Is Off",
                    MessageBoxButtons.OK, MessageBoxIcon.Stop);
                return false;
            }

            calibrating = true;

            DSPMode dsp_mode = rx1_dsp_mode;            // save current dsp mode
            RX1DSPMode = DSPMode.USB;                   // set dsp mode to CWL

            double vfo_freq = VFOAFreq;                     // save current frequency

            int pwr = ptbPWR.Value;                     // save current pwr level

            bool tx_eq = chkTXEQ.Checked;
            chkTXEQ.Checked = false;

            bool dx = chkDX.Checked;
            chkDX.Checked = false;

            bool cpdr = chkCPDR.Checked;
            chkCPDR.Checked = false;

            DisableAllFilters();
            DisableAllModes();
            VFOLock = true;
            comboPreamp.Enabled = false;
            comboDisplayMode.Enabled = false;

            int on_time = 2500;
            int off_time = 2500;

            switch (current_soundcard)
            {
                case SoundCard.AUDIGY_2_ZS:
                    on_time = 3000;
                    off_time = 4000;
                    break;
                case SoundCard.DELTA_44:
                    on_time = 2000;
                    off_time = 2000;
                    break;
            }

            progress.SetPercent(0.0f);

            float[] band_freqs = { 1.85f, 3.75f, 5.357f, 7.15f, 10.125f, 14.175f, 18.1f, 21.300f, 24.9f, 28.4f };

            int[] max_pwr = { 100, 100, 100, 100, 100, 100, 100, 100, 75, 75 };

            if (run[0]) setupForm.PAGain160 = 49.0f;
            if (run[1]) setupForm.PAGain80 = 49.0f;
            if (run[2]) setupForm.PAGain60 = 49.0f;
            if (run[3]) setupForm.PAGain40 = 49.0f;
            if (run[4]) setupForm.PAGain30 = 49.0f;
            if (run[5]) setupForm.PAGain20 = 49.0f;
            if (run[6]) setupForm.PAGain17 = 49.0f;
            if (run[7]) setupForm.PAGain15 = 49.0f;
            if (run[8]) setupForm.PAGain12 = 49.0f;
            if (run[9]) setupForm.PAGain10 = 49.0f;

            for (int i = 0; i < band_freqs.Length; i++)
            {
                if (run[i])
                {
                    int error_count = 0;
                    VFOLock = false;
                    VFOAFreq = band_freqs[i];               // set frequency
                    VFOLock = true;
                    ptbPWR.Value = Math.Min(target_watts, max_pwr[i]);
                    int target = ptbPWR.Value;

                    bool good_result = false;
                    while (good_result == false)
                    {
                        /*Audio.SwitchCount = 4;
						Audio.RampDown = true;
						Audio.NextMox = true;*/
                        Audio.SourceScale = 1.0;
                        Audio.TXInputSignal = Audio.SignalSource.SINE;
                        //Audio.TXOutputSignal = Audio.SignalSource.SINE;
                        tuning = true;
                        chkMOX.Checked = true;

                        for (int j = 0; j < on_time / 100; j++)
                        {
                            Thread.Sleep(100);
                            if (!progress.Visible)
                                goto end;
                        }

                        double watts = 0;
                        //pa_power_mutex.WaitOne();
                        watts = PAPower(pa_fwd_power);
                        //pa_power_mutex.ReleaseMutex();

                        chkMOX.Checked = false;
                        tuning = false;
                        /*Audio.RampDown = true;
						Audio.NextMox = false;
						Audio.SwitchCount = 4;*/
                        Audio.TXInputSignal = Audio.SignalSource.RADIO;
                        //Audio.TXOutputSignal = Audio.SignalSource.RADIO;

                        //Debug.WriteLine("watts: "+watts.ToString());

                        if (!progress.Visible)
                            goto end;

                        if (Math.Abs(watts - target) > 4)
                        {
                            // convert to dBm
                            float diff_dBm = (float)Math.Round((WattsTodBm(watts) - WattsTodBm((double)target)), 1);

                            switch (i)                                      // fix gain value
                            {
                                case 0:
                                    if (setupForm.PAGain160 + diff_dBm < 38.0)
                                    {
                                        if (++error_count > 6)
                                            goto error;

                                        setupForm.PAGain160 = (float)Math.Max(38.0, setupForm.PAGain160 - 2.0);
                                    }
                                    else setupForm.PAGain160 += diff_dBm;
                                    break;
                                case 1:
                                    if (setupForm.PAGain80 + diff_dBm < 38.0)
                                    {
                                        if (++error_count > 6)
                                            goto error;

                                        setupForm.PAGain80 = (float)Math.Max(38.0, setupForm.PAGain80 - 2.0);
                                    }
                                    else setupForm.PAGain80 += diff_dBm;
                                    break;
                                case 2:
                                    if (setupForm.PAGain60 + diff_dBm < 38.0)
                                    {
                                        if (++error_count > 6)
                                            goto error;

                                        setupForm.PAGain60 = (float)Math.Max(38.0, setupForm.PAGain60 - 2.0);
                                    }
                                    else setupForm.PAGain60 += diff_dBm;
                                    break;
                                case 3:
                                    if (setupForm.PAGain40 + diff_dBm < 38.0)
                                    {
                                        if (++error_count > 6)
                                            goto error;

                                        setupForm.PAGain40 = (float)Math.Max(38.0, setupForm.PAGain40 - 2.0);
                                    }
                                    else setupForm.PAGain40 += diff_dBm;
                                    break;
                                case 4:
                                    if (setupForm.PAGain30 + diff_dBm < 38.0)
                                    {
                                        if (++error_count > 6)
                                            goto error;

                                        setupForm.PAGain30 = (float)Math.Max(38.0, setupForm.PAGain30 - 2.0);
                                    }
                                    else setupForm.PAGain30 += diff_dBm;
                                    break;
                                case 5:
                                    if (setupForm.PAGain20 + diff_dBm < 38.0)
                                    {
                                        if (++error_count > 6)
                                            goto error;

                                        setupForm.PAGain20 = (float)Math.Max(38.0, setupForm.PAGain20 - 2.0);
                                    }
                                    else setupForm.PAGain20 += diff_dBm;
                                    break;
                                case 6:
                                    if (setupForm.PAGain17 + diff_dBm < 38.0)
                                    {
                                        if (++error_count > 6)
                                            goto error;

                                        setupForm.PAGain17 = (float)Math.Max(38.0, setupForm.PAGain17 - 2.0);
                                    }
                                    else setupForm.PAGain17 += diff_dBm;
                                    break;
                                case 7:
                                    if (setupForm.PAGain15 + diff_dBm < 38.0)
                                    {
                                        if (++error_count > 6)
                                            goto error;

                                        setupForm.PAGain15 = (float)Math.Max(38.0, setupForm.PAGain15 - 2.0);
                                    }
                                    else setupForm.PAGain15 += diff_dBm;
                                    break;
                                case 8:
                                    if (setupForm.PAGain12 + diff_dBm < 38.0)
                                    {
                                        if (++error_count > 6)
                                            goto error;

                                        setupForm.PAGain12 = (float)Math.Max(38.0, setupForm.PAGain12 - 2.0);
                                    }
                                    else setupForm.PAGain12 += diff_dBm;
                                    break;
                                case 9:
                                    if (setupForm.PAGain10 + diff_dBm < 38.0)
                                    {
                                        if (++error_count > 6)
                                            goto error;

                                        setupForm.PAGain10 = (float)Math.Max(38.0, setupForm.PAGain10 - 2.0);
                                    }
                                    else setupForm.PAGain10 += diff_dBm;
                                    break;
                            }
                        }
                        else good_result = true;
                        for (int j = 0; j < off_time / 100; j++)
                        {
                            Thread.Sleep(100);
                            if (!progress.Visible)
                                goto end;
                        }
                    }
                }
                progress.SetPercent((float)((float)(i + 1) / 10));
            }

            ret_val = true;

        end:
            if (!progress.Visible) progress.Text = "";
            progress.Hide();

            EnableAllFilters();
            EnableAllModes();
            VFOLock = false;
            comboPreamp.Enabled = true;
            comboDisplayMode.Enabled = true;

            chkTXEQ.Checked = tx_eq;
            chkDX.Checked = dx;
            chkCPDR.Checked = cpdr;

            chkMOX.Checked = false;
            tuning = false;
            //Audio.SwitchCount = 4;
            Audio.TXInputSignal = Audio.SignalSource.RADIO;
            Audio.TXOutputSignal = Audio.SignalSource.RADIO;

            RX1DSPMode = dsp_mode;                          // restore dsp mode
            VFOAFreq = vfo_freq;                                // restore frequency
            txtVFOAFreq_LostFocus(this, EventArgs.Empty);
            PWR = pwr;                                  // restore pwr level


            calibrating = false;

            //t1.Stop();
            //MessageBox.Show(t1.Duration.ToString());
            return ret_val;

        error:
            MessageBox.Show(new Form { TopMost = true }, "Calculated gain is invalid.  Please double check connections and try again.\n" +
                "If this problem persists, contact support@flexradio.com for support.",
                "Invalid Gain Found",
                MessageBoxButtons.OK,
                MessageBoxIcon.Error);
            goto end;
        }

        public bool CalibratePAGain2(Progress progress, bool[] run, bool suppress_warnings)
        {
            bool ret_val = false;

            if (!chkPower.Checked)
            {
                MessageBox.Show(new Form { TopMost = true }, "Power must be on in order to calibrate PA Gain 2.", "Power Is Off",
                    MessageBoxButtons.OK, MessageBoxIcon.Stop);
                return false;
            }

            progress.SetPercent(0.0f);
            int progress_count = 0;
            int progress_total = 0;
            for (int i = 0; i < 11; i++)
                if (run[i]) progress_total += 13;

            float[] band_freqs = { 1.85f, 3.75f, 5.357f, 7.15f, 10.125f, 14.175f, 18.1f, 21.300f, 24.9f, 28.4f, 50.11f };
            int[] target_table = { 1, 2, 5, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100 };
            double tol = 2.0;
            bool fduplex = FullDuplex;
            if (fwc_init && (current_model == Model.FLEX5000 || current_model == Model.FLEX3000))
            {
                tol = 0.5;
                FullDuplex = false;
            }

            calibrating = true;

            DSPMode mode = rx1_dsp_mode; // save current dsp mode
            RX1DSPMode = DSPMode.USB;

            double vfoa = VFOAFreq;         // save VFO A frequency
            chkVFOSplit.Checked = false;
            comboMeterTXMode.Text = "Fwd Pwr";

            bool tx_eq = chkTXEQ.Checked;
            chkTXEQ.Checked = false;

            bool dx = chkDX.Checked;
            chkDX.Checked = false;

            bool cpdr = chkCPDR.Checked;
            chkCPDR.Checked = false;

            DisableAllFilters();
            DisableAllModes();
            VFOLock = true;
            comboPreamp.Enabled = false;
            comboDisplayMode.Enabled = false;

            int on_time = 2500;
            int off_time = 2500;

            switch (current_soundcard)
            {
                case SoundCard.AUDIGY_2_ZS:
                    on_time = 3000;
                    off_time = 4000;
                    break;
                case SoundCard.DELTA_44:
                    on_time = 2000;
                    off_time = 2000;
                    break;
            }

            switch (current_model)
            {
                case Model.FLEX5000:
                case Model.FLEX3000:
                    on_time = 1000;
                    off_time = 1000;
                    break;
            }

            for (int i = 0; i < band_freqs.Length; i++)
            {
                if (i == 10 && current_model == Model.SDR1000)
                {
                    // do nothing
                }
                else if (run[i])
                {
                    VFOLock = false;
                    VFOAFreq = band_freqs[i];
                    if (fwc_init)
                    {
                        switch (current_model)
                        {
                            case Model.FLEX5000:
                                FWC.SetTXAnt(1);
                                break;
                            case Model.FLEX3000:
                                FWC.SetAmpTX1(false);
                                FWC.SetRCATX1(false);
                                break;
                        }
                    }

                    VFOLock = true;
                    Audio.SourceScale = 0.04 / audio_volts1;
                    double last_watts = 0.0;
                    double last_volts = 0.0;
                    if (fwc_init && (current_model == Model.FLEX5000 || current_model == Model.FLEX3000)) tol = 0.5;

                    for (int j = 0; j < power_table[i].Length; j++)
                    {
                        if (fwc_init && (current_model == Model.FLEX5000 || current_model == Model.FLEX3000) && j == 8) tol = 1.0;
                        if (j < 3 && current_model == Model.SDR1000)
                        {
                            // do nothing
                        }
                        else
                        {
                            bool found_power = false;
                            double target = target_table[j];
                            int count = 0;
                            while (!found_power && chkPower.Checked)
                            {
                                //								if(Audio.TXInputSignal != Audio.SignalSource.SINE)
                                //									Audio.TXInputSignal = Audio.SignalSource.SINE;
                                if (Audio.TXOutputSignal != Audio.SignalSource.SINE)
                                    Audio.TXOutputSignal = Audio.SignalSource.SINE;
                                //Audio.SourceScale = 1.0;
                                if (!chkMOX.Checked) chkMOX.Checked = true;
                                for (int k = 0; k < on_time / 100; k++)
                                {
                                    Thread.Sleep(100);
                                    if (!progress.Visible)
                                        goto end;
                                }

                                double watts = 0;
                                if (fwc_init && (current_model == Model.FLEX5000 || current_model == Model.FLEX3000))
                                    watts = FWCPAPower(pa_fwd_power);
                                else watts = PAPower(pa_fwd_power);

                                if (HighSWR)
                                {
                                    chkMOX.Checked = false;
                                    MessageBox.Show(new Form { TopMost = true }, "PA Calibration Error: High SWR.  Please check\n" +
                                        "connections and try again.",
                                        "PA Power: High SWR",
                                        MessageBoxButtons.OK,
                                        MessageBoxIcon.Error);
                                    goto end;
                                }

                                Debug.WriteLine("watts: " + watts.ToString("f3"));
                                if (target > 50)
                                {
                                    Audio.TXInputSignal = Audio.SignalSource.RADIO;
                                    Audio.TXOutputSignal = Audio.SignalSource.RADIO;
                                    //Audio.SourceScale = 1.0;
                                    chkMOX.Checked = false;
                                    for (int k = 0; k < off_time / 100; k++)
                                    {
                                        Thread.Sleep(100);
                                        if (!progress.Visible)
                                            goto end;
                                    }
                                }
                                else Thread.Sleep(100);

                                double diff = target - watts;
                                if (Math.Abs(diff) < tol)
                                {
                                    found_power = true;
                                    power_table[i + 1][j] = (float)Math.Round(Audio.SourceScale * audio_volts1, 4);

                                    if (j + 1 == power_table[i].Length) break;
                                    // calculate line  in y = ax + b format
                                    double x2 = Math.Pow(power_table[i + 1][j], 2.0);
                                    double x1 = 0.0;
                                    if (j > 0) x1 = Math.Pow(power_table[i + 1][j - 1], 2.0);

                                    double y1 = target;
                                    double y2 = target_table[j + 1];

                                    double a = (y2 - y1) / (x2 - x1); // a = (y2-y1)/(x2-x1)
                                    double b = target - a * x2;

                                    double next_volts = Math.Sqrt((target_table[j + 1] - b) / a);  // solved y = ax + b to get x = (y - b)/a
                                                                                                   //double next_volts = current_volts * Math.Sqrt((target+10)/target);
                                    Audio.SourceScale = next_volts / audio_volts1;
                                }
                                else
                                {
                                    if (fwc_init && (current_model == Model.FLEX5000 || current_model == Model.FLEX3000) && target <= 10)
                                    {
                                        // calculate line  in y = ax + b format
                                        double x1 = Math.Pow(last_volts, 2.0);
                                        double x2 = Math.Pow(Audio.SourceScale, 2.0);
                                        double y1 = last_watts;
                                        double y2 = watts;

                                        double a = (y2 - y1) / (x2 - x1);
                                        double b = y2 - a * x2;

                                        Debug.WriteLine("a: " + a.ToString("f2") + " b: " + b.ToString("f2"));
                                        double next_volts = Math.Sqrt((target - b) / a);
                                        if (double.IsNaN(next_volts))
                                        {
                                            //count = 8; // error out -- two times through the cap will do this
                                            next_volts = power_table[i + 1][j - 1];
                                        }
                                        last_volts = Audio.SourceScale;
                                        Audio.SourceScale = next_volts / audio_volts1;
                                        //double v_ratio = Math.Sqrt(target) / Math.Sqrt(Math.Max(1, watts));
                                        //Audio.RadioVolume *= v_ratio;
                                        if (fwc_init && (current_model == Model.FLEX5000 || current_model == Model.FLEX3000))
                                        {
                                            Audio.SourceScale = Math.Min(0.5, Audio.SourceScale); // 0.5 cap where 0.83 is max before overloading QSE
                                        }
                                    }
                                    else
                                    {
                                        Audio.SourceScale *= Math.Sqrt(target / watts);
                                    }
                                }

                                last_watts = watts;

                                // check for error conditions
                                if (count++ == 12) // poop out
                                {
                                    found_power = true;
                                    //if(double.IsNaN(Audio.RadioVolume)) Audio.RadioVolume = power_table[i+1][Math.Max(0, j-1)];
                                    //double final_value = Math.Min(power_table[i+1][Math.Max(0, j-1)], Audio.RadioVolume * 0.945); // 0.945 ~= down 0.5 dB
                                    double final_value = (j == 0 ? 0.0 : power_table[i + 1][j - 1]);
                                    for (int k = j; k < power_table[i].Length; k++)
                                        power_table[i + 1][k] = (float)Math.Round(final_value, 4);
                                    j = power_table.Length; // end loop for this band
                                    Audio.TXInputSignal = Audio.SignalSource.RADIO;
                                    Audio.TXOutputSignal = Audio.SignalSource.RADIO;
                                    chkMOX.Checked = false;
                                    //if(!suppress_warnings)
                                    {
                                        MessageBox.Show(new Form { TopMost = true }, "Unable to calibrate PA Power on current band.",
                                            "PA Power Cal Error",
                                            MessageBoxButtons.OK,
                                            MessageBoxIcon.Error);
                                    }
                                }
                            }
                            progress.SetPercent((float)((float)(++progress_count) / progress_total));
                        }
                    }
                }
            }

            ret_val = true;

        end:
            if (!progress.Visible) progress.Text = "";
            progress.Hide();

            chkMOX.Checked = false;
            Audio.TXInputSignal = Audio.SignalSource.RADIO;
            Audio.TXOutputSignal = Audio.SignalSource.RADIO;

            if (fwc_init && (current_model == Model.FLEX5000 || current_model == Model.FLEX3000))
                FullDuplex = false;

            if (current_model == Model.FLEX3000)
                FWC.SetAmpTX1(true);

            EnableAllFilters();
            EnableAllModes();
            VFOLock = false;
            comboPreamp.Enabled = true;
            comboDisplayMode.Enabled = true;

            chkTXEQ.Checked = tx_eq;
            chkDX.Checked = dx;
            chkCPDR.Checked = cpdr;

            for (int i = (int)Band.B2M; i < (int)Band.LAST; i++)
                for (int j = 0; j < 13; j++)
                    power_table[i][j] = (float)Math.Round(power_table[10][j], 4);

            RX1DSPMode = mode;                          // restore dsp mode
            VFOAFreq = 0.590;
            VFOAFreq = vfoa;                                // restore frequency

            try
            {
                StreamWriter writer = new StreamWriter(app_data_path + "power.csv"); //"\\power.csv" // look for %userprofile%\AppData\Roaming\FlexRadio Systems\PowerSDR v2.8.0\

                writer.WriteLine("Band, 1, 2, 5, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100");
                for (int i = 1; i <= (int)Band.B6M; i++)
                {
                    writer.Write(((Band)i).ToString() + ",");
                    for (int j = 0; j < 13; j++)
                        writer.Write(power_table[i][j].ToString("f4") + ",");
                    writer.WriteLine("");
                }
                writer.Close();
            }
            catch (Exception)
            {
                MessageBox.Show(new Form { TopMost = true }, "Error writing power.csv file.  Please make sure this file is not open and try again.",
                    "Error writing power.csv",
                    MessageBoxButtons.OK,
                    MessageBoxIcon.Error);
            }

            calibrating = false;
            return ret_val;
        }

        public bool LowPowerPASweep(Progress progress, int power) // calibrate PA Gain values
        {
            //			HiPerfTimer t1 = new HiPerfTimer();
            //			t1.Start();

            bool ret_val = false;

            if (!chkPower.Checked)
            {
                MessageBox.Show(new Form { TopMost = true }, "Power must be on in order to run PA Sweep.", "Power Is Off",
                    MessageBoxButtons.OK, MessageBoxIcon.Stop);
                return false;
            }

            calibrating = true;

            DSPMode dsp_mode = RX1DSPMode;              // save current DSP Mode
            RX1DSPMode = DSPMode.USB;                   // set DSP Mode to USB

            double vfo_freq = VFOAFreq;						// save current frequency

            int pwr = PWR;                      // save current pwr level
            PWR = power;                        // set pwr level to 100W

            progress.SetPercent(0.0f);

            float[] band_freqs = { 1.9f, 3.75f, 5.357f, 7.15f, 10.125f, 14.175f, 18.1f, 21.225f, 24.9f, 28.85f };

            for (int i = 0; i < band_freqs.Length; i++)
            {
                VFOAFreq = band_freqs[i];               // set frequency
                Audio.TXInputSignal = Audio.SignalSource.SINE;
                Audio.SourceScale = 1.0;
                chkMOX.Checked = true;
                for (int j = 0; j < 30; j++)
                {
                    Thread.Sleep(100);
                    if (!progress.Visible)
                        goto end;
                }
                chkMOX.Checked = false;
                Audio.TXInputSignal = Audio.SignalSource.RADIO;

                if (!progress.Visible)
                    goto end;

                for (int j = 0; j < 40; j++)
                {
                    Thread.Sleep(100);
                    if (!progress.Visible)
                        goto end;
                }
                if (!progress.Visible)
                    goto end;

                progress.SetPercent((float)((float)(i + 1) / 10));
            }

            ret_val = true;

        end:
            progress.Hide();
            chkMOX.Checked = false;
            Audio.TXInputSignal = Audio.SignalSource.RADIO;
            RX1DSPMode = dsp_mode;                          // restore dsp mode
            VFOAFreq = vfo_freq;                                // restore frequency
            txtVFOAFreq_LostFocus(this, EventArgs.Empty);
            PWR = pwr;                                  // restore pwr level

            calibrating = false;

            //t1.Stop();
            //MessageBox.Show(t1.Duration.ToString());
            return ret_val;
        }

        public bool CalibrateSoundCard(Progress progress, int card)
        {
            if (!chkPower.Checked)
            {
                MessageBox.Show(new Form { TopMost = true }, "Power must be on in order to calibrate Soundcard.", "Power Is Off",
                    MessageBoxButtons.OK, MessageBoxIcon.Stop);
                return false;
            }

            Audio.testing = true;
            progress.SetPercent(0.0f);

            double tx_volume = Audio.RadioVolume;   // save current TX volume
            double rx_volume = Audio.MonitorVolume; // save current RX volume

            if (num_channels == 4 || num_channels == 6)
            {
                chkMOX.Checked = true;
                Thread.Sleep(200);
                Hdw.TransmitRelay = false;
                Audio.RadioVolume = 1.0;                // set volume to max
                Audio.MonitorVolume = 0.0;
            }
            else
            {
                Mixer.SetMainVolume(mixer_id1, 100);
                Mixer.SetWaveOutVolume(mixer_id1, 100);
                Audio.MonitorVolume = 1.0;
            }

            Audio.RX1OutputSignal = Audio.SignalSource.SINE;    // Start sending tone

            progress.Focus();

            while (progress.Visible == true)            // keep sending tone until abort is pressed
                Thread.Sleep(100);

            Audio.RX1OutputSignal = Audio.SignalSource.RADIO;       // stop sending tone

            if (num_channels > 2)
            {
                Thread.Sleep(200);
                chkMOX.Checked = false;
            }

            Audio.RadioVolume = tx_volume;          // restore TX volume
            Audio.MonitorVolume = rx_volume;        // restore RX volume
            Audio.testing = false;

            return true;
        }

        #endregion

        #region Properties
        // ======================================================
        // Properties
        // ======================================================

        private bool limit_slew = false;
        public bool LimitSlew
        {
            get { return limit_slew; }
            set { limit_slew = value; }
        }

        public List<TuneStep> tune_step_list;				// A list of available tuning steps
        public List<TuneStep> TuneStepList
        {
            get { return tune_step_list; }
        }

        private int tune_step_index;						// An index into the above array
        public int TuneStepIndex
        {
            get { return tune_step_index; }
            set
            {
                if (value < 0 || value > tune_step_list.Count - 1)
                    return;

                tune_step_index = value;
                txtWheelTune.Text = tune_step_list[tune_step_index].Name;
                grpVFOBetween.Invalidate();

            }
        }



        //====================================================================================
        // ke9ns add  alt tunestep for flexcontrol
        private int tune_step_index2;						// An index into the above array
        public int TuneStepIndex2 // called by FlexControllnterface1/2.cs
        {

            get
            {
                if (setupForm != null) return tune_step_index2;
                return setupForm.tune_step_index2;
            }
            set
            {
                if (value < 0 || value > tune_step_list.Count - 1) return;

                if (setupForm != null) setupForm.tune_step_index2 = value;
                else tune_step_index2 = value;

                setupForm.txtWheelTune2.Text = tune_step_list[setupForm.tune_step_index2].Name;
                //  setupForm.txtWheelTune3.Text = tune_step_list[setupForm.tune_step_index3].Name;

                //  setupForm.tune_step_index4 = setupForm.tune_step_index2;

            }
        } //TuneStepIndex2





        public int TuneStepLookup(string s)
        {
            for (int i = 0; i < tune_step_list.Count; i++)
            {
                if (tune_step_list[i].Name == s)
                    return i;
            }

            return -1;
        }

        /// <summary>
        /// The transmit frequency in MHz
        /// </summary>
        public double TXFreq
        {
            get
            {
                double tx_freq = 0.0;

                if (!rx2_enabled)
                {
                    if (!chkVFOBTX.Checked)
                        tx_freq = VFOAFreq;
                    else
                        tx_freq = VFOBFreq;
                }
                else // if(rx2_enabled)
                {
                    if (chkVFOBTX.Checked)
                        tx_freq = VFOBFreq;
                    else if (chkVFOSplit.Checked)
                        tx_freq = VFOASubFreq;
                    else if (chkVFOATX.Checked)
                        tx_freq = VFOAFreq;
                }

                return tx_freq;
            }

            set
            {

                if (!rx2_enabled)
                {
                    if (!chkVFOBTX.Checked)
                        VFOAFreq = value;
                    else
                        VFOBFreq = value;
                }
                else // if(rx2_enabled)
                {
                    if (chkVFOBTX.Checked)
                        VFOBFreq = value;
                    else if (chkVFOSplit.Checked)
                        VFOASubFreq = value;
                    else if (chkVFOATX.Checked)
                        VFOAFreq = value;
                }
            }
        } // TXFreq

        //ke9ns add .207
        public double TXFreq2
        {
            get
            {
                double tx_freq = 0.0;

                if (!rx2_enabled)
                {
                    if (!chkVFOBTX.Checked)
                        tx_freq = VFOAFreq;
                    else
                        tx_freq = VFOBFreq;
                }
                else // if(rx2_enabled)
                {
                    if (chkVFOBTX.Checked)
                        tx_freq = VFOBFreq;
                    else if (chkVFOSplit.Checked)
                        tx_freq = VFOASubFreq;
                    else if (chkVFOATX.Checked)
                        tx_freq = VFOAFreq;
                }

                return tx_freq;
            }

            set
            {

                if (!rx2_enabled)
                {
                    if (!chkVFOBTX.Checked)
                    {
                        // VFOAFreq = value;

                    }
                    else
                    {
                        VFOBFreq = value;
                    }
                }
                else // if(rx2_enabled)
                {
                    if (chkVFOBTX.Checked)
                    {
                        VFOBFreq = value;
                    }

                    else if (chkVFOSplit.Checked) // no split available yet .207
                    {
                        //  VFOASubFreq = value;
                    }
                    else if (chkVFOATX.Checked)
                    {

                        VFOBFreq = value;
                        chkVFOBTX.Checked = true;


                    }
                }
            }
        } // TXFreq2

        //======================================================================================

        private FlexControlMode current_flexcontrol_mode = FlexControlMode.Basic;
        public void SetCurrentFlexControlMode(object sender, FlexControlMode mode)
        {

            current_flexcontrol_mode = mode;

            if (flexControlBasicForm != null) flexControlBasicForm.FlexControlMode = mode;

            if (flexControlAdvancedForm != null) flexControlAdvancedForm.FlexControlMode = mode;

            if (sender != null)
            {

                switch (current_flexcontrol_mode)
                {
                    case FlexControlMode.Basic:
                        flexControlBasicForm.Location = flexControlAdvancedForm.Location;
                        flexControlBasicForm.Show();
                        //   flexControlBasicForm.WindowState = FormWindowState.Normal; // ke9ns add
                        break;
                    case FlexControlMode.Advanced:
                        flexControlAdvancedForm.Location = flexControlBasicForm.Location;
                        flexControlAdvancedForm.Show();
                        //    flexControlAdvancedForm.WindowState = FormWindowState.Normal; // ke9ns add
                        break;
                }
            }

        }

        private bool flexcontrol_autodetect = true;
        public bool FlexControlAutoDetect
        {
            get { return flexcontrol_autodetect; }
            set
            {
                flexcontrol_autodetect = value;
                if (value)
                    FlexControlScan();
                else
                    FlexControlManager.Close();

                if (!initializing)
                {
                    flexControlBasicForm.AutoDetect = value;
                    flexControlAdvancedForm.AutoDetect = value;
                }
            }
        }

        public int RX0Gain
        {
            get
            {
                if (ptbRX0Gain != null) return ptbRX0Gain.Value;
                else return -1;
            }
            set
            {
                if (ptbRX0Gain != null) ptbRX0Gain.Value = value;
                ptbRX0Gain_Scroll(this, EventArgs.Empty);
            }
        }

        public int PanMainRX
        {
            get
            {
                if (ptbPanMainRX != null) return ptbPanMainRX.Value;
                else return -1;
            }
            set
            {
                if (ptbPanMainRX != null) ptbPanMainRX.Value = value;
                ptbPanMainRX_Scroll(this, EventArgs.Empty);
            }
        }


        public int RX1Gain
        {
            get
            {
                if (ptbRX1Gain != null) return ptbRX1Gain.Value;
                else return -1;
            }
            set
            {
                if (ptbRX1Gain != null) ptbRX1Gain.Value = value;
                ptbRX1Gain_Scroll(this, EventArgs.Empty);
            }
        }

        public int PanSubRX
        {
            get
            {
                if (ptbPanSubRX != null) return ptbPanSubRX.Value;
                else return -1;
            }
            set
            {
                if (ptbPanSubRX != null) ptbPanSubRX.Value = value;
                ptbPanSubRX_Scroll(this, EventArgs.Empty);
            }
        }

        public int RX2Gain
        {
            get
            {
                if (ptbRX2Gain != null) return ptbRX2Gain.Value;
                else return -1;
            }
            set
            {
                if (ptbRX2Gain != null) ptbRX2Gain.Value = value;
                ptbRX2Gain_Scroll(this, EventArgs.Empty);
            }
        }

        public int RX2Pan
        {
            get
            {
                if (ptbRX2Pan != null) return ptbRX2Pan.Value;
                else return -1;
            }
            set
            {
                if (ptbRX2Pan != null) ptbRX2Pan.Value = value;
                ptbRX2Pan_Scroll(this, EventArgs.Empty);
            }
        }


        public bool CATDiversityEnable
        {
            get
            {
                if (diversityForm != null)
                    return diversityForm.CATEnable;
                else
                    return false;
            }
            set
            {
                if (diversityForm != null)
                    if (value)
                        diversityForm.CATEnable = true;
                    else
                        diversityForm.CATEnable = false;
            }
        }

        public bool CATDiversityForm
        {
            get
            {
                if (diversityForm == null || diversityForm.IsDisposed)
                    return false;
                else
                    return true;
            }
            set
            {
                if (value)
                {
                    if (diversityForm == null || diversityForm.IsDisposed)
                        diversityForm = new DiversityForm(this);
                    diversityForm.Focus();
                    this.Invoke(new MethodInvoker(diversityForm.Show));
                }
                else
                    if (diversityForm != null)
                    this.Invoke(new MethodInvoker(diversityForm.Close));
            }
        }

        public bool CATCWXForm
        {
            get
            {
                if (cwxForm == null || cwxForm.IsDisposed)
                    return false;
                else
                    return true;
            }
            set
            {
                if (value)
                {
                    cWXToolStripMenuItem.PerformClick();
                }
                else
                    if (cwxForm != null)
                    this.Invoke(new MethodInvoker(cwxForm.Close));
            }
        }

        public bool VFOATX
        {
            get { return chkVFOATX.Checked; }
            set { chkVFOATX.Checked = value; }
        }

        public bool VFOBTX
        {
            get { return chkVFOBTX.Checked; }
            set { chkVFOBTX.Checked = value; }
        }

        private bool production = false;
        public bool Production
        {
            get { return production; }
        }

        private bool test_equip = false;
        public bool TestEquip
        {
            get { return test_equip; }
        }

        private int phone_blank_time = 200;
        public int PhoneBlankTime
        {
            get { return phone_blank_time; }
            set { phone_blank_time = value; }
        }

        private bool flex_1500_xref = false;
        public bool FLEX1500Xref
        {
            get { return flex_1500_xref; }
            set
            {
                flex_1500_xref = value;
                HIDDDSClockCorrection = HIDDDSClockCorrection;
            }
        }

        private bool hid_ptt_in = false;
        public bool HIDPTTIn
        {
            get { return hid_ptt_in; }
            set { hid_ptt_in = value; }
        }

        private bool hid_mic_ptt = false;
        public bool HIDMicPTT
        {
            get { return hid_mic_ptt; }
            set { hid_mic_ptt = value; }
        }

        private bool fwc_rca_ptt = false;
        public bool FWCRCAPTT
        {
            get { return fwc_rca_ptt; }
            set { fwc_rca_ptt = value; }
        }

        private bool fwc_mic_ptt = false;
        public bool FWCMicPTT
        {
            get { return fwc_mic_ptt; }
            set { fwc_mic_ptt = value; }
        }

        private bool swap_vfo_ab_tx = false;
        public bool SwapVFOA_BTX
        {
            get { return swap_vfo_ab_tx; }
            set
            {
                if (value)
                {
                    //chkVFOATX.Checked = false;
                    chkVFOBTX.Checked = true;
                }
                else
                {
                    chkVFOATX.Checked = true;
                    //chkVFOBTX.Checked = false;
                }
                swap_vfo_ab_tx = value;
            }
        }

        private string db_file_name = "";
        public string DBFileName
        {
            get { return db_file_name; }
            set
            {
                if (initializing) // ignore changes here after init is complete per design
                {
                    db_file_name = value;
                    DB.FileName = value;
                }
            }
        }

        //=======================================================================
        // ke9ns add my own database
        private string db_file_name1 = "";
        public string DBFileName1
        {
            get { return db_file_name1; }
            set
            {
                if (initializing) // ignore changes here after init is complete per design
                {
                    db_file_name1 = value;
                    DB.FileName1 = value;


                }
            }
        }



        private bool db_exists;
        public bool DB_Exists
        {
            get { return db_exists; }
            set { db_exists = value; }
        }


        private string app_data_path = "";
        public string AppDataPath
        {
            get { return app_data_path; }
            set
            {
                app_data_path = value;
                FWCEEPROM.AppDataPath = value;
                HIDEEPROM.AppDataPath = value;
                Skin.AppDataPath = value;
            }
        }

        private Radio radio_to_use;
        public Radio RadioToUse
        {
            get { return radio_to_use; }
            set { radio_to_use = value; }
        }

        private bool wheel_tunes_vfob = true;
        public bool WheelTunesVFOB
        {
            get { return wheel_tunes_vfob; }
            set { wheel_tunes_vfob = value; }
        }

        private bool disable_ui_mox_changes = true;
        public bool DisableUIMOXChanges
        {
            get { return disable_ui_mox_changes; }
            set { disable_ui_mox_changes = value; }
        }

        private HiPerfTimer mic_down_timer = new HiPerfTimer();
        private bool mic_down_running = false;
        private bool mic_down = false;
        public bool MicDown
        {
            get { return mic_down; }
            set
            {
                mic_down = value;
                Debug.WriteLine("mic_down: " + value.ToString());
                mic_down_timer.Start();
                if (mic_down)
                {
                    if (mic_down_running)
                        mic_down_running = false;
                    else if (mic_up_running)
                        mic_up_running = false;
                    else
                    {
                        if (mic_fast)
                            VFOAFreq -= 0.001000;
                        else VFOAFreq -= 0.000050;
                    }
                }
            }
        }

        private HiPerfTimer mic_up_timer = new HiPerfTimer();
        private bool mic_up_running = false;
        private bool mic_up = false;
        public bool MicUp
        {
            get { return mic_up; }
            set
            {
                mic_up = value;
                Debug.WriteLine("mic_up: " + value.ToString());
                mic_up_timer.Start();
                if (mic_up)
                {
                    if (mic_up_running)
                        mic_up_running = false;
                    else if (mic_down_running)
                        mic_down_running = false;
                    else
                    {
                        if (mic_fast)
                            VFOAFreq += 0.001000;
                        else VFOAFreq += 0.000050;
                    }
                }
            }
        }

        private HiPerfTimer mic_fast_timer = new HiPerfTimer();
        private bool mic_fast = false;
        public bool MicFast
        {
            get { return mic_fast; }
            set
            {
                mic_fast = value;
                Debug.WriteLine("mic_fast: " + value.ToString());
                mic_fast_timer.Start();
            }
        }

        private bool f3k_fan = false;
        private bool F3KFan
        {
            get { return f3k_fan; }
            set
            {
                f3k_fan = value;
                FWC.SetFan(value);
            }
        }

        private float f3k_temp_thresh = 70.0f;
        public float F3KTempThresh
        {
            get { return f3k_temp_thresh; }
            set
            {
                if (value < 30.0f) value = 30.0f;
                if (value > 70.0f) value = 70.0f;
                f3k_temp_thresh = value;
            }
        }

        private bool flex_wire_ucb = false;
        public bool FlexWireUCB
        {
            get { return flex_wire_ucb; }
            set { flex_wire_ucb = value; }
        }

        private float loop_gain = 0.0f;
        private float rx1_loop_offset = 0.0f;
        private float rx2_loop_offset = 0.0f;
        public float LoopGain
        {
            get { return loop_gain; }
            set
            {
                loop_gain = value;
                if (rx1_loop)
                {
                    rx1_loop_offset = loop_gain;
                    if (rx2_ant == FWCAnt.RX1TAP)
                        rx2_loop_offset = loop_gain;
                    UpdateDisplayOffsets();
                }
            }
        }

        private float rx1_xvtr_gain_offset;                     // gain offset as entered on the xvtr form
        public float RX1XVTRGainOffset
        {
            get { return rx1_xvtr_gain_offset; }
            set
            {
                rx1_xvtr_gain_offset = value;
                UpdateDisplayOffsets();
            }
        }

        private float rx2_xvtr_gain_offset;                     // gain offset as entered on the xvtr form
        public float RX2XVTRGainOffset
        {
            get { return rx2_xvtr_gain_offset; }
            set
            {
                rx2_xvtr_gain_offset = value;
                UpdateDisplayOffsets();
            }
        }

        private bool hid_amp_tx1 = true;
        public bool HIDAmpTX1
        {
            get { return hid_amp_tx1; }
            set
            {
                bool old = hid_amp_tx1;
                hid_amp_tx1 = value;
                if (old != value || initializing)
                    USBHID.EnableTXOutSeq(value);
            }
        }

        private bool fwc_amp_tx1 = true;
        public bool FWCAmpTX1
        {
            get { return fwc_amp_tx1; }
            set
            {
                Debug.WriteLine("SETTX3 " + value);

                bool old = fwc_amp_tx1;
                fwc_amp_tx1 = value;
                //  if ( initializing) // if (old != value || initializing)
                // {
                if (fwcAntForm == null) FWC.SetAmpTX1(value);
                else if (fwcAntForm.chkTX2Active.Checked == false) FWC.SetAmpTX1(value); // normal
                else // SO2R
                {
                    if (chkVFOATX.Checked) //VFOA TX
                    {
                        if (FWCAmpRX2TX1 == false && fwc_amp_tx1) FWC.SetAmpTX1(true);
                        else FWC.SetAmpTX1(false);
                    }
                    else // VFOB TX
                    {
                        if (FWCAmpRX2TX1 == true && fwc_amp_tx1) FWC.SetAmpTX1(true);
                        else FWC.SetAmpTX1(false);

                    }
                }
                //  }
            }
        }

        private bool fwc_amp_tx2 = true;
        public bool FWCAmpTX2
        {
            get { return fwc_amp_tx2; }
            set
            {
                bool old = fwc_amp_tx2;
                fwc_amp_tx2 = value;
                //  if (initializing) // if (old != value || initializing)
                // {
                if (fwcAntForm == null) FWC.SetAmpTX2(value);
                else if (fwcAntForm.chkTX2Active.Checked == false) FWC.SetAmpTX2(value);
                else
                {
                    if (chkVFOATX.Checked)
                    {
                        if (FWCAmpRX2TX2 == false && fwc_amp_tx2) FWC.SetAmpTX2(true);
                        else FWC.SetAmpTX2(false);
                    }
                    else
                    {
                        if (FWCAmpRX2TX2 == true && fwc_amp_tx2) FWC.SetAmpTX2(true);
                        else FWC.SetAmpTX2(false);

                    }
                }
                // }
            }
        }

        private bool fwc_amp_tx3 = true;
        public bool FWCAmpTX3
        {
            get { return fwc_amp_tx3; }
            set
            {
                bool old = fwc_amp_tx3;
                fwc_amp_tx3 = value;

                //  if (old != value || initializing)
                //{
                if (fwcAntForm == null) FWC.SetAmpTX1(value);
                else if (fwcAntForm.chkTX2Active.Checked == false) FWC.SetAmpTX3(value);
                else
                {
                    if (chkVFOATX.Checked)
                    {
                        if (FWCAmpRX2TX3 == false && fwc_amp_tx3) FWC.SetAmpTX3(true);
                        else FWC.SetAmpTX3(false);
                    }
                    else
                    {
                        if (FWCAmpRX2TX3 == true && fwc_amp_tx3) FWC.SetAmpTX3(true);
                        else FWC.SetAmpTX3(false);

                    }
                }

                Debug.WriteLine("RX2TX3 " + FWCAmpRX2TX3 + " ,ampTX3" + fwc_amp_tx3);

                //  }
            }
        }

        private bool fwc_pa_bias = false;
        public bool FWCPABias
        {
            get { return fwc_pa_bias; }
            set
            {
                bool old = fwc_pa_bias;
                fwc_pa_bias = value;
                if (old != value)
                    FWC.SetPABias(value);
            }
        }

        private bool fwc_rx1_attn = false;
        public bool FWCRX1Attn
        {
            get { return fwc_rx1_attn; }
            set
            {
                bool old = fwc_rx1_attn;
                fwc_rx1_attn = value;
                if (old != value)
                    FWC.SetRXAttn(value);
            }
        }

        private bool fwc_rx1_preamp = false;
        public bool FWCRX1Preamp
        {
            get { return fwc_rx1_preamp; }
            set
            {
                bool old = fwc_rx1_preamp;
                fwc_rx1_preamp = value;
                if (old != value) FWC.SetTRXPreamp(value);
            }
        }

        private bool hid_ptt_out = true;
        public bool HIDPTTOut
        {
            get { return hid_ptt_out; }
            set
            {
                bool old = hid_ptt_out;
                hid_ptt_out = value;
                if (old != value || initializing)
                    USBHID.SetTXOut(value);
            }
        }

        private int hid_trx_filter = 0;
        public int HIDTRXFilter
        {
            get { return hid_trx_filter; }
            set
            {
                int old = hid_trx_filter;
                hid_trx_filter = value;
                if (old != value)
                {
                    USBHID.SetRXFilter(value);
                    //Debug.WriteLine("SetTRXFilter(" + value + ")");
                }
            }
        }

        private int hid_pa_filter = 0;
        public int HIDPAFilter
        {
            get { return hid_pa_filter; }
            set
            {
                int old = hid_pa_filter;
                hid_pa_filter = value;
                if (old != value)
                {
                    USBHID.SetPAFilter(value);
                    //Debug.WriteLine("SetPAFilter(" + value + ")");
                }
            }
        }

        private bool fwc_rx2_preamp = false;
        public bool FWCRX2Preamp
        {
            get { return fwc_rx2_preamp; }
            set
            {
                bool old = fwc_rx2_preamp;
                fwc_rx2_preamp = value;
                if (old != value)
                    FWC.SetRX2Preamp(value);
            }
        }

        private bool enable_6m_preamp = false;
        public bool Enable6mPreamp
        {
            get { return enable_6m_preamp; }
            set
            {
                enable_6m_preamp = value;
                if (value)
                {
                    if (rx1_band == Band.B6M)
                        chkRX1Preamp.Enabled = true;
                    if (FWCEEPROM.RX2OK && rx2_band == Band.B6M)
                        chkRX2Preamp.Enabled = true;
                }
                else
                {
                    if (rx1_band == Band.B6M)
                    {
                        chkRX1Preamp.Enabled = false;
                        chkRX1Preamp.Checked = true;
                    }
                    if (FWCEEPROM.RX2OK && rx2_band == Band.B6M)
                    {
                        chkRX2Preamp.Enabled = false;
                        chkRX2Preamp.Checked = true;
                    }
                }
            }
        }

        private bool meter_detail = false;
        public bool MeterDetail
        {
            get { return meter_detail; }
            set { meter_detail = value; }
        }

        private MeterTXMode tune_meter_tx_mode = MeterTXMode.FORWARD_POWER;
        public MeterTXMode TuneTXMeterMode
        {
            get { return tune_meter_tx_mode; }
            set
            {
                tune_meter_tx_mode = value;
                if (chkTUN.Checked)
                {
                    CurrentMeterTXMode = value;
                    comboMeterTXMode_SelectedIndexChanged(this, EventArgs.Empty);

                    comboMeterTX1Mode_SelectedIndexChanged(this, EventArgs.Empty); // ke9ns add for lblrx2meter
                }
            }
        }

        public bool NB
        {
            get { return chkNB.Checked; }
            set { chkNB.Checked = value; }
        }

        public bool NB2
        {
            get { return chkDSPNB2.Checked; }
            set { chkDSPNB2.Checked = value; }
        }

        public bool QuickPlay
        {
            get
            {

                return ckQuickPlay.Checked;
            }
            set
            {
                ckQuickPlay.Checked = value;
            }
        }


        //=================================================================
        // ke9ns add: a way for waveform to communicate with console for TX Water ID
        //=================================================================
        public bool TXIDPlay  // ke9ns add
        {
            get { return TXIDMenuItem.Checked; }
            set { TXIDMenuItem.Checked = value; }
        }
        //=========================================================


        public bool DX
        {
            get { return chkDX.Checked; }
            set { chkDX.Checked = value; }
        }

        public bool DEXP
        {
            get { return chkNoiseGate.Checked; }
            set { chkNoiseGate.Checked = value; }
        }

        public int DXLevel
        {
            get { return ptbDX.Value; }
            set
            {
                ptbDX.Value = value;
                ptbDX_Scroll(this, EventArgs.Empty);
            }
        }

        private bool peak_tx_meter = true; // as opposed to avg
        public bool PeakTXMeter
        {
            get { return peak_tx_meter; }
            set { peak_tx_meter = value; }
        }

        // ke9ns add for 2nd TX meter 
        private bool peak_tx1_meter = true; // as opposed to avg
        public bool PeakTX1Meter
        {
            get { return peak_tx1_meter; }
            set { peak_tx1_meter = value; }
        }

        private bool allow_vac_bypass = true;
        public bool AllowVACBypass
        {
            get { return allow_vac_bypass; }
            set { allow_vac_bypass = value; }
        }

        public float NewMeterData
        {
            get { return new_meter_data; }
        }

        private bool all_mode_mic_ptt = true;
        public bool AllModeMicPTT
        {
            get { return all_mode_mic_ptt; }
            set { all_mode_mic_ptt = value; }
        }

        private int last_rx1_xvtr_index = -1;           // index of last xvtr in use
        public int LastRX1XVTRIndex
        {
            get { return last_rx1_xvtr_index; }
            set { last_rx1_xvtr_index = value; }
        }

        private int last_rx2_xvtr_index = -1;			// index of last xvtr in use
        public int LastRX2XVTRIndex
        {
            get { return last_rx2_xvtr_index; }
            set { last_rx2_xvtr_index = value; }
        }

        private int rx1_xvtr_index = -1;                // index of current xvtr in use
        public int RX1XVTRIndex
        {
            get { return rx1_xvtr_index; }
            set { rx1_xvtr_index = value; }
        }

        private int rx2_xvtr_index = -1;                // index of current xvtr in use
        public int RX2XVTRIndex
        {
            get { return rx2_xvtr_index; }
            set { rx2_xvtr_index = value; }
        }

        private int tx_xvtr_index = -1;                 // index of current xvtr in use
        public int TXXVTRIndex
        {
            get { return tx_xvtr_index; }
            set { tx_xvtr_index = value; }
        }


        private int last_tx_xvtr_index = -1;		    // index of last xvtr in use
        public int LastTXXVTRIndex
        {
            get { return last_tx_xvtr_index; }
            set { last_tx_xvtr_index = value; }
        }

        private float rx1_path_offset = 0.0f;
        public float RX1PathOffset
        {
            get { return rx1_path_offset; }
        }

        private float rx2_path_offset = 0.0f;
        public float RX2PathOffset
        {
            get { return rx2_path_offset; }
        }

        /*private bool[] ptt_out_by_band;
        public void SetPTTOut(Band b, bool on)
        {
            switch (current_ant_mode)
            {
                case AntMode.Simple:
                    HIDPTTOut = on;
                    break;
                case AntMode.Expert:
                    ptt_out_by_band[(int)b] = on;
                    Band band = tx_band;
                    if (tx_xvtr_index >= 0)
                        band = (Band)((int)Band.VHF0 + tx_xvtr_index);
                    if (band == b) HIDPTTOut = on;
                    break;
            }
        }*/

        private bool[] tx1_by_band;
        private bool[] tx1_by2_band; // ke9ns add .206


        public void SetTX1(Band b, bool on)
        {
            Debug.WriteLine("SETTX1 " + b + ", " + on + " , " + current_ant_mode);

            switch (current_ant_mode)
            {
                case AntMode.Simple:
                    FWCAmpTX1 = on;
                    break;
                case AntMode.Expert:
                    tx1_by_band[(int)b] = on;
                    Band band = tx_band;
                    if (tx_xvtr_index >= 0) band = (Band)((int)Band.VHF0 + tx_xvtr_index);
                    if (band == b) FWCAmpTX1 = on;
                    break;
            }

            Debug.WriteLine("SETTX2 " + b + ", " + on);


        } // SetTX1

        // ke9ns add .206

        bool FWCAmpRX2TX1 = false;
        bool FWCAmpRX2TX2 = false;
        bool FWCAmpRX2TX3 = false;

        public void SetRX2TX1(Band b, bool on, bool on1)
        {

            switch (current_ant_mode)
            {
                case AntMode.Simple:

                    FWCAmpRX2TX1 = on;
                    FWCAmpTX1 = on1;
                    break;
                case AntMode.Expert:
                    tx1_by2_band[(int)b] = on;
                    Band band = tx_band2;
                    if (tx_xvtr_index >= 0) band = (Band)((int)Band.VHF0 + tx_xvtr_index);
                    if (band == b)
                    {
                        FWCAmpRX2TX1 = on;
                        FWCAmpTX1 = on1;
                    }

                    break;
            }
            /*
                        if (chkVFOATX.Checked)
                        {
                            if (FWCAmpRX2TX1 == false && fwc_amp_tx1) FWC.SetAmpTX1(true);
                            else FWC.SetAmpTX1(false);
                        }
                        else
                        {
                            if (FWCAmpRX2TX1 == true && fwc_amp_tx1) FWC.SetAmpTX1(true);
                            else FWC.SetAmpTX1(false);

                        }
                      */
        } // SetRX2TX1

        public void SetRX2TX2(Band b, bool on, bool on1)
        {
            switch (current_ant_mode)
            {
                case AntMode.Simple:

                    FWCAmpRX2TX2 = on;
                    FWCAmpTX2 = on1;
                    break;
                case AntMode.Expert:
                    tx2_by2_band[(int)b] = on;
                    Band band = tx_band2;
                    if (tx_xvtr_index >= 0) band = (Band)((int)Band.VHF0 + tx_xvtr_index);
                    if (band == b)
                    {
                        FWCAmpRX2TX2 = on;
                        FWCAmpTX2 = on1;
                    }

                    break;
            }
            /*
                        if (chkVFOATX.Checked)
                        {
                            if (FWCAmpRX2TX2 == false && fwc_amp_tx2) FWC.SetAmpTX2(true);
                            else FWC.SetAmpTX2(false);
                        }
                        else
                        {
                            if (FWCAmpRX2TX2 == true && fwc_amp_tx2) FWC.SetAmpTX2(true);
                            else FWC.SetAmpTX2(false);

                        }
            */
        } // SetRX2TX2

        public void SetRX2TX3(Band b, bool on, bool on1)
        {
            switch (current_ant_mode)
            {
                case AntMode.Simple:

                    FWCAmpRX2TX3 = on;
                    FWCAmpTX3 = on1;

                    break;
                case AntMode.Expert:
                    tx3_by2_band[(int)b] = on;
                    Band band = tx_band2;
                    if (tx_xvtr_index >= 0) band = (Band)((int)Band.VHF0 + tx_xvtr_index);
                    if (band == b)
                    {
                        FWCAmpRX2TX3 = on;
                        FWCAmpTX3 = on1;
                    }

                    break;
            }
            /*
                        if (chkVFOATX.Checked)
                        {
                            if (FWCAmpRX2TX3 == false && fwc_amp_tx3) FWC.SetAmpTX3(true);
                            else FWC.SetAmpTX3(false);
                        }
                        else
                        {
                            if (FWCAmpRX2TX3 == true && fwc_amp_tx3) FWC.SetAmpTX3(true);
                            else FWC.SetAmpTX3(false);

                        }
            */
        } // SetRX2TX3

        public void Set1500TX1(Band b, bool on)
        {
            switch (current_ant_mode)
            {
                case AntMode.Simple:
                    HIDAmpTX1 = on;
                    break;
                case AntMode.Expert:
                    tx1_by_band[(int)b] = on;
                    Band band = tx_band;
                    if (tx_xvtr_index >= 0)
                        band = (Band)((int)Band.VHF0 + tx_xvtr_index);
                    if (band == b) HIDAmpTX1 = on;
                    break;
            }
        }

        public bool GetTX1(Band b)
        {
            return tx1_by_band[(int)b];
        }

        private bool[] tx2_by_band;
        private bool[] tx2_by2_band; // ke9ns add .206
        public void SetTX2(Band b, bool on)
        {
            switch (current_ant_mode)
            {
                case AntMode.Simple:
                    FWCAmpTX2 = on;
                    break;
                case AntMode.Expert:
                    tx2_by_band[(int)b] = on;
                    Band band = tx_band;
                    if (tx_xvtr_index >= 0)
                        band = (Band)((int)Band.VHF0 + tx_xvtr_index);
                    if (band == b) FWCAmpTX2 = on;
                    break;
            }
        }

        public bool GetTX2(Band b)
        {
            return tx2_by_band[(int)b];
        }

        private bool[] tx3_by_band;
        private bool[] tx3_by2_band; // ke9ns add .206
        public void SetTX3(Band b, bool on)
        {
            switch (current_ant_mode)
            {
                case AntMode.Simple:
                    FWCAmpTX3 = on;
                    break;
                case AntMode.Expert:
                    tx3_by_band[(int)b] = on;
                    Band band = tx_band;
                    if (tx_xvtr_index >= 0)
                        band = (Band)((int)Band.VHF0 + tx_xvtr_index);
                    if (band == b) FWCAmpTX3 = on;
                    break;
            }
        }

        public bool GetTX3(Band b)
        {
            return tx3_by_band[(int)b];
        }

        private PreampMode[] rx1_preamp_by_band;
        public void SetRX1Preamp(Band b, PreampMode mode)
        {
            AA.Restart(); // ke9ns
            autoadjust1 = true; // ke9ns add for automatic water and pan level updates

            if (mode > PreampMode.FIRST && mode < PreampMode.LAST)
                rx1_preamp_by_band[(int)b] = mode;
        }

        public PreampMode GetPreamp(Band b)
        {
            return rx1_preamp_by_band[(int)b];
        }

        private PreampMode[] rx2_preamp_by_band;

        private double[] fm_tx_offset_by_band_mhz;

        //=================================================================
        // ke9ns add (to allow different power levels per band and per mode
        private int[,] power_by_mode_by_band = new int[(int)Band.LAST, (int)DSPMode.LAST];
        private int[,] limit_by_mode_by_band = new int[(int)Band.LAST, (int)DSPMode.LAST]; // setupForm.udTXDriveMax setpoint

        public void SetPowerM(Band b, DSPMode d, int pwr)
        {
            power_by_mode_by_band[(int)b, (int)d] = pwr;
            if (tx_band == b) PWR = pwr;
        }

        public int GetPowerM(Band b, DSPMode d)
        {
            return power_by_mode_by_band[(int)b, (int)d];
        }


        private int[] power_by_band;
        public void SetPower(Band b, int pwr)
        {
            power_by_band[(int)b] = pwr;
            if (tx_band == b) PWR = pwr;
        }

        public int GetPower(Band b)
        {
            return power_by_band[(int)b];
        }

        private int[] rx1_agct_by_band;
        public void SetRFGain(Band b, int gain)
        {
            rx1_agct_by_band[(int)b] = gain;
            if (rx1_band == b) RF = gain;
        }

        public int GetRFGain(Band b)
        {
            return rx1_agct_by_band[(int)b];
        }

        private int[] rx2_agct_by_band;

        private AntMode current_ant_mode = AntMode.Simple;
        public AntMode CurrentAntMode // called by fwcAntForm.cs
        {

            get { return current_ant_mode; }
            set
            {
                AA.Restart(); // ke9ns
                autoadjust1 = true; // ke9ns add for automatic water and pan level updates

                current_ant_mode = value;
                if (current_ant_mode == AntMode.Expert && !initializing)
                {
                    TXAnt = GetTXAnt(rx1_band);
                    RX1Ant = GetRX1Ant(rx1_band);

                    if (FWCEEPROM.RX2OK)
                    {
                        TXAnt2 = GetTXAnt2(rx2_band); // ke9ns add .205
                        RX2Ant = GetRX2Ant(rx2_band);
                        // RX2Ant = GetRX2Ant(rx1_band); // original
                    }

                    if (current_model == Model.FLEX1500) // ke9ns add 1500
                    {
                        TXAnt1500 = GetTXAnt1500(rx1_band);
                        RXAnt1500 = GetRXAnt1500(rx1_band);
                    }

                }
            }
        }

        private FWCAnt[] rx1_ant_by_band;
        public void SetRX1Ant(Band b, FWCAnt ant)
        {
            AA.Restart(); // ke9ns
            autoadjust1 = true; // ke9ns add for automatic water and pan level updates

            switch (current_ant_mode)
            {
                case AntMode.Simple:
                    RX1Ant = ant;
                    break;
                case AntMode.Expert:
                    if (initializing) return;
                    rx1_ant_by_band[(int)b] = ant;
                    if (rx1_band == b)
                    {
                        RX1Ant = ant;
                        //  if (FWCEEPROM.RX2OK) RX2Ant = GetRX2Ant(rx1_band); // ke9ns add
                    }

                    break;
            }
        }

        public FWCAnt GetRX1Ant(Band b)
        {
            FWCAnt ret = FWCAnt.ANT1;
            switch (current_ant_mode)
            {
                case AntMode.Simple:
                    ret = rx1_ant;
                    break;
                case AntMode.Expert:
                    ret = rx1_ant_by_band[(int)b];
                    break;
            }
            return ret;
        }

        private FWCAnt[] rx2_ant_by_band;
        public void SetRX2Ant(Band b, FWCAnt ant)
        {
            AA.Restart(); // ke9ns
            autoadjust1 = true; // ke9ns add for automatic water and pan level updates

            switch (current_ant_mode)
            {
                case AntMode.Simple:
                    RX2Ant = ant;
                    break;
                case AntMode.Expert:
                    if (initializing) return;
                    rx2_ant_by_band[(int)b] = ant;
                    if (rx2_band == b) RX2Ant = ant;
                    break;
            }
        }

        public FWCAnt GetRX2Ant(Band b)
        {
            FWCAnt ret = FWCAnt.ANT1;
            switch (current_ant_mode)
            {
                case AntMode.Simple:
                    ret = rx2_ant;
                    break;
                case AntMode.Expert:
                    ret = rx2_ant_by_band[(int)b];
                    break;
            }
            return ret;
        }

        private FWCAnt[] tx_ant_by_band;
        private FWCAnt[] tx_ant_by2_band; // ke9ns add .205
        public void SetTXAnt(Band b, FWCAnt ant)   // Called only by fwcAntForm.cs     b = comboband text from expertmode, ant is the TX ant
        {
            AA.Restart(); // ke9ns
            autoadjust1 = true; // ke9ns add for automatic water and pan level updates

            //   Debug.WriteLine("SetTXAnt: " + b + " , " + ant);

            switch (current_ant_mode)
            {
                case AntMode.Simple:
                    TXAnt = ant;
                    break;
                case AntMode.Expert:
                    if (initializing) return;

                    tx_ant_by_band[(int)b] = ant; // ke9ns set to ant selected in the antform

                    //ke9ns remove		if(tx_band == b)
                    TXAnt = ant; // ke9ns causes problems for openned radio in expert mode.

                    break;
            }
        } // SetTXAnt

        public FWCAnt GetTXAnt(Band b)
        {
            FWCAnt ret = FWCAnt.ANT1;
            switch (current_ant_mode)
            {
                case AntMode.Simple:
                    ret = tx_ant;
                    break;
                case AntMode.Expert:
                    ret = tx_ant_by_band[(int)b];
                    break;
            }

            //  Debug.WriteLine("GetTXAnt " + b + " , " + ret);

            return ret; // return which antenna to use for TX
        }

        // ke9ns add .205

        public void SetTXAnt2(Band b, FWCAnt ant)   // Called only by fwcAntForm.cs    b = comboband text from expertmode, ant is the TX ant
        {
            AA.Restart(); // ke9ns
            autoadjust1 = true; // ke9ns add for automatic water and pan level updates

            //  Debug.WriteLine("SetTXAnt2: " + b + " , " + ant);

            switch (current_ant_mode)
            {
                case AntMode.Simple:
                    TXAnt2 = ant;
                    break;
                case AntMode.Expert:
                    if (initializing) return;

                    tx_ant_by2_band[(int)b] = ant; // ke9ns set to ant selected in the antform

                    //ke9ns remove		if(tx_band == b)
                    TXAnt2 = ant; // ke9ns causes problems for openned radio in expert mode.

                    break;
            }
        } // SetTXAnt2

        public FWCAnt GetTXAnt2(Band b)
        {
            FWCAnt ret = FWCAnt.ANT1;
            switch (current_ant_mode)
            {
                case AntMode.Simple:
                    ret = tx_ant2;
                    break;
                case AntMode.Expert:
                    ret = tx_ant_by2_band[(int)b];
                    break;
            }

            //  Debug.WriteLine("GetTXAnt2 " + b + " , " + ret);

            return ret; // return which antenna to use for TX

        } // FWCAnt2

        private HIDAnt[] rx_ant_1500_by_band;
        public void SetRXAnt1500(Band b, HIDAnt ant)
        {
            switch (current_ant_mode)
            {
                case AntMode.Simple:
                    RXAnt1500 = ant;
                    break;
                case AntMode.Expert:
                    if (initializing) return;
                    rx_ant_1500_by_band[(int)b] = ant;
                    if (rx1_band == b) RXAnt1500 = ant;
                    break;
            }
        }

        public HIDAnt GetRXAnt1500(Band b)
        {
            HIDAnt ret = HIDAnt.PA;
            switch (current_ant_mode)
            {
                case AntMode.Simple:
                    ret = rx_ant_1500;
                    break;
                case AntMode.Expert:
                    ret = rx_ant_1500_by_band[(int)b];
                    break;
            }
            return ret;
        }

        private HIDAnt[] tx_ant_1500_by_band;
        public void SetTXAnt1500(Band b, HIDAnt ant)
        {
            switch (current_ant_mode)
            {
                case AntMode.Simple:
                    TXAnt1500 = ant;
                    break;
                case AntMode.Expert:
                    if (initializing) return;
                    tx_ant_1500_by_band[(int)b] = ant;
                    if (tx_band == b) TXAnt1500 = ant;
                    break;
            }
        }

        public HIDAnt GetTXAnt1500(Band b)
        {
            HIDAnt ret = HIDAnt.PA;
            switch (current_ant_mode)
            {
                case AntMode.Simple:
                    ret = tx_ant_1500;
                    break;
                case AntMode.Expert:
                    ret = tx_ant_1500_by_band[(int)b];
                    break;
            }
            return ret;
        }

        private bool[] rx1_loop_by_band;
        public void SetRX1Loop(Band b, bool on)
        {
            switch (current_ant_mode)
            {
                case AntMode.Simple:
                    RX1Loop = on;
                    break;
                case AntMode.Expert:
                    if (initializing) return;
                    rx1_loop_by_band[(int)b] = on;
                    if (rx1_band == b && !mox) RX1Loop = on;
                    break;
            }
        }

        public bool GetRX1Loop(Band b)
        {
            bool ret = false;
            switch (current_ant_mode)
            {
                case AntMode.Simple:
                    ret = rx1_loop;
                    break;
                case AntMode.Expert:
                    ret = rx1_loop_by_band[(int)b];
                    break;
            }
            return ret;
        }

        private bool mouse_tune_step = false;
        public bool MouseTuneStep
        {
            get { return mouse_tune_step; }
            set { mouse_tune_step = value; }
        }

        private bool new_power_cal = false;
        public bool NewPowerCal
        {
            get { return new_power_cal; }
            set { new_power_cal = value; }
        }

        public bool ShowCWTXFreq
        {
            get { return chkShowTXCWFreq.Checked; }
            set { chkShowTXCWFreq.Checked = value; }
        }


        // ke9ns add
        bool rtty = false; // value passed from spotdecoder
        public bool RTTY // display checks this
        {
            get
            {
                return rtty;

            }
            set
            {
                rtty = value;
            }
        } // rtty

        // ke9ns add
        bool rxcw = false; // true= enabled
        public bool RXCW // display checks this
        {
            get
            {
                return rxcw;
            }
            set
            {
                rxcw = value;
            }
        } // rxcw

        //=========================================================
        // ke9ns add for display to check if Beacon needs an freq avg signal strength reading
        public bool BeaconSigAvg
        {
            get
            {

                if ((SpotForm != null))
                {
                    if ((SpotForm.beacon5 > 0) || (SpotForm.beacon11 > 0) || (SpotForm.WTime == true)) return true;  // if Fast or Slow Beacon scanning is enabled or WWV checking

                    // Debug.WriteLine("BEACON SIG AVG");

                }

                return false;

            }


        } //  public bool BeaconSigAvg



        //=============================
        // ke9ns add  scheduler calls this to set audio to POST and 48k SR for small file size recordings
        public bool RECPOST
        {
            //  get { return WaveForm.checkBoxRecord.Checked; }
            set
            {

                if (value == true)
                {
                    WaveForm.RECPLAY = true;                 // this sets recording to POST (not IQ pre) 
                    WaveForm.RECPLAY2 = true;                // and reduces .wav to 48000 SR to save file size

                    WaveForm.checkBoxRecord.Checked = true; // start recording

                }
                else
                {
                    //  WaveForm.RECPLAY3 = true;                // and restores .wav to original SR size
                    WaveForm.checkBoxRecord.Checked = value; // start recording

                }


            }

        }

        public bool RECPOST1
        {
            //  get { return WaveForm.checkBoxRecord.Checked; }
            set
            {
                WaveForm.RECPLAY3 = true;                // and restores .wav to original SR size
            }

        }
        // ke9ns add when schedule recording comes up, turn WAVE RED
        public bool REC1
        {
            //  get { return WaveForm.checkBoxRecord.Checked; }
            set
            {
                if (value == false)
                {
                    waveToolStripMenuItem.ForeColor = SystemColors.ControlLightLight;
                    waveToolStripMenuItem.Text = "Wave";

                }
                else
                {
                    waveToolStripMenuItem.ForeColor = Color.Red;
                    waveToolStripMenuItem.Text = "Record";


                }
            }

        } // REC1

        // ke9ns add when schedule comes up, turn Memory RED
        public bool SCHED1
        {
            //  get { return WaveForm.checkBoxRecord.Checked; }
            set
            {
                if (value == false)
                {

                    memoryToolStripMenuItem.ForeColor = SystemColors.ControlLightLight;
                    memoryToolStripMenuItem.Text = "Memory";
                }
                else
                {

                    memoryToolStripMenuItem.ForeColor = Color.Red;
                    memoryToolStripMenuItem.Text = "Mem Sched";
                }
            }

        } // REC1



        public bool ShowTXFilter
        {
            get { return chkShowTXFilter.Checked; }
            set { chkShowTXFilter.Checked = value; }
        }

        public bool ShowDigTXFilter
        {
            get { return chkShowDigTXFilter.Checked; }
            set { chkShowDigTXFilter.Checked = value; }
        }

        private bool rx1_loop = false;
        public bool RX1Loop
        {
            get { return rx1_loop; }
            set
            {
                bool old = rx1_loop;
                rx1_loop = value;
                if (old != value || initializing)
                {
                    FWC.SetRX1Loop(rx1_loop);

                    if (rx1_loop)
                        rx1_loop_offset = loop_gain;
                    else rx1_loop_offset = 0.0f;
                    if (rx2_ant == FWCAnt.RX1TAP)
                        rx2_loop_offset = rx1_loop_offset;
                    UpdateDisplayOffsets();
                }
            }
        }


        // ke9ns add .213
        bool SO2R = false;          // b6   64   0=RX2 BNC input  to RX2 receiver , 1=ANT1 to RX2 (if k11 off, K9 ON)
        bool TXMON = false;         // b7   128  0=ATU/PA output -80 dBc down signal sent to K4off = to RX1 out BNC or k4on = to RX1 input (for calibration purposes)
        bool EXTR = false;          // b14  16384
        bool XVTR = false;          // b11  2048    0=RX1 receive, 1= XVTR/COM sent to XVTX J15 on transmit
        bool XVCOM = false;         // b9   512    0=RX1 set to XVRX BNC for input, 1=RX1 set to XVTX/COM BNC for input
        bool XVEN = false;          // b12  4096   0=normal, 1= xvtr BNC inputs or VU5K
        bool XVINT = false;         // b10  1024   0=normal, 1= VU5K


        // ke9ns add .213
        public void XVTR_RELAY()
        {

            // I2C_ReadValue(ushort addr, out uint val)

            uint temp = 0; // ke9ns .213

            temp = 0;

            FWC.I2C_HFIO(out temp);


            Debug.WriteLine("XVTR = : " + temp.ToString());


            /*
                        if ((temp & 64) == 64) SO2R = true;
                        else SO2R = false;
                        if ((temp & 128) == 128) TXMON = true;
                        else TXMON = false;
                        if ((temp & 512) == 512) XVCOM = true;
                        else XVCOM = false;
                        if ((temp & 1024) == 1024) XVINT = true;
                        else XVINT = false;
                        if ((temp & 2048) == 2048) XVTR = true;
                        else XVTR = false;
                        if ((temp & 4096) == 4096) XVEN = true;
                        else XVEN = false;
                        if ((temp & 16384) == 16384) EXTR = true;
                        else EXTR = false;

                        Debug.WriteLine("SO2R: " + SO2R);
                        Debug.WriteLine("TXMON: " + TXMON);

                        Debug.WriteLine("TXCOM: " + XVCOM);
                        Debug.WriteLine("XVINT: " + XVINT);
                        Debug.WriteLine("XVTR: " + XVTR);
                       Debug.WriteLine("XVEN: " + XVEN);
                        Debug.WriteLine("EXTR: " + EXTR);
            */
            Debug.WriteLine(" \r\n");


        } // XVTR_READ

        //=============================================================================
        private bool vu_ant = false;
        private FWCAnt rx1_ant = FWCAnt.ANT1;
        public FWCAnt RX1Ant
        {
            get { return rx1_ant; }
            set
            {
                if (!fwc_init || current_model != Model.FLEX5000) return;

                FWCAnt old = rx1_ant;
                rx1_ant = value;

                Debug.WriteLine("XVTR2: " + rx1_xvtr_index + " , " + rx1_ant);

                if (FWCEEPROM.VUOK)
                {
                    if (rx1_xvtr_index == 0)
                    {
                        lblAntRX1a.Text = "VHF";
                        lblAntTXa.Text = "VHF";

                        rx1_path_offset = 0.0f;
                        return;
                    }
                    else if (rx1_xvtr_index == 1)
                    {
                        lblAntRX1a.Text = "UHF";
                        lblAntTXa.Text = "UHF";
                        rx1_path_offset = 0.0f;
                        return;
                    }

                }

                if (value != old || initializing || vu_ant)
                {
                    switch (rx1_ant)
                    {
                        case FWCAnt.NC:
                            lblAntRX1a.Text = "N/C";
                            FWC.SetRX1Ant(0);
                            break;
                        case FWCAnt.ANT1:
                            lblAntRX1a.Text = "ANT1";
                            FWC.SetRX1Ant(1);
                            rx1_path_offset = 0.5f;
                            break;
                        case FWCAnt.ANT2:
                            lblAntRX1a.Text = "ANT2";
                            FWC.SetRX1Ant(2);
                            rx1_path_offset = 0.5f;
                            break;
                        case FWCAnt.ANT3:
                            lblAntRX1a.Text = "ANT3";
                            FWC.SetRX1Ant(3);
                            rx1_path_offset = 0.5f;
                            break;
                        case FWCAnt.RX1IN:
                            lblAntRX1a.Text = "RX1 IN";
                            FWC.SetRX1Ant(4);
                            rx1_path_offset = 0.0f;
                            break;
                        case FWCAnt.SIG_GEN:
                            lblAntRX1a.Text = "Sig Gen";
                            rx1_path_offset = 0.0f;
                            break;
                        case FWCAnt.VHF:
                            lblAntRX1a.Text = "VHF";
                            lblAntTXa.Text = "VHF";
                            rx1_path_offset = 0.0f;
                            break;
                        case FWCAnt.UHF:
                            lblAntRX1a.Text = "UHF";
                            lblAntTXa.Text = "UHF";
                            rx1_path_offset = 0.0f;
                            break;
                    } // switch (rx1_ant)

                    UpdateDisplayOffsets();
                    if (FWCEEPROM.RX2OK && rx2_ant == FWCAnt.RX1TAP)
                    {
                        RX2Ant = rx2_ant;
                    }
                }




            } // set
        } // RX1Ant

        private FWCAnt rx2_ant = FWCAnt.RX2IN;
        public FWCAnt RX2Ant
        {
            get { return rx2_ant; }
            set
            {
                if (!fwc_init || current_model != Model.FLEX5000) return;

                FWCAnt old = rx2_ant;
                rx2_ant = value;

                if (FWCEEPROM.VUOK)
                {
                    if (rx2_xvtr_index == 0)
                    {
                        lblAntRX2a.Text = "VHF";
                        lblAntTX2a.Text = "VHF";
                        rx2_path_offset = 0.0f;
                        FWC.SetRX2Ant(5); // RX2 In
                        return;
                    }
                    else if (rx2_xvtr_index == 1)
                    {
                        lblAntRX2a.Text = "UHF";
                        lblAntTX2a.Text = "UHF";
                        rx2_path_offset = 0.0f;
                        FWC.SetRX2Ant(5); // RX2 In
                        return;
                    }
                }

                if (old != value || initializing || vu_ant)
                {
                    switch (rx2_ant)
                    {
                        case FWCAnt.ANT1:
                            lblAntRX2a.Text = "ANT1";
                            FWC.SetRX2Ant(1);
                            rx2_path_offset = -rx2_res_offset - 2.9f;
                            rx2_loop_offset = 0.0f;
                            break;
                        case FWCAnt.RX2IN:
                            lblAntRX2a.Text = "RX2 IN";
                            FWC.SetRX2Ant(5);
                            rx2_path_offset = -rx2_res_offset - 2.8f;
                            rx2_loop_offset = 0.0f;
                            break;
                        case FWCAnt.RX1TAP:
                            lblAntRX2a.Text = "RX1 Tap";
                            FWC.SetRX2Ant(6);
                            switch (rx1_ant)
                            {
                                case FWCAnt.ANT1:
                                case FWCAnt.ANT2:
                                case FWCAnt.ANT3:
                                    rx2_path_offset = 0.6f;
                                    break;
                                case FWCAnt.RX1IN:
                                case FWCAnt.SIG_GEN:
                                    rx2_path_offset = 0.0f;
                                    break;
                            }
                            rx2_loop_offset = rx1_loop_offset;
                            break;
                        case FWCAnt.NC:
                            lblAntRX2a.Text = "N/C";
                            FWC.SetRX2Ant(0);
                            rx2_path_offset = -rx2_res_offset - 2.8f;
                            rx2_loop_offset = 0.0f;
                            break;
                        case FWCAnt.VHF:
                            lblAntRX2a.Text = "VHF";
                            lblAntTX2a.Text = "VHF";
                            rx2_path_offset = 0.0f;
                            break;
                        case FWCAnt.UHF:
                            lblAntRX2a.Text = "UHF";
                            lblAntTX2a.Text = "UHF";
                            rx2_path_offset = 0.0f;
                            break;
                        default:
                            FWC.SetRX2Ant(5);
                            lblAntRX2a.Text = "RX2 IN";
                            rx2_path_offset = -2.0f;
                            rx2_loop_offset = 0.0f;
                            break;
                    }
                    UpdateDisplayOffsets();
                }
            }
        }

        private HIDAnt rx_ant_1500 = HIDAnt.PA;
        public HIDAnt RXAnt1500
        {
            get { return rx_ant_1500; }
            set
            {
                if (!hid_init || current_model != Model.FLEX1500) return;
                HIDAnt old = rx_ant_1500;
                rx_ant_1500 = value;
                if (value != old || initializing)
                {
                    switch (rx_ant_1500)
                    {
                        case HIDAnt.PA:
                            lblAntRX1a.Text = "PA";
                            USBHID.SetRXAnt(0);
                            break;
                        case HIDAnt.XVTX_COM:
                            lblAntRX1a.Text = "XVTX/COM";
                            USBHID.SetRXAnt(2);
                            break;
                        case HIDAnt.XVRX:
                            lblAntRX1a.Text = "XVRX";
                            USBHID.SetRXAnt(1);
                            break;
                        case HIDAnt.BITE:
                            lblAntRX1a.Text = "BITE";
                            USBHID.SetRXAnt(3);
                            break;
                    }
                }
            }
        }

        bool tx_ant_6m_reset = false;
        private FWCAnt tx_ant = FWCAnt.ANT1;
        private FWCAnt tx_ant2 = FWCAnt.ANT1; // ke9ns add .205

        public FWCAnt TXAnt
        {
            get
            {
                //  Debug.WriteLine("GET TXAnt: " + tx_ant + " 2: " + tx_ant2);    
                return tx_ant;
            }
            set
            {

                if (!fwc_init || current_model != Model.FLEX5000) return;
                Debug.WriteLine("SET TXAnt: " + tx_ant + " , " + value);

                FWCAnt old = 0;
                tx_ant = value;

                Debug.WriteLine("XVTR TXAnt: " + rx1_xvtr_index);


                //  if (old != value || tx_ant_6m_reset || initializing || tx_cal || value != tx_ant2)
                //  {
                if (tx_ant_6m_reset) tx_ant_6m_reset = false;

                if (fwcAntForm != null && fwcAntForm.chkTX2Active.Checked) // so2r checked
                {
                    if (lblAntRX2a.Text == "VHF")
                    {
                        lblAntTX2a.Text = "VHF";
                    }
                    else if (lblAntRX2a.Text == "UHF")
                    {
                        lblAntTX2a.Text = "UHF";
                    }
                    else
                    {
                        switch (tx_ant2) // .212
                        {
                            case FWCAnt.ANT1:
                                lblAntTX2a.Text = "ANT1"; // ke9ns mod (add 2 spaces)
                                if (chkVFOBTX.Checked) FWC.SetTXAnt(1);
                                break;
                            case FWCAnt.ANT2:
                                lblAntTX2a.Text = "ANT2";
                                if (chkVFOBTX.Checked) FWC.SetTXAnt(2);
                                break;
                            case FWCAnt.ANT3:
                                lblAntTX2a.Text = "ANT3";
                                if (chkVFOBTX.Checked) FWC.SetTXAnt(3);
                                break;
                        }
                    }

                    lblAntTX.Text = "TX1:";
                    if (lblAntRX1a.Text == "VHF")
                    {
                        lblAntTXa.Text = "VHF";

                    }
                    else if (lblAntRX1a.Text == "UHF")
                    {
                        lblAntTXa.Text = "UHF";

                    }
                    else if ((rx1_xvtr_index > 1) && current_model == Model.FLEX5000) // .213
                    {
                        if (xvtrForm.GetXVTRRF(rx1_xvtr_index) == true)
                        {

                            lblAntRX1a.Text = "XVRX";
                            lblAntTXa.Text = "XVTX";
                        }
                        else
                        {
                            lblAntRX1a.Text = "XVTX/C";
                            lblAntTXa.Text = "XVTX/C";
                        }

                    }
                    else
                    {
                        switch (tx_ant)
                        {

                            case FWCAnt.ANT1:
                                lblAntTXa.Text = "ANT1"; // ke9ns mod (add 2 spaces)
                                if (!chkVFOBTX.Checked) FWC.SetTXAnt(1);
                                break;
                            case FWCAnt.ANT2:
                                lblAntTXa.Text = "ANT2";
                                if (!chkVFOBTX.Checked) FWC.SetTXAnt(2);
                                break;
                            case FWCAnt.ANT3:
                                lblAntTXa.Text = "ANT3";
                                if (!chkVFOBTX.Checked) FWC.SetTXAnt(3);
                                break;
                        }
                    }
                } // rx2 present
                else
                {
                    lblAntTX.Text = "TX :";

                    if (lblAntRX1a.Text == "VHF")
                    {
                        lblAntTXa.Text = "VHF";

                    }
                    else if (lblAntRX1a.Text == "UHF")
                    {
                        lblAntTXa.Text = "UHF";

                    }
                    else if ((rx1_xvtr_index > 1) && current_model == Model.FLEX5000) // .213
                    {
                        if (xvtrForm.GetXVTRRF(rx1_xvtr_index) == true)
                        {

                            lblAntRX1a.Text = "XVRX";
                            lblAntTXa.Text = "XVTX";
                        }
                        else
                        {
                            lblAntRX1a.Text = "XVTX/C";
                            lblAntTXa.Text = "XVTX/C";
                        }

                    }

                    else
                    {
                        switch (tx_ant)
                        {
                            case FWCAnt.ANT1:
                                lblAntTXa.Text = "ANT1"; // ke9ns mod (add 2 spaces)
                                FWC.SetTXAnt(1);
                                break;
                            case FWCAnt.ANT2:
                                lblAntTXa.Text = "ANT2";
                                FWC.SetTXAnt(2);
                                break;
                            case FWCAnt.ANT3:
                                lblAntTXa.Text = "ANT3";
                                FWC.SetTXAnt(3);
                                break;
                        }
                    }

                    if (lblAntRX2a.Text == "VHF")
                    {
                        lblAntTX2a.Text = "VHF";

                    }
                    else if (lblAntRX2a.Text == "UHF")
                    {
                        lblAntTX2a.Text = "UHF";

                    }
                    else
                    {
                        switch (tx_ant2) // .212
                        {
                            case FWCAnt.ANT1:
                                lblAntTX2a.Text = "ANT1"; // ke9ns mod (add 2 spaces)

                                break;
                            case FWCAnt.ANT2:
                                lblAntTX2a.Text = "ANT2";

                                break;
                            case FWCAnt.ANT3:
                                lblAntTX2a.Text = "ANT3";

                                break;
                        }
                    }
                } // no 2nd rx2



                //   } // need to update the text in the ant panel
            }
        } // TXAnt

        //ke9ns add .205
        public FWCAnt TXAnt2
        {
            get
            {
                //  Debug.WriteLine("GET TXAnt2: " + tx_ant + " 2: " + tx_ant2);

                return tx_ant2;
            }
            set
            {

                if (!fwc_init || current_model != Model.FLEX5000) return;
                Debug.WriteLine("SET TXAnt2: " + value + " 2: " + tx_ant2 + " , " + lblAntRX2a.Text + " , " + lblAntTX2a.Text);

                FWCAnt old = 0;
                tx_ant2 = value;

                //  if (old != value || tx_ant_6m_reset || initializing || tx_cal || value != tx_ant) // ke9ns mod .205
                //  {
                if (tx_ant_6m_reset) tx_ant_6m_reset = false;


                if (lblAntRX2a.Text == "VHF")
                {
                    lblAntTX2a.Text = "VHF";

                }
                else if (lblAntRX2a.Text == "UHF")
                {
                    lblAntTX2a.Text = "UHF";

                }
                else
                {
                    switch (tx_ant2)
                    {
                        case FWCAnt.ANT1:
                            lblAntTX2a.Text = "ANT1"; // ke9ns mod (add 2 spaces)
                            if (chkVFOBTX.Checked) FWC.SetTXAnt(1);
                            break;
                        case FWCAnt.ANT2:
                            lblAntTX2a.Text = "ANT2";
                            if (chkVFOBTX.Checked) FWC.SetTXAnt(2);
                            break;
                        case FWCAnt.ANT3:
                            lblAntTX2a.Text = "ANT3";
                            if (chkVFOBTX.Checked) FWC.SetTXAnt(3);
                            break;
                    }
                    //  }


                    if (lblAntRX1a.Text == "VHF")
                    {
                        lblAntTXa.Text = "VHF";

                    }
                    else if (lblAntRX1a.Text == "UHF")
                    {
                        lblAntTXa.Text = "UHF";

                    }
                    else
                    {

                        switch (tx_ant)
                        {
                            case FWCAnt.ANT1:
                                lblAntTXa.Text = "ANT1"; // ke9ns mod (add 2 spaces)
                                if (!chkVFOBTX.Checked) FWC.SetTXAnt(1);
                                break;
                            case FWCAnt.ANT2:
                                lblAntTXa.Text = "ANT2";
                                if (!chkVFOBTX.Checked) FWC.SetTXAnt(2);
                                break;
                            case FWCAnt.ANT3:
                                lblAntTXa.Text = "ANT3";
                                if (!chkVFOBTX.Checked) FWC.SetTXAnt(3);
                                break;
                        }

                    }


                }
            }
        } // TXAnt2


        private HIDAnt tx_ant_1500 = HIDAnt.PA;
        public HIDAnt TXAnt1500
        {
            get { return tx_ant_1500; }
            set
            {
                if (!hid_init || current_model != Model.FLEX1500) return;
                HIDAnt old = tx_ant_1500;
                tx_ant_1500 = value;
                if (old != value || initializing)
                {
                    lblAntTX.Text = "TX :"; // .212

                    switch (tx_ant_1500)
                    {
                        case HIDAnt.PA:
                            lblAntTXa.Text = "PA"; // .212 mod
                            USBHID.SetTXAnt(0);
                            Set1500Filters(VFOAFreq);
                            break;
                        case HIDAnt.XVTX_COM:
                            lblAntTXa.Text = "XVTX/COM";
                            USBHID.SetTXAnt(2);
                            HIDPAFilter = 0;
                            break;
                        case HIDAnt.BITE:
                            lblAntTXa.Text = "BITE";
                            USBHID.SetTXAnt(3);
                            HIDPAFilter = 0;
                            break;
                    }
                }
            }
        }

        private bool zero_beat_rit = false;
        public bool ZeroBeatRIT
        {
            get { return zero_beat_rit; }
            set { zero_beat_rit = value; }
        }

        private float fwc_preamp_offset = 13.0f;
        public float FWCPreampOffset
        {
            get { return fwc_preamp_offset; }
            set { fwc_preamp_offset = value; }
        }

        /*private bool fwc_att_on = false;
		public bool FWCATTOn
		{
			get { return fwc_att_on; }
			set
			{
				fwc_att_on = value;
				FWC.SetAttOn(fwc_index, fwc_att_on);
				UpdateDisplayOffset();
			}
		}*/

        /*private float[] fwc_att_offset = new float[32];
		private int fwc_att_val = 0;
		public int FWCATTVal
		{
			get { return fwc_att_val; }
			set
			{
				fwc_att_val = value;
				FWC.SetAttVal(fwc_index, fwc_att_val);
				UpdateDisplayOffset();
			}
		}*/

        private float meter_offset = 0.0f;
        private void UpdateDisplayOffsets()
        {
            Display.RX1PreampOffset = rx1_preamp_offset[(int)rx1_preamp_mode];
            Display.RX2PreampOffset = rx2_preamp_offset[(int)rx2_preamp_mode];
            Display.RX1DisplayCalOffset = rx1_level_table[(int)rx1_band][0] + rx1_path_offset + rx1_xvtr_gain_offset + rx1_loop_offset;
            Display.RX2DisplayCalOffset = rx2_level_table[(int)rx2_band][0] + rx2_path_offset + rx2_xvtr_gain_offset + rx2_loop_offset;

        }

        private bool snap_to_click_tuning = true;
        public bool SnapToClickTuning
        {
            get { return snap_to_click_tuning; }
            set { snap_to_click_tuning = value; }
        }

        private bool xvtr_tune_power = false;
        public bool XVTRTunePower
        {
            get { return xvtr_tune_power; }
            set { xvtr_tune_power = value; }
        }

        public bool DisableToolTips
        {
            set
            {
                if (toolTip1 != null) toolTip1.Active = !value;
            }
        }

        public bool X2TR
        {
            get
            {
                if (chkX2TR != null) return chkX2TR.Checked;
                else return false;
            }
            set
            {
                if (chkX2TR != null) chkX2TR.Checked = value;
            }
        }

        public string TXProfile
        {
            get
            {
                if (comboTXProfile != null) return comboTXProfile.Text;
                else return "";
            }
            set
            {
                if (comboTXProfile != null) comboTXProfile.Text = value;
                if (comboDigTXProfile != null) comboDigTXProfile.Text = value;
                if (comboCWTXProfile != null) comboCWTXProfile.Text = value;  // ke9ns add to show TX profile on all the panels of the main console
                if (comboFMTXProfile != null) comboFMTXProfile.Text = value; // ke9ns add

            }
        }

        private string vac_sample_rate = "48000";
        public string VACSampleRate
        {
            get { return vac_sample_rate; }

            set
            {
                vac_sample_rate = value;

                if (comboVACSampleRate != null && !(chkVAC2.Checked && chkVFOBTX.Checked))
                {
                    comboVACSampleRate.Text = value;
                }
            }
        }

        private string vac2_sample_rate = "48000";
        public string VAC2SampleRate
        {
            get { return vac2_sample_rate; }

            set
            {
                vac2_sample_rate = value;

                if (comboVACSampleRate != null && chkVAC2.Checked && chkVFOBTX.Checked)
                {
                    comboVACSampleRate.Text = value;
                }
            }
        }
        private bool vac_stereo = false;
        public bool VACStereo
        {
            get { return vac_stereo; }

            set
            {
                vac_stereo = value;

                if (chkVACStereo != null && !(chkVAC2.Checked && chkVFOBTX.Checked))
                {
                    chkVACStereo.Checked = value;
                }
            }
        }

        private bool vac2_stereo = false;
        public bool VAC2Stereo
        {
            get { return vac2_stereo; }

            set
            {
                vac2_stereo = value;

                if (chkVACStereo != null && chkVAC2.Checked && chkVFOBTX.Checked)
                {
                    chkVACStereo.Checked = value;
                }
            }
        }

        public bool CWIambic
        {
            get
            {
                if (chkCWIambic != null) return chkCWIambic.Checked;
                else return false;
            }

            set
            {
                if (chkCWIambic != null) chkCWIambic.Checked = value;
            }
        }

        //================================================================
        //================================================================
        // ke9ns  comes here after you go to setup->appearance-> meters
        // used to cycle through and select meter from list
        //================================================================
        //================================================================
        private MultiMeterDisplayMode current_meter_display_mode = MultiMeterDisplayMode.Analog; // ke9ns mod was Edge
        public MultiMeterDisplayMode CurrentMeterDisplayMode
        {
            get { return current_meter_display_mode; }
            set
            {
                switch (current_meter_display_mode)
                {

                    case MultiMeterDisplayMode.Edge:
                        switch (value) // value = CurrentMeterDisplayMode being passed into this routine
                        {
                            case MultiMeterDisplayMode.Edge:
                                picMultiMeterDigital.Invalidate();
                                picMultiMeterDigital.BackColor = edge_meter_background_color;

                                if (meterCombo == true) picRX3Meter.Invalidate(); // ke9ns12 add
                                else picRX2Meter.Invalidate(); // ke9ns12 add

                                //  picRX2Meter.Invalidate();
                                picRX2Meter.BackColor = edge_meter_background_color;
                                break; // edge

                            case MultiMeterDisplayMode.Original:
                                picMultiMeterDigital.Invalidate();
                                picMultiMeterDigital.BackColor = meter_background_color;

                                picRX2Meter.Invalidate();
                                picRX2Meter.BackColor = meter_background_color;
                                break; // original

                            case MultiMeterDisplayMode.Analog:

                                picMultiMeterDigital.BackColor = analog_meter_background_color;
                                picMultiMeterDigital.Invalidate();

                                picRX2Meter.BackColor = analog_meter_background_color;
                                picRX2Meter.Invalidate();

                                break; // original
                        }
                        break; // edge

                    case MultiMeterDisplayMode.Original:
                        switch (value)
                        {
                            case MultiMeterDisplayMode.Edge:
                                picMultiMeterDigital.Invalidate();
                                picMultiMeterDigital.BackColor = edge_meter_background_color;

                                if (meterCombo == true) picRX3Meter.Invalidate(); // ke9ns12 add
                                else picRX2Meter.Invalidate(); // ke9ns12 add

                                //picRX2Meter.Invalidate();
                                picRX2Meter.BackColor = edge_meter_background_color;
                                break; // edge

                            case MultiMeterDisplayMode.Original:
                                picMultiMeterDigital.Invalidate();
                                picMultiMeterDigital.BackColor = meter_background_color;
                                picRX2Meter.Invalidate();
                                picRX2Meter.BackColor = meter_background_color;
                                break; // original

                            case MultiMeterDisplayMode.Analog:
                                picMultiMeterDigital.BackColor = analog_meter_background_color;
                                picMultiMeterDigital.Invalidate();

                                picRX2Meter.BackColor = analog_meter_background_color;
                                picRX2Meter.Invalidate();

                                break; // original

                        }

                        break; // original

                    case MultiMeterDisplayMode.Analog:
                        switch (value)
                        {
                            case MultiMeterDisplayMode.Edge:
                                picMultiMeterDigital.Invalidate();
                                picMultiMeterDigital.BackColor = edge_meter_background_color;

                                if (meterCombo == true) picRX3Meter.Invalidate(); // ke9ns12 add
                                else picRX2Meter.Invalidate(); // ke9ns12 add

                                //picRX2Meter.Invalidate();
                                picRX2Meter.BackColor = edge_meter_background_color;
                                break; // edge

                            case MultiMeterDisplayMode.Original:
                                picMultiMeterDigital.Invalidate();
                                picMultiMeterDigital.BackColor = meter_background_color;
                                picRX2Meter.Invalidate();
                                picRX2Meter.BackColor = meter_background_color;
                                break; // original

                            case MultiMeterDisplayMode.Analog:
                                picMultiMeterDigital.BackColor = analog_meter_background_color;
                                picMultiMeterDigital.Invalidate();

                                picRX2Meter.BackColor = analog_meter_background_color;
                                picRX2Meter.Invalidate();

                                break; // original

                        }

                        break; // analog

                } //switch(current_meter_display_mode

                current_meter_display_mode = value;
                picMultiMeterDigital.Invalidate();

            } // set


        } // MultiMeterDisplayMode CurrentMeterDisplayMode
          //==========================================================================================


        private static Color gen_background_color = SystemColors.Control;//k6jca 1/13/08

        public Color GenBackgroundColor                           //k6jca  1/13/08
        {
            get
            {
                return gen_background_color;
            }
            set
            {
                /*gen_background_color = value;
				this.BackColor = value;
				grpVFOA.BackColor = value;
				grpVFOB.BackColor = value;*/
            }
        }

        public bool VFOSync
        {
            get { return chkVFOSync.Checked; }
            set { chkVFOSync.Checked = value; }
        }

        private static Color vfo_background_color = Color.Black;
        public Color VFOBackgroundColor
        {
            get { return vfo_background_color; }
            set
            {
                vfo_background_color = value;
                txtVFOAFreq.BackColor = value;
                txtVFOAMSD.BackColor = value;
                txtVFOALSD.BackColor = value;
                txtVFOBFreq.BackColor = value;
                txtVFOBMSD.BackColor = value;
                txtVFOBLSD.BackColor = value;
                panelVFOAHover.BackColor = value;
                panelVFOBHover.BackColor = value;
            }
        }

        private static Color meter_digital_text_color = Color.Yellow;
        public Color MeterDigitalTextColor
        {
            get { return meter_digital_text_color; }
            set
            {
                meter_digital_text_color = value;
                txtMultiText.ForeColor = value;
                txtRX2Meter.ForeColor = value;
            }
        }

        private static Color meter_digital_background_color = Color.Black;
        public Color MeterDigitalBackgroundColor
        {
            get { return meter_digital_background_color; }
            set
            {
                meter_digital_background_color = value;
                txtMultiText.BackColor = value;
                txtRX2Meter.BackColor = value;
            }
        }

        private static Color band_background_color = Color.Black;
        public Color BandBackgroundColor
        {
            get { return band_background_color; }
            set
            {
                band_background_color = value;
                txtVFOABand.BackColor = value;
                txtVFOBBand.BackColor = value;
            }
        }


        //===========================================================================
        // ke9ns EDGE meter colors
        private static Color edge_meter_background_color = Color.Black;
        public Color EdgeMeterBackgroundColor
        {
            get { return edge_meter_background_color; }
            set
            {
                edge_meter_background_color = value;

                if (current_meter_display_mode == MultiMeterDisplayMode.Edge)
                {
                    picMultiMeterDigital.BackColor = value; // background is black
                    picMultiMeterDigital.Invalidate();

                    picRX2Meter.BackColor = value;

                    if (meterCombo == true) picRX3Meter.Invalidate(); // ke9ns12 add
                    else picRX2Meter.Invalidate(); // ke9ns12 add

                    //  picRX2Meter.Invalidate();  // RX2
                }
                else if (current_meter_display_mode == MultiMeterDisplayMode.Original)
                {
                    picMultiMeterDigital.BackColor = Color.Black; // background is black
                    picMultiMeterDigital.Invalidate();

                    picRX2Meter.BackColor = Color.Black;
                    picRX2Meter.Invalidate();  // RX2
                }


            } // set
        }

        private static Color edge_low_color = Color.White;
        public Color EdgeLowColor
        {
            get { return edge_low_color; }
            set
            {
                edge_low_color = value;
                if (current_meter_display_mode == MultiMeterDisplayMode.Edge)
                {
                    picMultiMeterDigital.Invalidate();

                    if (meterCombo == true) picRX3Meter.Invalidate(); // ke9ns12 add
                    else picRX2Meter.Invalidate(); // ke9ns12 add

                    //  picRX2Meter.Invalidate();
                }
            }
        }

        private static Color edge_high_color = Color.Red;
        public Color EdgeHighColor
        {
            get { return edge_high_color; }
            set
            {
                edge_high_color = value;
                if (current_meter_display_mode == MultiMeterDisplayMode.Edge)
                {
                    picMultiMeterDigital.Invalidate();
                    if (meterCombo == true) picRX3Meter.Invalidate(); // ke9ns12 add
                    else picRX2Meter.Invalidate(); // ke9ns12 add

                    //picRX2Meter.Invalidate();
                }
            }
        }

        private static Color edge_avg_color = Color.Yellow;  // ke9ns needle color
        public Color EdgeAVGColor
        {
            get { return edge_avg_color; }
            set
            {
                edge_avg_color = value;
                if (current_meter_display_mode == MultiMeterDisplayMode.Edge)
                {
                    picMultiMeterDigital.Invalidate();
                    if (meterCombo == true) picRX3Meter.Invalidate(); // ke9ns12 add
                    else picRX2Meter.Invalidate(); // ke9ns12 add

                    //   picRX2Meter.Invalidate();
                }

            }
        }


        //===========================================================================
        // ke9ns ANALOG meter colors

        private static Color analog_low_color = Color.White;
        public Color AnalogLowColor
        {
            get { return analog_low_color; }
            set
            {
                analog_low_color = value;
                if (current_meter_display_mode == MultiMeterDisplayMode.Analog)
                {
                    picMultiMeterDigital.Invalidate();
                    picRX2Meter.Invalidate();
                }
            }
        }

        private static Color analog_high_color = Color.Red;
        public Color AnalogHighColor
        {
            get { return analog_high_color; }
            set
            {
                analog_high_color = value;
                if (current_meter_display_mode == MultiMeterDisplayMode.Analog)
                {
                    picMultiMeterDigital.Invalidate();
                    picRX2Meter.Invalidate(); //  if (chkRX2.Checked)
                }
            }
        }

        private static Color analog_avg_color = Color.Yellow;  // ke9ns needle color
        public Color AnalogAVGColor
        {
            get { return analog_avg_color; }
            set
            {
                analog_avg_color = value;
                if (current_meter_display_mode == MultiMeterDisplayMode.Analog)
                {
                    picMultiMeterDigital.Invalidate();
                    picRX2Meter.Invalidate();
                }

            }
        }


        //====================================================================================
        // ke9ns add
        private bool meterLMB = false; // light meter background = true
        private bool meterDMB = false; // dark meter background = true
        public bool meterCombo = false; // combo meter background = true

        // ke9ns add
        public bool AnalogMeterLMB
        {

            get { return meterLMB; }
            set
            {
                meterLMB = value;
            }

        } // AnalogMeterLMB

        // ke9ns add
        public bool AnalogMeterDMB
        {

            get { return meterDMB; }
            set
            {
                meterDMB = value;
            }

        } // AnalogMeterDMB

        // ke9ns add 
        public bool ComboMeter
        {

            get { return meterCombo; }
            set
            {
                meterCombo = value;
            }

        } // ComboMeter

        private bool meterPointer = false;
        public bool AnalogPointer
        {

            get { return meterPointer; }
            set
            {
                meterPointer = value;
            }

        } // AnalogMeterDMB

        private static Color analog_meter_background_color = Color.Black;
        public Color AnalogMeterBackgroundColor
        {
            get { return analog_meter_background_color; }
            set
            {
                analog_meter_background_color = value;

                if (current_meter_display_mode == MultiMeterDisplayMode.Analog)
                {
                    picMultiMeterDigital.BackColor = value; // background is black
                    picMultiMeterDigital.Invalidate();

                    picRX2Meter.BackColor = value;
                    picRX2Meter.Invalidate();  // RX2
                }
                else if (current_meter_display_mode == MultiMeterDisplayMode.Original)
                {
                    picMultiMeterDigital.BackColor = Color.Black; // background is black
                    picMultiMeterDigital.Invalidate();

                    picRX2Meter.BackColor = Color.Black;
                    picRX2Meter.Invalidate();  // RX2
                }


            }// set


        } // AnalogMeterBackgroundcolor


        private static Color meter_background_color = Color.Black; // ke9ns used by original meter 
        /*
                public Color MeterBackgroundColor
                {
                    get { return meter_background_color; }
                    set
                    {
                        meter_background_color = value;
                        if (current_meter_display_mode == MultiMeterDisplayMode.Original)
                        {

                            picMultiMeterDigital.BackColor = value;
                            picMultiMeterDigital.Invalidate();

                            picRX2Meter.BackColor = value;
                            if (chkRX2.Checked) picRX2Meter.Invalidate();

                        }
                    }
                }
        */
        //=======================================================================


        private static Color peak_background_color = Color.Black;
        public Color PeakBackgroundColor
        {
            get { return peak_background_color; }
            set
            {
                peak_background_color = value;
                txtDisplayCursorOffset.BackColor = value;
                txtDisplayCursorPower.BackColor = value;
                txtDisplayCursorFreq.BackColor = value;

                txtDisplayPeakOffset.BackColor = value;
                txtDisplayPeakPower.BackColor = value;
                txtDisplayPeakFreq.BackColor = value;

                autoBrightBox.BackColor = value; // ke9ns add
                ScreenCap.BackColor = value; // ke9ns add
                ScreenCap1.BackColor = value;
            }
        }

        private bool small_lsd = true;
        public bool SmallLSD
        {
            get { return small_lsd; }
            set
            {
                small_lsd = value;
                txtVFOALSD.Visible = value;
                txtVFOAMSD.Visible = value;
                txtVFOBLSD.Visible = value;
                txtVFOBMSD.Visible = value;
            }
        }

        private static Color small_vfo_color = Color.OrangeRed;
        public Color SmallVFOColor
        {
            get { return small_vfo_color; }
            set
            {
                small_vfo_color = value;
                if (small_lsd && chkPower.Checked)
                {
                    txtVFOALSD.ForeColor = small_vfo_color;
                    if (chkVFOSplit.Checked)
                        txtVFOBLSD.ForeColor = small_vfo_color;
                }
            }
        }


        //============================================================
        // ke9ns add
        private Color ring_vfo_color = Color.DarkGreen;
        public Color RingVFOColor
        {
            get { return ring_vfo_color; }
            set
            {
                ring_vfo_color = value;
                grpVFOA.Invalidate();
                grpVFOB.Invalidate();
                grpMultimeter.Invalidate();
                grpRX2Meter.Invalidate();
                grpVFOBetween.Invalidate();
                panelDateTime.Invalidate();
                panelAntenna.Invalidate();
                panelOptions.Invalidate();

                //  panelTS1.Invalidate(); // local weather

                panelModeSpecificPhone.Invalidate();
                panelModeSpecificFM.Invalidate();
                panelModeSpecificCW.Invalidate();
                panelModeSpecificDigital.Invalidate();

                panelBandHF.Invalidate();
                panelBandGN.Invalidate();
                panelBandVHF.Invalidate();

                panelBandHFRX2.Invalidate();  // .203
                panelBandGNRX2.Invalidate();
                panelBandVHFRX2.Invalidate();

                panelMode.Invalidate();
                panelFilter.Invalidate();
                panelRX2Filter.Invalidate();
                panelRX2Mode.Invalidate();

                panelTSBandStack.Invalidate();
                panelTSRadar.Invalidate(); //.246

            }

        } //RingVFOColor


        private int default_low_cut = 150;
        public int DefaultLowCut
        {
            get { return default_low_cut; }
            set
            {
                for (DSPMode m = DSPMode.FIRST + 1; m < DSPMode.LAST; m++)
                {
                    for (Filter f = Filter.FIRST + 1; f < Filter.LAST; f++)
                    {
                        int low = rx1_filters[(int)m].GetLow(f);
                        int high = rx1_filters[(int)m].GetHigh(f);
                        // Removed DIGU and DIGL cases - W4TME
                        switch (m)
                        {
                            case DSPMode.USB:
                                /* case DSPMode.DIGU: */
                                if (low == default_low_cut) rx1_filters[(int)m].SetLow(f, value);
                                break;
                            case DSPMode.LSB:
                                /* case DSPMode.DIGL: */
                                if (high == -default_low_cut) rx1_filters[(int)m].SetHigh(f, -value);
                                break;
                        }
                    }
                }
                default_low_cut = value;
                RX1Filter = rx1_filter;
            }
        }

        public int CPDRVal
        {
            get
            {
                if (ptbCPDR != null) return ptbCPDR.Value;
                else return -1;
            }
            set
            {
                if (ptbCPDR != null) ptbCPDR.Value = value;
                ptbCPDR_Scroll(this, EventArgs.Empty);
            }
        }

        public int NoiseGate
        {
            get
            {
                if (ptbNoiseGate != null) return ptbNoiseGate.Value;
                else return -1;
            }
            set
            {
                if (ptbNoiseGate != null)
                {
                    if (value > ptbNoiseGate.Maximum) value = ptbNoiseGate.Maximum;
                    ptbNoiseGate.Value = value;
                    ptbNoiseGate_Scroll(this, EventArgs.Empty);
                }
            }
        }

        public int VOXSens
        {
            get
            {
                if (ptbVOX != null)
                {
                    prettyTrackBarVOX.Value = ptbVOX.Value;
                    return ptbVOX.Value;
                }
                else return -1;
            }
            set
            {
                if (ptbVOX != null)
                {
                    prettyTrackBarVOX.Value = value;
                    ptbVOX.Value = value;
                    ptbVOX_Scroll(this, EventArgs.Empty);
                    prettyTrackBarVOX_Scroll(this, EventArgs.Empty);
                }
            }
        }

        public bool NoiseGateEnabled
        {
            get
            {
                if (chkNoiseGate != null) return chkNoiseGate.Checked;
                else return false;
            }
            set
            {
                if (chkNoiseGate != null) chkNoiseGate.Checked = value;
            }
        }

        private int vac_rx_gain = 0;
        public int VACRXGain
        {
            get { return vac_rx_gain; }
            set
            {
                vac_rx_gain = value;

                if (ptbVACRXGain != null && !(chkVAC2.Checked && chkVFOBTX.Checked))
                {
                    ptbVACRXGain.Value = value;
                    ptbVACRXGain_Scroll(this, EventArgs.Empty);
                }
            }
        }

        private int vac2_rx_gain = 0;
        public int VAC2RXGain
        {
            get { return vac2_rx_gain; }
            set
            {
                vac2_rx_gain = value;

                if (ptbVACRXGain != null && chkVAC2.Checked && chkVFOBTX.Checked)
                {
                    ptbVACRXGain.Value = value;
                    ptbVACRXGain_Scroll(this, EventArgs.Empty);
                }
            }
        }

        private int vac_tx_gain = 0;
        public int VACTXGain
        {
            get { return vac_tx_gain; }
            set
            {
                vac_tx_gain = value;

                if (ptbVACTXGain != null && !(chkVAC2.Checked && chkVFOBTX.Checked))
                {
                    ptbVACTXGain.Value = value;
                    ptbVACTXGain_Scroll(this, EventArgs.Empty);
                }
            }
        }

        private int vac2_tx_gain = 0;
        public int VAC2TXGain
        {
            get { return vac2_tx_gain; }
            set
            {
                vac2_tx_gain = value;

                if (ptbVACTXGain != null && chkVAC2.Checked && chkVFOBTX.Checked)
                {
                    ptbVACTXGain.Value = value;
                    ptbVACTXGain_Scroll(this, EventArgs.Empty);
                }
            }
        }

        public bool BreakInEnabled
        {
            get
            {
                if (chkCWBreakInEnabled != null) return chkCWBreakInEnabled.Checked;
                else return false;
            }
            set
            {
                if (chkCWBreakInEnabled != null) chkCWBreakInEnabled.Checked = value;
            }
        }

        public bool VOXEnable
        {
            get
            {
                if (chkVOX != null)
                {
                    checkVOX.Checked = chkVOX.Checked;
                    return chkVOX.Checked;
                }
                else return false;
            }
            set
            {
                if (chkVOX != null)
                {
                    checkVOX.Checked = value;
                    chkVOX.Checked = value;
                }
            }
        }

        public int RF
        {
            get
            {
                if (ptbRF != null) return ptbRF.Value;
                else return -1;
            }
            set
            {
                if (ptbRF != null)
                {
                    ptbRF.Value = value;
                    ptbRF_Scroll(this, EventArgs.Empty);
                }
            }
        }

        public int RX2RF
        {
            get
            {
                if (ptbRX2RF != null) return ptbRX2RF.Value;
                else return -1;
            }
            set
            {
                if (ptbRX2RF != null)
                {
                    ptbRX2RF.Value = value;
                    ptbRX2RF_Scroll(this, EventArgs.Empty);
                }
            }
        }

        private bool enable_kb_shortcuts = true;
        public bool EnableKBShortcuts
        {
            get { return enable_kb_shortcuts; }
            set { enable_kb_shortcuts = value; }
        }

        private bool save_filter_changes = true;
        public bool SaveFilterChanges
        {
            get { return save_filter_changes; }
            set { save_filter_changes = value; }
        }

        //=====================================================================================
        private int max_filter_shift = 9999;
        public int MaxFilterShift
        {
            get { return max_filter_shift; }
            set
            {
                max_filter_shift = value;
                UpdateRX1Filters(dsp.GetDSPRX(0, 0).RXFilterLow, dsp.GetDSPRX(0, 0).RXFilterHigh);
            }
        }

        //=====================================================================================
        private int max_filter_width = 9999;
        public int MaxFilterWidth
        {
            get { return max_filter_width; }
            set
            {
                max_filter_width = value;
                UpdateRX1Filters(dsp.GetDSPRX(0, 0).RXFilterLow, dsp.GetDSPRX(0, 0).RXFilterHigh);
            }
        }

        //=====================================================================================
        private bool mic_boost = false;
        public bool MicBoost
        {
            get { return mic_boost; }
            set
            {
                mic_boost = value;
                ptbMic_Scroll(this, EventArgs.Empty);
            }
        }

        //=====================================================================================
        // ke9ns add  checkbox in setup to allow 2nd TX meter
        private bool tx_meter2 = false;
        public bool TXMeter2
        {
            get
            {
                if (setupForm != null) tx_meter2 = setupForm.chkTXMeter2.Checked;
                return tx_meter2;
            }
            set
            {
                tx_meter2 = value;

                Debug.WriteLine("TXMETER2 " + tx_meter2);

                if (!FWCEEPROM.RX2OK)  // if no 2nd receiver then make the 2nd meter visable
                {
                    if (tx_meter2 == true)
                    {
                        //   grpRX2Meter.Text = "------------------------ TX Meter (2nd)";

                        comboRX2MeterMode.Visible = false;
                        grpRX2Meter.Visible = true;
                    }
                    else
                    {
                        grpRX2Meter.Visible = false;
                    }

                    panelBandGNRX2.Size = new Size(1, 1); // no rX2 so no band buttons
                    panelBandHFRX2.Size = new Size(1, 1);
                    panelBandVHFRX2.Size = new Size(1, 1);

                }
                else // if you have RX2
                {
                    if (setupForm != null && setupForm.chk2ndMeter.Checked == false && setupForm.chkBoxMeterTop.Checked == false)
                    {
                        panelBandGNRX2.Size = new Size(1, 1);
                        panelBandHFRX2.Size = new Size(1, 1);
                        panelBandVHFRX2.Size = new Size(1, 1);


                    }
                    else
                    {
                        panelBandHFRX2.Size = new Size(173, 127);
                        panelBandVHFRX2.Size = new Size(173, 127);
                        panelBandGNRX2.Size = new Size(173, 127);
                    }
                }
            }
        } // TXMeter2

        //=====================================================================================
        // ke9ns add  checkbox in setup for Move meter to top line
        private bool metertop = false;

        public bool MeterTop
        {
            get
            {
                if (setupForm != null) metertop = setupForm.chkBoxMeterTop.Checked;
                return metertop;
            }
            set
            {
                if (this.Size.Width < 1000)
                {
                    value = false;
                    metertop = false;
                    if (setupForm != null)
                    {
                        setupForm.chkBoxMeterTop.CheckedChanged -= setupForm.chkBoxMeterTop_CheckedChanged;  // ke9ns turn off checkchanged temporarily   
                        setupForm.chkBoxMeterTop.Checked = false;
                        setupForm.chkBoxMeterTop.CheckedChanged += setupForm.chkBoxMeterTop_CheckedChanged;
                    }

                }

                if (value == true) MeterMenu = false; // turn off menu when you switch to TOP meters


                if (setupForm != null)
                {
                    setupForm.chkBoxMeterTop.CheckedChanged -= setupForm.chkBoxMeterTop_CheckedChanged;  // ke9ns turn off checkchanged temporarily   
                    setupForm.chkBoxMeterTop.Checked = value;
                    setupForm.chkBoxMeterTop.CheckedChanged += setupForm.chkBoxMeterTop_CheckedChanged;
                }
                metertop = value;

                if (panelTSBandStack.Enabled == true)
                {
                    BandStackMove(); // off
                    BandStackMove(); // back on
                }

            }

        } // MeterTop


        //=====================================================================================
        // ke9ns add:  checkbox in setup removing meter menus from console
        bool MeterSelectVis = true; // ke9ns add: true = show RX and TX meter menu items on console screen. False = hide them.
        int metermenu = 0; // ke9ns add
        public bool MeterMenu
        {
            get
            {
                if (setupForm != null) MeterSelectVis = setupForm.chkBoxMeterMenus.Checked;
                return MeterSelectVis;
            }
            set
            {
                if (value != MeterSelectVis)
                {
                    metermenu = 2; // ke9ns this is to force a console resize after painting
                    MeterSelectVis = value;

                    grpMultimeter.Invalidate();
                    grpRX2Meter.Invalidate();


                    //   Console_Resize(this, EventArgs.Empty);
                }

                if (setupForm != null)
                    if (setupForm.chkBoxMeterMenus.Checked != MeterSelectVis)
                    {
                        setupForm.chkBoxMeterMenus.CheckedChanged -= setupForm.chkBoxMeterMenus_CheckedChanged;  // ke9ns turn off checkchanged temporarily  
                        setupForm.chkBoxMeterMenus.Checked = value;
                        setupForm.chkBoxMeterMenus.CheckedChanged += setupForm.chkBoxMeterMenus_CheckedChanged;
                    }

            }

        } //  MeterMenu

        //=====================================================================================
        // ke9ns add  checkbox in setup for vfo dials
        private bool vfodial = false;

        public bool VFODIAL
        {
            get
            {
                if (setupForm != null) vfodial = setupForm.chkBoxDial.Checked;
                return vfodial;
            }
            set
            {
                vfodial = value;

                Debug.WriteLine("vfodial " + vfodial);

                if (vfodial == true)
                {

                    try
                    {
                        Thread t = new Thread(new ThreadStart(DIALA));
                        t.Name = "rotate vfoAdial dial Thread";
                        t.IsBackground = true;
                        t.Priority = ThreadPriority.Normal;
                        t.Start();

                        Thread t1 = new Thread(new ThreadStart(DIALB));
                        t1.Name = "rotate vfoB dial Thread";
                        t1.IsBackground = true;
                        t1.Priority = ThreadPriority.Normal;
                        t1.Start();
                    }
                    catch (Exception)
                    {

                    }
                }
                else
                {

                }
            }
        } // vfodial


        //=====================================================================================
        // ke9ns add  checkbox in setup for local weather on console
        private bool localweather = false;
        private bool localweatherblock = true; // keep off screen until you know there is enough space
        private bool localweatherupdate = false; // true = new data to update screen
        private bool CHECKMIN = true;

        public bool LOCALWEATHER // hits this at the screen cpu % update rate
        {
            get
            {
                if (setupForm != null)
                {
                    if (noaaON == 3) localweather = true;
                    else localweather = false;
                }
                return localweather;
            }
            set
            {
                localweather = value;

                //  Debug.WriteLine("localweatherblock " + localweatherblock);
                //   Debug.WriteLine("localweatherupdate " + localweatherupdate);

                //  Debug.WriteLine("SIZE " + this.RestoreBounds.Size.Width + ", " + this.Size.Width);


                if (CHECKMIN == false) // need to check for min window size because when console is minimized it does not report its size anymore.
                {
                    if (this.Size.Width < 1350)
                    {
                        if (localweatherblock == false)
                        {
                            int h_delta = this.Width - console_basis_size.Width;
                            int v_delta = Math.Max(this.Height - console_basis_size.Height, 0);
                            //  Debug.WriteLine("was FALSE now TRUeE " + this.RestoreBounds.Size.Width +  ", " + this.Size.Width);

                            if (CHECKMIN == false) ResizeConsole(h_delta, v_delta);
                        }
                        localweatherblock = true;
                    }
                    else
                    {
                        if (localweatherblock == true)
                        {
                            int h_delta = this.Width - console_basis_size.Width;
                            int v_delta = Math.Max(this.Height - console_basis_size.Height, 0);
                            // Debug.WriteLine("was TRUE now FALSE " + this.RestoreBounds.Size.Width);

                            if (CHECKMIN == false) ResizeConsole(h_delta, v_delta);
                        }

                        localweatherblock = false;
                    }
                } // CHECKMIN check
                else
                {
                    //  Debug.WriteLine("CHECKMIN");

                }

                //----------------------------------------------------
                if ((localweather == true) && (localweatherblock == false))
                {

                    if (localweatherupdate == true)
                    {
                        panelTS1.Visible = true;
                        panelTS1.Enabled = true;
                        //   Debug.WriteLine("WEATHER UPDATE SCREEN");
                        localweatherupdate = false;
                        richTextBox7.Text = "Height = " + localheight + "' / " + localheightm + "m"; // station height reported at your lat and long
                        richTextBox6.Text = "Temp = " + localcurrtemp + "°F / " + localcurrtempC + "°C";
                        richTextBox3.Text = "Humidity = " + localcurrhum + " %";

                        if (OpenWeather == true)
                        {
                            richTextBox2.Text = "Barometer = " + localcurrbar + " mBar";
                            richTextBox8.Text = "Wind= " + localcurrwindM + " kph@" + localcurrwinddir + "° " + localcurrwinddirS;  // + localcurrwinddirS;        //localcurrwinddir + " °";

                        }
                        else
                        {
                            richTextBox2.Text = "Barometer = " + localcurrbar + " inHg";
                            richTextBox8.Text = "Wind= " + localcurrwindM + "mph@" + localcurrwinddir + "° " + localcurrwinddirS;  // + localcurrwinddirS;        //localcurrwinddir + " °";

                        }


                        richTextBox5.Text = localcurrfor;
                        panelTS1.Invalidate();
                    }


                }
                else
                {
                    panelTS1.Visible = false;
                    panelTS1.Enabled = false;
                    panelTS1.Invalidate();
                    // Debug.WriteLine("WEATHER  OFF");
                }
            }
        } // LocalWeather



        private bool always_on_top = false;
        public bool AlwaysOnTop
        {
            get { return always_on_top; }
            set
            {
                always_on_top = value;
                if (value)
                {
                    Win32.SetWindowPos(this.Handle.ToInt32(),
                        -1, this.Left, this.Top, this.Width, this.Height, 0);
                }
                else
                {
                    Win32.SetWindowPos(this.Handle.ToInt32(),
                        -2, this.Left, this.Top, this.Width, this.Height, 0);
                }
            }
        }

        private bool quick_qsy = true;
        public bool QuickQSY
        {
            get { return quick_qsy; }
            set { quick_qsy = value; }
        }

        public HW Hdw
        {
            set { hw = value; }
            get { return hw; }
        }

        public SIOListenerII Siolisten
        {
            get { return siolisten; }
            set { siolisten = value; }
        }

        // ke9ns add: .180 port 2-5
        public SIOListenerII2 Siolisten2
        {
            get { return siolisten2; }
            set { siolisten2 = value; }
        }
        public SIOListenerII3 Siolisten3
        {
            get { return siolisten3; }
            set { siolisten3 = value; }
        }
        public SIOListenerII4 Siolisten4
        {
            get { return siolisten4; }
            set { siolisten4 = value; }
        }
        public SIOListenerII5 Siolisten5
        {
            get { return siolisten5; }
            set { siolisten5 = value; }
        }

        // ke9ns port6  .200 spoof VFOA to B
        public SIOListenerII6 Siolisten6
        {
            get { return siolisten6; }
            set { siolisten6 = value; }
        }


        // ke9ns add: ant rotor control
        public SIOListenerIII Siolisten1
        {
            get { return siolisten1; }
            set { siolisten1 = value; }
        }

        public bool HideTuneStep
        {
            get { return txtWheelTune.Visible; }
            set
            {
                if (setupForm != null)
                    txtWheelTune.Visible = value;
            }
        }

        public string DisplayModeText
        {
            get { return comboDisplayMode.Text; }
            set { comboDisplayMode.Text = value; }
        }

        private bool auto_mute = false;
        public bool AutoMute
        {
            get { return auto_mute; }
            set { auto_mute = value; }
        }

        private float multimeter_avg_mult_old = 1 - (float)1 / 10;
        private float multimeter_avg_mult_new = (float)1 / 10;
        private int multimeter_avg_num_blocks = 10;
        public int MultiMeterAvgBlocks
        {
            get { return multimeter_avg_num_blocks; }
            set
            {
                multimeter_avg_num_blocks = value;
                multimeter_avg_mult_old = 1 - (float)1 / multimeter_avg_num_blocks;
                multimeter_avg_mult_new = (float)1 / multimeter_avg_num_blocks;
            }
        }

        private float multimeter_peak_mult_old = 1 - (float)1 / 10; // ke9ns  
        private float multimeter_peak_mult_new = (float)1 / 10;
        private int multimeter_peak_num_blocks = 10;
        public int MultiMeterPeakBlocks
        {
            get { return multimeter_peak_num_blocks; }
            set
            {
                multimeter_peak_num_blocks = value;
                multimeter_peak_mult_old = 1 - (float)1 / multimeter_peak_num_blocks;
                multimeter_peak_mult_new = (float)1 / multimeter_peak_num_blocks;
            }
        }

        private bool vac_auto_enable = false;
        public bool VACAutoEnable
        {
            get { return vac_auto_enable; }
            set
            {
                vac_auto_enable = value;
                if (setupForm == null) return;
                if (vac_auto_enable)
                {
                    switch (rx1_dsp_mode)
                    {
                        case DSPMode.DIGL:
                        case DSPMode.DIGU:
                        case DSPMode.DRM:
                            setupForm.VACEnable = true;
                            break;
                        default:
                            setupForm.VACEnable = false;
                            break;
                    }
                }
                else setupForm.VACEnable = false;
            }
        }

        private bool vac2_rx2 = true;
        public bool VAC2RX2
        {
            get { return vac2_rx2; }
            set
            {
                vac2_rx2 = value;
                Audio.VAC2RX2 = value;
                if (vac2_auto_enable)
                {
                    DSPMode dsp_mode = rx1_dsp_mode;
                    if (vac2_rx2) dsp_mode = rx2_dsp_mode;

                    switch (dsp_mode)
                    {
                        case DSPMode.DIGL:
                        case DSPMode.DIGU:
                        case DSPMode.DRM:
                            setupForm.VAC2Enable = true;
                            break;
                        default:
                            setupForm.VAC2Enable = false;
                            break;
                    }
                }
            }
        }




        private bool vac2_auto_enable = false;
        public bool VAC2AutoEnable
        {
            get { return vac2_auto_enable; }
            set
            {
                vac2_auto_enable = value;
                if (setupForm == null) return;

                if (vac2_auto_enable)
                {
                    DSPMode dsp_mode = rx1_dsp_mode;
                    if (vac2_rx2) dsp_mode = rx2_dsp_mode;

                    switch (dsp_mode)
                    {
                        case DSPMode.DIGL:
                        case DSPMode.DIGU:
                        case DSPMode.DRM:
                            setupForm.VAC2Enable = true;
                            break;
                        default:
                            setupForm.VAC2Enable = false;
                            break;
                    }
                }
                else setupForm.VAC2Enable = false; // ke9ns 
            }
        }

        private float rx1_display_cal_offset;                   // display calibration offset per volume setting in dB
        public float RX1DisplayCalOffset
        {
            get { return rx1_display_cal_offset; }
            set
            {
                rx1_display_cal_offset = value;
                //Display.RX1DisplayCalOffset = value;
                UpdateDisplayOffsets();
            }
        }

        private float rx2_display_cal_offset;                   // display calibration offset per volume setting in dB
        public float RX2DisplayCalOffset
        {
            get { return rx2_display_cal_offset; }
            set
            {
                rx2_display_cal_offset = value;
                //Display.RX2DisplayCalOffset = value;
                UpdateDisplayOffsets();
            }
        }

        private int display_cursor_x;                       // x-coord of the cursor when over the display
        public int DisplayCursorX
        {
            get { return display_cursor_x; }
            set
            {
                display_cursor_x = value;
                Display.DisplayCursorX = value;
            }
        }

        private int display_cursor_y;                       // y-coord of the cursor when over the display
        public int DisplayCursorY
        {
            get { return display_cursor_y; }
            set
            {
                display_cursor_y = value;
                Display.DisplayCursorY = value;
            }
        }

        //private bool long_crosshair;						// If true, the long yellow cursors are displayed
        //public bool LongCrosshair
        //{
        //	get { return long_crosshair; }
        //	set { long_crosshair = value; }
        //}

        private ClickTuneMode current_click_tune_mode = ClickTuneMode.Off;
        public ClickTuneMode CurrentClickTuneMode
        {
            get { return current_click_tune_mode; }
            set
            {
                current_click_tune_mode = value;
                Display.CurrentClickTuneMode = value;
                switch (current_click_tune_mode)
                {
                    case ClickTuneMode.Off:
                        break;
                    default:
                        picDisplay.Cursor = Cursors.Cross;
                        break;
                }
            }
        }

        private DisplayEngine current_display_engine = DisplayEngine.GDI_PLUS;
        public DisplayEngine CurrentDisplayEngine
        {
            get { return current_display_engine; }
            set
            {
                /*switch(value)
				{
					case DisplayEngine.GDI_PLUS:
						current_display_engine = value;
						Display.DirectXRelease();
						break;
					case DisplayEngine.DIRECT_X:
						Display.DirectXInit();
						current_display_engine = value;
						Display.PrepareDisplayVars(Display.CurrentDisplayMode);
						Display.DrawBackground();
						break;
				}*/
                Display.CurrentDisplayEngine = value;
            }
        }

        private float waterfall_high_threshold_160m = -80.0F;
        public float WaterfallHighThreshold160m
        {
            get { return waterfall_high_threshold_160m; }
            set { waterfall_high_threshold_160m = value; }
        }

        private float waterfall_low_threshold_160m = -120.0F;
        public float WaterfallLowThreshold160m
        {
            get { return waterfall_low_threshold_160m; }
            set { waterfall_low_threshold_160m = value; }
        }

        private float waterfall_high_threshold_80m = -80.0F;
        public float WaterfallHighThreshold80m
        {
            get { return waterfall_high_threshold_80m; }
            set { waterfall_high_threshold_80m = value; }
        }

        private float waterfall_low_threshold_80m = -120.0F;
        public float WaterfallLowThreshold80m
        {
            get { return waterfall_low_threshold_80m; }
            set { waterfall_low_threshold_80m = value; }
        }

        private float waterfall_high_threshold_60m = -80.0F;
        public float WaterfallHighThreshold60m
        {
            get { return waterfall_high_threshold_60m; }
            set { waterfall_high_threshold_60m = value; }
        }

        private float waterfall_low_threshold_60m = -120.0F;
        public float WaterfallLowThreshold60m
        {
            get { return waterfall_low_threshold_60m; }
            set { waterfall_low_threshold_60m = value; }
        }

        private float waterfall_high_threshold_40m = -80.0F;
        public float WaterfallHighThreshold40m
        {
            get { return waterfall_high_threshold_40m; }
            set { waterfall_high_threshold_40m = value; }
        }

        private float waterfall_low_threshold_40m = -120.0F;
        public float WaterfallLowThreshold40m
        {
            get { return waterfall_low_threshold_40m; }
            set { waterfall_low_threshold_40m = value; }
        }

        private float waterfall_high_threshold_30m = -80.0F;
        public float WaterfallHighThreshold30m
        {
            get { return waterfall_high_threshold_30m; }
            set { waterfall_high_threshold_30m = value; }
        }

        private float waterfall_low_threshold_30m = -130.0F;
        public float WaterfallLowThreshold30m
        {
            get { return waterfall_low_threshold_30m; }
            set { waterfall_low_threshold_30m = value; }
        }

        private float waterfall_high_threshold_20m = -80.0F;
        public float WaterfallHighThreshold20m
        {
            get { return waterfall_high_threshold_20m; }
            set { waterfall_high_threshold_20m = value; }
        }

        private float waterfall_low_threshold_20m = -130.0F;
        public float WaterfallLowThreshold20m
        {
            get { return waterfall_low_threshold_20m; }
            set { waterfall_low_threshold_20m = value; }

        }


        //----------------------------
        // ke9ns add
        private float waterfall_high_threshold_LMF = -80.0F;
        public float WaterfallHighThresholdLMF
        {
            get { return waterfall_high_threshold_LMF; }
            set { waterfall_high_threshold_LMF = value; }
        }
        private float waterfall_low_threshold_LMF = -130.0F;
        public float WaterfallLowThresholdLMF
        {
            get { return waterfall_low_threshold_LMF; }
            set { waterfall_low_threshold_LMF = value; }
        }

        //----------------------------
        // ke9ns add
        private float waterfall_high_threshold_120m = -80.0F;
        public float WaterfallHighThreshold120m
        {
            get { return waterfall_high_threshold_120m; }
            set { waterfall_high_threshold_120m = value; }
        }

        private float waterfall_low_threshold_120m = -130.0F;
        public float WaterfallLowThreshold120m
        {
            get { return waterfall_low_threshold_120m; }
            set { waterfall_low_threshold_120m = value; }
        }

        //----------------------------
        // ke9ns add
        private float waterfall_high_threshold_90m = -80.0F;
        public float WaterfallHighThreshold90m
        {
            get { return waterfall_high_threshold_90m; }
            set { waterfall_high_threshold_90m = value; }
        }

        private float waterfall_low_threshold_90m = -130.0F;
        public float WaterfallLowThreshold90m
        {
            get { return waterfall_low_threshold_90m; }
            set { waterfall_low_threshold_90m = value; }
        }

        //----------------------------
        // ke9ns add
        private float waterfall_high_threshold_61m = -80.0F;
        public float WaterfallHighThreshold61m
        {
            get { return waterfall_high_threshold_61m; }
            set { waterfall_high_threshold_61m = value; }
        }

        private float waterfall_low_threshold_61m = -130.0F;
        public float WaterfallLowThreshold61m
        {
            get { return waterfall_low_threshold_61m; }
            set { waterfall_low_threshold_61m = value; }
        }

        //----------------------------
        // ke9ns add
        private float waterfall_high_threshold_49m = -80.0F;
        public float WaterfallHighThreshold49m
        {
            get { return waterfall_high_threshold_49m; }
            set { waterfall_high_threshold_49m = value; }
        }
        private float waterfall_low_threshold_49m = -130.0F;
        public float WaterfallLowThreshold49m
        {
            get { return waterfall_low_threshold_49m; }
            set { waterfall_low_threshold_49m = value; }
        }
        //----------------------------
        // ke9ns add
        private float waterfall_high_threshold_41m = -80.0F;
        public float WaterfallHighThreshold41m
        {
            get { return waterfall_high_threshold_41m; }
            set { waterfall_high_threshold_41m = value; }
        }
        private float waterfall_low_threshold_41m = -130.0F;
        public float WaterfallLowThreshold41m
        {
            get { return waterfall_low_threshold_41m; }
            set { waterfall_low_threshold_41m = value; }
        }

        //----------------------------
        // ke9ns add
        private float waterfall_high_threshold_31m = -80.0F;
        public float WaterfallHighThreshold31m
        {
            get { return waterfall_high_threshold_31m; }
            set { waterfall_high_threshold_31m = value; }
        }
        private float waterfall_low_threshold_31m = -130.0F;
        public float WaterfallLowThreshold31m
        {
            get { return waterfall_low_threshold_31m; }
            set { waterfall_low_threshold_31m = value; }
        }

        //----------------------------
        // ke9ns add
        private float waterfall_high_threshold_25m = -80.0F;
        public float WaterfallHighThreshold25m
        {
            get { return waterfall_high_threshold_25m; }
            set { waterfall_high_threshold_25m = value; }
        }
        private float waterfall_low_threshold_25m = -130.0F;
        public float WaterfallLowThreshold25m
        {
            get { return waterfall_low_threshold_25m; }
            set { waterfall_low_threshold_25m = value; }
        }


        //----------------------------
        // ke9ns add
        private float waterfall_high_threshold_22m = -80.0F;
        public float WaterfallHighThreshold22m
        {
            get { return waterfall_high_threshold_22m; }
            set { waterfall_high_threshold_22m = value; }
        }
        private float waterfall_low_threshold_22m = -130.0F;
        public float WaterfallLowThreshold22m
        {
            get { return waterfall_low_threshold_22m; }
            set { waterfall_low_threshold_22m = value; }
        }


        //----------------------------
        // ke9ns add
        private float waterfall_high_threshold_19m = -80.0F;
        public float WaterfallHighThreshold19m
        {
            get { return waterfall_high_threshold_19m; }
            set { waterfall_high_threshold_19m = value; }
        }
        private float waterfall_low_threshold_19m = -130.0F;
        public float WaterfallLowThreshold19m
        {
            get { return waterfall_low_threshold_19m; }
            set { waterfall_low_threshold_19m = value; }
        }


        //----------------------------
        // ke9ns add
        private float waterfall_high_threshold_16m = -80.0F;
        public float WaterfallHighThreshold16m
        {
            get { return waterfall_high_threshold_16m; }
            set { waterfall_high_threshold_16m = value; }
        }
        private float waterfall_low_threshold_16m = -130.0F;
        public float WaterfallLowThreshold16m
        {
            get { return waterfall_low_threshold_16m; }
            set { waterfall_low_threshold_16m = value; }
        }

        //----------------------------
        // ke9ns add
        private float waterfall_high_threshold_14m = -80.0F;
        public float WaterfallHighThreshold14m
        {
            get { return waterfall_high_threshold_14m; }
            set { waterfall_high_threshold_14m = value; }
        }

        private float waterfall_low_threshold_14m = -130.0F;
        public float WaterfallLowThreshold14m
        {
            get { return waterfall_low_threshold_14m; }
            set { waterfall_low_threshold_14m = value; }
        }

        //----------------------------
        // ke9ns add
        private float waterfall_high_threshold_13m = -80.0F;
        public float WaterfallHighThreshold13m
        {
            get { return waterfall_high_threshold_13m; }
            set { waterfall_high_threshold_13m = value; }
        }
        private float waterfall_low_threshold_13m = -130.0F;
        public float WaterfallLowThreshold13m
        {
            get { return waterfall_low_threshold_13m; }
            set { waterfall_low_threshold_13m = value; }
        }

        //----------------------------
        // ke9ns add
        private float waterfall_high_threshold_11m = -80.0F;
        public float WaterfallHighThreshold11m
        {
            get { return waterfall_high_threshold_11m; }
            set { waterfall_high_threshold_11m = value; }
        }
        private float waterfall_low_threshold_11m = -130.0F;
        public float WaterfallLowThreshold11m
        {
            get { return waterfall_low_threshold_11m; }
            set { waterfall_low_threshold_11m = value; }
        }

        //-------------------------

        private float waterfall_high_threshold_17m = -80.0F;
        public float WaterfallHighThreshold17m
        {
            get { return waterfall_high_threshold_17m; }
            set { waterfall_high_threshold_17m = value; }
        }

        private float waterfall_low_threshold_17m = -130.0F;
        public float WaterfallLowThreshold17m
        {
            get { return waterfall_low_threshold_17m; }
            set { waterfall_low_threshold_17m = value; }
        }

        private float waterfall_high_threshold_15m = -80.0F;
        public float WaterfallHighThreshold15m
        {
            get { return waterfall_high_threshold_15m; }
            set { waterfall_high_threshold_15m = value; }
        }

        private float waterfall_low_threshold_15m = -130.0F;
        public float WaterfallLowThreshold15m
        {
            get { return waterfall_low_threshold_15m; }
            set { waterfall_low_threshold_15m = value; }
        }

        private float waterfall_high_threshold_12m = -80.0F;
        public float WaterfallHighThreshold12m
        {
            get { return waterfall_high_threshold_12m; }
            set { waterfall_high_threshold_12m = value; }
        }

        private float waterfall_low_threshold_12m = -140.0F;
        public float WaterfallLowThreshold12m
        {
            get { return waterfall_low_threshold_12m; }
            set { waterfall_low_threshold_12m = value; }
        }

        private float waterfall_high_threshold_10m = -80.0F;
        public float WaterfallHighThreshold10m
        {
            get { return waterfall_high_threshold_10m; }
            set { waterfall_high_threshold_10m = value; }
        }

        private float waterfall_low_threshold_10m = -140.0F;
        public float WaterfallLowThreshold10m
        {
            get { return waterfall_low_threshold_10m; }
            set { waterfall_low_threshold_10m = value; }
        }

        private float waterfall_high_threshold_6m = -80.0F;
        public float WaterfallHighThreshold6m
        {
            get { return waterfall_high_threshold_6m; }
            set { waterfall_high_threshold_6m = value; }
        }

        private float waterfall_low_threshold_6m = -140.0F;
        public float WaterfallLowThreshold6m
        {
            get { return waterfall_low_threshold_6m; }
            set { waterfall_low_threshold_6m = value; }
        }

        private float waterfall_high_threshold_wwv = -80.0F;
        public float WaterfallHighThresholdWWV
        {
            get { return waterfall_high_threshold_wwv; }
            set { waterfall_high_threshold_wwv = value; }
        }

        private float waterfall_low_threshold_wwv = -130.0F;
        public float WaterfallLowThresholdWWV
        {
            get { return waterfall_low_threshold_wwv; }
            set { waterfall_low_threshold_wwv = value; }
        }

        private float waterfall_high_threshold_gen = -80.0F;
        public float WaterfallHighThresholdGEN
        {
            get { return waterfall_high_threshold_gen; }
            set { waterfall_high_threshold_gen = value; }
        }

        private float waterfall_low_threshold_gen = -130.0F;
        public float WaterfallLowThresholdGEN
        {
            get { return waterfall_low_threshold_gen; }
            set { waterfall_low_threshold_gen = value; }
        }

        private float waterfall_high_threshold_xvtr = -80.0F;
        public float WaterfallHighThresholdXVTR
        {
            get { return waterfall_high_threshold_xvtr; }
            set { waterfall_high_threshold_xvtr = value; }
        }

        private float waterfall_low_threshold_xvtr = -140.0F;
        public float WaterfallLowThresholdXVTR
        {
            get { return waterfall_low_threshold_xvtr; }
            set { waterfall_low_threshold_xvtr = value; }
        }
        //==========================================================================================


        private float waterfall_lowRX2_threshold_160m = -120.0F;
        public float WaterfallLowRX2Threshold160m
        {
            get { return waterfall_lowRX2_threshold_160m; }
            set { waterfall_lowRX2_threshold_160m = value; }
        }

        private float waterfall_lowRX2_threshold_80m = -120.0F;
        public float WaterfallLowRX2Threshold80m
        {
            get { return waterfall_lowRX2_threshold_80m; }
            set { waterfall_lowRX2_threshold_80m = value; }
        }

        private float waterfall_lowRX2_threshold_60m = -120.0F;
        public float WaterfallLowRX2Threshold60m
        {
            get { return waterfall_lowRX2_threshold_60m; }
            set { waterfall_lowRX2_threshold_60m = value; }
        }

        private float waterfall_lowRX2_threshold_40m = -120.0F;
        public float WaterfallLowRX2Threshold40m
        {
            get { return waterfall_lowRX2_threshold_40m; }
            set { waterfall_lowRX2_threshold_40m = value; }
        }

        private float waterfall_lowRX2_threshold_30m = -130.0F;
        public float WaterfallLowRX2Threshold30m
        {
            get { return waterfall_lowRX2_threshold_30m; }
            set { waterfall_lowRX2_threshold_30m = value; }
        }

        private float waterfall_lowRX2_threshold_20m = -130.0F;
        public float WaterfallLowRX2Threshold20m
        {
            get { return waterfall_lowRX2_threshold_20m; }
            set { waterfall_lowRX2_threshold_20m = value; }
        }

        private float waterfall_lowRX2_threshold_17m = -130.0F;
        public float WaterfallLowRX2Threshold17m
        {
            get { return waterfall_lowRX2_threshold_17m; }
            set { waterfall_lowRX2_threshold_17m = value; }
        }

        private float waterfall_lowRX2_threshold_15m = -130.0F;
        public float WaterfallLowRX2Threshold15m
        {
            get { return waterfall_lowRX2_threshold_15m; }
            set { waterfall_lowRX2_threshold_15m = value; }
        }

        private float waterfall_lowRX2_threshold_12m = -140.0F;
        public float WaterfallLowRX2Threshold12m
        {
            get { return waterfall_lowRX2_threshold_12m; }
            set { waterfall_lowRX2_threshold_12m = value; }
        }

        private float waterfall_lowRX2_threshold_10m = -140.0F;
        public float WaterfallLowRX2Threshold10m
        {
            get { return waterfall_lowRX2_threshold_10m; }
            set { waterfall_lowRX2_threshold_10m = value; }
        }

        private float waterfall_lowRX2_threshold_6m = -140.0F;
        public float WaterfallLowRX2Threshold6m
        {
            get { return waterfall_lowRX2_threshold_6m; }
            set { waterfall_lowRX2_threshold_6m = value; }
        }

        private float waterfall_lowRX2_threshold_wwv = -130.0F;
        public float WaterfallLowRX2ThresholdWWV
        {
            get { return waterfall_lowRX2_threshold_wwv; }
            set { waterfall_lowRX2_threshold_wwv = value; }
        }

        private float waterfall_lowRX2_threshold_gen = -130.0F;
        public float WaterfallLowRX2ThresholdGEN
        {
            get { return waterfall_lowRX2_threshold_gen; }
            set { waterfall_lowRX2_threshold_gen = value; }
        }

        private float waterfall_lowRX2_threshold_xvtr = -140.0F;
        public float WaterfallLowRX2ThresholdXVTR
        {
            get { return waterfall_lowRX2_threshold_xvtr; }
            set { waterfall_lowRX2_threshold_xvtr = value; }
        }


        //==========================================================================================
        // ke9ns add: .158 

        private float waterfall_lowRX2_threshold_LMF = -120.0F;
        public float WaterfallLowRX2ThresholdLMF
        {
            get { return waterfall_lowRX2_threshold_LMF; }
            set { waterfall_lowRX2_threshold_LMF = value; }
        }

        private float waterfall_lowRX2_threshold_120m = -120.0F;
        public float WaterfallLowRX2Threshold120m
        {
            get { return waterfall_lowRX2_threshold_120m; }
            set { waterfall_lowRX2_threshold_120m = value; }
        }

        private float waterfall_lowRX2_threshold_90m = -120.0F;
        public float WaterfallLowRX2Threshold90m
        {
            get { return waterfall_lowRX2_threshold_90m; }
            set { waterfall_lowRX2_threshold_90m = value; }
        }

        private float waterfall_lowRX2_threshold_61m = -120.0F;
        public float WaterfallLowRX2Threshold61m
        {
            get { return waterfall_lowRX2_threshold_61m; }
            set { waterfall_lowRX2_threshold_61m = value; }
        }

        private float waterfall_lowRX2_threshold_49m = -130.0F;
        public float WaterfallLowRX2Threshold49m
        {
            get { return waterfall_lowRX2_threshold_49m; }
            set { waterfall_lowRX2_threshold_49m = value; }
        }

        private float waterfall_lowRX2_threshold_41m = -130.0F;
        public float WaterfallLowRX2Threshold41m
        {
            get { return waterfall_lowRX2_threshold_41m; }
            set { waterfall_lowRX2_threshold_41m = value; }
        }

        private float waterfall_lowRX2_threshold_31m = -130.0F;
        public float WaterfallLowRX2Threshold31m
        {
            get { return waterfall_lowRX2_threshold_31m; }
            set { waterfall_lowRX2_threshold_31m = value; }
        }

        private float waterfall_lowRX2_threshold_25m = -130.0F;
        public float WaterfallLowRX2Threshold25m
        {
            get { return waterfall_lowRX2_threshold_25m; }
            set { waterfall_lowRX2_threshold_25m = value; }
        }

        private float waterfall_lowRX2_threshold_22m = -140.0F;
        public float WaterfallLowRX2Threshold22m
        {
            get { return waterfall_lowRX2_threshold_22m; }
            set { waterfall_lowRX2_threshold_22m = value; }
        }

        private float waterfall_lowRX2_threshold_19m = -140.0F;
        public float WaterfallLowRX2Threshold19m
        {
            get { return waterfall_lowRX2_threshold_19m; }
            set { waterfall_lowRX2_threshold_19m = value; }
        }

        private float waterfall_lowRX2_threshold_16m = -140.0F;
        public float WaterfallLowRX2Threshold16m
        {
            get { return waterfall_lowRX2_threshold_16m; }
            set { waterfall_lowRX2_threshold_16m = value; }
        }

        private float waterfall_lowRX2_threshold_14m = -130.0F;
        public float WaterfallLowRX2Threshold14m
        {
            get { return waterfall_lowRX2_threshold_14m; }
            set { waterfall_lowRX2_threshold_14m = value; }
        }

        private float waterfall_lowRX2_threshold_13m = -130.0F;
        public float WaterfallLowRX2Threshold13m
        {
            get { return waterfall_lowRX2_threshold_13m; }
            set { waterfall_lowRX2_threshold_13m = value; }
        }

        private float waterfall_lowRX2_threshold_11m = -140.0F;
        public float WaterfallLowRX2Threshold11m
        {
            get { return waterfall_lowRX2_threshold_11m; }
            set { waterfall_lowRX2_threshold_11m = value; }
        }



        //=======================================================================================
        //=======================================================================================
        // ke9ns add: TX Low waterfall level setting communicate with display.cs
        //=======================================================================================
        //=======================================================================================
        private float waterfall_low_threshold_Mic = -100.0F; // ke9ns ADD
        public float WaterfallLowThresholdMic
        {
            get { return waterfall_low_threshold_Mic; }
            set { waterfall_low_threshold_Mic = value; }
        }
        //=====================================================

        private int waterfall_update_period = 50;
        public int WaterfallUpdatePeriod
        {
            get { return waterfall_update_period; }
            set { waterfall_update_period = value; }
        }

        private string lsb_txprofile = "Default";
        public string LSB_TXProfile
        {
            get { return lsb_txprofile; }
            set { lsb_txprofile = value; }
        }

        private string usb_txprofile = "Default";
        public string USB_TXProfile
        {
            get { return usb_txprofile; }
            set { usb_txprofile = value; }
        }

        private string dsb_txprofile = "Default";
        public string DSB_TXProfile
        {
            get { return dsb_txprofile; }
            set { dsb_txprofile = value; }
        }

        private string cwl_txprofile = "Default";
        public string CWL_TXProfile
        {
            get { return cwl_txprofile; }
            set { cwl_txprofile = value; }
        }

        private string cwu_txprofile = "Default";
        public string CWU_TXProfile
        {
            get { return cwu_txprofile; }
            set { cwu_txprofile = value; }
        }
        private string fm_txprofile = "Default";
        public string FM_TXProfile
        {
            get { return fm_txprofile; }
            set { fm_txprofile = value; }
        }

        private string am_txprofile = "Default";
        public string AM_TXProfile
        {
            get { return am_txprofile; }
            set { am_txprofile = value; }
        }

        private string sam_txprofile = "Default";
        public string SAM_TXProfile
        {
            get { return sam_txprofile; }
            set { sam_txprofile = value; }
        }

        private string spec_txprofile = "Default";
        public string SPEC_TXProfile
        {
            get { return spec_txprofile; }
            set { spec_txprofile = value; }
        }

        private string digl_txprofile = "Default";
        public string DIGL_TXProfile
        {
            get { return digl_txprofile; }
            set { digl_txprofile = value; }
        }

        private string digu_txprofile = "Default";
        public string DIGU_TXProfile
        {
            get { return digu_txprofile; }
            set { digu_txprofile = value; }
        }

        private string drm_txprofile = "Default";
        public string DRM_TXProfile
        {
            get { return drm_txprofile; }
            set { drm_txprofile = value; }
        }
        private bool tx_profile_by_mode = false;
        public bool TXProfileByMode
        {
            get { return tx_profile_by_mode; }
            set { tx_profile_by_mode = value; }
        }

        private int digu_click_tune_offset = 1500;
        public int DIGUClickTuneOffset
        {
            get { return digu_click_tune_offset; }
            set
            {
                digu_click_tune_offset = value;
                Filter filter1 = RX1Filter;     // save RX1 filter
                Filter filter2 = RX2Filter;     // save RX2 filter
                                                //reset preset filter's center frequency - W4TME

                for (Filter f = Filter.F1; f < Filter.LAST; f++)
                {
                    int low = rx1_filters[(int)DSPMode.DIGU].GetLow(f);
                    int high = rx1_filters[(int)DSPMode.DIGU].GetHigh(f);
                    string name = rx1_filters[(int)DSPMode.DIGU].GetName(f);

                    int bw = high - low;
                    low = digu_click_tune_offset - bw / 2;
                    high = digu_click_tune_offset + bw / 2;
                    rx1_filters[(int)DSPMode.DIGU].SetFilter(f, low, high, name);
                    rx2_filters[(int)DSPMode.DIGU].SetFilter(f, low, high, name);
                }
                RX1Filter = filter1;            // restore RX1 filter
                RX2Filter = filter2;            // restore RX2 filter
            }
        }

        private int digl_click_tune_offset = 2210;
        public int DIGLClickTuneOffset
        {
            get { return digl_click_tune_offset; }
            set
            {
                digl_click_tune_offset = value;
                Filter filter1 = RX1Filter;     // save RX1 filter
                Filter filter2 = RX2Filter;     // save RX2 filter
                                                //reset preset filter's center frequency - W4TME

                for (Filter f = Filter.F1; f < Filter.LAST; f++)
                {
                    int low = rx1_filters[(int)DSPMode.DIGL].GetLow(f);
                    int high = rx1_filters[(int)DSPMode.DIGL].GetHigh(f);
                    string name = rx1_filters[(int)DSPMode.DIGL].GetName(f);

                    int bw = high - low;
                    low = -digl_click_tune_offset - bw / 2;
                    high = -digl_click_tune_offset + bw / 2;
                    rx1_filters[(int)DSPMode.DIGL].SetFilter(f, low, high, name);
                    rx2_filters[(int)DSPMode.DIGL].SetFilter(f, low, high, name);
                }
                RX1Filter = filter1;        // restore RX1 filter
                RX2Filter = filter2;        // restore RX2 filter
            }
        }

        // ke9ns add: setup->general->hardware config->PTT hang timer
        private double pttht_hang_time = 250.0;
        public double PTTHT
        {
            get
            {
                double temp = pttht_hang_time;
                if (pttht_active == false) temp = 0;

                return temp;
            }
            set
            {
                if (pttht_active == false) pttht_hang_time = 0;
                else pttht_hang_time = value;
            }
        }

        // ke9ns add
        private bool pttht_active = false;
        public bool PTTHTActive
        {
            get { return pttht_active; }
            set { pttht_active = value; }
        }


        private double vox_hang_time = 250.0;
        public double VOXHangTime
        {
            get { return vox_hang_time; }
            set { vox_hang_time = value; }
        }



        private bool vox_active = false;
        public bool VOXActive
        {
            get { return vox_active; }
            set { vox_active = value; }
        }

        private bool save_txprofile_on_exit = false;
        public bool SaveTXProfileOnExit
        {
            get { return save_txprofile_on_exit; }
            set { save_txprofile_on_exit = value; }
        }

        private SoundCard current_soundcard = SoundCard.UNSUPPORTED_CARD;
        public SoundCard CurrentSoundCard
        {
            get { return current_soundcard; }
            set
            {
                current_soundcard = value;
                Audio.CurSoundCard = value;
                if (setupForm != null && setupForm.CurrentSoundCard != current_soundcard)
                    setupForm.CurrentSoundCard = current_soundcard;
            }
        }

        private Model current_model = Model.FLEX5000;
        public Model CurrentModel
        {
            get { return current_model; }
            set
            {
                Model saved_model = current_model;
                if (value == Model.SDR1000 && hw == null)
                {
                    hw = new HW(0x378);
                    hw.USBPresent = usb_present;
                }
                current_model = value;
                Display.CurrentModel = value;
                chkFullDuplex.Visible = false;
                switch (current_model)
                {
                    case Model.FLEX5000:
                        MinFreq = Math.Max(if_freq, 0.000001);
                        MaxFreq = 75.0;  //.240 was 65.0 
                        if (!fwc_init)
                        {

                            Debug.WriteLine("CURRENTMODEL");

                            //fwc_init = FWCMidi.Open();
                            fwc_init = Pal.Init();
                            if (fwc_init)
                            {
                                FWCEEPROM.Init();
                                FWC.SetPalCallback();
                            }
                        }
                        if (fwc_init)
                        {
                            /*string preamp = comboPreamp.Text;
                            comboPreamp.Items.Clear();
                            comboPreamp.Items.Add("Off");
                            comboPreamp.Items.Add("On");
                            if(preamp == "Off") comboPreamp.Text = "Off";
                            else comboPreamp.Text = "On";*/

                            comboPreamp.Visible = false;
                            //lblPreamp.Visible = false;
                            chkRX1Preamp.Visible = true;
                            chkRX1Preamp_CheckedChanged(this, EventArgs.Empty);

                            if (!comboMeterTXMode.Items.Contains("Ref Pwr")) comboMeterTXMode.Items.Insert(1, "Ref Pwr");
                            if (!comboMeterTXMode.Items.Contains("SWR")) comboMeterTXMode.Items.Insert(2, "SWR");
                            if (comboMeterTXMode.SelectedIndex < 0) comboMeterTXMode.SelectedIndex = 0;

                            //ke9ns add below for 2nd TX mode meter
                            if (!comboMeterTX1Mode.Items.Contains("Ref Pwr")) comboMeterTX1Mode.Items.Insert(1, "Ref Pwr"); // 
                            if (!comboMeterTX1Mode.Items.Contains("SWR")) comboMeterTX1Mode.Items.Insert(2, "SWR"); // 
                            if (comboMeterTX1Mode.SelectedIndex < 0) comboMeterTX1Mode.SelectedIndex = 0; //

                            chkBCI.Visible = false;
                            chkBCI.Checked = false;

                            //mnuFWC.Visible = true;
                            mixerToolStripMenuItem.Visible = true;
                            antennaToolStripMenuItem.Visible = true;
                            herosToolStripMenuItem.Visible = true;
                            //mnuRelays.Visible = true;
                            //mnuInfo.Visible = true;

                            FWC.WriteCodecReg(0x1B, 0x02);
                            byte reg_7;
                            FWC.ReadCodecReg(0x07, out reg_7);
                            FWC.WriteCodecReg(0x07, (byte)(reg_7 & 0xFC));
                            if (fwcMixForm == null) fwcMixForm = new FWCMixForm(this);
                            if (fwcAntForm == null) fwcAntForm = new FWCAntForm(this);

                            chkFWCATUBypass.Visible = true;

                            if (FWCEEPROM.ATUOK)
                            {
                                aTUToolStripMenuItem.Visible = true;
                                if (fwcAtuForm == null) fwcAtuForm = new FWCATUForm(this);

                                if ((chkTUN.Text != "TUN")) chkFWCATU.Enabled = false;  // ke9ns add
                                else chkFWCATU.Enabled = true;   // ke9ns mod

                                //  chkFWCATU.Enabled = true; // original code

                                chkFWCATU.Text = "ATU";
                                chkFWCATUBypass.Enabled = true;
                                chkFWCATUBypass.Text = "BYP";
                            }
                            else
                            {
                                chkX2TR.Text = "";
                                chkX2TR.Enabled = false;
                            }
                            if (flex5000DebugForm == null) flex5000DebugForm = new FLEX5000DebugForm(this);

                            if (FWCEEPROM.RX2OK)  // RX2 option
                            {
                                eSCToolStripMenuItem.Enabled = true;
                                if (dax_audio_enum) chkVAC2.Enabled = true;
                            }

                            //  chkVAC2.Enabled = true; // ke9ns 


                            //   chkFullDuplex.Visible = true; // ke9ns this is normally false
                            panelAntenna.Visible = true; // this is for model 5000
                        }
                        else
                        {
                            chkPower.Enabled = false;
                        }

                        DttSP.SetSwchFlag(0, true);
                        DttSP.SetSwchRiseThresh(0, 3e-4f);

                        break;

                    case Model.FLEX3000:
                        MinFreq = Math.Max(if_freq, 0.000001);
                        MaxFreq = 65.0;
                        FWCDDSClockCorrection = fwc_dds_clock_correction;
                        if (!fwc_init)
                        {
                            //fwc_init = FWCMidi.Open();
                            fwc_init = Pal.Init();
                            if (fwc_init)
                            {
                                FWCEEPROM.Init();
                                FWC.SetPalCallback();
                            }
                        }
                        if (fwc_init)
                        {
                            comboPreamp.Visible = true;
                            chkRX1Preamp.Visible = false;
                            //lblPreamp.Text = "RX Gain";
                            string preamp = comboPreamp.Text;
                            comboPreamp.Items.Clear();
                            comboPreamp.Items.Add("Attn");
                            comboPreamp.Items.Add("Off");
                            comboPreamp.Items.Add("Pre1");
                            comboPreamp.Items.Add("Pre2");
                            comboPreamp.Text = preamp;
                            if (comboPreamp.SelectedIndex < 0)
                                comboPreamp.SelectedIndex = 1;
                            //comboPreamp_SelectedIndexChanged(this, EventArgs.Empty);
                            Application.DoEvents();

                            if (!comboMeterTXMode.Items.Contains("Ref Pwr")) comboMeterTXMode.Items.Insert(1, "Ref Pwr");
                            if (!comboMeterTXMode.Items.Contains("SWR")) comboMeterTXMode.Items.Insert(2, "SWR");
                            if (comboMeterTXMode.SelectedIndex < 0) comboMeterTXMode.SelectedIndex = 0;

                            //ke9ns add below
                            if (!comboMeterTX1Mode.Items.Contains("Ref Pwr")) comboMeterTX1Mode.Items.Insert(1, "Ref Pwr");
                            if (!comboMeterTX1Mode.Items.Contains("SWR")) comboMeterTX1Mode.Items.Insert(2, "SWR");
                            if (comboMeterTX1Mode.SelectedIndex < 0) comboMeterTX1Mode.SelectedIndex = 0;


                            chkBCI.Visible = false;
                            chkBCI.Checked = false;

                            //mnuFWC.Visible = true;
                            mixerToolStripMenuItem.Visible = true;
                            antennaToolStripMenuItem.Visible = false;
                            herosToolStripMenuItem.Visible = true;
                            //mnuRelays.Visible = true;
                            //mnuInfo.Visible = true;

                            //FWC.WriteCodecReg(0x1B, 0x02);
                            //if(fwcMixForm == null) fwcMixForm = new FWCMixForm(this);
                            if (flex3000MixerForm == null) flex3000MixerForm = new FLEX3000MixerForm(this);
                            //if(fwcAntForm == null) fwcAntForm = new FWCAntForm(this);
                            chkFWCATUBypass.Visible = true;

                            try
                            {
                                ATUDLLTest.test();
                                oldATU = false;
                                aTUToolStripMenuItem.Visible = true;

#if (NO_NEW_ATU)
                                //force old atu because exception won't be caught
                                oldATU = true;
                                aTUToolStripMenuItem.Visible = false;
#endif

                            }
                            catch (Exception)
                            {
                                oldATU = true;
                                aTUToolStripMenuItem.Visible = false;
                            }


                            if (flex3000ATUForm == null) flex3000ATUForm = new FLEX3000ATUForm(this);


                            if ((chkTUN.Text != "TUN")) chkFWCATU.Enabled = false;  // ke9ns add
                            else chkFWCATU.Enabled = true;   // ke9ns mod

                            //  chkFWCATU.Enabled = true; // original code

                            chkFWCATU.Text = "ATU";
                            chkFWCATUBypass.Enabled = true;
                            chkFWCATUBypass.Text = "BYP";

                            chkX2TR.Text = "";
                            chkX2TR.Enabled = false;

                            if (flex5000DebugForm == null) flex5000DebugForm = new FLEX5000DebugForm(this);

                            //chkFullDuplex.Visible = true;
                            panelAntenna.Visible = false; // this is for model 3000

                            //   chkVAC2.Enabled = true; // ke9ns add chkVAC2


                            /*if(fwcTestForm == null || fwcTestForm.IsDisposed)
                                fwcTestForm = new FWCTestForm(this);
                            fwcTestForm.Show();*/
                        }
                        else
                        {
                            chkPower.Enabled = false;
                        }

                        DttSP.SetSwchFlag(0, true);
                        DttSP.SetSwchRiseThresh(0, 3e-4f);
                        break;
                    case Model.FLEX1500:
                        MinFreq = Math.Max(if_freq, 0.000001);
                        MaxFreq = 54.0;

                        if (!hid_init)
                        {
                            hid_init = Flex1500.Init();
                            if (hid_init)
                                HIDEEPROM.Init();
                        }
                        if (hid_init)
                        {
                            chkVOX.Visible = false;
                            ptbVOX.Visible = false;
                            picVOX.Visible = false;
                            lblVOXVal.Visible = false;

                            prettyTrackBarVOX.Visible = false; // ke9ns add section
                            pictureBoxVOX.Visible = false;
                            labelVOXVal.Visible = false;

                            lblPreamp.Text = "Preamp";
                            comboPreamp.Items.Clear();
                            comboPreamp.Items.Add("-10");
                            comboPreamp.Items.Add("  0");
                            comboPreamp.Items.Add("+10");
                            comboPreamp.Items.Add("+20");
                            comboPreamp.Items.Add("+30");
                            comboPreamp.Visible = true;
                            chkRX1Preamp.Visible = false;
                            comboPreamp.Text = "  0";
                            comboPreamp_SelectedIndexChanged(this, EventArgs.Empty);

                            if (comboMeterTXMode.Items.Contains("Ref Pwr")) comboMeterTXMode.Items.Remove("Ref Pwr");
                            if (comboMeterTXMode.Items.Contains("SWR")) comboMeterTXMode.Items.Remove("SWR");

                            if (comboMeterTXMode.SelectedIndex < 0 ||
                                comboMeterTXMode.SelectedIndex > comboMeterTXMode.Items.Count - 1)
                                comboMeterTXMode.SelectedIndex = 0;

                            // ke9ns add below for 2nd meter
                            if (comboMeterTX1Mode.Items.Contains("Ref Pwr")) comboMeterTX1Mode.Items.Remove("Ref Pwr");
                            if (comboMeterTX1Mode.Items.Contains("SWR")) comboMeterTX1Mode.Items.Remove("SWR");

                            if (comboMeterTX1Mode.Items.Contains("Combo")) comboMeterTX1Mode.Items.Remove("Combo"); //ke9ns add for full combo TX meter  (Power, SWR, ALC, MIC)

                            if (comboMeterTX1Mode.SelectedIndex < 0 || comboMeterTX1Mode.SelectedIndex > comboMeterTX1Mode.Items.Count - 1)
                                comboMeterTX1Mode.SelectedIndex = 0;


                            chkBCI.Visible = false;
                            chkBCI.Checked = false;

                            dsp.GetDSPRX(0, 0).DCBlock = true;
                            dsp.GetDSPRX(0, 1).DCBlock = true;

                            mixerToolStripMenuItem.Visible = true;
                            if (flex1500MixerForm == null) flex1500MixerForm = new FLEX1500MixerForm(this);

                            chkX2TR.Text = "";
                            chkX2TR.Enabled = false;

                            if (hidAntForm == null) hidAntForm = new HIDAntForm(this);
                            antennaToolStripMenuItem.Visible = true;
                            herosToolStripMenuItem.Visible = true;
                            panelAntenna.Visible = true;  // this is for model 1500
                            chkFWCATUBypass.Enabled = false;

                            //DttSP.SetCorrectIQEnable(0); // disable IQ correction -- for now

                            //USBHID.WriteI2C2Value(0x30, 0x0C, 0x50); // turn HPF on
                        }
                        else
                        {
                            chkPower.Enabled = false;
                        }
                        break;
                    case Model.SDR1000:
                        MinFreq = Math.Max(if_freq, 0.000001);
                        if (XVTRPresent)
                            MaxFreq = 146.0;
                        else MaxFreq = 65.0;
                        comboPreamp.Items.Clear();
                        comboPreamp.Items.Add("Off");
                        comboPreamp.Items.Add("Low");
                        comboPreamp.Items.Add("Med");
                        comboPreamp.Items.Add("High");
                        comboPreamp.Visible = true;
                        //lblPreamp.Visible = true;
                        chkRX1Preamp.Visible = false;
                        comboPreamp_SelectedIndexChanged(this, EventArgs.Empty);

                        chkBCI.Visible = true;
                        //mnuFWC.Visible = false;
                        mixerToolStripMenuItem.Visible = false;
                        antennaToolStripMenuItem.Visible = false;
                        relaysToolStripMenuItem.Visible = false;
                        aTUToolStripMenuItem.Visible = false;
                        panelAntenna.Visible = false;
                        chkFWCATU.Visible = false;
                        chkFWCATUBypass.Visible = false;
                        break;
                    case Model.SOFTROCK40:
                        MinFreq = soft_rock_center_freq - sample_rate1 / 2 * 1e-6;
                        MaxFreq = soft_rock_center_freq + sample_rate1 / 2 * 1e-6;
                        //mnuFWC.Visible = false;
                        mixerToolStripMenuItem.Visible = false;
                        antennaToolStripMenuItem.Visible = false;
                        aTUToolStripMenuItem.Visible = false;
                        panelAntenna.Visible = false;
                        chkFWCATU.Visible = false;
                        chkFWCATUBypass.Visible = false;
                        break;
                    case Model.DEMO:
                        MinFreq = Math.Max(if_freq, 0.000001);
                        if (XVTRPresent)
                            MaxFreq = 146.0;
                        else MaxFreq = 65.0;
                        //mnuFWC.Visible = false;
                        mixerToolStripMenuItem.Visible = false;
                        antennaToolStripMenuItem.Visible = false;
                        aTUToolStripMenuItem.Visible = false;
                        panelAntenna.Visible = false;
                        chkFWCATU.Visible = false;
                        chkFWCATUBypass.Visible = false;
                        break;
                }
                if (setupForm != null && saved_model != current_model)
                {
                    txtVFOAFreq_LostFocus(this, EventArgs.Empty);
                    txtVFOBFreq_LostFocus(this, EventArgs.Empty);

                }
            }
        }

        private DateTimeMode current_datetime_mode = DateTimeMode.LOCAL;
        public DateTimeMode CurrentDateTimeMode
        {
            get { return current_datetime_mode; }
            set
            {
                current_datetime_mode = value;
                if (current_datetime_mode == DateTimeMode.OFF)
                {
                    panelDateTime.Text = "Date/Time - Off";
                    timer_clock.Enabled = false;
                    txtDate.Text = "";
                    txtTime.Text = "";
                }
                else
                {
                    if (panelDateTime.Text != "Date/Time") panelDateTime.Text = "Date/Time";
                    if (!timer_clock.Enabled) timer_clock.Enabled = true;
                }
            }
        }

        private double soft_rock_center_freq = 7.056;
        public double SoftRockCenterFreq
        {
            get { return soft_rock_center_freq; }
            set
            {
                soft_rock_center_freq = value;
                /*	if(current_model == Model.SOFTROCK40)
                    {
                        MinFreq = soft_rock_center_freq - sample_rate1/2*1e-6;
                        MaxFreq = soft_rock_center_freq + sample_rate1/2*1e-6;
                        if(setupForm != null)
                            txtVFOAFreq_LostFocus(this, EventArgs.Empty);
                    } */
            }
        }

        private double saved_vfoa_freq = 7.0;
        /*		public float SavedVFOAFreq
				{
					get { return saved_vfoa_freq; }
					set { saved_vfoa_freq = value; }
				}
		*/

        private double saved_vfoa_sub_freq = 7.0;

        private double saved_vfob_freq = 7.0;
        /*		public float SavedVFOBFreq
				{
					get { return saved_vfob_freq; }
					set { saved_vfob_freq = value; }
				}
		*/
        private bool ext_ctrl_enabled = false;
        public bool ExtCtrlEnabled
        {
            get { return ext_ctrl_enabled; }
            set { ext_ctrl_enabled = value; }
        }

        private bool cw_semi_break_in_enabled = true;
        public bool CWSemiBreakInEnabled
        {
            get { return cw_semi_break_in_enabled; }
            set { cw_semi_break_in_enabled = value; }
        }

        private bool cw_sidetone = true;
        public bool CWSidetone
        {
            get { return cw_sidetone; }
            set
            {
                cw_sidetone = value;
                if (chkCWSidetone != null) chkCWSidetone.Checked = value;

                DSPMode tx_mode = rx1_dsp_mode;
                if (chkVFOBTX.Checked && chkRX2.Checked) tx_mode = rx2_dsp_mode;

                if (tx_mode == DSPMode.CWL || tx_mode == DSPMode.CWU) chkMON.Checked = value;
            }
        }

        public float RX1FilterSizeCalOffset
        {
            get { return rx1_filter_size_cal_offset; }
            set { rx1_filter_size_cal_offset = value; }
        }

        public float RX2FilterSizeCalOffset
        {
            get { return rx2_filter_size_cal_offset; }
            set { rx2_filter_size_cal_offset = value; }
        }

        private PTTMode current_ptt_mode = PTTMode.NONE;
        public PTTMode CurrentPTTMode
        {
            get { return current_ptt_mode; }
            set { current_ptt_mode = value; }
        }

        #region X2 Properties

        private byte x2_160_rx = 0;
        public byte X2160RX
        {
            get { return x2_160_rx; }
            set
            {
                x2_160_rx = value;
                if (tx_band == Band.B160M && !mox)
                    txtVFOAFreq_LostFocus(this, EventArgs.Empty);
            }
        }

        private byte x2_160_tx = 0;
        public byte X2160TX
        {
            get { return x2_160_tx; }
            set
            {
                x2_160_tx = value;
                if (tx_band == Band.B160M && mox)
                    txtVFOAFreq_LostFocus(this, EventArgs.Empty);
            }
        }

        private byte x2_80_rx = 0;
        public byte X280RX
        {
            get { return x2_80_rx; }
            set
            {
                x2_80_rx = value;
                if (tx_band == Band.B80M && !mox)
                    txtVFOAFreq_LostFocus(this, EventArgs.Empty);
            }
        }

        private byte x2_80_tx = 0;
        public byte X280TX
        {
            get { return x2_80_tx; }
            set
            {
                x2_80_tx = value;
                if (tx_band == Band.B80M && mox)
                    txtVFOAFreq_LostFocus(this, EventArgs.Empty);
            }
        }

        private byte x2_60_rx = 0;
        public byte X260RX
        {
            get { return x2_60_rx; }
            set
            {
                x2_60_rx = value;
                if (tx_band == Band.B60M && !mox)
                    txtVFOAFreq_LostFocus(this, EventArgs.Empty);
            }
        }

        private byte x2_60_tx = 0;
        public byte X260TX
        {
            get { return x2_60_tx; }
            set
            {
                x2_60_tx = value;
                if (tx_band == Band.B60M && mox)
                    txtVFOAFreq_LostFocus(this, EventArgs.Empty);
            }
        }

        private byte x2_40_rx = 0;
        public byte X240RX
        {
            get { return x2_40_rx; }
            set
            {
                x2_40_rx = value;
                if (tx_band == Band.B40M && !mox)
                    txtVFOAFreq_LostFocus(this, EventArgs.Empty);
            }
        }

        private byte x2_40_tx = 0;
        public byte X240TX
        {
            get { return x2_40_tx; }
            set
            {
                x2_40_tx = value;
                if (tx_band == Band.B40M && mox)
                    txtVFOAFreq_LostFocus(this, EventArgs.Empty);
            }
        }

        private byte x2_30_rx = 0;
        public byte X230RX
        {
            get { return x2_30_rx; }
            set
            {
                x2_30_rx = value;
                if (tx_band == Band.B30M && !mox)
                    txtVFOAFreq_LostFocus(this, EventArgs.Empty);
            }
        }

        private byte x2_30_tx = 0;
        public byte X230TX
        {
            get { return x2_30_tx; }
            set
            {
                x2_30_tx = value;
                if (tx_band == Band.B30M && mox)
                    txtVFOAFreq_LostFocus(this, EventArgs.Empty);
            }
        }

        private byte x2_20_rx = 0;
        public byte X220RX
        {
            get { return x2_20_rx; }
            set
            {
                x2_20_rx = value;
                if (tx_band == Band.B20M && !mox)
                    txtVFOAFreq_LostFocus(this, EventArgs.Empty);
            }
        }

        private byte x2_20_tx = 0;
        public byte X220TX
        {
            get { return x2_20_tx; }
            set
            {
                x2_20_tx = value;
                if (tx_band == Band.B20M && mox)
                    txtVFOAFreq_LostFocus(this, EventArgs.Empty);
            }
        }

        private byte x2_17_rx = 0;
        public byte X217RX
        {
            get { return x2_17_rx; }
            set
            {
                x2_17_rx = value;
                if (tx_band == Band.B17M && !mox)
                    txtVFOAFreq_LostFocus(this, EventArgs.Empty);
            }
        }

        private byte x2_17_tx = 0;
        public byte X217TX
        {
            get { return x2_17_tx; }
            set
            {
                x2_17_tx = value;
                if (tx_band == Band.B17M && mox)
                    txtVFOAFreq_LostFocus(this, EventArgs.Empty);
            }
        }

        private byte x2_15_rx = 0;
        public byte X215RX
        {
            get { return x2_15_rx; }
            set
            {
                x2_15_rx = value;
                if (tx_band == Band.B15M && !mox)
                    txtVFOAFreq_LostFocus(this, EventArgs.Empty);
            }
        }

        private byte x2_15_tx = 0;
        public byte X215TX
        {
            get { return x2_15_tx; }
            set
            {
                x2_15_tx = value;
                if (tx_band == Band.B15M && mox)
                    txtVFOAFreq_LostFocus(this, EventArgs.Empty);
            }
        }

        private byte x2_12_rx = 0;
        public byte X212RX
        {
            get { return x2_12_rx; }
            set
            {
                x2_12_rx = value;
                if (tx_band == Band.B12M && !mox)
                    txtVFOAFreq_LostFocus(this, EventArgs.Empty);
            }
        }

        private byte x2_12_tx = 0;
        public byte X212TX
        {
            get { return x2_12_tx; }
            set
            {
                x2_12_tx = value;
                if (tx_band == Band.B12M && mox)
                    txtVFOAFreq_LostFocus(this, EventArgs.Empty);
            }
        }

        private byte x2_10_rx = 0;
        public byte X210RX
        {
            get { return x2_10_rx; }
            set
            {
                x2_10_rx = value;
                if (tx_band == Band.B10M && !mox)
                    txtVFOAFreq_LostFocus(this, EventArgs.Empty);
            }
        }

        private byte x2_10_tx = 0;
        public byte X210TX
        {
            get { return x2_10_tx; }
            set
            {
                x2_10_tx = value;
                if (tx_band == Band.B10M && mox)
                    txtVFOAFreq_LostFocus(this, EventArgs.Empty);
            }
        }

        private byte x2_6_rx = 0;
        public byte X26RX
        {
            get { return x2_6_rx; }
            set
            {
                x2_6_rx = value;
                if (tx_band == Band.B6M && !mox)
                    txtVFOAFreq_LostFocus(this, EventArgs.Empty);
            }
        }

        private byte x2_6_tx = 0;
        public byte X26TX
        {
            get { return x2_6_tx; }
            set
            {
                x2_6_tx = value;
                if (tx_band == Band.B6M && mox)
                    txtVFOAFreq_LostFocus(this, EventArgs.Empty);
            }
        }

        private byte x2_2_rx = 0;
        public byte X22RX
        {
            get { return x2_2_rx; }
            set
            {
                x2_2_rx = value;
                if (tx_band == Band.B2M && !mox)
                    txtVFOAFreq_LostFocus(this, EventArgs.Empty);
            }
        }

        private byte x2_2_tx = 0;
        public byte X22TX
        {
            get { return x2_2_tx; }
            set
            {
                x2_2_tx = value;
                if (tx_band == Band.B2M && mox)
                    txtVFOAFreq_LostFocus(this, EventArgs.Empty);
            }
        }

        #endregion

        //==================================================
        // ke9ns add
        private bool vfo_lockB = false;
        public bool VFOLockB
        {
            get { return vfo_lockB; }
            set
            {
                vfo_lockB = value;
                bool enabled = !value;
                txtVFOBFreq.Enabled = enabled;
                comboRX2Band.Enabled = enabled;

                btnVFOBtoA.Enabled = enabled;
                btnVFOSwap.Enabled = enabled;
                btnMemoryQuickRestore.Enabled = enabled;

            } // set

        } // VFOLockB


        //===================================================
        private bool vfo_lock = false;
        public bool VFOLock
        {
            get { return vfo_lock; }
            set
            {
                vfo_lock = value;
                bool enabled = !value;

                txtVFOAFreq.Enabled = enabled;

                radBand160.Enabled = enabled;
                radBand80.Enabled = enabled;
                radBand60.Enabled = enabled;
                radBand40.Enabled = enabled;
                radBand30.Enabled = enabled;
                radBand20.Enabled = enabled;
                radBand17.Enabled = enabled;
                radBand15.Enabled = enabled;
                radBand12.Enabled = enabled;
                radBand10.Enabled = enabled;
                radBand6.Enabled = enabled;
                radBand2.Enabled = enabled;
                radBandWWV.Enabled = enabled;
                radBandGEN.Enabled = enabled;

                //   btnBandVHF.Enabled = enabled; 
                //   radBandVHF0.Enabled = enabled;
                //  radBandVHF1.Enabled = enabled;
                //  radBandVHF2.Enabled = enabled;
                //  radBandVHF3.Enabled = enabled;
                //  radBandVHF4.Enabled = enabled;
                //  radBandVHF5.Enabled = enabled;
                //  radBandVHF6.Enabled = enabled;
                //  radBandVHF7.Enabled = enabled;
                //  radBandVHF8.Enabled = enabled;
                //  radBandVHF5.Enabled = enabled;
                //  radBandVHF9.Enabled = enabled;
                // radBandVHF10.Enabled = enabled;
                //  radBandVHF11.Enabled = enabled;
                // radBandVHF12.Enabled = enabled;
                //  radBandVHF13.Enabled = enabled;



                btnBandHF1.Enabled = enabled; // ke9ns add
                radBandGN0.Enabled = enabled;
                radBandGN1.Enabled = enabled;
                radBandGN2.Enabled = enabled;
                radBandGN3.Enabled = enabled;
                radBandGN4.Enabled = enabled;
                radBandGN5.Enabled = enabled;
                radBandGN6.Enabled = enabled;
                radBandGN7.Enabled = enabled;
                radBandGN8.Enabled = enabled;
                radBandGN5.Enabled = enabled;
                radBandGN9.Enabled = enabled;
                radBandGN10.Enabled = enabled;
                radBandGN11.Enabled = enabled;
                radBandGN12.Enabled = enabled;
                radBandGN13.Enabled = enabled;


                radModeLSB.Enabled = enabled;
                radModeUSB.Enabled = enabled;
                radModeDSB.Enabled = enabled;
                radModeCWL.Enabled = enabled;
                radModeCWU.Enabled = enabled;
                radModeFMN.Enabled = enabled;
                radModeAM.Enabled = enabled;
                radModeSAM.Enabled = enabled;
                radModeSPEC.Enabled = enabled;
                radModeDIGL.Enabled = enabled;
                radModeDIGU.Enabled = enabled;
                radModeDRM.Enabled = enabled;

                btnVFOBtoA.Enabled = enabled;
                btnVFOSwap.Enabled = enabled;

                btnMemoryQuickRestore.Enabled = enabled;

            } // set

        } // VFOlockA



        //==================================================================================================
        // ke9ns    playback audio file on vf0a only
        private double wave_freq = 0.0;
        private bool wave_playback = false;
        public bool WavePlayback
        {
            get { return wave_playback; }
            set
            {
                wave_playback = value;
                if (wave_playback)
                {
                    wave_freq = (VFOAFreq * 1e6) % sample_rate1; // 25000 hz = (3.865 * 1mhz) % 192000hz  (modulus is remainder only)
                                                                 //  Debug.WriteLine("wave_freq " + wave_freq);  // ke9ns test
                                                                 //  Debug.WriteLine("VFO_freq " + VFOAFreq);  // ke9ns test
                                                                 //  Debug.WriteLine("SR " + sample_rate1);  // ke9ns test

                }
                else
                {
                    txtVFOAFreq_LostFocus(this, EventArgs.Empty);
                }
            }
        } // WavePlayback




        private bool saved_rx_only = false;
        private bool rx_only = false;
        public bool RXOnly
        {
            get
            {
                return rx_only;
            }
            set
            {
                rx_only = value;

                if (rx1_dsp_mode != DSPMode.SPEC && rx1_dsp_mode != DSPMode.DRM && chkPower.Checked) chkMOX.Enabled = !rx_only;

                chkTUN.Enabled = !rx_only;
                chkVOX.Enabled = !rx_only;

                if (rx_only && chkMOX.Checked) chkMOX.Checked = false;

                if (setupForm != null)
                {
                    if (setupForm.RXOnly != rx_only) setupForm.RXOnly = rx_only;
                }

                // ke9ns add: below to allow PTT to pause the Radio while another radio transmits
                if (rx_only == true)
                {
                    if (poll_RXOnly_thread == null || !poll_RXOnly_thread.IsAlive)
                    {
                        poll_RXOnly_thread = new Thread(new ThreadStart(PollRXOnly));
                        poll_RXOnly_thread.Name = "Poll RXOnly Thread";
                        poll_RXOnly_thread.Priority = ThreadPriority.Normal;
                        poll_RXOnly_thread.IsBackground = true;
                        poll_RXOnly_thread.Start();


                    }
                }
                else
                {
                    if ((poll_RXOnly_thread != null)) // ke9ns mod
                    {
                        if (!poll_RXOnly_thread.Join(500)) poll_RXOnly_thread.Abort();
                    }
                }

            } // set


        } // RXOnly

        private XVTRTRMode current_xvtr_tr_mode = XVTRTRMode.NEGATIVE;
        public XVTRTRMode CurrentXVTRTRMode
        {
            get { return current_xvtr_tr_mode; }
            set
            {
                if (current_model != Model.SDR1000) return;
                current_xvtr_tr_mode = value;
                switch (current_xvtr_tr_mode)
                {
                    case XVTRTRMode.NEGATIVE:
                        Hdw.XVTR_TR = true;         // Set to receive
                        break;
                    case XVTRTRMode.POSITIVE:
                        Hdw.XVTR_TR = false;            // Set to receive
                        break;
                    case XVTRTRMode.NONE:
                        Hdw.XVTR_TR = false;
                        break;
                }
            }
        }

        private double dds_step_size = 200.0 / 0xFFFFFFFFFFFF;
        private double corrected_dds_clock = 200.0;
        private double dds_clock_correction = 0.0;
        public double DDSClockCorrection
        {
            get { return dds_clock_correction; }
            set
            {
                dds_clock_correction = value;
                corrected_dds_clock = 200.0 + dds_clock_correction;
                dds_step_size = corrected_dds_clock / 0xFFFFFFFFFFFF;
                DDSFreq = dds_freq;
            }
        }

        private double fwc_dds_step_size = 500.0 / 0xFFFFFFFF;
        private double fwc_corrected_dds_clock = 500.0;
        private double fwc_dds_clock_correction = 0.0;
        public double FWCDDSClockCorrection
        {
            get { return fwc_dds_clock_correction; }
            set
            {
                double clock = 500.0;
                switch (current_model)
                {
                    case Model.FLEX3000:
                        clock = 499.201;
                        break;
                    case Model.FLEX5000:
                        clock = 500.0;
                        break;
                }

                fwc_dds_clock_correction = value;
                fwc_corrected_dds_clock = clock + fwc_dds_clock_correction;
                fwc_dds_step_size = fwc_corrected_dds_clock / 0xFFFFFFFF;
                if (setupForm != null)
                    txtVFOAFreq_LostFocus(this, EventArgs.Empty);
            }
        }

        private double hid_dds_step_size = 384.0 / 0xFFFFFFFF / 2;
        private double hid_corrected_dds_clock = 384.0;
        private double hid_dds_clock_correction = 0.0;
        public double HIDDDSClockCorrection
        {
            get { return hid_dds_clock_correction; }
            set
            {
                double clock = 384.0;
                if (flex_1500_xref)
                    clock = 400.0;

                hid_dds_clock_correction = value;
                hid_corrected_dds_clock = clock + hid_dds_clock_correction;
                hid_dds_step_size = hid_corrected_dds_clock / 0xFFFFFFFF / 2;
                if (setupForm != null)
                    txtVFOAFreq_LostFocus(this, EventArgs.Empty);
            }
        }

        /*private double rx2_dds_step_size = 500.0 / 0xFFFFFFFF;
		private double rx2_corrected_dds_clock = 500.0;
		private double rx2_dds_clock_correction = 0.0;
		public double RX2DDSClockCorrection
		{
			get	{ return rx2_dds_clock_correction; }
			set
			{
				rx2_dds_clock_correction = value;
				rx2_corrected_dds_clock = 500.0 + rx2_dds_clock_correction;
				rx2_dds_step_size = rx2_corrected_dds_clock / 0xFFFFFFFF;
				RX2DDSFreq = rx2_dds_freq;
			}
		}*/

        public FRSRegion current_region = FRSRegion.US;
        public FRSRegion CurrentRegion
        {
            get
            {
                return current_region;
            }
            set
            {
                current_region = value;
            }
        }

        private bool spur_reduction = true;
        public bool SpurReduction
        {
            get { return spur_reduction; }
            set
            {
                spur_reduction = value;
                if (setupForm != null) txtVFOAFreq_LostFocus(this, EventArgs.Empty);
                chkSR.Checked = value;
            }
        }

        private bool rx2_spur_reduction = true;
        public bool RX2SpurReduction
        {
            get { return rx2_spur_reduction; }
            set
            {
                rx2_spur_reduction = value;
                if (setupForm != null && rx2_enabled)
                    txtVFOBFreq_LostFocus(this, EventArgs.Empty);
                chkRX2SR.Checked = value;
                if (!rx2_spur_reduction) rx2_last_tw = 0;
            }
        }

        public long Freq2TW(double freq)
        {
            long tw = 0;
            switch (current_model)
            {
                case Model.SDR1000:
                    tw = (long)(0xFFFFFFFFFFFF * freq / corrected_dds_clock);
                    break;
                case Model.FLEX3000:
                case Model.FLEX5000:
                    tw = (long)(0xFFFFFFFF * freq / fwc_corrected_dds_clock);
                    break;
                case Model.FLEX1500:
                    tw = (long)(0xFFFFFFFF * freq * 2 / hid_corrected_dds_clock);
                    break;
            }
            return tw;
        } // Freq2TW

        private double TW2Freq(long tw)
        {
            double freq = 0.0;
            switch (current_model)
            {
                case Model.SDR1000:
                    freq = tw * corrected_dds_clock / 0xFFFFFFFFFFFF;
                    break;
                case Model.FLEX3000:
                case Model.FLEX5000:
                    freq = tw * fwc_corrected_dds_clock / 0xFFFFFFFF;
                    break;
                case Model.FLEX1500:
                    freq = tw * hid_corrected_dds_clock / 0xFFFFFFFF / 2;
                    break;
            }
            return freq;
        }

        bool rx1_dds_freq_updated = false;
        uint rx1_dds_freq_tw;
        float rx1_dds_freq_mhz;

        private void UpdateRX1DDSFreq() // ke9ns: THREAD running all the time when power on
        {
            while (chkPower.Checked)
            {
                if (rx1_dds_freq_updated) // ke9ns: Occurs after FWCDDSFreq is called (but not all time, as it depends on where you are)
                {
                    Debug.WriteLine("UpdateRX1DDSFreq");


                    uint tw = rx1_dds_freq_tw;
                    float freq = rx1_dds_freq_mhz;
                    rx1_dds_freq_updated = false;
                    switch (current_model)
                    {
                        case Model.FLEX5000:
                        case Model.FLEX3000:

                            FWC.SetRX1FreqTW(tw, freq); // ke9ns: send new corrected clock and freq to radio ?

                            break;
                        case Model.FLEX1500:
                            USBHID.SetFreqTW(tw);
                            Set1500Filters(TW2Freq(tw));
                            break;
                    }

                    if (!mox) WBIRRX1Holdoff();

                    UP1 = true; // .251
                }
                else Thread.Sleep(100);
            }
        } //  UpdateRX1DDSFreq() 

        bool rx2_dds_freq_updated = false;
        uint rx2_dds_freq_tw;
        float rx2_dds_freq_mhz;
        private void UpdateRX2DDSFreq() // ke9ns: THREAD routine running all the time
        {
            while (chkPower.Checked)
            {
                if (rx2_dds_freq_updated)
                {
                    uint tw = rx2_dds_freq_tw;
                    float freq = rx2_dds_freq_mhz;
                    rx2_dds_freq_updated = false;
                    FWC.SetRX2FreqTW(tw, freq);
                    if (!mox) WBIRRX1Holdoff();
                }
                else Thread.Sleep(100);
            }
        } // UpdateRX2DDSFreq()

        bool tx_dds_freq_updated = false;
        uint tx_dds_freq_tw;
        float tx_dds_freq_mhz;
        double last_tx_carrier_key = 0.0;
        private void UpdateTXDDSFreq() //ke9ns:  THREAD to update TX freq of DSP routine all the time
        {
            while (chkPower.Checked)
            {
                if (tx_dds_freq_updated) //  // ke9ns: Occurs after FWCDDSFreq is called (all the time assuming your TX is moving as well as RX)
                {

                    Debug.WriteLine("UpdateTXDDSFreq");

                    uint tw = tx_dds_freq_tw;
                    float freq = tx_dds_freq_mhz;
                    tx_dds_freq_updated = false;
                    FWC.SetTXFreqTW(tw, freq);

                    double key = 0.0;
                    if (FindNearestKey<uint>(tx_dds_freq_mhz, tx_carrier_cal, out key))
                    {
                        if (key != last_tx_carrier_key || calibrating)
                        {
                            uint val = tx_carrier_cal[key];
                            FWC.SetTRXPot(val);
                            last_tx_carrier_key = key;

                            flex5000DebugForm.SetTRXPot(0, (byte)(val >> 24));
                            flex5000DebugForm.SetTRXPot(1, (byte)(val >> 16));
                            flex5000DebugForm.SetTRXPot(2, (byte)(val >> 8));
                            flex5000DebugForm.SetTRXPot(3, (byte)(val >> 0));
                        }
                    }


                }
                else Thread.Sleep(100);

            } // while

        } // UpdateTXDDSFreq()


        private uint last_tw = 0;
        private double fwc_dds_freq = 7.0;
        public double FWCDDSFreq  // ke9ns: Used to actually change RX1 freq of the DSP routine from txtVFOAFreq_lostFocus() routine (for Flex-1500,3000,5000 only)
        {
            get { return fwc_dds_freq; }
            set
            {

                fwc_dds_freq = value; // ke9ns: freq that you want from txtVFOAFreq_lostFocus() routine

                if (spur_reduction)
                {
                    double f = fwc_dds_freq + vfo_offset;
                    if (if_shift) f -= if_freq;
                    uint tw = (uint)Freq2TW(f); //Debug.WriteLine("tw: "+tw.ToString("X"));
                    uint sr_tw = tw & 0xFFFF0000;

                    double step_size = fwc_dds_step_size;
                    if (current_model == Model.FLEX1500) step_size = hid_dds_step_size;

                    double dsp_osc_freq = (double)(1e6 * ((tw - sr_tw) * step_size));

                    if (if_shift) dsp.GetDSPRX(0, 0).RXOsc = -dsp_osc_freq - if_freq * 1e6 + vfo_offset;
                    else dsp.GetDSPRX(0, 0).RXOsc = -dsp_osc_freq + vfo_offset;

                    if (last_tw != sr_tw)
                    {
                        //Debug.WriteLine("sr_tw: "+sr_tw.ToString("X")+" VFO: "+VFOAFreq.ToString("f6" ));

                        if (fwc_init || hid_init) // ke9ns: always set to true (Unless SDR-1000)
                        {

                            switch (current_model)
                            {
                                /*case Model.SDRX:
                                    FWC.SetDDSFreq(fwc_index, (float)TW2Freq(sr_tw));
                                    break;*/
                                case Model.FLEX5000:
                                    rx1_dds_freq_tw = sr_tw;
                                    rx1_dds_freq_mhz = (float)TW2Freq(sr_tw) * (float)(500.0 / fwc_corrected_dds_clock);
                                    rx1_dds_freq_updated = true;
                                    //   Debug.WriteLine("DDS_FREQ===sr_tw=====" + sr_tw);
                                    //    Debug.WriteLine("DDS_FREQ===freqMhz=====" + rx1_dds_freq_mhz);

                                    //FWC.SetRX1FreqTW(sr_tw, (float)TW2Freq(sr_tw) * (float)(500.0 / fwc_corrected_dds_clock));
                                    //FWC.SetRX1Freq((float)TW2Freq(sr_tw) * (float)(500.0 / fwc_corrected_dds_clock));
                                    break;
                                case Model.FLEX3000:
                                    rx1_dds_freq_tw = sr_tw;
                                    rx1_dds_freq_mhz = (float)TW2Freq(sr_tw) * (float)(499.2 / fwc_corrected_dds_clock);
                                    rx1_dds_freq_updated = true;
                                    //FWC.SetRX1FreqTW(sr_tw, (float)TW2Freq(sr_tw) * (float)(499.2 / fwc_corrected_dds_clock));
                                    //FWC.SetRX1Freq((float)TW2Freq(sr_tw) * (float)(499.2 / fwc_corrected_dds_clock));
                                    break;
                                case Model.FLEX1500:
                                    rx1_dds_freq_tw = sr_tw;
                                    double clock = 384.0;
                                    if (flex_1500_xref) clock = 400.0;
                                    rx1_dds_freq_mhz = (float)TW2Freq(sr_tw) * (float)(clock / fwc_corrected_dds_clock);
                                    rx1_dds_freq_updated = true;
                                    break;
                            }
                        } //

                    } // if (last_tw != sr_tw)
                    last_tw = sr_tw;
                    UP1 = true; // .251 

                    //Debug.WriteLine("sr_tw freq: "+TW2Freq(sr_tw).ToString("f6" )+" osc: "+(-dsp_osc_freq*1e-6).ToString("f6" )+" total: "+(TW2Freq(sr_tw)+dsp_osc_freq*1e-6).ToString("f6" ));
                } // spur_reduction
                else
                {
                    if (fwc_init || hid_init) // ke9ns: fwc_init is always true for Flex-3000 and 5000 (not used by SDR-1000)
                    {
                        switch (current_model)
                        {
                            /*case Model.SDRX:
                                FWC.SetDDSFreq(fwc_index, (float)fwc_dds_freq-(float)if_freq);
                                break;*/
                            case Model.FLEX5000:
                            case Model.FLEX3000:
                                double f = fwc_dds_freq + vfo_offset;
                                if (if_shift) f -= if_freq;
                                uint tw = (uint)Freq2TW(f);
                                rx1_dds_freq_tw = tw;
                                rx1_dds_freq_mhz = (float)f;
                                rx1_dds_freq_updated = true;
                                //FWC.SetRX1FreqTW(tw, (float)f);
                                break;
                            case Model.FLEX1500:
                                f = fwc_dds_freq + vfo_offset;
                                if (if_shift) f -= if_freq;
                                tw = (uint)Freq2TW(f);
                                rx1_dds_freq_tw = tw;
                                rx1_dds_freq_updated = true;
                                break;
                        }
                    }
                    if (if_shift)
                        dsp.GetDSPRX(0, 0).RXOsc = -if_freq * 1e6;
                    else
                        dsp.GetDSPRX(0, 0).RXOsc = 0.0;
                    last_tw = 0;
                    //Debug.WriteLine("dds: "+fwc_dds_freq.ToString("f6" )+" osc: "+(-if_freq*1e6).ToString("f6" )+" total: "+(fwc_dds_freq+if_freq).ToString("f6" ));

                } // spur_reduction = no

                Debug.WriteLine("FWCDDSFreq");

                //  UP1 = true; // .251

            } // set

        } // FWCDDSFreq 



        private uint rx2_last_tw = 0;
        private double rx2_dds_freq = 7.0;
        public double RX2DDSFreq        // ke9ns: set freq for 2nd receiver (flex-5000 only)
        {
            get { return rx2_dds_freq; }
            set
            {
                rx2_dds_freq = value;

                if (rx2_spur_reduction)
                {
                    double f = rx2_dds_freq + rx2_vfo_offset;
                    if (rx2_if_shift) f -= rx2_if_freq;
                    uint tw = (uint)Freq2TW(f); //Debug.WriteLine("tw: "+tw.ToString("X"));
                    uint sr_tw = tw & 0xFFFF0000;
                    double dsp_osc_freq = (double)(1e6 * ((tw - sr_tw) * fwc_dds_step_size));
                    if (rx2_if_shift) dsp.GetDSPRX(1, 0).RXOsc = -dsp_osc_freq - rx2_if_freq * 1e6 + rx2_vfo_offset;
                    else dsp.GetDSPRX(1, 0).RXOsc = -dsp_osc_freq + rx2_vfo_offset;
                    if (rx2_last_tw != sr_tw)
                    {
                        //Debug.WriteLine("sr_tw: "+sr_tw.ToString("X")+" VFO: "+VFOAFreq.ToString("f6" ));
                        if (fwc_init)
                        {
                            switch (current_model)
                            {
                                /*case Model.SDRX:
                                    FWC.SetDDSFreq(fwc_index, (float)TW2Freq(sr_tw));
                                    break;*/
                                case Model.FLEX5000:
                                    //FWC.SetRX2Freq((float)TW2Freq(sr_tw) * (float)(500.0 / fwc_corrected_dds_clock));
                                    //FWC.SetRX2FreqTW(sr_tw, (float)TW2Freq(sr_tw) * (float)(500.0 / fwc_corrected_dds_clock));
                                    rx2_dds_freq_tw = sr_tw;
                                    rx2_dds_freq_mhz = (float)TW2Freq(sr_tw) * (float)(500.0 / fwc_corrected_dds_clock);
                                    rx2_dds_freq_updated = true;
                                    break;
                            }
                        }
                    }
                    rx2_last_tw = sr_tw;
                    //Debug.WriteLine("sr_tw freq: "+TW2Freq(sr_tw).ToString("f6" )+" osc: "+(-dsp_osc_freq*1e-6).ToString("f6" )+" total: "+(TW2Freq(sr_tw)+dsp_osc_freq*1e-6).ToString("f6" ));
                }
                else
                {
                    if (fwc_init)
                    {
                        switch (current_model)
                        {
                            /*case Model.SDRX:
                                FWC.SetDDSFreq(fwc_index, (float)fwc_dds_freq-(float)if_freq);
                                break;*/
                            case Model.FLEX5000:
                                double f = rx2_dds_freq + rx2_vfo_offset;
                                if (rx2_if_shift) f -= rx2_if_freq;
                                uint tw = (uint)Freq2TW(f);
                                //FWC.SetRX2FreqTW(tw, (float)f);
                                rx2_dds_freq_tw = tw;
                                rx2_dds_freq_mhz = (float)f;
                                rx2_dds_freq_updated = true;
                                break;
                        }
                    }

                    if (rx2_if_shift)
                        dsp.GetDSPRX(1, 0).RXOsc = -rx2_if_freq * 1e6;
                    else
                        dsp.GetDSPRX(1, 0).RXOsc = 0.0;
                    last_tw = 0;
                    //Debug.WriteLine("dds: "+fwc_dds_freq.ToString("f6" )+" osc: "+(-if_freq*1e6).ToString("f6" )+" total: "+(fwc_dds_freq+if_freq).ToString("f6" ));
                } // spur_reduction

                UP2 = true;
            } // set

        } // RX2DDSFreq




        private double dds_freq = 7.0;
        public double DDSFreq        // ke9ns: this is only for SDR-1000 and others,  Flex-1500,3000,5000 use FWCDDSFreq (above)
        {
            get { return dds_freq; }
            set
            {
                Debug.WriteLine("DDSFreq");

                dds_freq = value;
                //Debug.WriteLine("dds_freq: "+dds_freq.ToString("f6" ));

                double vfoFreq = value, f = value;
                double dsp_osc_freq = 0;

                //calculate DDS Tuning Word
                // ke9ns test
                if (xvtr_present && f >= 122 && f <= 165)        // If transverter enabled compute 28MHz IF frequency
                {
                    f -= 116;     // 94                               // Subtract 116MHz (144-28) from VFO display frequency
                }


                /*
                                if (xvtr_present && f >= 144 && f <= 146)        // If transverter enabled compute 28MHz IF frequency
                                {
                                    f -= 116;                                   // Subtract 116MHz (144-28) from VFO display frequency
                                }
                */
                if (if_shift)
                {
                    f -= if_freq;                               // adjust for IF shift
                    dsp_osc_freq = -if_freq * 1e6;
                }

                f += vfo_offset;                                // adjust for vfo offset
                /*if(mox && current_dsp_mode == DSPMode.DRM)
                    f -= 0.008;*/
                long tuning_word = (long)(f / corrected_dds_clock * Math.Pow(2, 48));

                if (spur_reduction)
                {
                    long sr_tuning_word = tuning_word &     // start with current tuning word
                        ~(0x8000ffffffff);  // clear first bit, low 32 bits

                    double software_offset = (sr_tuning_word - tuning_word) * dds_step_size;
                    dsp_osc_freq += 1000000.0 * software_offset;

                    tuning_word = sr_tuning_word;
                }

                if (current_model == Model.SDR1000)
                {
                    if (Hdw.DDSTuningWord != tuning_word)
                        WBIRRX1Holdoff();

                    Hdw.DDSTuningWord = tuning_word;
                    SetHWFilters(dds_freq);
                }
                if (!mox) dsp.GetDSPRX(0, 0).RXOsc = dsp_osc_freq;


            } // set

        } // DDSfreq

        public double TuningWordToFreq(long word)
        {
            return word * corrected_dds_clock / Math.Pow(2, 48);
        }

        private double min_freq = 0.011025;
        public double MinFreq
        {
            get { return min_freq; }
            set
            {
                min_freq = value;
                if (VFOAFreq < min_freq)
                    VFOAFreq = min_freq;
            }
        }

        private double max_freq = 75.0; // .240 was 65.0 now 75
        public double MaxFreq
        {
            get { return max_freq; }
            set
            {
                max_freq = value;

                if (setupForm == null) return;
                if (VFOAFreq > max_freq && rx1_xvtr_index < 0) VFOAFreq = max_freq;
            }
        }

        private double vfo_offset = 0.0;
        public double VFOOffset
        {
            get { return vfo_offset; }
            set { vfo_offset = value; }
        }

        private double rx2_vfo_offset = 0.0;
        public double RX2VFOOffset
        {
            get { return rx2_vfo_offset; }
            set { rx2_vfo_offset = value; }
        }

        private double if_freq = 0.009000; // ke9ns .009 = 9000 value
        public double IFFreq
        {
            get { return if_freq; }
            set
            {
                if_freq = value;
                if (setupForm != null) txtVFOAFreq_LostFocus(this, EventArgs.Empty);
                ptbDisplayPan_Scroll(this, EventArgs.Empty);
            }
        }

        private double rx2_if_freq = 0.009000;
        public double RX2IFFreq
        {
            get { return rx2_if_freq; }
            set
            {
                rx2_if_freq = value;
                if (setupForm != null && rx2_enabled)
                    txtVFOBFreq_LostFocus(this, EventArgs.Empty);
            }
        }

        private bool if_shift = true;
        public bool IFShift
        {
            get { return if_shift; }
            set { if_shift = value; }
        }

        private bool rx2_if_shift = true;
        public bool RX2IFShift
        {
            get { return rx2_if_shift; }
            set { rx2_if_shift = value; }
        }

        public bool extended = false;
        public bool Extended
        {
            get { return extended; }
            set { extended = value; }
        }

        private bool enable_LPF0 = false;
        public bool EnableLPF0
        {
            get { return enable_LPF0; }
            set { enable_LPF0 = value; }
        }

        private int latch_delay = 0;
        public int LatchDelay
        {
            get { return latch_delay; }
            set { latch_delay = value; }
        }

        private bool x2_enabled = false;
        public bool X2Enabled
        {
            get { return x2_enabled; }
            set
            {
                x2_enabled = value;
                X2TR = value;
                if (current_model == Model.SDR1000)
                {
                    if (value && mox)
                        Hdw.X2 |= 0x40;
                    else Hdw.X2 &= 0xBF;
                }
            }
        }

        private int x2_delay = 500;
        public int X2Delay
        {
            get { return x2_delay; }
            set { x2_delay = value; }
        }

        public bool CPDR
        {
            get { return chkCPDR.Checked; }
            set
            {
                if (setupForm == null)
                    return;

                chkCPDR.Checked = value;
            }
        }

        public int CPDRLevel
        {
            get { return ptbCPDR.Value; }
            set
            {
                if (setupForm == null) return;
                ptbCPDR.Value = value;
                ptbCPDR_Scroll(this, EventArgs.Empty);
            }
        }

        public int Mic
        {
            get { return ptbMic.Value; }
            set
            {
                if (setupForm == null)
                    return;

                ptbMic.Value = value;
                ptbMic_Scroll(this, EventArgs.Empty);
            }
        }

        public int FMMic  // W4TME
        {
            get { return ptbFMMic.Value; }
            set
            {
                if (setupForm == null)
                    return;
                ptbFMMic.Value = value;
                ptbFMMic_Scroll(this, EventArgs.Empty);
            }
        }



        #region CAT Properties

        // props for cat control 

        public double CATVFOA
        {
            get { return saved_vfoa_freq; }
        }

        public double CATVFOB
        {
            get { return saved_vfob_freq; }
        }

        public int CATTXProfileCount
        {
            get
            {
                return comboTXProfile.Items.Count;
            }
        }

        public int CATTXProfile
        {
            get
            {
                return comboTXProfile.SelectedIndex;
            }
            set
            {
                UpdateTXProfile(value);
            }
        }

        public string CATPanSwap
        {
            get
            {
                if (chkPanSwap.Checked)
                    return "1";
                else
                    return "0";
            }
            set
            {
                if (value == "1")
                    chkPanSwap.Checked = true;
                else
                    chkPanSwap.Checked = false;
            }
        }

        public string CATPhoneDX
        {
            get
            {
                if (chkDX.Checked)
                    return "1";
                else
                    return "0";
            }
            set
            {
                if (value == "1")
                    chkDX.Checked = true;
                else
                    chkDX.Checked = false;
            }
        }

        public string CATMultRX
        {
            get
            {
                if (chkEnableMultiRX.Checked)
                    return "1";
                else
                    return "0";
            }
            set
            {
                if (value == "1")
                    chkEnableMultiRX.Checked = true;
                else
                    chkEnableMultiRX.Checked = false;
            }

        }

        public string CATRXEQ
        {
            get
            {
                if (chkRXEQ.Checked)
                    return "1";
                else
                    return "0";
            }
            set
            {
                if (value == "1")
                    chkRXEQ.Checked = true;
                else
                    chkRXEQ.Checked = false;
            }
        }

        public string CATTXEQ
        {
            get
            {
                if (chkTXEQ.Checked)
                    return "1";
                else
                    return "0";
            }
            set
            {
                if (value == "1")
                    chkTXEQ.Checked = true;
                else
                    chkTXEQ.Checked = false;
            }
        }

        public string CATDispPeak
        {
            get
            {
                if (chkDisplayPeak.Checked)
                    return "1";
                else
                    return "0";
            }
            set
            {
                if (value == "1")
                    chkDisplayPeak.Checked = true;
                else
                    chkDisplayPeak.Checked = false;
            }

        }

        public string CATDispCenter // RX1
        {
            set
            {
                btnDisplayPanCenter.PerformClick();

                //  btnDisplayPanCenter_MouseDown(this, MouseEventArgs.

                // MouseEventArgs me = (MouseEventArgs)e;

                //  if ((me.Button == System.Windows.Forms.MouseButtons.Right))

                //  if (current_model == Model.FLEX5000 && FWCEEPROM.RX2OK && chkRX2.Checked)  //.220 corrected
            }
        }

        public string CATDispCenter2 // RX2 (.221 add)
        {
            set
            {
                btnDisplayPanCenter.PerformClick();
            }
        } // CATDispCenter2

        public string CATDispZoom // RX1
        {
            set
            {
                switch (value)
                {
                    case "0":
                        radDisplayZoom05.PerformClick();
                        break;
                    case "1":
                        radDisplayZoom1x.PerformClick();
                        break;
                    case "2":
                        radDisplayZoom2x.PerformClick();
                        break;
                    case "3":
                        radDisplayZoom4x.PerformClick();
                        break;
                    default:
                        radDisplayZoom1x.PerformClick();
                        break;
                }
            }

            get
            {
                if (radDisplayZoom05.Checked)
                    return "0";
                else if (radDisplayZoom1x.Checked)
                    return "1";
                else if (radDisplayZoom2x.Checked)
                    return "2";
                else if (radDisplayZoom4x.Checked)
                    return "3";
                else
                    return "4";
            }
        } // RX1 CATDispZoom

        public string CATDispZoom2 // RX2  .221
        {
            set
            {
                switch (value)
                {
                    case "0":
                        radDisplayZoom05.PerformClick();
                        break;
                    case "1":
                        radDisplayZoom1x.PerformClick();
                        break;
                    case "2":
                        radDisplayZoom2x.PerformClick();
                        break;
                    case "3":
                        radDisplayZoom4x.PerformClick();
                        break;
                    default:
                        radDisplayZoom1x.PerformClick();
                        break;
                }
            }

            get
            {
                if (radDisplayZoom05.Checked)
                    return "0";
                else if (radDisplayZoom1x.Checked)
                    return "1";
                else if (radDisplayZoom2x.Checked)
                    return "2";
                else if (radDisplayZoom4x.Checked)
                    return "3";
                else
                    return "4";
            }
        } // CATDispZoom2 RX2


        public string CATZB
        {
            set
            {
                btnZeroBeat.PerformClick();
            }
        }

        public void CATTuneStepUp()
        {
            ChangeTuneStepUp();
        }

        public void CATTuneStepDown()
        {
            ChangeTuneStepDown();
        }


        //Added 03/18/07 BT BCI Reject
        private int cat_bci_reject = 0;
        public int CATBCIReject
        {
            get
            {
                if (chkBCI.Checked)
                    cat_bci_reject = 1;
                else
                    cat_bci_reject = 0;
                return cat_bci_reject;
            }
            set
            {
                if (value == 1)
                    chkBCI.Checked = true;
                else
                    chkBCI.Checked = false;
            }
        }
        // Added 06/20/05 BT for CAT commands
        private int cat_nr_status = 0;
        public int CATNR
        {
            get { return cat_nr_status; }
            set
            {
                if (value == 0)
                    chkNR.Checked = false;
                else if (value == 1)
                    chkNR.Checked = true;
            }
        }

        // Added 06/20/05 BT for CAT commands
        private int cat_anf_status = 0;
        public int CATANF
        {
            get { return cat_anf_status; }
            set
            {
                if (value == 0)
                    chkANF.Checked = false;
                else if (value == 1)
                    chkANF.Checked = true;
            }
        }

        // Added 06/21/05 BT for CAT Commands
        private int cat_nb1_status = 0;
        public int CATNB1
        {
            get { return cat_nb1_status; }
            set
            {
                if (value == 0)
                    chkNB.Checked = false;
                else if (value == 1)
                    chkNB.Checked = true;
            }
        }

        // Added 06/21/05 BT for CAT commands
        private int cat_nb2_status = 0;
        public int CATNB2
        {
            get { return cat_nb2_status; }
            set
            {
                if (value == 0)
                    chkDSPNB2.Checked = false;
                else if (value == 1)
                    chkDSPNB2.Checked = true;
            }
        }

        public bool CATATU
        {
            get { return chkFWCATU.Checked; }
            set
            {
                if (value)
                    chkFWCATU_Click(this.chkFWCATU, EventArgs.Empty);
            }
        }

        public bool CATBYP
        {
            get { return chkFWCATUBypass.Checked; }
            set
            {
                chkFWCATUBypass_Click(this.chkFWCATUBypass, EventArgs.Empty);
            }
        }



        private int cat_rx2nb1_status = 0;
        public int CATRX2NB1
        {
            get
            {
                if (this.CurrentModel == Model.FLEX5000 && FWCEEPROM.RX2OK)
                    return cat_rx2nb1_status;
                else
                    return 0;
            }
            set
            {
                if (this.CurrentModel == Model.FLEX5000 && FWCEEPROM.RX2OK)
                {
                    if (value == 0)
                        chkRX2NB.Checked = false;
                    else
                        chkRX2NB.Checked = true;
                }
            }
        }

        public void CATRX2BandUpDown(int direction)
        {
            comboRX2Band.Focus();

            string filter = "", mode = "", next = "", previous = "";
            string new_band = "";
            double freq = 0.0;
            bool b = false;
            switch (comboRX2Band.Text)
            {
                case "160m": next = "80m"; previous = "GEN"; break;
                case "80m": next = "60m"; previous = "160m"; break;
                case "60m": next = "40m"; previous = "80m"; break;
                case "40m": next = "30m"; previous = "60m"; break;
                case "30m": next = "20m"; previous = "40m"; break;
                case "20m": next = "17m"; previous = "30m"; break;
                case "17m": next = "15m"; previous = "20m"; break;
                case "15m": next = "12m"; previous = "17m"; break;
                case "12m": next = "10m"; previous = "12m"; break;
                case "10m": next = "6m"; previous = "12m"; break;
                case "6m": next = "2m"; previous = "10m"; break;
                case "2m": next = "WWV"; previous = "6m"; break;
                case "GEN": next = "160m"; previous = "VHF13"; break;
                case "WWV": next = "VHF0"; previous = "6m"; break;


                case "VU 2m": next = "VHF1"; previous = "WWV"; break;
                case "VU 70cm": next = "VHF2"; previous = "VHF0"; break;
                case "VHF2": next = "VHF3"; previous = "VHF1"; break;
                case "VHF3": next = "VHF4"; previous = "VHF2"; break;
                case "VHF4": next = "VHF5"; previous = "VHF3"; break;
                case "VHF5": next = "VHF6"; previous = "VHF4"; break;
                case "VHF6": next = "VHF7"; previous = "VHF5"; break;
                case "VHF7": next = "VHF8"; previous = "VHF6"; break;
                case "VHF8": next = "VHF9"; previous = "VHF7"; break;
                case "VHF9": next = "VHF10"; previous = "VHF8"; break;
                case "VHF10": next = "VHF11"; previous = "VHF9"; break;
                case "VHF11": next = "VHF12"; previous = "VHF10"; break;
                case "VHF12": next = "VHF13"; previous = "VHF11"; break;
                case "VHF13": next = "GEN"; previous = "VHF12"; break;



            }


            if (next.StartsWith("VHF"))                                 //see if the next vhf entry is enabled
            {
                int next_ndx = Convert.ToInt32(next.Substring(3));
                if (!this.xvtrForm.GetEnabled(next_ndx))
                    next = "GEN";                                       //if not, go back to GEN
            }

            if (previous.StartsWith("VHF"))
            {
                int previous_ndx = Convert.ToInt32(previous.Substring(3));
                if (previous_ndx != 0)
                {
                    if (previous_ndx > 0)
                    {
                        for (int n = previous_ndx - 1; n >= 0; n--)     //find the last enabled VHF entry
                        {
                            if (this.xvtrForm.GetEnabled(n))
                            {
                                previous = "VHF" + n.ToString();
                                break;
                            }
                            else
                                previous = "WWV";                       //or default to the value just below the VHF selections
                        }
                    }
                    else
                        previous = "WWV";
                }
            }


            if (direction == 1)
                new_band = next;
            else
                new_band = previous;


            int register = -1;
            switch (new_band)
            {
                case "160m": register = band_160m_register; break;
                case "80m": register = band_80m_register; break;
                case "60m": register = band_60m_register; break;
                case "40m": register = band_40m_register; break;
                case "30m": register = band_30m_register; break;
                case "20m": register = band_20m_register; break;
                case "17m": register = band_17m_register; break;
                case "15m": register = band_15m_register; break;
                case "12m": register = band_12m_register; break;
                case "10m": register = band_10m_register; break;
                case "6m": register = band_6m_register; break;
                case "2m": register = band_2m_register; break;
                case "GEN": register = band_gen_register; break;
                case "WWV": register = band_wwv_register; break;

                case "LMF": register = band_LMF_register; break; // ke9ns add
                case "120M": register = band_120m_register; break;
                case "90M": register = band_90m_register; break;
                case "61M": register = band_61m_register; break;
                case "49M": register = band_49m_register; break;
                case "41M": register = band_41m_register; break;
                case "31M": register = band_31m_register; break;
                case "25M": register = band_25m_register; break;
                case "22M": register = band_22m_register; break;
                case "19M": register = band_19m_register; break;
                case "16M": register = band_16m_register; break;
                case "14M": register = band_14m_register; break;
                case "13M": register = band_13m_register; break;
                case "11M": register = band_11m_register; break;

                case "VHF0": register = band_vhf0_register; break;
                case "VHF1": register = band_vhf1_register; break;
                case "VHF2": register = band_vhf2_register; break;
                case "VHF3": register = band_vhf3_register; break;
                case "VHF4": register = band_vhf4_register; break;
                case "VHF5": register = band_vhf5_register; break;
                case "VHF6": register = band_vhf6_register; break;
                case "VHF7": register = band_vhf7_register; break;
                case "VHF8": register = band_vhf8_register; break;
                case "VHF9": register = band_vhf9_register; break;
                case "VHF10": register = band_vhf10_register; break;
                case "VHF11": register = band_vhf11_register; break;
                case "VHF12": register = band_vhf12_register; break;
                case "VHF13": register = band_vhf13_register; break;



            }

            //if(new_band.StartsWith("VHF"))
            //{
            //    int ndx = Convert.ToInt32(new_band.Substring(3));
            //    if (this.xvtrForm.GetEnabled(ndx))
            //        b = DB.GetBandStack(new_band, 0, out mode, out filter, out freq);
            //    else
            //        b = DB.GetBandStack("160m", 0, out mode, out filter, out freq);
            //}
            //else
            b = DB.GetBandStack(new_band, 0, out mode, out filter, out freq);


            if (b)
            {
                if (filter.Contains("@"))
                {
                    filter = filter.Substring(0, (filter.Length) - 1); // ke9ns add for bandstack lockout
                }
                VFOBFreq = freq;
                RX2DSPMode = (DSPMode)Enum.Parse(typeof(DSPMode), mode);
                VFOBFreq = freq;

                RX2Filter = (Filter)Enum.Parse(typeof(Filter), filter);
            }

            btnHidden.Focus();
        }

        private int cat_rx2nb2_status = 0;
        public int CATRX2NB2
        {
            get
            {
                if (this.CurrentModel == Model.FLEX5000 && FWCEEPROM.RX2OK)
                    return cat_rx2nb2_status;
                else
                    return 0;
            }
            set
            {
                if (this.CurrentModel == Model.FLEX5000 && FWCEEPROM.RX2OK)
                {
                    if (value == 0)
                        chkRX2NB2.Checked = false;
                    else
                        chkRX2NB2.Checked = true;
                }
            }
        }


        // Added 06/22/05 BT for CAT commands
        private int cat_cmpd_status = 0;
        public int CATCmpd
        {
            get { return cat_cmpd_status; }
            set
            {
                if (value == 0)
                    chkCPDR.Checked = false;
                else if (value == 1)
                    chkCPDR.Checked = true;
            }
        }

        // Added 06/22/05 BT for CAT commands
        private int cat_mic_status = 0;
        public int CATMIC
        {
            get
            {
                cat_mic_status = ptbMic.Value;
                return cat_mic_status;
            }
            set
            {
                value = Math.Max(0, value);
                value = Math.Min(100, value);
                ptbMic.Value = value;
                ptbMic_Scroll(this, EventArgs.Empty);
            }
        }

        // Added 06/22/05 BT for CAT commands
        // modified 07/22/05 to fix display problem
        private int cat_filter_width = 0;
        public int CATFilterWidth
        {
            get
            {
                cat_filter_width = ptbFilterWidth.Value;
                return cat_filter_width;
            }
            set
            {
                value = Math.Max(1, value);
                value = Math.Min(10000, value);
                ptbFilterWidth.Value = value;
                ptbFilterWidth_Scroll(this.ptbFilterWidth, EventArgs.Empty);    // added
            }
        }

        // Added 07/22/05 for cat commands
        public int CATFilterShift
        {
            get
            {
                return ptbFilterShift.Value;
            }
            set
            {
                value = Math.Max(-1000, value);
                value = Math.Min(1000, value);
                ptbFilterShift.Value = value;
                ptbFilterShift_Scroll(this.ptbFilterShift, EventArgs.Empty);
            }
        }

        // Added 07/22/05 for CAT commands
        public int CATFilterShiftReset
        {
            set
            {
                if (value == 1)
                    btnFilterShiftReset.PerformClick();
            }
        }

        // Added 06/22/05 BT for CAT commands
        private int cat_bin_status = 0;
        public int CATBIN
        {
            get
            {
                if (chkBIN.Checked)
                    cat_bin_status = 1;
                else
                    cat_bin_status = 0;

                return cat_bin_status;
            }
            set
            {
                if (value == 1)
                    chkBIN.Checked = true;
                else if (value == 0)
                    chkBIN.Checked = false;
            }
        }

        // Added/repaired 7/10/05 BT for cat commands
        public PreampMode CATPreamp
        {
            //set{comboPreamp.SelectedIndex = value;}
            //get{return comboPreamp.SelectedIndex;}
            set { RX1PreampMode = value; }
            get { return RX1PreampMode; }
        }

        // Added 06/30/05 BT for CAT commands
        public int CATCWSpeed
        {
            get
            {
                return ptbCWSpeed.Value;
            }
            set
            {
                value = Math.Max(1, value);
                value = Math.Min(60, value);
                ptbCWSpeed.Value = value;
                ptbCWSpeed_Scroll(this, EventArgs.Empty);
            }
        }

        // Added 06/30/05 BT for CAT commands
        private int cat_display_avg_status = 0;
        public int CATDisplayAvg
        {
            get
            {
                if (chkDisplayAVG.Checked)
                    cat_display_avg_status = 1;
                else
                    cat_display_avg_status = 0;

                return cat_display_avg_status;
            }
            set
            {
                if (value == 1)
                    chkDisplayAVG.Checked = true;
                else
                    chkDisplayAVG.Checked = false;
            }
        }

        // Added 06/30/05 BT for CAT commands
        private int cat_squelch_status = 0;
        public int CATSquelch
        {
            get
            {
                if (chkSquelch.Checked)
                    cat_squelch_status = 1;
                else
                    cat_squelch_status = 0;

                return cat_squelch_status;
            }
            set
            {
                if (value == 1)
                    chkSquelch.Checked = true;
                else
                    chkSquelch.Checked = false;
            }
        }

        public string CATSquelch2
        {
            get
            {
                if (FWCEEPROM.RX2OK && chkRX2Squelch.Checked)
                    return "1";
                else
                    return "0";
            }
            set
            {
                if (FWCEEPROM.RX2OK)
                {
                    if (value == "1")
                        chkRX2Squelch.Checked = true;
                    else
                        chkRX2Squelch.Checked = false;
                }
            }
        }

        // Added 7/9/05 BT for cat commands
        public string CATQMSValue
        {
            get { return this.txtMemoryQuick.Text; }
        }

        private Parity cat_parity;
        public Parity CATParity
        {
            set { cat_parity = value; }
            get { return cat_parity; }
        }

        private StopBits cat_stop_bits;
        public StopBits CATStopBits
        {
            set { cat_stop_bits = value; }
            get { return cat_stop_bits; }
        }

        private Handshake cat_handshake;
        public Handshake CATHandshake
        {
            set { cat_handshake = value; }
            get { return cat_handshake; }
        }

        private int cat_data_bits;
        public int CATDataBits
        {
            set { cat_data_bits = value; }
            get { return cat_data_bits; }
        }

        private int cat_baud_rate;
        public int CATBaudRate
        {
            set { cat_baud_rate = value; }
            get { return cat_baud_rate; }
        }

        private bool cat_enabled;
        public bool CATEnabled
        {
            set
            {
                try
                {
                    cat_enabled = value;
                    if (siolisten != null)  // if we've got a listener tell them about state change 
                    {
                        if (cat_enabled)
                        {
                            Siolisten.enableCAT();

                        }
                        else
                        {
                            Siolisten.disableCAT();

                        }
                    }
                }
                catch (Exception)
                {
                    if (cat_port != 0)
                    {
                        MessageBox.Show(new Form { TopMost = true }, "Error enabling CAT on COM" + cat_port + ".\n" +
                            "Please check CAT settings and try again.",
                            "CAT Initialization Error",
                            MessageBoxButtons.OK,
                            MessageBoxIcon.Error);
                    }
                    else
                    {
                        MessageBox.Show(new Form { TopMost = true }, "Error enabling CAT comm port.\n" +
                            "Previously defined CAT comm port not enumerated.\n" +
                            "Please check CAT settings and try again.",
                            "CAT Initialization Error",
                            MessageBoxButtons.OK,
                            MessageBoxIcon.Error);
                    }

                    if (setupForm != null) setupForm.CATEnabled = false;
                }



            } // set
            get { return cat_enabled; }
        } // CATEnabled



        //==============================
        // ke9ns add .180 port 2 -5

        private bool cat_enabled2;
        public bool CATEnabled2
        {
            set
            {
                try
                {
                    cat_enabled2 = value;
                    if (siolisten2 != null)  // if we've got a listener tell them about state change 
                    {
                        if (cat_enabled2)
                        {
                            Siolisten2.enableCAT2();
                        }
                        else
                        {
                            Siolisten2.disableCAT2();

                        }
                    }
                }
                catch (Exception)
                {
                    if (cat_port2 != 0)
                    {
                        MessageBox.Show(new Form { TopMost = true }, "Error enabling CAT2 on COM" + cat_port2 + ".\n" +
                            "Please check CAT2 settings and try again.",
                            "CAT2 Initialization Error",
                            MessageBoxButtons.OK,
                            MessageBoxIcon.Error);
                    }
                    else
                    {
                        MessageBox.Show(new Form { TopMost = true }, "Error enabling CAT2 comm port.\n" +
                            "Previously defined CAT2 comm port not enumerated.\n" +
                            "Please check CAT2 settings and try again.",
                            "CAT2 Initialization Error",
                            MessageBoxButtons.OK,
                            MessageBoxIcon.Error);
                    }

                    if (setupForm != null) setupForm.CATEnabled2 = false;
                }

            } // set
            get { return cat_enabled2; }
        } // CATEnabled2

        private bool cat_enabled3;
        public bool CATEnabled3
        {
            set
            {
                try
                {
                    cat_enabled3 = value;
                    if (siolisten3 != null)  // if we've got a listener tell them about state change 
                    {
                        if (cat_enabled3)
                        {
                            Siolisten3.enableCAT3();
                        }
                        else
                        {
                            Siolisten3.disableCAT3();

                        }
                    }
                }
                catch (Exception)
                {
                    if (cat_port3 != 0)
                    {
                        MessageBox.Show(new Form { TopMost = true }, "Error enabling CAT3 on COM" + cat_port3 + ".\n" +
                            "Please check CAT3 settings and try again.",
                            "CAT3 Initialization Error",
                            MessageBoxButtons.OK,
                            MessageBoxIcon.Error);
                    }
                    else
                    {
                        MessageBox.Show(new Form { TopMost = true }, "Error enabling CAT3 comm port.\n" +
                            "Previously defined CAT3 comm port not enumerated.\n" +
                            "Please check CAT3 settings and try again.",
                            "CAT3 Initialization Error",
                            MessageBoxButtons.OK,
                            MessageBoxIcon.Error);
                    }

                    if (setupForm != null) setupForm.CATEnabled3 = false;
                }

            } // set
            get { return cat_enabled3; }
        } // CATEnabled3

        private bool cat_enabled4;
        public bool CATEnabled4
        {
            set
            {
                try
                {
                    cat_enabled4 = value;
                    if (siolisten4 != null)  // if we've got a listener tell them about state change 
                    {
                        if (cat_enabled4)
                        {
                            Siolisten4.enableCAT4();

                        }
                        else
                        {
                            Siolisten4.disableCAT4();


                        }
                    }
                }
                catch (Exception)
                {
                    if (cat_port4 != 0)
                    {
                        MessageBox.Show(new Form { TopMost = true }, "Error enabling CAT4 on COM" + cat_port4 + ".\n" +
                            "Please check CAT4 settings and try again.",
                            "CAT4 Initialization Error",
                            MessageBoxButtons.OK,
                            MessageBoxIcon.Error);
                    }
                    else
                    {
                        MessageBox.Show(new Form { TopMost = true }, "Error enabling CAT4 comm port.\n" +
                            "Previously defined CAT4 comm port not enumerated.\n" +
                            "Please check CAT4 settings and try again.",
                            "CAT4 Initialization Error",
                            MessageBoxButtons.OK,
                            MessageBoxIcon.Error);
                    }

                    if (setupForm != null) setupForm.CATEnabled4 = false;
                }

            } // set
            get { return cat_enabled4; }
        } // CATEnabled4

        private bool cat_enabled5;
        public bool CATEnabled5
        {
            set
            {
                try
                {
                    cat_enabled5 = value;
                    if (siolisten5 != null)  // if we've got a listener tell them about state change 
                    {
                        if (cat_enabled5)
                        {
                            Siolisten5.enableCAT5();

                        }
                        else
                        {
                            Siolisten5.disableCAT5();


                        }
                    }
                }
                catch (Exception)
                {
                    if (cat_port5 != 0)
                    {
                        MessageBox.Show(new Form { TopMost = true }, "Error enabling CAT5 on COM" + cat_port5 + ".\n" +
                            "Please check CAT5 settings and try again.",
                            "CAT5 Initialization Error",
                            MessageBoxButtons.OK,
                            MessageBoxIcon.Error);
                    }
                    else
                    {
                        MessageBox.Show(new Form { TopMost = true }, "Error enabling CAT5 comm port.\n" +
                            "Previously defined CAT5 comm port not enumerated.\n" +
                            "Please check CAT5 settings and try again.",
                            "CAT5 Initialization Error",
                            MessageBoxButtons.OK,
                            MessageBoxIcon.Error);
                    }

                    if (setupForm != null) setupForm.CATEnabled5 = false;
                }

            } // set
            get { return cat_enabled5; }
        } // CATEnabled5


        // ke9ns .200 spoof VFOA to B

        private bool cat_enabled6;
        public bool CATEnabled6
        {
            set
            {
                try
                {
                    cat_enabled6 = value;
                    if (siolisten6 != null)  // if we've got a listener tell them about state change 
                    {
                        if (cat_enabled6)
                        {
                            Siolisten6.enableCAT6();

                        }
                        else
                        {
                            Siolisten6.disableCAT6();


                        }
                    }
                }
                catch (Exception)
                {
                    if (cat_port6 != 0)
                    {
                        MessageBox.Show(new Form { TopMost = true }, "Error enabling CAT6 on COM" + cat_port6 + ".\n" +
                            "Please check CAT6 settings and try again.",
                            "CAT6 Initialization Error",
                            MessageBoxButtons.OK,
                            MessageBoxIcon.Error);
                    }
                    else
                    {
                        MessageBox.Show(new Form { TopMost = true }, "Error enabling CAT6 comm port.\n" +
                            "Previously defined CAT6 comm port not enumerated.\n" +
                            "Please check CAT6 settings and try again.",
                            "CAT6 Initialization Error",
                            MessageBoxButtons.OK,
                            MessageBoxIcon.Error);
                    }

                    if (setupForm != null) setupForm.CATEnabled6 = false;
                }

            } // set
            get { return cat_enabled6; }
        } // CATEnabled6




        private int cat_rig_type;
        public int CATRigType
        {
            get { return cat_rig_type; }
            set { cat_rig_type = value; }
        }

        private int cat_port;
        public int CATPort
        {
            get { return cat_port; }
            set { cat_port = value; }
        }

        // ke9ns add 2-5
        private int cat_port2;
        public int CATPort2
        {
            get { return cat_port2; }
            set { cat_port2 = value; }
        }

        private int cat_port3;
        public int CATPort3
        {
            get { return cat_port3; }
            set { cat_port3 = value; }
        }

        private int cat_port4;
        public int CATPort4
        {
            get { return cat_port4; }
            set { cat_port4 = value; }
        }

        private int cat_port5;
        public int CATPort5
        {
            get { return cat_port5; }
            set { cat_port5 = value; }
        }

        private int cat_port6;
        public int CATPort6 // .200
        {
            get { return cat_port6; }
            set { cat_port6 = value; }
        }




        //========================================================================================
        //========================================================================================
        // ke9ns antennar rotor control via DDUtil VSP rotor port using Hygain protocol
        private bool rotor_enabled;
        public bool ROTOREnabled
        {
            get
            {
                return rotor_enabled;
            }
            set
            {
                try
                {
                    Debug.WriteLine("ROTORENabled " + value);
                    rotor_enabled = value;

                    if (siolisten1 != null)  // if we've got a listener tell them about state change 
                    {
                        if (rotor_enabled)
                        {
                            Siolisten1.enableROTOR();

                            if (SpotForm != null)
                            {
                                SpotForm.RotorHead.Visible = true;
                                SpotForm.button3.Visible = true;
                                SpotForm.numBeamHeading.Visible = true;

                                string answer = spotDDUtil_Rotor1; // get rotor angle current position
                                SpotForm.RotorHead.Text = answer + "°";

                                int temp1 = 0;

                                try
                                {
                                    temp1 = Convert.ToInt16(answer);
                                }
                                catch
                                {
                                    temp1 = 0;
                                }

                                SpotForm.numBeamHeading.Value = temp1;

                                SpotForm.RotorUpdate(); // start up thread to read position of rotor

                            } //  if (SpotForm != null)

                        }
                        else
                        {
                            Siolisten1.disableROTOR();

                            if (SpotForm != null)
                            {
                                SpotForm.RotorHead.Visible = false;
                                SpotForm.button3.Visible = false;
                                SpotForm.numBeamHeading.Visible = false;
                            }
                        }
                    }
                }
                catch (Exception)
                {
                    if (rotor_port != 0)
                    {
                        MessageBox.Show(new Form { TopMost = true }, "Error enabling ROTOR on COM" + rotor_port + ".\n" +
                            "Please check ROTOR settings and try again.",
                            "ROTOR Initialization Error",
                            MessageBoxButtons.OK,
                            MessageBoxIcon.Error);
                    }
                    else
                    {
                        MessageBox.Show(new Form { TopMost = true }, "Error enabling ROTOR comm port.\n" +
                            "Previously defined ROTOR comm port not enumerated.\n" +
                            "Please check ROTOR settings and try again.",
                            "ROTOR Initialization Error",
                            MessageBoxButtons.OK,
                            MessageBoxIcon.Error);
                    }

                    if (setupForm != null) setupForm.ROTOREnabled = false;
                }


            } // set


        } // ROTOREnabled



        private int rotor_port;
        public int ROTORPort
        {
            get { return rotor_port; }
            set { rotor_port = value; }
        }


        //========================================================================================
        //========================================================================================


        private bool cat_ptt_rts = false;
        public bool CATPTTRTS
        {
            get { return cat_ptt_rts; }
            set { cat_ptt_rts = value; }
        }

        private bool cat_ptt_dtr;
        public bool CATPTTDTR
        {
            get { return cat_ptt_dtr; }
            set { cat_ptt_dtr = value; }
        }

        public SerialPortPTT serialPTT = null;
        private bool ptt_bit_bang_enabled;
        public bool PTTBitBangEnabled
        {
            get { return ptt_bit_bang_enabled; }
            set
            {
                ptt_bit_bang_enabled = value;
                if (serialPTT != null)  // kill current serial PTT if we have one 
                {
                    serialPTT.Destroy();
                    serialPTT = null;
                }
                if (ptt_bit_bang_enabled)
                {
                    // wjt -- don't really like popping a msg box in here ...   nasty when we do a remoted 
                    // setup ... will let that wait for the great console refactoring 
                    try
                    {
                        serialPTT = new SerialPortPTT(cat_ptt_bit_bang_port, cat_ptt_rts, cat_ptt_dtr);
                        serialPTT.Init();
                    }
                    catch (Exception ex)
                    {
                        ptt_bit_bang_enabled = false;
                        if (setupForm != null)
                        {
                            setupForm.copyCATPropsToDialogVars(); // need to make sure the props on the setup page get reset 
                        }
                        MessageBox.Show(new Form { TopMost = true }, "Could not initialize PTT Bit Bang control.  Exception was:\n\n " + ex.Message +
                            "\n\nPTT Bit Bang control has been disabled.", "Error Initializing PTT control",
                            MessageBoxButtons.OK, MessageBoxIcon.Error);

                    }
                }
            }
        }

        private int cat_ptt_bit_bang_port;
        public int CATPTTBitBangPort
        {
            get { return cat_ptt_bit_bang_port; }
            set { cat_ptt_bit_bang_port = value; }
        }


        #endregion

        private int tune_power;                             // power setting to use when TUN button is pressed
        public int TunePower
        {
            get { return tune_power; }
            set
            {
                if (setupForm != null)
                {
                    if (setupForm.udTXDriveMax.Value < setupForm.udTXTunePower.Value) // ke9ns add for drive max 
                    {
                        value = (int)setupForm.udTXDriveMax.Value;
                        setupForm.udTXTunePower.Value = setupForm.udTXDriveMax.Value;
                    }
                }
                tune_power = value;

                ptbTune.Value = value; // ke9ns add
                lblTUNE.Text = "Tune: " + ptbTune.Value.ToString(); // ke9ns add


                if (setupForm != null) setupForm.TunePower = tune_power;

                if (chkTUN.Checked)
                {
                    if (atu_present)
                    {
                        if ((ATUTuneMode)comboTuneMode.SelectedIndex == ATUTuneMode.BYPASS) PWR = tune_power;
                    }
                    else PWR = tune_power;
                }
            }
        }

        private int previous_pwr = 50;
        public int PreviousPWR
        {
            get { return previous_pwr; }
            set { previous_pwr = value; }
        }

        private bool no_hardware_offset = false;
        public bool NoHardwareOffset
        {
            get { return no_hardware_offset; }
            set
            {
                no_hardware_offset = value;
                comboPreamp_SelectedIndexChanged(this, EventArgs.Empty);
            }
        }

        #region CAT Properties


        //==================================================================
        private Band rx1_band;
        public byte AMPBAND = 0; //  ke9ns add 0x4E address
        public byte AMPBAND1 = 0; //  ke9ns add 0x4F address

        public byte HEROBAND = 0; // ke9ns add

        public string[] SLowScan = new string[]
           {" ", " ", " ", " ", " ", " ", " ", " ", " ", " ",
            " ", " ", " ", " ", " ", " ", " ", " ", " ", " ",
            " ", " ", " ", " ", " ", " ", " ", " ", " ", " ",
            " ", " ", " ", " ", " ", " ", " ", " ", " ", " ",
            " ", " ", " ", " ", " ", " ", " ", " ", " ", " " }; // ke9ns add .186 to save scanner low/high instead of default band edges

        public string[] SHighScan = new string[]
           {" ", " ", " ", " ", " ", " ", " ", " ", " ", " ",
            " ", " ", " ", " ", " ", " ", " ", " ", " ", " ",
            " ", " ", " ", " ", " ", " ", " ", " ", " ", " ",
            " ", " ", " ", " ", " ", " ", " ", " ", " ", " ",
            " ", " ", " ", " ", " ", " ", " ", " ", " ", " " }; // ke9ns add .186

        public bool scanUpdate = false;  // ke9ns add .186 

        public Band RX1Band
        {
            get { return rx1_band; }
            set
            {
                
              //  Debug.WriteLine("RX1BAND " + value + " , " + VFOAFreq);

                Band old_band = rx1_band;
                rx1_band = value;

                Band lo_band = Band.FIRST;

                if (xvtrForm != null && rx1_xvtr_index >= 0)
                {

                    lo_band = BandByFreq(xvtrForm.TranslateFreq(VFOAFreq), -1, false, current_region);

                }

                if ((rx1_band != old_band)) // ke9ns: if bands changed
                {
                    if ((flex_wire_ucb)) // ke9ns: if using the UCB form
                    {
                        if (ucbForm != null && !ucbForm.IsDisposed)
                        {
                            ushort val = 0;
                            byte b1 = 0;
                            byte b2 = 0;

                            if (rx1_xvtr_index >= 0)
                            {
                                val = ucbForm.GetLine(rx1_xvtr_index); // line is a 2 byte int (ushort) = relays on by bit, relay1 = bit0, relay 16=bit15
                                b1 = (byte)val; // get the lower byte
                                b2 = (byte)(val >> 8); // get the upper byte
                            }



                            switch (current_model)
                            {
                                case Model.FLEX5000:
                                case Model.FLEX3000:
                                    if (fwc_init)
                                    {

                                        //   Debug.WriteLine("===I2C=== 0x4C here");

                                        FWC.FlexWire_Write2Value(0x4C, 0x06, 0x00); // UCB (Universal Control board) AMP uses 0x4E and 0x4A, HERO uses 0x40, bands use 0x42, 0x44, 0x46
                                        FWC.FlexWire_Write2Value(0x4C, 0x07, 0x00);
                                        FWC.FlexWire_Write2Value(0x4C, 0x02, b1);    // lower byte 
                                        FWC.FlexWire_Write2Value(0x4C, 0x03, b2); // upper byte
                                    }
                                    break;
                                case Model.FLEX1500:
                                    if (hid_init)
                                    {
                                        USBHID.FlexWire_Write2Value(0x4C, 0x06, 0x00);
                                        USBHID.FlexWire_Write2Value(0x4C, 0x07, 0x00);
                                        USBHID.FlexWire_Write2Value(0x4C, 0x02, b1);
                                        USBHID.FlexWire_Write2Value(0x4C, 0x03, b2);
                                    }
                                    break;

                            } // switch
                        }
                    } //  if ((flex_wire_ucb))


                } //   if ((rx1_band != old_band))


                if (rx1_preamp_mode > PreampMode.FIRST) rx1_preamp_by_band[(int)old_band] = rx1_preamp_mode;


                // moved logic for preamp stuff to txtVFOAFreq_LostFocus



                if (rx1_band != old_band || initializing || scanUpdate == true)
                {
                    scanUpdate = false;
                    //================================================================================           
                    // ke9ns ADD for use by scanner so it knows which band button your on currently

                    ScanControl.ScanRST = 0;


                    AMPBAND = 0;
                    HEROBAND = 0;

                    if (rx1_band == Band.B160M)
                    {

                        ScanControl.freq_Low = 1.8;
                        ScanControl.freq_High = 2.0;
                        LPF_G = 0;
                        ScanControl.freq_Low1 = 1.8;
                        ScanControl.freq_High1 = 2.0;
                        AMPBAND = 1;
                        AMPBAND1 = 1;
                        HEROBAND = 1; // A

                    }
                    else if (rx1_band == Band.B80M)
                    {
                        ScanControl.freq_Low = 3.5;
                        ScanControl.freq_High = 4.0;
                        LPF_G = 0;
                        ScanControl.freq_Low1 = 3.5;
                        ScanControl.freq_High1 = 4.0;
                        AMPBAND = 2;
                        AMPBAND1 = 2;
                        HEROBAND = 2; // B
                    }
                    else if (rx1_band == Band.B60M)
                    {
                        ScanControl.freq_Low = 5.3;
                        ScanControl.freq_High = 5.6;
                        LPF_G = 0;
                        ScanControl.freq_Low1 = 5.3;
                        ScanControl.freq_High1 = 5.6;
                        AMPBAND = 2;
                        AMPBAND1 = 2;
                        HEROBAND = 3; // C

                    }
                    else if (rx1_band == Band.B40M)
                    {
                        ScanControl.freq_Low = 7.0;
                        ScanControl.freq_High = 7.3;
                        LPF_G = 0;
                        ScanControl.freq_Low1 = 7.0;
                        ScanControl.freq_High1 = 7.3;
                        AMPBAND = 4;
                        AMPBAND1 = 4;
                        HEROBAND = 3; // C

                    }
                    else if (rx1_band == Band.B30M)
                    {
                        ScanControl.freq_Low = 10.1;
                        ScanControl.freq_High = 10.15;
                        LPF_G = 0;
                        ScanControl.freq_Low1 = 10.1;
                        ScanControl.freq_High1 = 10.15;
                        AMPBAND = 4;
                        AMPBAND1 = 4;
                        HEROBAND = 3; // C
                    }
                    else if (rx1_band == Band.B20M)
                    {
                        ScanControl.freq_Low = 14.000;
                        ScanControl.freq_High = 14.350;
                        LPF_G = 0;
                        ScanControl.freq_Low1 = 14.000;
                        ScanControl.freq_High1 = 14.350;
                        AMPBAND = 8;
                        AMPBAND1 = 8;
                        HEROBAND = 4; // D
                    }
                    else if (rx1_band == Band.B17M)
                    {
                        ScanControl.freq_Low = 18.068;
                        ScanControl.freq_High = 18.168;
                        LPF_G = 0;
                        ScanControl.freq_Low1 = 18.068;
                        ScanControl.freq_High1 = 18.168;
                        AMPBAND = 8;
                        AMPBAND1 = 8;
                        HEROBAND = 4; // D

                    }
                    else if (rx1_band == Band.B15M)
                    {
                        ScanControl.freq_Low = 21.0;
                        ScanControl.freq_High = 21.45;
                        LPF_G = 0;
                        ScanControl.freq_Low1 = 21.0;
                        ScanControl.freq_High1 = 21.45;
                        AMPBAND = 8;
                        AMPBAND1 = 16;
                        HEROBAND = 4; // D
                    }
                    else if (rx1_band == Band.B12M)
                    {
                        ScanControl.freq_Low = 24.89;
                        ScanControl.freq_High = 24.990;
                        LPF_G = 0;
                        ScanControl.freq_Low1 = 24.89;
                        ScanControl.freq_High1 = 24.990;
                        AMPBAND = 16;
                        AMPBAND1 = 16;
                        HEROBAND = 5; // E

                    }
                    else if (rx1_band == Band.B10M)
                    {
                        ScanControl.freq_Low = 28.0;
                        ScanControl.freq_High = 29.7;
                        LPF_G = 0;
                        ScanControl.freq_Low1 = 28.0;
                        ScanControl.freq_High1 = 29.7;
                        AMPBAND = 16;
                        AMPBAND1 = 16;
                        HEROBAND = 5; // E
                    }
                    else if (rx1_band == Band.B6M)
                    {
                        ScanControl.freq_Low = 50.0;
                        ScanControl.freq_High = 54.0;
                        LPF_G = 0;
                        ScanControl.freq_Low1 = 50.0;
                        ScanControl.freq_High1 = 54.0;
                        AMPBAND = 32;
                        AMPBAND1 = 32;
                        HEROBAND = 0; // OFF

                    }
                    else if (rx1_band == Band.B2M)
                    {
                        ScanControl.freq_Low = 144.0;
                        ScanControl.freq_High = 148.0;
                        LPF_G = 0;
                        ScanControl.freq_Low1 = 144.0;
                        ScanControl.freq_High1 = 148.0;
                        AMPBAND = 128;
                        AMPBAND1 = 128;
                        HEROBAND = 0; // OFF
                    }
                    else if (rx1_band == Band.VHF0)
                    {
                        ScanControl.freq_Low = 144.0;
                        ScanControl.freq_High = 148.0;
                        LPF_G = 1;
                        ScanControl.freq_Low1 = 144.0;
                        ScanControl.freq_High1 = 148.0;
                        AMPBAND = 128;
                        AMPBAND1 = 128;
                        HEROBAND = 0; // OFF
                    }
                    else if (rx1_band == Band.VHF1)
                    {
                        ScanControl.freq_Low = 430.0;
                        ScanControl.freq_High = 450.0;
                        LPF_G = 1;
                        ScanControl.freq_Low1 = 430.0;
                        ScanControl.freq_High1 = 450.0;
                        AMPBAND = 128;
                        AMPBAND1 = 128;
                        HEROBAND = 0; // OFF
                    }
                    else if (rx1_band == Band.BLMF)
                    {
                        ScanControl.freq_Low = 0.4;
                        ScanControl.freq_High = 1.8;
                        LPF_G = 1;
                        ScanControl.freq_Low1 = 0.4;
                        ScanControl.freq_High1 = 1.8;
                        AMPBAND = 1;
                        AMPBAND1 = 1;
                        HEROBAND = 0; // OFF
                    }
                    else if (rx1_band == Band.B120M)
                    {
                        ScanControl.freq_Low = 2.0;
                        ScanControl.freq_High = 3.0;
                        LPF_G = 1;
                        ScanControl.freq_Low1 = 2.0;
                        ScanControl.freq_High1 = 3.0;
                        AMPBAND = 1;
                        AMPBAND1 = 1;
                        HEROBAND = 1; // A
                    }
                    else if (rx1_band == Band.B90M)
                    {
                        ScanControl.freq_Low = 3.0;
                        ScanControl.freq_High = 3.5;
                        LPF_G = 1;
                        ScanControl.freq_Low1 = 3.0;
                        ScanControl.freq_High1 = 3.5;
                        AMPBAND = 2;
                        AMPBAND1 = 2;
                        HEROBAND = 2; // B
                    }
                    else if (rx1_band == Band.B61M)
                    {
                        ScanControl.freq_Low = 4.0;
                        ScanControl.freq_High = 5.3;
                        LPF_G = 1;
                        ScanControl.freq_Low1 = 4.0;
                        ScanControl.freq_High1 = 5.3;
                        AMPBAND = 2;
                        AMPBAND1 = 2;
                        HEROBAND = 2; // B
                    }
                    else if (rx1_band == Band.B49M)
                    {
                        ScanControl.freq_Low = 5.4;
                        ScanControl.freq_High = 7.0;
                        LPF_G = 1;
                        ScanControl.freq_Low1 = 5.4;
                        ScanControl.freq_High1 = 7.0;
                        AMPBAND = 2;
                        AMPBAND1 = 2;
                        HEROBAND = 3; // C
                    }
                    else if (rx1_band == Band.B41M)
                    {
                        ScanControl.freq_Low = 7.2;
                        ScanControl.freq_High = 9.0;
                        LPF_G = 1;
                        ScanControl.freq_Low1 = 7.2;
                        ScanControl.freq_High1 = 9.0;
                        AMPBAND = 4;
                        AMPBAND1 = 4;
                        HEROBAND = 3; // C

                    }
                    else if (rx1_band == Band.B31M)
                    {
                        ScanControl.freq_Low = 9.000001;
                        ScanControl.freq_High = 9.99;
                        LPF_G = 1;
                        ScanControl.freq_Low1 = 9.000001;
                        ScanControl.freq_High1 = 9.99;
                        AMPBAND = 4;
                        AMPBAND1 = 4;
                        HEROBAND = 3; // C


                    }
                    else if (rx1_band == Band.B25M)
                    {
                        ScanControl.freq_Low = 10.150001;
                        ScanControl.freq_High = 13.57;
                        LPF_G = 1;
                        ScanControl.freq_Low1 = 10.150001;
                        ScanControl.freq_High1 = 13.57;
                        AMPBAND = 8;
                        AMPBAND1 = 8;
                        HEROBAND = 4; // D

                    }
                    else if (rx1_band == Band.B22M)
                    {
                        ScanControl.freq_Low = 13.570001;
                        ScanControl.freq_High = 14.00;
                        LPF_G = 1;
                        ScanControl.freq_Low1 = 13.570001;
                        ScanControl.freq_High1 = 14.00;
                        AMPBAND = 8;
                        AMPBAND1 = 8;
                        HEROBAND = 4; // D

                    }
                    else if (rx1_band == Band.B19M)
                    {
                        ScanControl.freq_Low = 14.350; // was 15.1
                        ScanControl.freq_High = 17.0;
                        LPF_G = 1;
                        ScanControl.freq_Low1 = 14.350;
                        ScanControl.freq_High1 = 17.0;
                        AMPBAND = 8;
                        AMPBAND1 = 8;
                        HEROBAND = 4; // D
                    }
                    else if (rx1_band == Band.B16M)
                    {
                        ScanControl.freq_Low = 17.0;
                        ScanControl.freq_High = 18.0;
                        LPF_G = 1;
                        ScanControl.freq_Low1 = 17.0;
                        ScanControl.freq_High1 = 18.0;
                        AMPBAND = 8;
                        AMPBAND1 = 8;
                        HEROBAND = 4; // D
                    }
                    else if (rx1_band == Band.B14M)
                    {
                        ScanControl.freq_Low = 18.0;
                        ScanControl.freq_High = 21.0;
                        LPF_G = 1;
                        ScanControl.freq_Low1 = 18.0;
                        ScanControl.freq_High1 = 21.0;

                        AMPBAND = 8;
                        AMPBAND1 = 16;
                        HEROBAND = 4; // D
                    }
                    else if (rx1_band == Band.B13M)
                    {
                        ScanControl.freq_Low = 21.0;
                        ScanControl.freq_High = 25.0;
                        LPF_G = 1;
                        ScanControl.freq_Low1 = 21.0;
                        ScanControl.freq_High1 = 25.0;

                        AMPBAND = 16;
                        AMPBAND1 = 16;
                        HEROBAND = 5; // E
                    }
                    else if (rx1_band == Band.B11M)
                    {
                        ScanControl.freq_Low = 25.0;
                        ScanControl.freq_High = 28.0;
                        LPF_G = 1;
                        ScanControl.freq_Low1 = 25.0;
                        ScanControl.freq_High1 = 28.0;

                        AMPBAND = 16;
                        AMPBAND1 = 16;
                        HEROBAND = 5; // E
                    }
                    else // ke9ns need to add xvtr scanner capability
                    {
                        ScanControl.freq_Low = 28.0;
                        ScanControl.freq_High = 29.0;
                        LPF_G = 1;
                        ScanControl.freq_Low1 = 28.0;
                        ScanControl.freq_High1 = 29.0;

                        AMPBAND = 16;
                        AMPBAND1 = 16;
                        HEROBAND = 5; // E
                    }
                    if (ScanForm != null)
                    {
                        if (RX1Band >= 0 && SLowScan[(int)RX1Band] != " ")
                        {
                            ScanForm.lowFBox.Text = SLowScan[(int)RX1Band];
                        }
                        else
                        {
                            ScanForm.lowFBox.Text = ScanControl.freq_Low.ToString("f6" );
                        }

                  
                        try
                        {

                            if (Convert.ToDouble(ScanForm.lowFBox.Text) > 54.0) // .226
                            {
                                ScanForm.checkBoxSWR.Checked = false; // .226 no swr beyond 6m
                            }

                        }
                        catch (Exception)
                        {


                        }

                        if (RX1Band >= 0 && SLowScan[(int)RX1Band] != " ")
                        {
                            ScanForm.highFBox.Text = SHighScan[(int)RX1Band];
                        }
                        else
                        {
                            ScanForm.highFBox.Text = ScanControl.freq_High.ToString("f6" );
                        }

                        try
                        {
                            if (Convert.ToDouble(ScanForm.highFBox.Text) > 54.0) // .226
                            {
                                ScanForm.checkBoxSWR.Checked = false; // .226 no swr beyond 6m
                            }


                        }
                        catch (Exception)
                        {



                        }
                    }

                    Debug.WriteLine("RX1band1");

                    IIC_HEROCONTROL(HEROBAND); // ke9ns: send IIC command for HERO preselect
                    IIC_AMPCONTROL(AMPBAND, AMPBAND1); // ke9ns: send IIC command for SS AMP band control


                    //============================================================== ke9ns end
                   

                    WBIRRX1Holdoff();

                    // save values for old band
                    rx1_agct_by_band[(int)old_band] = ptbRF.Value;

                    RX1PreampMode = rx1_preamp_by_band[(int)value];
                    RF = rx1_agct_by_band[(int)value];
                    ptbRF_Scroll(this, EventArgs.Empty);


                    Debug.WriteLine("XVTR1: " + rx1_xvtr_index + " , " + old_band + " , " + rx1_band);

                    if ((rx1_xvtr_index > 1) && current_model == Model.FLEX5000) // .213
                    {
                        if (xvtrForm != null && xvtrForm.GetXVTRRF(rx1_xvtr_index) == true)
                        {

                            lblAntRX1a.Text = "XVRX";
                            // lblAntTXa.Text = "XVTX/C";
                        }
                        else
                        {
                            lblAntRX1a.Text = "XVTX/C";
                            //  lblAntTXa.Text = "XVTX/C";
                        }


                    }


                    switch (current_model)
                    {
                        case Model.FLEX5000:
                            if (!fwc_init) break;

                            if (current_ant_mode == AntMode.Expert)
                            {
                                // set saved values for new band
                                int band = (int)value;
                                if (rx1_xvtr_index >= 0) band = (int)Band.VHF0 + rx1_xvtr_index;

                                if (rx1_ant != FWCAnt.SIG_GEN)
                                {
                                    if (FWCEEPROM.VUOK &&
                                    (rx1_band == Band.VHF0 || rx1_band == Band.VHF1 || // going to VU band
                                     old_band == Band.VHF0 || old_band == Band.VHF1)) // coming from VU band
                                    {
                                        vu_ant = true;
                                    }
                                    else if ((old_band > (Band)15) && (old_band < (Band)28) && current_model == Model.FLEX5000)
                                    {
                                        vu_ant = true;

                                    }
                                    RX1Ant = rx1_ant_by_band[band];
                                    if (vu_ant) vu_ant = false;
                                }



                                if (rx1_ant != FWCAnt.RX1IN) RX1Loop = rx1_loop_by_band[band];
                            }
                            else // Simple antenna mode
                            {
                                if (FWCEEPROM.VUOK &&
                                    (rx1_band == Band.VHF0 || rx1_band == Band.VHF1 || // going to VU band
                                     old_band == Band.VHF0 || old_band == Band.VHF1)) // coming from VU band
                                {
                                    vu_ant = true;
                                    RX1Ant = rx1_ant;
                                    vu_ant = false;
                                }
                                else if ((old_band > (Band)15) && (old_band < (Band)28) && current_model == Model.FLEX5000)
                                {
                                    vu_ant = true;
                                    RX1Ant = rx1_ant;
                                    vu_ant = false;
                                }


                            }

                            Band b = rx1_band;
                            if (rx1_xvtr_index >= 0) b = lo_band;

                            if (fwc_init && FWCEEPROM.VUOK)
                            {
                                switch (rx1_xvtr_index)
                                {
                                    case 0: // 2m on 19-23MHz
                                        b = Band.B15M;
                                        break;
                                    case 1: // 70cm on 30-50MHz
                                        b = Band.B6M;
                                        break;
                                }
                            }

                            RX1DisplayCalOffset = rx1_level_table[(int)b][0];
                            rx1_preamp_offset[(int)PreampMode.OFF] = 0.0f;
                            rx1_preamp_offset[(int)PreampMode.HIGH] = rx1_level_table[(int)b][1];
                            rx1_meter_cal_offset = rx1_level_table[(int)b][2];
                            UpdateDisplayOffsets();

                            if (FWCEEPROM.RX1ImageVer == 5)
                            {
                                dsp.GetDSPRX(0, 0).SetRXCorrectIQW(rx1_image_gain_table[(int)b], rx1_image_phase_table[(int)b]);
                                dsp.GetDSPRX(0, 1).SetRXCorrectIQW(rx1_image_gain_table[(int)b], rx1_image_phase_table[(int)b]);
                            }

                            Audio.IQGain = 1.0f + 0.001f * rx1_image_gain_table[(int)b];
                            Audio.IQPhase = 0.001f * rx1_image_phase_table[(int)b];

                            //  Debug.WriteLine("RX1Band HIGH-LOW band value " + value + " Tband: " + tx_band);


                            if (fwcAntForm != null && !fwcAntForm.IsDisposed) fwcAntForm.SetBand(value);

                            break;
                        case Model.FLEX3000:
                            if (!fwc_init) break;
                            b = rx1_band;
                            if (rx1_xvtr_index >= 0) b = lo_band;
                            RX1DisplayCalOffset = rx1_level_table[(int)b][0];
                            rx1_preamp_offset[(int)PreampMode.OFF] = rx1_level_table[(int)b][1];
                            rx1_preamp_offset[(int)PreampMode.LOW] = 0.0f;
                            rx1_preamp_offset[(int)PreampMode.MED] = rx1_level_table[(int)b][1] + rx1_level_table[(int)b][2];
                            rx1_preamp_offset[(int)PreampMode.HIGH] = rx1_level_table[(int)b][2];
                            rx1_meter_cal_offset = rx1_level_table[(int)b][0] + 27.2f;
                            UpdateDisplayOffsets();

                            if (FWCEEPROM.RX1ImageVer == 4)
                            {
                                dsp.GetDSPRX(0, 0).SetRXCorrectIQW(rx1_image_gain_table[(int)b], rx1_image_phase_table[(int)b]);
                                dsp.GetDSPRX(0, 1).SetRXCorrectIQW(rx1_image_gain_table[(int)b], rx1_image_phase_table[(int)b]);
                            }

                            Audio.IQGain = 1.0f + 0.001f * rx1_image_gain_table[(int)b];
                            Audio.IQPhase = 0.001f * rx1_image_phase_table[(int)b];
                            break;
                        case Model.FLEX1500:
                            if (!hid_init) break;
                            b = rx1_band;
                            if (current_ant_mode == AntMode.Expert)
                            {
                                int band = (int)value;
                                if (rx1_xvtr_index >= 0) band = (int)Band.VHF0 + rx1_xvtr_index;

                                if (rx_ant_1500 != HIDAnt.BITE) RXAnt1500 = rx_ant_1500_by_band[band];
                            }
                            RX1DisplayCalOffset = rx1_level_table[(int)b][0];
                            rx1_preamp_offset[(int)PreampMode.OFF] = rx1_level_table[(int)b][1] + 10.0f; // -10
                            rx1_preamp_offset[(int)PreampMode.LOW] = rx1_level_table[(int)b][1]; // 0
                            rx1_preamp_offset[(int)PreampMode.MED] = +10.0f; // +10
                            rx1_preamp_offset[(int)PreampMode.HIGH] = 0.0f; // +20
                            rx1_preamp_offset[(int)PreampMode.LAST] = -10.0f; // +30
                            rx1_meter_cal_offset = rx1_level_table[(int)b][0] + 27.2f;
                            UpdateDisplayOffsets();

                            dsp.GetDSPRX(0, 0).SetRXCorrectIQW(rx1_image_gain_table[(int)b], rx1_image_phase_table[(int)b]);
                            dsp.GetDSPRX(0, 1).SetRXCorrectIQW(rx1_image_gain_table[(int)b], rx1_image_phase_table[(int)b]);

                            //Audio.IQGain = 1.0f + 0.001f * rx1_image_gain_table[(int)b];
                            //Audio.IQPhase = 0.001f * rx1_image_phase_table[(int)b];

                            if (hidAntForm != null && !hidAntForm.IsDisposed) hidAntForm.SetBand(value);
                            break;
                    } // current model



                } // rx1_band != oldBand


            } // set
        } // RX1Band



        public void IIC_AMPCONTROL(byte AMPBAND_1, byte AMPBAND_2)
        {  //===================================================================
           // ke9ns add to allow IIC remote control of my SS AMP

            /*
            IIC FlexWire bus(address 0x4E and now 0x4A) to send band change commands to an external device for AMP control.
            Address space of the PCA9534 chip is (0,1,0,0, A2,A2,A0, X) from 0x40 = HEROs, 0x42:1=2200m, 2=630m, 4=160m, 8=80m, , 0x44, 0x46, 0x48, 0x4A = AMP1, 0x4C = UCB XVTR, 0x4E=AMP  

            The AMP uses the W6PQL Output FIlter board
            4E is original Filter board.
            4F is Rev6 and newer filter board.
            For reading the IIC bus, you can use a  PCA9534 device and some relays, and use the FlexWire port for power.

            Upon startup and band change, PowerSDR will send 2 IIC command strings:
            1) Address 0x4E  Register 0x01 Value = < DATA >
            2)  Address 0x4E, Register 0x03, Value = 0xFF

            Where<DATA> runs from the following map:
            1 = Select bands: L/MW, 160m, 120m(no relay needed)
            2 = Select bands: 90m, 80m, 61m, 60m, 49m
            4 = Select bands: 41m, 40m, 31m ,30m
          
            8 = Select bands: 25m, 22m, 20m, 17m, 16m, 15m, 14m  // 4E
            16 = Select bands: 13m, 12m, 11m, 10m
 
            8 = Select bands: 25m, 22m, 20m, 17m, 16m,  // 4F
            16 = Select bands: 15m, 14m, 13m, 12m, 11m, 10m

            32 = Select bands: 6m

            64 = Remote ON / OFF (N.C. relay contact to setup AMP for remote band switching)
                                  (N.O. relay to Power ON AMP and/or PTT enable)

           128 = Select Bands: VHF/UHF bands (currently not used) (now used for PTT instead)

            */



            if ((setupForm != null) && (setupForm.chkBoxIIC.Checked == true)) //ke9ns check if IIC is Enabled
            {
                byte temp1 = 0, temp2 = 0;

                if ((setupForm.chkBoxIICON.Checked == true) && (AMPBAND_1 != 128)) // 128=vhf but not using it now. using it for ptt
                {
                    temp1 = (byte)(AMPBAND_1 | 64); // If AMP is to be ON, then OR 64

                    if (checkBoxIICPTT.Checked == true) temp1 = (byte)(AMPBAND_1 | 128 | 64); // if Amp is to allow PTT, then OR 64

                }
                else
                {
                    //  if (AMPBAND == 128) temp1 = (byte)(128); // also if in VHF/UHF shut down the AMP
                    //  else temp1 = 0; // turn OFF
                }

                if (AMPBAND > 128) // shut down
                {
                    temp1 = 0;

                }

                if ((setupForm.chkBoxIICON.Checked == true) && (AMPBAND_2 != 128)) // 128=vhf but not using it now. using it for ptt
                {
                    temp1 = (byte)(AMPBAND_2 | 64); // If AMP is to be ON, then OR 64

                    if (checkBoxIICPTT.Checked == true) temp1 = (byte)(AMPBAND_2 | 128 | 64); // if Amp is to allow PTT, then OR 64

                }
                else
                {
                    //  if (AMPBAND == 128) temp1 = (byte)(128); // also if in VHF/UHF shut down the AMP
                    //  else temp1 = 0; // turn OFF
                }

                if (AMPBAND1 > 128) // shut down
                {
                    temp2 = 0;
                }

                switch (CurrentModel)
                {
                    case Model.FLEX5000:
                    case Model.FLEX3000:
                        if (fwc_init)
                        {

                            //  Debug.WriteLine("===I2C=== w6pql AMP control: 0x4E/F 0x4A/B here");
                            //  Debug.WriteLine("SEND IIC zcode " + temp1);
                            FWC.FlexWire_Write2Value(0x4E, 0x01, temp1); //w6pql amp control (older revision) send temp1 to output port of IIC chip
                            FWC.FlexWire_Write2Value(0x4E, 0x03, 0x00); // turn all pins to outputs


                            FWC.FlexWire_Write2Value(0x4A, 0x01, temp2); // w6pql amp control (newest revision)
                            FWC.FlexWire_Write2Value(0x4A, 0x03, 0x00); // turn all pins to outputs

                        }

                        break;
                    case Model.FLEX1500:
                        if (hid_init)
                        {

                            //  Debug.WriteLine("SEND IIC zcode " + temp1);

                            USBHID.FlexWire_Write2Value(0x4E, 0x01, temp1);
                            USBHID.FlexWire_Write2Value(0x4E, 0x03, 0x00); // turn all pins to outputs

                            USBHID.FlexWire_Write2Value(0x4A, 0x01, temp1);
                            USBHID.FlexWire_Write2Value(0x4A, 0x03, 0x00); // turn all pins to outputs


                        }
                        break;
                } // switch

            }

        } // IIC_AMPCONTROL


        ushort IIC_Band = 0; // ke9ns add
        ushort IIC_Band_Last = 0; // ke9ns add

        double IIC_Last_Freq = 0; // ke9ns add

        // ke9ns add: allow bandchange to control HERO preselect via IIC bus
        public void IIC_HEROCONTROL(byte HEROBAND1)
        {

            byte reg0 = 0, reg1 = 0;



            if (setupForm != null)
            {

                reg0 = 0;
                reg1 = 0;

                try
                {
                    if (setupForm.chkBoxHERO.Checked == true)
                    {

                        // ke9ns: this is not part of the HERO, but gives a bit for the band your on in HF mode
                        IIC_Band = 0;

                        if (VFOAFreq >= 0.135700 && VFOAFreq <= 0.137799) //  0.135700, 0.137799, "2.2kM CW & Narrow Band",   true, // 2200m ham ke9ns change
                            IIC_Band = 1;

                        else if (VFOAFreq >= 0.472000 && VFOAFreq <= 0.478999) //   0.472000, 0.478999, "630M CW/JT9/WSPR/Narrow",    true, // 630m ham ke9ns change
                            IIC_Band = 2;
                        else if (VFOAFreq >= 1.8 && VFOAFreq <= 2.0) //  160m
                            IIC_Band = 4;
                        else if (VFOAFreq >= 3.5 && VFOAFreq <= 4.0) //  80m
                            IIC_Band = 8;
                        else if (VFOAFreq >= 5.3 && VFOAFreq <= 5.6) //  60m
                            IIC_Band = 16;
                        else if (VFOAFreq >= 7.0 && VFOAFreq <= 7.3) //  40m
                            IIC_Band = 32;
                        else if (VFOAFreq >= 10.1 && VFOAFreq <= 10.15) //  30m
                            IIC_Band = 64;
                        else if (VFOAFreq >= 14.0 && VFOAFreq <= 14.35) //  20m
                            IIC_Band = 128;
                        else if (VFOAFreq >= 18.068 && VFOAFreq <= 18.168) //  17m
                            IIC_Band = 256;
                        else if (VFOAFreq >= 21.0 && VFOAFreq <= 21.45) //  15m
                            IIC_Band = 512;
                        else if (VFOAFreq >= 24.89 && VFOAFreq <= 24.99) //  12m
                            IIC_Band = 1024;
                        else if (VFOAFreq >= 28.0 && VFOAFreq <= 30.0) //  10m
                            IIC_Band = 2048;
                        else if (VFOAFreq >= 50.00 && VFOAFreq <= 54.0) //  6m
                            IIC_Band = 4096;
                        else IIC_Band = 8192;



                        //---------------------------------------------------

                        if (HEROBAND1 == 1) reg0 += (1 << 4); // Port 04
                        else if (HEROBAND1 == 2)
                            reg0 += (1 << 1); // Port 01
                        else if (HEROBAND1 == 3)
                            reg0 += (1 << 0); // Port 00
                        else if (HEROBAND1 == 4)
                            reg0 += (1 << 2); // Port 02
                        else if (HEROBAND1 == 5)
                            reg0 += (1 << 3); // Port 03


                        if (preSelForm != null)
                        {

                            if (preSelForm.radAntRXOnly.Checked)
                                reg0 += (1 << 5); // Port 05

                            if (preSelForm.radAnt1.Checked)
                                reg0 += (1 << 6); // Port 06

                            if (mox && !preSelForm.chkBypassTR.Checked) //  if (mox && !chkBypassTR.Checked)
                                reg0 += (1 << 7); // Port 07

                            reg1 = ReverseBits((byte)preSelForm.tbTune.Value);
                        }
                        else
                        {

                            // if (preSelForm.radAnt1.Checked)
                            reg0 += (1 << 6); // Port 06


                            if (MOX) //  if (mox && !chkBypassTR.Checked)
                            {
                                reg0 += (1 << 7); // Port 07
                            }

                            reg1 = ReverseBits((byte)128);


                        }
                        //  Debug.WriteLine("Presel slider: " + ((byte)tbTune.Value).ToString("X") + "  reg1: " + reg1.ToString("X"));

                        switch (CurrentModel)
                        {


                            case Model.FLEX5000:
                            case Model.FLEX3000:
                                if (fwc_init)


                                    Debug.WriteLine("IIC HERO " + IIC_Band);

                                FWC.FlexWire_Write2Value(0x40, reg0, reg1);

                                if (IIC_Band != IIC_Band_Last)
                                {
                                    Debug.WriteLine("IIC band " + IIC_Band);

                                    // ke9ns: for use with the MCP23017 16 bit I2C port
                                    FWC.FlexWire_Write2Value(0x46, 0x00, 0x00); // turn all pins to outputs
                                    FWC.FlexWire_Write2Value(0x46, 0x01, 0x00); // turn all pins to outputs

                                    FWC.FlexWire_Write2Value(0x46, 0x12, (byte)IIC_Band);
                                    FWC.FlexWire_Write2Value(0x46, 0x13, (byte)(IIC_Band >> 8));



                                    // ke9ns: for use with the PCA9534 8 bit I2C ports
                                    FWC.FlexWire_Write2Value(0x42, 0x01, (byte)IIC_Band); // low value
                                    FWC.FlexWire_Write2Value(0x42, 0x03, 0x00); // turn all pins to outputs

                                    FWC.FlexWire_Write2Value(0x44, 0x01, (byte)(IIC_Band >> 8)); // high value
                                    FWC.FlexWire_Write2Value(0x44, 0x03, 0x00); // turn all pins to outputs



                                    IIC_Band_Last = IIC_Band;
                                    IIC_Last_Freq = VFOAFreq;

                                }

                                break;
                            case Model.FLEX1500:
                                if (hid_init)
                                    USBHID.FlexWire_Write2Value(0x40, reg0, reg1);

                                if (IIC_Band != IIC_Band_Last)
                                {

                                    // ke9ns: for use with the MCP23017 16 bit I2C port
                                    USBHID.FlexWire_Write2Value(0x46, 0x00, 0x00); // turn all pins to outputs
                                    USBHID.FlexWire_Write2Value(0x46, 0x01, 0x00); // turn all pins to outputs

                                    USBHID.FlexWire_Write2Value(0x46, 0x12, (byte)IIC_Band);
                                    USBHID.FlexWire_Write2Value(0x46, 0x13, (byte)(IIC_Band >> 8));


                                    // ke9ns: for use with the PCA9534 8 bit I2C ports
                                    USBHID.FlexWire_Write2Value(0x42, 0x01, (byte)IIC_Band);
                                    USBHID.FlexWire_Write2Value(0x42, 0x03, 0x00); // turn all pins to outputs

                                    USBHID.FlexWire_Write2Value(0x44, 0x01, (byte)(IIC_Band >> 8));
                                    USBHID.FlexWire_Write2Value(0x44, 0x03, 0x00); // turn all pins to outputs

                                    IIC_Band_Last = IIC_Band;
                                    IIC_Last_Freq = VFOAFreq;
                                }
                                break;

                        }


                    } // chkboxhero

                }
                catch (Exception e)
                {
                    Debug.WriteLine("========HEROFAIL=======");
                }
            } // setupform

        } //IIC_HEROCONTROL

        private byte ReverseBits(byte b)
        {
            byte temp = 0;
            for (int i = 0; i < 8; i++)
                temp += (byte)(((b >> i) & 0x01) << (7 - i));
            return temp;
        }

        //  panelBandGNRX2.Visible = false;
        //  panelBandHFRX2.Visible = false;
        //  if (FWCEEPROM.RX2OK) panelBandVHFRX2.Visible = true; // ke9ns add keep VHF panel open when VHF button selected
        private string BandToString(Band b)
        {
            string ret = "GEN";

            switch (b)
            {
                case Band.GEN: ret = "GEN"; break;
                case Band.B160M: ret = "160m"; if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; panelBandVHFRX2.Visible = false; break;
                case Band.B80M: ret = "80m"; if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; panelBandVHFRX2.Visible = false; break;
                case Band.B60M: ret = "60m"; if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; panelBandVHFRX2.Visible = false; break;
                case Band.B40M: ret = "40m"; if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; panelBandVHFRX2.Visible = false; break;
                case Band.B30M: ret = "30m"; if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; panelBandVHFRX2.Visible = false; break;
                case Band.B20M: ret = "20m"; if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; panelBandVHFRX2.Visible = false; break;
                case Band.B17M: ret = "17m"; if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; panelBandVHFRX2.Visible = false; break;
                case Band.B15M: ret = "15m"; if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; panelBandVHFRX2.Visible = false; break;
                case Band.B12M: ret = "12m"; if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; panelBandVHFRX2.Visible = false; break;
                case Band.B10M: ret = "10m"; if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; panelBandVHFRX2.Visible = false; break;
                case Band.B6M: ret = "6m"; if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; panelBandVHFRX2.Visible = false; break;
                case Band.B2M: ret = "2m"; if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; panelBandVHFRX2.Visible = false; break;
                case Band.WWV: ret = "WWV"; if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true; panelBandGNRX2.Visible = false; panelBandVHFRX2.Visible = false; break;

                case Band.BLMF: ret = "LMF"; panelBandHFRX2.Visible = false; if (FWCEEPROM.RX2OK) panelBandGNRX2.Visible = true; panelBandVHFRX2.Visible = false; break;  // ke9ns add
                case Band.B120M: ret = "120m"; panelBandHFRX2.Visible = false; if (FWCEEPROM.RX2OK) panelBandGNRX2.Visible = true; panelBandVHFRX2.Visible = false; break;
                case Band.B90M: ret = "90m"; panelBandHFRX2.Visible = false; if (FWCEEPROM.RX2OK) panelBandGNRX2.Visible = true; panelBandVHFRX2.Visible = false; break;
                case Band.B61M: ret = "61m"; panelBandHFRX2.Visible = false; if (FWCEEPROM.RX2OK) panelBandGNRX2.Visible = true; panelBandVHFRX2.Visible = false; break;
                case Band.B49M: ret = "49m"; panelBandHFRX2.Visible = false; if (FWCEEPROM.RX2OK) panelBandGNRX2.Visible = true; panelBandVHFRX2.Visible = false; break;
                case Band.B41M: ret = "41m"; panelBandHFRX2.Visible = false; if (FWCEEPROM.RX2OK) panelBandGNRX2.Visible = true; panelBandVHFRX2.Visible = false; break;
                case Band.B31M: ret = "31m"; panelBandHFRX2.Visible = false; if (FWCEEPROM.RX2OK) panelBandGNRX2.Visible = true; panelBandVHFRX2.Visible = false; break;
                case Band.B25M: ret = "25m"; panelBandHFRX2.Visible = false; if (FWCEEPROM.RX2OK) panelBandGNRX2.Visible = true; panelBandVHFRX2.Visible = false; break;
                case Band.B22M: ret = "22m"; panelBandHFRX2.Visible = false; if (FWCEEPROM.RX2OK) panelBandGNRX2.Visible = true; panelBandVHFRX2.Visible = false; break;
                case Band.B19M: ret = "19m"; panelBandHFRX2.Visible = false; if (FWCEEPROM.RX2OK) panelBandGNRX2.Visible = true; panelBandVHFRX2.Visible = false; break;
                case Band.B16M: ret = "16m"; panelBandHFRX2.Visible = false; if (FWCEEPROM.RX2OK) panelBandGNRX2.Visible = true; panelBandVHFRX2.Visible = false; break;
                case Band.B14M: ret = "14m"; panelBandHFRX2.Visible = false; if (FWCEEPROM.RX2OK) panelBandGNRX2.Visible = true; panelBandVHFRX2.Visible = false; break;
                case Band.B13M: ret = "13m"; panelBandHFRX2.Visible = false; if (FWCEEPROM.RX2OK) panelBandGNRX2.Visible = true; panelBandVHFRX2.Visible = false; break;
                case Band.B11M: ret = "11m"; panelBandHFRX2.Visible = false; if (FWCEEPROM.RX2OK) panelBandGNRX2.Visible = true; panelBandVHFRX2.Visible = false; break;

                case Band.VHF0: ret = "VU 2m"; panelBandHFRX2.Visible = false; panelBandGNRX2.Visible = false; if (FWCEEPROM.RX2OK) panelBandVHFRX2.Visible = true; break;
                case Band.VHF1: ret = "VU 70cm"; panelBandHFRX2.Visible = false; panelBandGNRX2.Visible = false; if (FWCEEPROM.RX2OK) panelBandVHFRX2.Visible = true; break;
                case Band.VHF2: ret = "VHF2"; panelBandHFRX2.Visible = false; panelBandGNRX2.Visible = false; if (FWCEEPROM.RX2OK) panelBandVHFRX2.Visible = true; break;
                case Band.VHF3: ret = "VHF3"; panelBandHFRX2.Visible = false; panelBandGNRX2.Visible = false; if (FWCEEPROM.RX2OK) panelBandVHFRX2.Visible = true; break;
                case Band.VHF4: ret = "VHF4"; panelBandHFRX2.Visible = false; panelBandGNRX2.Visible = false; if (FWCEEPROM.RX2OK) panelBandVHFRX2.Visible = true; break;
                case Band.VHF5: ret = "VHF5"; panelBandHFRX2.Visible = false; panelBandGNRX2.Visible = false; if (FWCEEPROM.RX2OK) panelBandVHFRX2.Visible = true; break;
                case Band.VHF6: ret = "VHF6"; panelBandHFRX2.Visible = false; panelBandGNRX2.Visible = false; if (FWCEEPROM.RX2OK) panelBandVHFRX2.Visible = true; break;
                case Band.VHF7: ret = "VHF7"; panelBandHFRX2.Visible = false; panelBandGNRX2.Visible = false; if (FWCEEPROM.RX2OK) panelBandVHFRX2.Visible = true; break;
                case Band.VHF8: ret = "VHF8"; panelBandHFRX2.Visible = false; panelBandGNRX2.Visible = false; if (FWCEEPROM.RX2OK) panelBandVHFRX2.Visible = true; break;
                case Band.VHF9: ret = "VHF9"; panelBandHFRX2.Visible = false; panelBandGNRX2.Visible = false; if (FWCEEPROM.RX2OK) panelBandVHFRX2.Visible = true; break;
                case Band.VHF10: ret = "VHF10"; panelBandHFRX2.Visible = false; panelBandGNRX2.Visible = false; if (FWCEEPROM.RX2OK) panelBandVHFRX2.Visible = true; break;
                case Band.VHF11: ret = "VHF11"; panelBandHFRX2.Visible = false; panelBandGNRX2.Visible = false; if (FWCEEPROM.RX2OK) panelBandVHFRX2.Visible = true; break;
                case Band.VHF12: ret = "VHF12"; panelBandHFRX2.Visible = false; panelBandGNRX2.Visible = false; if (FWCEEPROM.RX2OK) panelBandVHFRX2.Visible = true; break;
                case Band.VHF13: ret = "VHF13"; panelBandHFRX2.Visible = false; panelBandGNRX2.Visible = false; if (FWCEEPROM.RX2OK) panelBandVHFRX2.Visible = true; break;
                default: ret = "GEN"; panelBandHFRX2.Visible = false; if (FWCEEPROM.RX2OK) panelBandGNRX2.Visible = true; panelBandVHFRX2.Visible = false; break;
            }

            return ret;
        }

        private Band StringToBand(string s)
        {
            Band b = Band.GEN;
            switch (s)
            {
                case "GEN": b = Band.GEN; break;
                case "160m": b = Band.B160M; break;
                case "80m": b = Band.B80M; break;
                case "60m": b = Band.B60M; break;
                case "40m": b = Band.B40M; break;
                case "30m": b = Band.B30M; break; // ke9ns add .217
                case "20m": b = Band.B20M; break;
                case "17m": b = Band.B17M; break;
                case "15m": b = Band.B15M; break;
                case "12m": b = Band.B12M; break;
                case "10m": b = Band.B10M; break;
                case "6m": b = Band.B6M; break;
                case "2m": b = Band.B2M; break;
                case "WWV": b = Band.WWV; break;

                case "LMF": b = Band.BLMF; break; // ke9ns add
                case "120m": b = Band.B120M; break;
                case "90m": b = Band.B90M; break;
                case "61m": b = Band.B61M; break;
                case "49m": b = Band.B49M; break;
                case "41m": b = Band.B41M; break;
                case "31m": b = Band.B31M; break;
                case "25m": b = Band.B25M; break;
                case "22m": b = Band.B22M; break;
                case "19m": b = Band.B19M; break;
                case "16m": b = Band.B16M; break;
                case "14m": b = Band.B14M; break;
                case "13m": b = Band.B13M; break;
                case "11m": b = Band.B11M; break;

                case "VU 2m": b = Band.VHF0; break;
                case "VU 70cm": b = Band.VHF1; break;
                case "VHF2": b = Band.VHF2; break;
                case "VHF3": b = Band.VHF3; break;
                case "VHF4": b = Band.VHF4; break;
                case "VHF5": b = Band.VHF5; break;
                case "VHF6": b = Band.VHF6; break;
                case "VHF7": b = Band.VHF7; break;
                case "VHF8": b = Band.VHF8; break;
                case "VHF9": b = Band.VHF9; break;
                case "VHF10": b = Band.VHF10; break;
                case "VHF11": b = Band.VHF11; break;
                case "VHF12": b = Band.VHF12; break;
                case "VHF13": b = Band.VHF13; break;
            }

            return b;
        }

        private Band rx2_band;
        public Band RX2Band
        {
            get { return rx2_band; }
            set
            {
                if (!fwc_init || current_model != Model.FLEX5000 || !FWCEEPROM.RX2OK)
                    return;


                Band old_band = rx2_band;
                rx2_band = value;
                //comboRX2Band.Focus();

                //comboRX2Band.SelectedIndex = Math.Min(Math.Max(0, (int)value), comboRX2Band.Items.Count-1);
                comboRX2Band.Text = BandToString(rx2_band);
                //btnHidden.Focus();

                Band lo_band = Band.FIRST;
                Debug.WriteLine("2XVTR NOW");
                if (rx2_xvtr_index >= 0) lo_band = BandByFreq(xvtrForm.TranslateFreq(VFOBFreq), -1, false, current_region);
                Debug.WriteLine("3XVTR NOW");
                rx2_preamp_by_band[(int)old_band] = rx2_preamp_mode;

                double freq = VFOBFreq;
                if (freq < 2.0)
                {
                    if (chkRX2Preamp.Enabled) chkRX2Preamp.Enabled = false;
                    if (chkRX2Preamp.Checked) chkRX2Preamp.Checked = false;
                }
                else if (freq >= 28.0 && rx2_xvtr_index < 0 && !enable_6m_preamp)
                {
                    if (chkRX2Preamp.Enabled) chkRX2Preamp.Enabled = false;
                    if (!chkRX2Preamp.Checked) chkRX2Preamp.Checked = true;
                }
                else if (!chkRX2Preamp.Enabled) chkRX2Preamp.Enabled = true;


                if (rx2_band != old_band || initializing)
                {
                    WBIRRX2Holdoff();

                    // save values for old band
                    rx2_agct_by_band[(int)old_band] = ptbRX2RF.Value;

                    RX2PreampMode = rx2_preamp_by_band[(int)value];
                    RX2RF = rx2_agct_by_band[(int)value];
                    ptbRX2RF_Scroll(this, EventArgs.Empty);

                    if (current_ant_mode == AntMode.Expert)
                    {
                        int band = (int)value;
                        if (rx2_xvtr_index >= 0)
                            band = (int)Band.VHF0 + rx2_xvtr_index;

                        if (FWCEEPROM.VUOK &&
                            (rx2_band == Band.VHF0 || rx2_band == Band.VHF1 || // going to a VU band
                             old_band == Band.VHF0 || old_band == Band.VHF1)) // coming from a VU band
                            vu_ant = true;
                        RX2Ant = rx2_ant_by_band[band];
                        if (vu_ant) vu_ant = false;
                    }
                    else // simple antenna mode
                    {
                        if (FWCEEPROM.VUOK &&
                            (rx2_band == Band.VHF0 || rx2_band == Band.VHF1 || // going to a VU band
                             old_band == Band.VHF0 || old_band == Band.VHF1)) // coming from a VU band
                        {
                            vu_ant = true;
                            RX2Ant = rx2_ant;
                            vu_ant = false;
                        }
                    }

                    Band b = rx2_band;
                    if (rx2_xvtr_index >= 0) b = lo_band;

                    if (FWCEEPROM.VUOK)
                    {
                        switch (rx2_xvtr_index)
                        {
                            case 0: // 2m on 19-23MHz
                                b = Band.B15M;
                                break;
                            case 1: // 70cm on 30-50MHz
                                b = Band.B6M;
                                break;
                        }
                    }

                    RX2DisplayCalOffset = rx2_level_table[(int)b][0];
                    rx2_preamp_offset[(int)PreampMode.OFF] = 0.0f;
                    rx2_preamp_offset[(int)PreampMode.HIGH] = rx2_level_table[(int)b][1];
                    rx2_meter_cal_offset = rx2_level_table[(int)b][2];
                    UpdateDisplayOffsets();

                    if (FWCEEPROM.RX2ImageVer == 5)
                    {
                        dsp.GetDSPRX(1, 0).SetRXCorrectIQW(rx2_image_gain_table[(int)b], rx2_image_phase_table[(int)b]);
                        dsp.GetDSPRX(1, 1).SetRXCorrectIQW(rx2_image_gain_table[(int)b], rx2_image_phase_table[(int)b]);
                    }

                    if (fwcAntForm != null && !fwcAntForm.IsDisposed) fwcAntForm.SetBand2(value); // ke9ns mod: was SetBand() now just for RX2
                }
            }
        } // RX2band


        //========================================
        // ke9ns add
        private DSPMode newMode = DSPMode.LAST;

        public DSPMode TXMode
        {
            get
            {
                return rx1_dsp_mode;
            }
            set
            {
                newMode = value;

                if ((int)tx_band < 0) return; // dont save mode drive levels if invalid band or mode data
                if ((int)rx1_dsp_mode < 0) return;


                int old_pwr = ptbPWR.Value; // current value of the power slider
                int old_mode = (int)rx1_dsp_mode; // current dsp mode (am,ssb,etc)

                int old_limit = 100;
                if (setupForm != null) old_limit = (int)setupForm.udTXDriveMax.Value;


                if (old_mode < 0) old_mode = 0;

                if (old_pwr > old_limit) old_pwr = old_limit; // check


                try
                {
                    if (old_mode >= 0)
                    {
                        power_by_mode_by_band[(int)tx_band, old_mode] = old_pwr; // save current drive slider setting
                        limit_by_mode_by_band[(int)tx_band, old_mode] = old_limit; // save current setting for drive limit
                    }
                }
                catch
                {

                }

                if ((setupForm != null) && (setupForm.chkBandModeSave.Checked == true)) // only update slider and max if the option is enabled.
                {

                    try
                    {
                        if ((int)newMode == 12) newMode = rx1_dsp_mode;

                        if ((int)newMode >= 0 && (int)newMode < 12)
                        {
                            if (limit_by_mode_by_band[(int)tx_band, (int)newMode] > 100) limit_by_mode_by_band[(int)tx_band, (int)newMode] = 100;
                            if (limit_by_mode_by_band[(int)tx_band, (int)newMode] < 0) limit_by_mode_by_band[(int)tx_band, (int)newMode] = 0;

                            if (power_by_mode_by_band[(int)tx_band, (int)newMode] > limit_by_mode_by_band[(int)tx_band, (int)newMode])
                            {
                                power_by_mode_by_band[(int)tx_band, (int)newMode] = limit_by_mode_by_band[(int)tx_band, (int)newMode];
                            }

                            if (power_by_mode_by_band[(int)tx_band, (int)newMode] < 0) power_by_mode_by_band[(int)tx_band, (int)newMode] = 0;
                        }
                    }
                    catch
                    {

                    }

                    try
                    {
                        if ((int)newMode == 12) newMode = rx1_dsp_mode;

                        if ((int)newMode >= 0 && (int)newMode < 12)
                        {
                            PWR = power_by_mode_by_band[(int)tx_band, (int)newMode]; // set the drive slider to the value from the database because you changed mode
                            ptbPWR_Scroll(this, EventArgs.Empty);
                        }
                    }
                    catch (Exception e)
                    {
                        Debug.WriteLine("TXMode drive slider fail " + e);
                    }

                    try
                    {
                        if (setupForm != null) setupForm.udTXDriveMax.Value = limit_by_mode_by_band[(int)tx_band, (int)newMode]; // set the drive slider to the value from the database because you changed mode

                    }
                    catch (Exception e)
                    {
                        Debug.WriteLine("TXMODE drive limit fail " + e);
                    }

                }


            } // set


        } // DSPMode TXMode

        //===================================================
        private Band tx_band;
        private Band old_band; // ke9ns move here .192
        public Band TXBand
        {

            get { return tx_band; }
            set
            {

                Debug.WriteLine("HIGH-LOW ... TXband value " + tx_band + " , " + tx_filter_high + " , " + tx_filter_low + " band: " + rx1_band + " Tband: " + tx_band);

                old_band = tx_band; // ke9ns mod: .192 moved creation up so it doesnt get clobbered every time it runs.

                tx_band = value;

                Band lo_band = Band.FIRST;

                if (tx_xvtr_index >= 0)
                {
                    Debug.WriteLine("4XVTR NOW");
                    lo_band = BandByFreq(xvtrForm.TranslateFreq(VFOAFreq), -1, true, current_region);
                    Debug.WriteLine("5XVTR NOW");
                }


                if (tx_band != old_band || initializing || ((rx1_dsp_mode != rx1_dsp_mode_last) && (setupForm != null) && (setupForm.chkBandModeSave.Checked == true))) // ke9ns mod
                {
                    WBIRRX1Holdoff();


                    rx1_dsp_mode_last = rx1_dsp_mode; // ke9ns

                    //  save values for old band
                    int old_pwr = ptbPWR.Value;
                    int old_mode = (int)rx1_dsp_mode;



                    int old_limit = 100; // ke9ns add
                    if (setupForm != null) old_limit = (int)setupForm.udTXDriveMax.Value; // ke9ns add

                    if (old_pwr > old_limit) old_pwr = old_limit; // check

                    try
                    {

                        if (setupForm != null && setupForm.chkBandModeSave.Checked == true && (old_mode >= 0 && old_mode < 12 && (int)old_band >= 0 && (int)tx_band >= 0)) // ke9ns add only update slider and max if the option is enabled.
                        {
                            power_by_mode_by_band[(int)old_band, old_mode] = old_pwr; // ke9ns add
                            limit_by_mode_by_band[(int)old_band, old_mode] = old_limit; // save current setting for drive limit
                        }
                        else
                        {
                            power_by_band[(int)old_band] = old_pwr; // original way
                        }

                        if (old_mode >= 0 && old_mode < 12 && (int)old_band >= 0 && (int)tx_band >= 0)
                        {
                            if (limit_by_mode_by_band[(int)tx_band, (int)newMode] > 100) limit_by_mode_by_band[(int)tx_band, (int)newMode] = 100;
                            if (limit_by_mode_by_band[(int)tx_band, (int)newMode] < 0) limit_by_mode_by_band[(int)tx_band, (int)newMode] = 0;

                            if (power_by_mode_by_band[(int)tx_band, (int)newMode] > limit_by_mode_by_band[(int)tx_band, (int)newMode])
                            {
                                power_by_mode_by_band[(int)tx_band, (int)newMode] = limit_by_mode_by_band[(int)tx_band, (int)newMode];
                            }

                            if (power_by_mode_by_band[(int)tx_band, (int)newMode] < 0) power_by_mode_by_band[(int)tx_band, (int)newMode] = 0;
                            //if (tx_xvtr_index < 0)
                        }

                        if (setupForm != null && setupForm.chkBandModeSave.Checked == true && (old_mode >= 0 && old_mode < 12 && (int)old_band >= 0 && (int)tx_band >= 0)) // ke9ns add  only update slider and max if the option is enabled.
                        {
                            PWR = power_by_mode_by_band[(int)value, (int)newMode]; // ke9ns add
                            if (setupForm != null) setupForm.udTXDriveMax.Value = limit_by_mode_by_band[(int)value, (int)newMode]; // set the drive slider to the value from the database because you changed mode
                        }
                        else
                        {
                            PWR = power_by_band[(int)value]; // original way
                        }

                        ptbPWR_Scroll(this, EventArgs.Empty);
                    }
                    catch
                    {

                    }


                    // save FM TX Offset
                    fm_tx_offset_by_band_mhz[(int)old_band] = fm_tx_offset_mhz;
                    udFMOffset.Value = (decimal)(fm_tx_offset_by_band_mhz[(int)value]);

                    switch (current_model)
                    {
                        case Model.FLEX5000:
                            if (!fwc_init) break;

                            if (FWCEEPROM.VUOK && tx_xvtr_index != last_tx_xvtr_index)
                            {
                                if (tx_xvtr_index == 0)
                                {
                                    FWC.SetVU_TXBand(0);
                                }
                                else if (tx_xvtr_index == 1)
                                {
                                    FWC.SetVU_TXBand(1);
                                    //SetVURXPath();
                                }
                                else
                                {
                                    FWC.SetVU_TXBand(2);
                                }
                            }

                            if (value == Band.B6M && (byte)FWCEEPROM.RFIORev < 34)
                            {
                                FWC.SetTXAnt(3);
                                tx_ant_by_band[(int)value] = FWCAnt.ANT3;

                            }

                            if (old_band == Band.B6M && (byte)FWCEEPROM.RFIORev < 34 && current_ant_mode == AntMode.Simple)
                                tx_ant_6m_reset = true;

                            if (current_ant_mode == AntMode.Expert)
                            {
                                int band = (int)value;
                                if (tx_xvtr_index >= 0) band = (int)Band.VHF0 + tx_xvtr_index;

                                TXAnt = tx_ant_by_band[band];

                                FWCAmpTX1 = tx1_by_band[band];
                                FWCAmpTX2 = tx2_by_band[band];
                                FWCAmpTX3 = tx3_by_band[band];
                            }
                            else if (value != Band.B6M)
                            {
                                TXAnt = tx_ant;
                                //   TXAnt2 = tx_ant2; // ke9ns add .205
                            }

                            Band b = tx_band;

                            if (tx_xvtr_index >= 0) b = lo_band;

                            if (fwc_init && current_model == Model.FLEX5000 && FWCEEPROM.VUOK)
                            {
                                switch (tx_xvtr_index)
                                {
                                    case 0: // 2m on 19-23MHz
                                        b = Band.B15M;
                                        break;
                                    case 1: // 70cm on 30-50MHz
                                        b = Band.B10M;
                                        break;
                                }
                            }


                            if (fwcAtuForm != null && !fwcAtuForm.IsDisposed && !fwcAtuForm.ATUEnabledOnBandChange())
                            {
                                switch (fwcAtuForm.CurrentTuneMode)
                                {
                                    case FWCATUMode.SemiAutomatic:
                                        fwcAtuForm.CurrentTuneMode = FWCATUMode.Bypass;
                                        break;
                                }
                                FWCATUBypass();
                            }



                            Debug.WriteLine("TXband value " + value);

                            if (!extended) // ke9ns add: this if statement. extended uses ham bands to transmit on but antenna switch gets confused when RXBand and TXBand dont match when in SWL bands
                            {
                                if (fwcAntForm != null && !fwcAntForm.IsDisposed) fwcAntForm.SetBand(value); // ke9ns test commented this out
                            }

                            bool tx1, tx2, tx3;
                            if (flex5000RelayForm != null) flex5000RelayForm.UpdateRelayState(out tx1, out tx2, out tx3);

                            break;

                        case Model.FLEX3000:
                            if (!fwc_init) break;

                            b = tx_band;
                            if (tx_xvtr_index >= 0) b = lo_band;



                            if (flex3000ATUForm != null && !flex3000ATUForm.IsDisposed)
                            {
                                flex3000ATUForm.DoBypass();
                                FWCATUBypass();
                            }


                            break;

                        case Model.FLEX1500:
                            if (current_ant_mode == AntMode.Expert)
                            {
                                int band = (int)value;
                                if (tx_xvtr_index >= 0) band = (int)Band.VHF0 + tx_xvtr_index;

                                HIDAnt old_ant = tx_ant_1500;
                                TXAnt1500 = tx_ant_1500_by_band[band];

                                if (old_ant != tx_ant_1500) ptbPWR_Scroll(this, EventArgs.Empty);
                            }
                            break;
                    }

                    switch (current_model)
                    {
                        case Model.FLEX5000:
                        case Model.FLEX3000:
                        case Model.FLEX1500:
                            Band b = tx_band;
                            if (tx_xvtr_index >= 0) b = lo_band;

                            if (fwc_init && current_model == Model.FLEX5000 && FWCEEPROM.VUOK)
                            {
                                switch (tx_xvtr_index)
                                {
                                    case 0: // 2m on 19-23MHz
                                        b = Band.B15M;
                                        break;
                                    case 1: // 70cm on 30-50MHz
                                        b = Band.B10M;
                                        break;
                                }
                            }

                            if (setupForm != null && !setupForm.IsDisposed)
                            {
                                setupForm.ImageGainTX = tx_image_gain_table[(int)b];
                                setupForm.ImagePhaseTX = tx_image_phase_table[(int)b];
                            }
                            break;
                    }

                    if (tx_band == Band.B60M) // ke9ns: if new band on 60m transmit then set a 2800 khz wide TX audio
                    {
                        tx_filter_low_save = tx_filter_low;
                        tx_filter_high_save = tx_filter_high;

                        if (tx_filter_low < 100)
                            setupForm.TXFilterLow = 100;

                        if (tx_filter_high > 2900)
                            setupForm.TXFilterHigh = 2900;
                    }


                    if (old_band == Band.B60M) // if you move off of 60m, put back the TX audio the way it was
                    {
                        if (tx_filter_low != tx_filter_low_save)
                            setupForm.TXFilterLow = tx_filter_low_save;

                        if (tx_filter_high != tx_filter_high_save)
                            setupForm.TXFilterHigh = tx_filter_high_save;
                    }

                    if (setupForm != null) // ke9ns add: Force UPDATE of ANT Display .119
                    {
                        if (current_model == Model.FLEX5000)
                        {
                            if (fwcAntForm.radModeExpert.Checked)
                            {
                                CurrentAntMode = AntMode.Expert;
                                fwcAntForm.CurrentAntMode = current_ant_mode;
                                fwcAntForm.RX1Ant = rx1_ant;
                                fwcAntForm.RX1Loop = rx1_loop;
                                fwcAntForm.RX2Ant = rx2_ant;
                                fwcAntForm.TXAnt = tx_ant;
                                fwcAntForm.TXAnt2 = tx_ant2; // ke9ns add .205
                            }
                            else CurrentAntMode = AntMode.Simple;
                        }

                    }

                } // if new band (band change)

                //  Debug.WriteLine("HIGH-LOW TXband value " +  tx_band + " , " + tx_filter_high + " , " + tx_filter_low + " Rband: " + rx1_band + " Tband: " + tx_band);


            } // set txband


        } // TXBand



        //===================================================
        private Band tx_band2;
        private Band old_band2; // ke9ns move here .192
        public Band TXBand2
        {

            get { return tx_band2; }
            set
            {

                Debug.WriteLine("HIGH-LOW2 ... TXband2 value " + tx_band2 + " , " + tx_filter_high + " , " + tx_filter_low + " band: " + rx1_band + " Tband: " + tx_band2);

                old_band2 = tx_band2; // ke9ns mod: .192 moved creation up so it doesnt get clobbered every time it runs.

                tx_band2 = value;

                Band lo_band = Band.FIRST;

                if (tx_xvtr_index >= 0)
                {
                    Debug.WriteLine("6XVTR NOW");
                    lo_band = BandByFreq(xvtrForm.TranslateFreq(VFOAFreq), -1, true, current_region);
                }


                if (tx_band2 != old_band2 || initializing || ((rx1_dsp_mode != rx1_dsp_mode_last) && (setupForm != null) && (setupForm.chkBandModeSave.Checked == true))) // ke9ns mod
                {
                    WBIRRX1Holdoff();


                    rx1_dsp_mode_last = rx1_dsp_mode; // ke9ns

                    //  save values for old band
                    int old_pwr = ptbPWR.Value;
                    int old_mode = (int)rx1_dsp_mode;



                    int old_limit = 100; // ke9ns add
                    if (setupForm != null) old_limit = (int)setupForm.udTXDriveMax.Value; // ke9ns add

                    if (old_pwr > old_limit) old_pwr = old_limit; // check

                    try
                    {

                        if (setupForm != null && setupForm.chkBandModeSave.Checked == true && (old_mode >= 0 && old_mode < 12 && (int)old_band2 >= 0 && (int)tx_band2 >= 0)) // ke9ns add only update slider and max if the option is enabled.
                        {
                            power_by_mode_by_band[(int)old_band2, old_mode] = old_pwr; // ke9ns add
                            limit_by_mode_by_band[(int)old_band2, old_mode] = old_limit; // save current setting for drive limit
                        }
                        else
                        {
                            power_by_band[(int)old_band2] = old_pwr; // original way
                        }

                        if (old_mode >= 0 && old_mode < 12 && (int)old_band2 >= 0 && (int)tx_band2 >= 0)
                        {
                            if (limit_by_mode_by_band[(int)tx_band2, (int)newMode] > 100) limit_by_mode_by_band[(int)tx_band2, (int)newMode] = 100;
                            if (limit_by_mode_by_band[(int)tx_band2, (int)newMode] < 0) limit_by_mode_by_band[(int)tx_band2, (int)newMode] = 0;

                            if (power_by_mode_by_band[(int)tx_band2, (int)newMode] > limit_by_mode_by_band[(int)tx_band2, (int)newMode])
                            {
                                power_by_mode_by_band[(int)tx_band2, (int)newMode] = limit_by_mode_by_band[(int)tx_band2, (int)newMode];
                            }

                            if (power_by_mode_by_band[(int)tx_band2, (int)newMode] < 0) power_by_mode_by_band[(int)tx_band2, (int)newMode] = 0;
                            //if (tx_xvtr_index < 0)
                        }

                        if (setupForm != null && setupForm.chkBandModeSave.Checked == true && (old_mode >= 0 && old_mode < 12 && (int)old_band2 >= 0 && (int)tx_band2 >= 0)) // ke9ns add  only update slider and max if the option is enabled.
                        {
                            PWR = power_by_mode_by_band[(int)value, (int)newMode]; // ke9ns add
                            if (setupForm != null) setupForm.udTXDriveMax.Value = limit_by_mode_by_band[(int)value, (int)newMode]; // set the drive slider to the value from the database because you changed mode
                        }
                        else
                        {
                            PWR = power_by_band[(int)value]; // original way
                        }

                        ptbPWR_Scroll(this, EventArgs.Empty);
                    }
                    catch
                    {

                    }


                    // save FM TX Offset
                    fm_tx_offset_by_band_mhz[(int)old_band2] = fm_tx_offset_mhz;
                    udFMOffset.Value = (decimal)(fm_tx_offset_by_band_mhz[(int)value]);

                    switch (current_model)
                    {
                        case Model.FLEX5000:
                            if (!fwc_init) break;

                            if (FWCEEPROM.VUOK && tx_xvtr_index != last_tx_xvtr_index)
                            {
                                if (tx_xvtr_index == 0)
                                {
                                    FWC.SetVU_TXBand(0);
                                }
                                else if (tx_xvtr_index == 1)
                                {
                                    FWC.SetVU_TXBand(1);
                                    //SetVURXPath();
                                }
                                else
                                {
                                    FWC.SetVU_TXBand(2);
                                }
                            }

                            if (value == Band.B6M && (byte)FWCEEPROM.RFIORev < 34)
                            {
                                FWC.SetTXAnt(3);
                                tx_ant_by2_band[(int)value] = FWCAnt.ANT3; // ke9ns add .205
                            }

                            if (old_band2 == Band.B6M && (byte)FWCEEPROM.RFIORev < 34 && current_ant_mode == AntMode.Simple)
                                tx_ant_6m_reset = true;

                            if (current_ant_mode == AntMode.Expert)
                            {
                                int band = (int)value;
                                if (tx_xvtr_index >= 0) band = (int)Band.VHF0 + tx_xvtr_index;

                                TXAnt2 = tx_ant_by2_band[band]; // ke9ns add .205

                                FWCAmpTX1 = tx1_by_band[band];
                                FWCAmpTX2 = tx2_by_band[band];
                                FWCAmpTX3 = tx3_by_band[band];
                            }
                            else // if (value != Band.B6M)
                            {

                                Debug.WriteLine("TXBAND2 " + tx_ant2);
                                TXAnt2 = tx_ant2; // ke9ns add .205
                            }

                            Band b = tx_band2;

                            if (tx_xvtr_index >= 0) b = lo_band;

                            if (fwc_init && current_model == Model.FLEX5000 && FWCEEPROM.VUOK)
                            {
                                switch (tx_xvtr_index)
                                {
                                    case 0: // 2m on 19-23MHz
                                        b = Band.B15M;
                                        break;
                                    case 1: // 70cm on 30-50MHz
                                        b = Band.B10M;
                                        break;
                                }
                            }



                            if (fwcAtuForm != null && !fwcAtuForm.IsDisposed && !fwcAtuForm.ATUEnabledOnBandChange())
                            {
                                switch (fwcAtuForm.CurrentTuneMode)
                                {
                                    case FWCATUMode.SemiAutomatic:
                                        fwcAtuForm.CurrentTuneMode = FWCATUMode.Bypass;
                                        break;
                                }
                                FWCATUBypass();
                            }



                            Debug.WriteLine("TXband value " + value);

                            if (!extended) // ke9ns add this if statement. extended uses ham bands to transmit on but antenna switch gets confused when RXBand and TXBand dont match when in SWL bands
                            {
                                if (fwcAntForm != null && !fwcAntForm.IsDisposed) fwcAntForm.SetBand(value); // ke9ns test commented this out
                            }

                            bool tx1, tx2, tx3;
                            if (flex5000RelayForm != null) flex5000RelayForm.UpdateRelayState(out tx1, out tx2, out tx3);
                            break;



                    }

                    switch (current_model)
                    {
                        case Model.FLEX5000:
                        case Model.FLEX3000:
                        case Model.FLEX1500:
                            Band b = tx_band2;
                            if (tx_xvtr_index >= 0) b = lo_band;

                            if (fwc_init && current_model == Model.FLEX5000 && FWCEEPROM.VUOK)
                            {
                                switch (tx_xvtr_index)
                                {
                                    case 0: // 2m on 19-23MHz
                                        b = Band.B15M;
                                        break;
                                    case 1: // 70cm on 30-50MHz
                                        b = Band.B10M;
                                        break;
                                }
                            }

                            if (setupForm != null && !setupForm.IsDisposed)
                            {
                                setupForm.ImageGainTX = tx_image_gain_table[(int)b];
                                setupForm.ImagePhaseTX = tx_image_phase_table[(int)b];
                            }
                            break;
                    }

                    if (tx_band2 == Band.B60M) // ke9ns: if new band on 60m transmit then set a 2800 khz wide TX audio
                    {
                        tx_filter_low_save = tx_filter_low;
                        tx_filter_high_save = tx_filter_high;

                        if (tx_filter_low < 100)
                            setupForm.TXFilterLow = 100;

                        if (tx_filter_high > 2900)
                            setupForm.TXFilterHigh = 2900;
                    }


                    if (old_band2 == Band.B60M) // if you move off of 60m, put back the TX audio the way it was
                    {
                        if (tx_filter_low != tx_filter_low_save)
                            setupForm.TXFilterLow = tx_filter_low_save;

                        if (tx_filter_high != tx_filter_high_save)
                            setupForm.TXFilterHigh = tx_filter_high_save;
                    }

                    if (setupForm != null) // ke9ns add: Force UPDATE of ANT Display .119
                    {
                        if (current_model == Model.FLEX5000)
                        {
                            if (fwcAntForm.radModeExpert.Checked)
                            {
                                CurrentAntMode = AntMode.Expert;
                                fwcAntForm.CurrentAntMode = current_ant_mode;
                                fwcAntForm.RX1Ant = rx1_ant;
                                fwcAntForm.RX1Loop = rx1_loop;
                                fwcAntForm.RX2Ant = rx2_ant;
                                fwcAntForm.TXAnt = tx_ant;
                                fwcAntForm.TXAnt2 = tx_ant2; // ke9ns add .205
                            }
                            else CurrentAntMode = AntMode.Simple;
                        }

                    }

                } // if new band (band change)

                //  Debug.WriteLine("HIGH-LOW TXband value " +  tx_band2 + " , " + tx_filter_high + " , " + tx_filter_low + " Rband: " + rx1_band + " Tband: " + tx_band2);


            } // set txband2


        } // TXBand2








        private int tx_filter_low_save = 200;
        private int tx_filter_high_save = 3100;

        // Added 06/24/05 BT for CAT commands
        public bool CATVFOLock
        {
            get { return chkVFOLock.Checked; }
            set { chkVFOLock.Checked = value; }
        }

        public string CATGetVersion()
        {
            Assembly assembly = Assembly.GetExecutingAssembly();
            FileVersionInfo fvi = FileVersionInfo.GetVersionInfo(assembly.Location);
            //			int current_version = VersionTextToInt(fvi.FileVersion);
            return fvi.FileVersion;
        }

        // Added 07/30/05 BT for cat commands next 8 functions

        public string CATReadSigStrength()
        {
            float num = 0f;
            num = DttSP.CalculateRXMeter(0, 0, DttSP.MeterType.SIGNAL_STRENGTH);
            num = num +
                rx1_meter_cal_offset +
                rx1_preamp_offset[(int)rx1_preamp_mode] +
                rx1_filter_size_cal_offset +
                rx1_path_offset +
                rx1_xvtr_gain_offset;
            return num.ToString("f1") + " dBm";
        }

        public string CATReadAvgStrength()
        {
            float num = 0f;
            num = DttSP.CalculateRXMeter(0, 0, DttSP.MeterType.AVG_SIGNAL_STRENGTH);
            num = num +
                rx1_meter_cal_offset +
                rx1_preamp_offset[(int)rx1_preamp_mode] +
                rx1_filter_size_cal_offset +
                rx1_path_offset +
                rx1_xvtr_gain_offset;
            return num.ToString("f1") + " dBm";
        }

        //=======================================================================================
        // ke9ns add
        public int ReadAvgStrength(uint sub) // DttSP.MeterType.AVG_SIGNAL_STRENGTH
        {
            float num = 0f;
            num = DttSP.CalculateRXMeter(0, sub, DttSP.MeterType.AVG_SIGNAL_STRENGTH);
            num = num +
                rx1_meter_cal_offset +
                rx1_preamp_offset[(int)rx1_preamp_mode] +
                rx1_filter_size_cal_offset +
                rx1_path_offset +
                rx1_xvtr_gain_offset;
            return (int)num;
        }

        //=======================================================================================
        // ke9ns add
        public int ReadStrength(uint sub) // DttSP.MeterType.AVG_SIGNAL_STRENGTH
        {
            float num = 0f;
            num = DttSP.CalculateRXMeter(0, sub, DttSP.MeterType.SIGNAL_STRENGTH);
            num = num +
                rx1_meter_cal_offset +
                rx1_preamp_offset[(int)rx1_preamp_mode] +
                rx1_filter_size_cal_offset +
                rx1_path_offset +
                rx1_xvtr_gain_offset;
            return (int)num;

        } // int ReadStrength(uint sub)




        public Mutex WWV_mutex = new Mutex();                // ke9ns add 

        public float[] WWV_data = new float[16384];          // ke9ns add    used to get out_l_ptr1 audio stream in 2048 pieces at a time

        public int WWVframeCount = 0;

        public int WWV_Count = 0;

        public int WWVTone = 0;                             // ke9ns add   Magnetude of the Tone received in audio.cs routine
        public int WWVTone2 = 0;                             // ke9ns add   Magnetude of the Tone received in audio.cs routine

        public bool WWVReady = false;                       // ke9ns add  let you know when a new magnetude is updated
        public Stopwatch WWVST = new Stopwatch();           // ke9ns add 

        //=======================================================================================
        // ke9ns add
        public void ReadScope()      // get dBm value at dead center of current spectrum (defined by LOW / HIGH filters)
        {
            WWV_mutex.WaitOne();

            //  Debug.WriteLine("scopetime" + scope_time);
            fixed (float* ptr = &wwvbuf[0])
            {
                DttSP.GetScope(0, ptr, 2048);  // scope time = 50
            }

            WWV_mutex.ReleaseMutex();


        } //  ReadScope()


        //=======================================================================================
        // ke9ns add
        public int ReadSpectrum()      // get dBm value at dead center of current spectrum (defined by LOW / HIGH filters)
        {
            float[] buf = new float[Display.BUFFER_SIZE];

            float num = 0f;

            WWV_mutex.WaitOne();

            fixed (float* ptr = &buf[0])            // ke9ns prevent garbage collecion from moving this pointer data
            {
                DttSP.GetSpectrum(0, ptr);      // get the spectrum values
            }

            WWV_mutex.ReleaseMutex();

            num = buf[2047]; // get data from middle of spectrum 

            num = num + Display.RX1DisplayCalOffset + Display.RX1PreampOffset;


            return (int)num;

        } //  ReadSpectrum(uint sub) 


        //=======================================================================================
        // ke9ns
        public void ReadPLL(uint c, float* a, float* b)     // 
        {
            DttSP.GetSAMPLLvals(0, c, a, b);            // ke9ns save original a and b values to put back after you getfreq

        }

        //=======================================================================================
        // ke9ns
        public void SetPLL(uint c, float a, float b)        // a=alpha, b=beta
        {

            DttSP.SetSAMPLLvals(0, c, a, b);     // ke9ns 
        }

        //=======================================================================================
        // ke9ns
        public void SetPLL1(uint c, float a, float b)        // a=alpha, b=beta
        {
            float a1 = a * 0.1f;
            float b1 = 0.25f * a1 * a1;            // ke9ns a1 = 10% of original value, b1= 25% of a1^2

            DttSP.SetSAMPLLvals(0, c, a1, b1);     // ke9ns 
        }


        //=======================================================================================
        // ke9ns
        public float ReadPLLFreq(uint c)     // 
        {
            float temp;
            DttSP.GetSAMFreq(0, c, &temp);                   // ke9ns ?? returns a freq matching the SetPLL ?
            return temp;
        }


        //==============================================================
        public string CATReadADC_L()
        {
            float num = 0f;
            num = DttSP.CalculateRXMeter(0, 0, DttSP.MeterType.ADC_REAL);
            return num.ToString("f1") + " dBFS";
        }

        public string CATReadADC_R()
        {
            float num = 0f;
            num = DttSP.CalculateRXMeter(0, 0, DttSP.MeterType.ADC_IMAG);
            return num.ToString("f1") + " dBFS";
        }

        public string CATReadALC()
        {
            float num = 0f;

            if (peak_tx_meter)
                num = (float)Math.Max(-30.0f, -DttSP.CalculateTXMeter(1, DttSP.MeterType.ALC_PK));
            else num = (float)Math.Max(-30.0f, -DttSP.CalculateTXMeter(1, DttSP.MeterType.ALC) + 3.0f);
            return num.ToString("f0") + " dB";
        }

        public string CATReadFwdPwr()
        {
            string ret_val = "";
            double power = 0.0;
            float num = 0f;
            switch (current_model)
            {
                case Model.SDR1000:
                    if (pa_present && VFOAFreq < 30.0)
                    {
                        //pa_power_mutex.WaitOne();
                        power = PAPower(pa_fwd_power);
                        //pa_power_mutex.ReleaseMutex();

                        ret_val = power.ToString("f0") + " W";
                    }
                    else
                    {
                        num = (float)Math.Max(0.0, DttSP.CalculateTXMeter(0, DttSP.MeterType.PWR));
                        num *= (float)((double)ptbPWR.Value * 0.01);
                        ret_val = num.ToString("f2") + " W";
                    }
                    break;
                case Model.FLEX5000:
                case Model.FLEX3000:
                    power = FWCPAPower(pa_fwd_power);
                    ret_val = power.ToString("f0") + " W";
                    break;
                case Model.FLEX1500:
                    num = (float)Math.Max(0.0, DttSP.CalculateTXMeter(0, DttSP.MeterType.PWR));
                    num *= (float)(5.0 * (double)ptbPWR.Value / 70.0);
                    ret_val = num.ToString("f1") + " W";
                    break;
            }

            return ret_val;
        }

        public string CATReadPeakPwr()
        {
            float num = 0f;

            if (pa_present && VFOAFreq < 30.0)
            {
                num = (float)Math.Max(0.0, DttSP.CalculateTXMeter(0, DttSP.MeterType.ALC));
                num *= (float)ptbPWR.Value;

                meter_text_history[meter_text_history_index] = num;
                meter_text_history_index = (meter_text_history_index + 1) % multimeter_text_peak_samples;
                float max = float.MinValue;
                for (int i = 0; i < multimeter_text_peak_samples; i++)
                {
                    if (meter_text_history[i] > max)
                        max = meter_text_history[i];
                }
                num = max;

                return num.ToString("f0") + " W";
            }
            else
            {
                num = (float)Math.Max(0.0, DttSP.CalculateTXMeter(0, DttSP.MeterType.ALC));
                num *= (float)((float)ptbPWR.Value * 0.01);
                return num.ToString("f2") + " W";
            }
        }

        public string CATReadRevPwr()
        {
            double power = 0.0;
            switch (current_model)
            {
                case Model.SDR1000:
                    power = PAPower(pa_rev_power);
                    break;
                case Model.FLEX5000:
                case Model.FLEX3000:
                    power = FWCPAPower(pa_rev_power);
                    break;
                default:
                    power = 0.0;
                    break;
            }

            return power.ToString("f0") + " W";
        }

        public string CATReadSWR()
        {
            double swr = 0.0;

            switch (current_model)
            {
                case Model.SDR1000:
                    swr = SWR(pa_fwd_power, pa_rev_power);
                    break;
                case Model.FLEX5000:
                case Model.FLEX3000:
                    swr = FWCSWR(pa_fwd_power, pa_rev_power);
                    if (swr >= 19) // try 1 more time before displaying SWR
                    {
                        for (int q = 0; q < 5; q++) // ke9ns copy from .184 to .191
                        {
                            Thread.Sleep(10);
                            swr = FWCSWR(pa_fwd_power, pa_rev_power);
                            if (swr < 19) break;
                        } // for loop

                    } // if SWR >=19
                    break;
                default:
                    swr = 0.0;
                    break;
            }

            return swr.ToString("f1") + " : 1";
        }

        //*************end of 8 functions.

        private bool kw_auto_information = false;
        private bool kw_auto_information2 = false; // .214
        private bool kw_auto_information3 = false;
        private bool kw_auto_information4 = false;
        private bool kw_auto_information5 = false;
        private bool kw_auto_information6 = false;
        private bool kw_auto_information7 = false; // for TCP/IP CAT

        public bool KWAI1 = false; // .214  true = CAT port 1 received an CAT command, check if its AI, false = done checking 
        public bool KWAI2 = false; // .214  
        public bool KWAI3 = false; // .214
        public bool KWAI4 = false; // .214
        public bool KWAI5 = false; // .214
        public bool KWAI6 = false; // .214
        public bool KWAI7 = false; // .214
        public string CATURLFREQ = ""; // .215

        public bool KWAutoInformation
        {
            get { return kw_auto_information; }
            set { kw_auto_information = value; }
        }

        public bool KWAutoInformation2 // ke9ns add  .214
        {
            get { return kw_auto_information2; }
            set { kw_auto_information2 = value; }

        } // KWAutoInformation2

        public bool KWAutoInformation3 // ke9ns add  .214
        {
            get { return kw_auto_information3; }
            set { kw_auto_information3 = value; }

        } // KWAutoInformation3

        public bool KWAutoInformation4 // ke9ns add  .214
        {
            get { return kw_auto_information4; }
            set { kw_auto_information4 = value; }

        } // KWAutoInformation4

        public bool KWAutoInformation5 // ke9ns add  .214
        {
            get { return kw_auto_information5; }
            set { kw_auto_information5 = value; }

        } // KWAutoInformation5

        public bool KWAutoInformation6 // ke9ns add  .214
        {
            get { return kw_auto_information6; }
            set { kw_auto_information6 = value; }

        } // KWAutoInformation6

        public bool KWAutoInformation7 // ke9ns add  .214
        {
            get { return kw_auto_information7; }
            set { kw_auto_information7 = value; }

        } // KWAutoInformation7


        #endregion

        public DSPMode RX1DSPMODE = DSPMode.FIRST; // ke9ns add: .196 to allow TXPROFILE to save MODES (will have to programatically select LSB vs USB)
        public DSPMode RX2DSPMODE = DSPMode.FIRST; // ke9ns add: .196

        private DSPMode rx1_dsp_mode = DSPMode.FIRST;
        private DSPMode rx1_dsp_mode_last = DSPMode.FIRST; // ke9ns add

        public DSPMode RX1DSPMode
        {
            get
            {
                RX1DSPMODE = rx1_dsp_mode; // .196
                return rx1_dsp_mode;
            }
            set
            {
                RX1DSPMODE = value; //. .196

                RadioButtonTS r = null;
                switch (value)
                {
                    case DSPMode.LSB:
                        r = radModeLSB;
                        break;
                    case DSPMode.USB:
                        r = radModeUSB;
                        break;
                    case DSPMode.DSB:
                        r = radModeDSB;
                        break;
                    case DSPMode.CWL:
                        r = radModeCWL;
                        break;
                    case DSPMode.CWU:
                        r = radModeCWU;
                        break;
                    case DSPMode.FM:
                        r = radModeFMN;
                        break;
                    case DSPMode.AM:
                        r = radModeAM;
                        break;
                    case DSPMode.SAM:
                        r = radModeSAM;
                        break;
                    case DSPMode.SPEC:
                        r = radModeSPEC;
                        break;
                    case DSPMode.DIGL:
                        r = radModeDIGL;
                        break;
                    case DSPMode.DIGU:
                        r = radModeDIGU;
                        break;
                    case DSPMode.DRM:
                        r = radModeDRM;
                        break;
                }

                r.Checked = true;
            }
        } // RX1DSPMODE

        private DSPMode rx2_dsp_mode = DSPMode.FIRST;
        public DSPMode RX2DSPMode
        {
            get
            {
                RX2DSPMODE = rx2_dsp_mode; // .196    
                return rx2_dsp_mode;
            }
            set
            {
                RX2DSPMODE = value; //. .196

                RadioButtonTS r = null;
                switch (value)
                {
                    case DSPMode.LSB:
                        r = radRX2ModeLSB;
                        break;
                    case DSPMode.USB:
                        r = radRX2ModeUSB;
                        break;
                    case DSPMode.DSB:
                        r = radRX2ModeDSB;
                        break;
                    case DSPMode.CWL:
                        r = radRX2ModeCWL;
                        break;
                    case DSPMode.CWU:
                        r = radRX2ModeCWU;
                        break;
                    case DSPMode.FM:
                        r = radRX2ModeFMN;
                        break;
                    case DSPMode.AM:
                        r = radRX2ModeAM;
                        break;
                    case DSPMode.SAM:
                        r = radRX2ModeSAM;
                        break;
                    case DSPMode.DIGL:
                        r = radRX2ModeDIGL;
                        break;
                    case DSPMode.DIGU:
                        r = radRX2ModeDIGU;
                        break;
                    case DSPMode.DRM:
                        r = radRX2ModeDRM;
                        break;
                }

                r.Checked = true;
            }
        } // RX2DSPMODE

        private Filter rx1_filter = Filter.FIRST;
        public Filter RX1Filter
        {
            get { return rx1_filter; }
            set
            {
                RadioButtonTS r = null;
                switch (value)
                {
                    case Filter.F1:
                        r = radFilter1;
                        break;
                    case Filter.F2:
                        r = radFilter2;
                        break;
                    case Filter.F3:
                        r = radFilter3;
                        break;
                    case Filter.F4:
                        r = radFilter4;
                        break;
                    case Filter.F5:
                        r = radFilter5;
                        break;
                    case Filter.F6:
                        r = radFilter6;
                        break;
                    case Filter.F7:
                        r = radFilter7;
                        break;
                    case Filter.F8:
                        r = radFilter8;
                        break;
                    case Filter.F9:
                        r = radFilter9;
                        break;
                    case Filter.F10:
                        r = radFilter10;
                        break;
                    case Filter.VAR1:
                        r = radFilterVar1;
                        break;
                    case Filter.VAR2:
                        r = radFilterVar2;
                        break;
                    case Filter.NONE:
                        SetRX1Filter(Filter.NONE);
                        break;
                }

                if (r != null)
                {
                    if (r.Checked)
                    {
                        r.Checked = false;
                    }

                    r.Checked = true;
                }
            }
        }


        private Filter rx2_filter = Filter.FIRST;
        public Filter RX2Filter
        {
            get { return rx2_filter; }
            set
            {
                //comboRX2Filter.SelectedIndex = (int)value;
                RadioButtonTS r = null;
                switch (value)
                {
                    case Filter.F1:
                        r = radRX2Filter1;
                        break;
                    case Filter.F2:
                        r = radRX2Filter2;
                        break;
                    case Filter.F3:
                        r = radRX2Filter3;
                        break;
                    case Filter.F4:
                        r = radRX2Filter4;
                        break;
                    case Filter.F5:
                        r = radRX2Filter5;
                        break;
                    case Filter.F6:
                        r = radRX2Filter6;
                        break;
                    case Filter.F7:
                        r = radRX2Filter7;
                        break;
                    case Filter.VAR1:
                        r = radRX2FilterVar1;
                        break;
                    case Filter.VAR2:
                        r = radRX2FilterVar2;
                        break;
                    case Filter.NONE:
                        SetRX2Filter(Filter.NONE);
                        break;
                }

                if (r != null)
                {
                    if (r.Checked)
                    {
                        r.Checked = false;
                    }

                    r.Checked = true;
                }
            }
        }

        private MeterRXMode current_meter_rx_mode = MeterRXMode.SIGNAL_STRENGTH;
        public MeterRXMode CurrentMeterRXMode
        {
            get { return current_meter_rx_mode; }
            set
            {
                string text = "";
                switch (value)
                {
                    case MeterRXMode.SIGNAL_STRENGTH:
                        text = "Signal";
                        break;
                    case MeterRXMode.SIGNAL_AVERAGE:
                        text = "Sig Avg";
                        break;
                    case MeterRXMode.SIGNAL_PEAK: // ke9ns ADD signal peak and hold meter
                        text = "Sig Pk";
                        break;
                    case MeterRXMode.ADC_L:
                        text = "ADC L";
                        break;
                    case MeterRXMode.ADC_R:
                        text = "ADC R";
                        break;
                    case MeterRXMode.ADC2_L:
                        text = "ADC2 L";
                        break;
                    case MeterRXMode.ADC2_R:
                        text = "ADC2 R";
                        break;
                    case MeterRXMode.OFF:   // BT Added 7/24/05 for CAT commands
                        text = "Off";
                        break;
                }

                if (text == "") return;

                comboMeterRXMode.Text = text;
            }
        }

        private MeterRXMode rx2_meter_mode = MeterRXMode.SIGNAL_STRENGTH;
        public MeterRXMode RX2MeterMode
        {
            get { return rx2_meter_mode; }
            set
            {
                string text = "";
                switch (value)
                {
                    case MeterRXMode.SIGNAL_STRENGTH:
                        text = "Signal";
                        break;
                    case MeterRXMode.SIGNAL_AVERAGE:
                        text = "Sig Avg";
                        break;
                    case MeterRXMode.SIGNAL_PEAK: // ke9ns ADD signal peak and hold meter
                        text = "Sig Pk";
                        break;
                    case MeterRXMode.ADC_L:
                        text = "ADC L";
                        break;
                    case MeterRXMode.ADC_R:
                        text = "ADC R";
                        break;
                    case MeterRXMode.ADC2_L:
                        text = "ADC2 L";
                        break;
                    case MeterRXMode.ADC2_R:
                        text = "ADC2 R";
                        break;
                    case MeterRXMode.OFF:   // BT Added 7/24/05 for CAT commands
                        text = "Off";
                        break;
                }

                if (text == "") return;

                comboRX2MeterMode.Text = text;
            }
        } // RX2metermode

        //=====================================================================================================
        // ke9ns for RX1 meter

        private MeterTXMode current_meter_tx_mode = MeterTXMode.FIRST;
        public MeterTXMode CurrentMeterTXMode
        {
            get { return current_meter_tx_mode; }
            set
            {
                string text = "";
                switch (value)
                {
                    case MeterTXMode.FORWARD_POWER:
                        text = "Fwd Pwr";
                        break;
                    case MeterTXMode.REVERSE_POWER:
                        text = "Ref Pwr";
                        break;
                    case MeterTXMode.MIC:
                        text = "Mic";
                        break;
                    case MeterTXMode.EQ:
                        text = "EQ";
                        break;
                    case MeterTXMode.LEVELER:
                        text = "Leveler";
                        break;
                    case MeterTXMode.LVL_G:
                        text = "Lvl Gain";
                        break;
                    case MeterTXMode.CPDR:
                        text = "CPDR";
                        break;
                    case MeterTXMode.ALC:
                        text = "ALC";
                        break;
                    case MeterTXMode.ALC_G:
                        text = "ALC Comp";
                        break;
                    case MeterTXMode.SWR:
                        text = "SWR";
                        break;

                    case MeterTXMode.Combo:
                        text = "Combo"; //ke9ns add
                        break;

                    case MeterTXMode.OFF:       // BT Added 07/24/05 for CAT commands
                        text = "Off";
                        break;
                }
                if (text == "") return;

                comboMeterTXMode.Text = text;
            }

        } //currentmeterTXmode


        //==============================================================================================
        // ke9ns add  for 2nd TX meter function using the RX2 meter movement
        private MeterTXMode current_meter_tx1_mode = MeterTXMode.FIRST;
        public MeterTXMode CurrentMeterTX1Mode
        {
            get { return current_meter_tx1_mode; }
            set
            {
                string text = "";
                switch (value)
                {
                    case MeterTXMode.FORWARD_POWER:
                        text = "Fwd Pwr";
                        break;
                    case MeterTXMode.REVERSE_POWER:
                        text = "Ref Pwr";
                        break;
                    case MeterTXMode.MIC:
                        text = "Mic";
                        break;
                    case MeterTXMode.EQ:
                        text = "EQ";
                        break;
                    case MeterTXMode.LEVELER:
                        text = "Leveler";
                        break;
                    case MeterTXMode.LVL_G:
                        text = "Lvl Gain";
                        break;
                    case MeterTXMode.CPDR:
                        text = "CPDR";
                        break;
                    case MeterTXMode.ALC:
                        text = "ALC";
                        break;
                    case MeterTXMode.ALC_G:
                        text = "ALC Comp";
                        break;
                    case MeterTXMode.SWR:
                        text = "SWR";
                        break;
                    case MeterTXMode.Combo:
                        text = "Combo"; // ke9ns add
                        break;

                    case MeterTXMode.OFF:       // BT Added 07/24/05 for CAT commands
                        text = "Off";
                        break;
                }
                if (text == "") return;

                comboMeterTX1Mode.Text = text;
            }

        } //currentmetertx1mode




        private int cw_pitch = 600;
        public int CWPitch
        {
            get { return cw_pitch; }
            set
            {
                int diff = cw_pitch - value;
                cw_pitch = value;
                //CWSynth.Pitch = value;

                switch (dsp.GetDSPTX(0).CurrentDSPMode)
                {
                    case DSPMode.CWL:
                        CWSynth.Pitch = cw_pitch;
                        break;
                    case DSPMode.CWU:
                        CWSynth.Pitch = -cw_pitch;
                        break;
                }

                Audio.SineFreq1 = cw_pitch;
                udCWPitch.Value = cw_pitch;
                Display.CWPitch = cw_pitch;
                if (fwc_init && (current_model == Model.FLEX5000 || current_model == Model.FLEX3000))
                    FWC.SetCWPitch((uint)cw_pitch);

                for (Filter f = Filter.F1; f < Filter.LAST; f++)
                {
                    int low = rx1_filters[(int)DSPMode.CWL].GetLow(f);
                    int high = rx1_filters[(int)DSPMode.CWL].GetHigh(f);
                    string name = rx1_filters[(int)DSPMode.CWL].GetName(f);

                    int bw = high - low;


                    if (setupForm != null && setupForm.chkOptCWFilterPitch.Checked) // .170
                    {
                        // ke9ns: dont modify (this setting prevents the filter from going around the carrier freq
                        Debug.WriteLine("CWPITCH OFF");

                    }
                    else
                    {
                        low = -cw_pitch - bw / 2;
                        high = -cw_pitch + bw / 2;
                    }

                    rx1_filters[(int)DSPMode.CWL].SetFilter(f, low, high, name);
                    rx2_filters[(int)DSPMode.CWL].SetFilter(f, low, high, name); // n6vl

                    low = rx1_filters[(int)DSPMode.CWU].GetLow(f);
                    high = rx1_filters[(int)DSPMode.CWU].GetHigh(f);
                    name = rx1_filters[(int)DSPMode.CWU].GetName(f);

                    bw = high - low;

                    if (setupForm != null && setupForm.chkOptCWFilterPitch.Checked) // .170
                    {
                        // ke9ns dont modify
                        Debug.WriteLine("CWPITCH OFF");

                    }
                    else
                    {
                        low = cw_pitch - bw / 2;
                        high = cw_pitch + bw / 2;

                    }
                    rx1_filters[(int)DSPMode.CWU].SetFilter(f, low, high, name);
                    rx2_filters[(int)DSPMode.CWU].SetFilter(f, low, high, name); // n6vl
                }

                switch (rx1_dsp_mode)
                {
                    case DSPMode.CWL:
                        diff = -diff;
                        if (mox)
                        {
                            VFOAFreq += (double)diff / 1e6;
                            if (chkVFOSplit.Checked) VFOBFreq += (double)diff / 1e6;
                        }
                        else
                        {
                            txtVFOAFreq_LostFocus(this, EventArgs.Empty);
                            txtVFOBFreq_LostFocus(this, EventArgs.Empty); // n6vl
                        }
                        RX1Filter = rx1_filter;
                        RX2Filter = rx2_filter; // n6vl
                        break;
                    case DSPMode.CWU:
                        if (mox)
                        {
                            VFOAFreq += (double)diff / 1e6;
                            if (chkVFOSplit.Checked) VFOBFreq += (double)diff / 1e6;
                        }
                        else
                        {
                            txtVFOAFreq_LostFocus(this, EventArgs.Empty);
                            txtVFOBFreq_LostFocus(this, EventArgs.Empty); // n6vl
                        }
                        RX1Filter = rx1_filter;
                        RX2Filter = rx2_filter; // n6vl
                        break;
                }
            }
        }

        private int histogram_hang_time = 100;
        public int HistogramHangTime
        {
            get { return histogram_hang_time; }
            set { histogram_hang_time = value; }
        }

        //  string separator = System.Globalization.CultureInfo.CurrentCulture.NumberFormat.NumberDecimalSeparator;


        public double VFOAFreq // output in mhz  7.185 mhz
        {
            get
            {
                try
                {
                    return double.Parse(txtVFOAFreq.Text);
                }
                catch (Exception)
                {
                    Debug.WriteLine("VFOAFreq convert string to double failed " + txtVFOAFreq.Text);
                    
                    return 7.125;
                }
            }
            set
            {
                if (vfo_lock || setupForm == null) return;

                //   UP1 = true; // .251


                if (!this.InvokeRequired)
                {
                    txtVFOAFreq.Text = value.ToString("f6"); //.253
                    txtVFOAFreq_LostFocus(this, EventArgs.Empty);
                }
                else
                {
                    VFOUpdateDel del = new VFOUpdateDel(VFOAUpdate); // ke9ns: does a txtvfoafreq_lostfocus
                    Invoke(del, new object[] { value });
                }

                if (setupForm != null && setupForm.chkBoxHERO.Checked == true)
                {

                    double temp1 = 0;

                    try
                    {
                        temp1 = double.Parse(txtVFOAFreq.Text);
                    }
                    catch (Exception)
                    {
                        Debug.WriteLine("1VFOAFreq convert string to double failed " + txtVFOAFreq.Text);

                    }

                    // ke9ns: this is not part of the HERO, but gives a bit for the band your on in HF mode
                    IIC_Band = 0;

                    if (temp1 != IIC_Last_Freq)
                    {
                        if (temp1 >= 0.135700 && temp1 <= 0.137799) //  0.135700, 0.137799, "2.2kM CW & Narrow Band",   true, // 2200m ham ke9ns change
                            IIC_Band = 1;

                        else if (temp1 >= 0.472000 && temp1 <= 0.478999) //   0.472000, 0.478999, "630M CW/JT9/WSPR/Narrow",    true, // 630m ham ke9ns change
                            IIC_Band = 2;
                        else if (temp1 >= 1.8 && temp1 <= 2.0) //  160m
                            IIC_Band = 4;
                        else if (temp1 >= 3.5 && temp1 <= 4.0) //  80m
                            IIC_Band = 8;
                        else if (temp1 >= 5.3 && temp1 <= 5.6) //  60m
                            IIC_Band = 16;
                        else if (temp1 >= 7.0 && temp1 <= 7.3) //  40m
                            IIC_Band = 32;
                        else if (temp1 >= 10.1 && temp1 <= 10.15) //  30m
                            IIC_Band = 64;
                        else if (temp1 >= 14.0 && temp1 <= 14.35) //  20m
                            IIC_Band = 128;
                        else if (temp1 >= 18.068 && temp1 <= 18.168) //  17m
                            IIC_Band = 256;
                        else if (temp1 >= 21.0 && temp1 <= 21.45) //  15m
                            IIC_Band = 512;
                        else if (temp1 >= 24.89 && temp1 <= 24.99) //  12m
                            IIC_Band = 1024;
                        else if (temp1 >= 28.0 && temp1 <= 30.0) //  10m
                            IIC_Band = 2048;
                        else if (temp1 >= 50.00 && temp1 <= 54.0) //  6m
                            IIC_Band = 4096;
                        else IIC_Band = 8192;

                        if (IIC_Band_Last != IIC_Band) IIC_HEROCONTROL(HEROBAND);


                        IIC_Last_Freq = temp1;
                    }
                }

                if (ESCSYNC == true && VFOSync == false && FWCEEPROM.RX2OK) picRadar.Invalidate(); //.246 .249

            } //set


        } // VFOAFreq

        public bool UP1 = false; // ke9ns add .251 RX1 vfo freq change true = UpdateRX1DDSFreq done
        public bool UP2 = false; // ke9ns add .251 RX2 vfo freq change = true

        private delegate void VFOUpdateDel(double freq);
        private void VFOAUpdate(double freq)
        {


            txtVFOAFreq.Text = freq.ToString("f6"); // fixed point with 6 digits
            
            txtVFOAFreq_LostFocus(this, EventArgs.Empty);

            double temp1 = 0;

            temp1 = freq;

            // ke9ns: this is not part of the HERO, but gives a bit for the band your on in HF mode
            IIC_Band = 0;

            if (temp1 != IIC_Last_Freq)
            {
                if (temp1 >= 0.135700 && temp1 <= 0.137799) //  0.135700, 0.137799, "2.2kM CW & Narrow Band",   true, // 2200m ham ke9ns change
                    IIC_Band = 1;

                else if (temp1 >= 0.472000 && temp1 <= 0.478999) //   0.472000, 0.478999, "630M CW/JT9/WSPR/Narrow",    true, // 630m ham ke9ns change
                    IIC_Band = 2;
                else if (temp1 >= 1.8 && temp1 <= 2.0) //  160m
                    IIC_Band = 4;
                else if (temp1 >= 3.5 && temp1 <= 4.0) //  80m
                    IIC_Band = 8;
                else if (temp1 >= 5.3 && temp1 <= 5.6) //  60m
                    IIC_Band = 16;
                else if (temp1 >= 7.0 && temp1 <= 7.3) //  40m
                    IIC_Band = 32;
                else if (temp1 >= 10.1 && temp1 <= 10.15) //  30m
                    IIC_Band = 64;
                else if (temp1 >= 14.0 && temp1 <= 14.35) //  20m
                    IIC_Band = 128;
                else if (temp1 >= 18.068 && temp1 <= 18.168) //  17m
                    IIC_Band = 256;
                else if (temp1 >= 21.0 && temp1 <= 21.45) //  15m
                    IIC_Band = 512;
                else if (temp1 >= 24.89 && temp1 <= 24.99) //  12m
                    IIC_Band = 1024;
                else if (temp1 >= 28.0 && temp1 <= 30.0) //  10m
                    IIC_Band = 2048;
                else if (temp1 >= 50.00 && temp1 <= 54.0) //  6m
                    IIC_Band = 4096;
                else IIC_Band = 8192;

                if (IIC_Band_Last != IIC_Band) IIC_HEROCONTROL(HEROBAND);

                IIC_Last_Freq = temp1;
            }


        } // VFOAUpdate(double freq)

        public double VFOASubFreq
        {
            get
            {
                if (!rx2_enabled || (!chkEnableMultiRX.Checked && !chkVFOSplit.Checked)) return -999.999;
                try
                {
                    return double.Parse(txtVFOABand.Text);
                }
                catch (Exception)
                {
                    return -999.999;
                }
            }

            set
            {
                if (vfo_lock || setupForm == null) return;
                txtVFOABand.Text = value.ToString("f6" );
                txtVFOABand_LostFocus(this, EventArgs.Empty);
            }
        }

        public double VFOBFreq
        {
            get
            {
                try
                {
                    return double.Parse(txtVFOBFreq.Text);
                }
                catch (Exception)
                {
                    return 0;
                }
            }
            set
            {
                if (vfo_lockB || setupForm == null) return;

                value = Math.Max(0, value);
                txtVFOBFreq.Text = value.ToString("f6" );
                txtVFOBFreq_LostFocus(this, EventArgs.Empty);

                if (ESCSYNC == true && VFOSync == false && FWCEEPROM.RX2OK) picRadar.Invalidate(); //.246 .249
            }

        }

        public int PWR
        {
            get { return ptbPWR.Value; }
            set
            {
                value = Math.Max(0, value);         // lower bound

                if (setupForm != null) value = Math.Min((int)setupForm.udTXDriveMax.Value, value);       // upper bound ke9ns drive max
                else value = Math.Min(100, value);       // upper bound

                ptbPWR.Value = value;
                ptbPWR_Scroll(this, EventArgs.Empty);
            }
        }


        public int AF
        {
            get
            {

                return ptbAF.Value;
            }
            set
            {
                value = Math.Max(0, value);         // lower bound
                value = Math.Min(100, value);       // upper bound


                ptbAF.Value = value;
                ptbAF_Scroll(this, EventArgs.Empty);
            }
        }


        private int rxaf = 50;
        public int RXAF                  // ke9ns used to keep the last value of the AF to put back after unkeying the flex radio
        {
            get { return rxaf; }
            set { rxaf = value; }
        }


        private int txaf = 50;
        public int TXAF
        {
            get { return txaf; }
            set
            {
                txaf = value;

                ptbMON.Value = txaf; // ke9ns add
                lblMON.Text = "MON: " + ptbMON.Value.ToString(); // ke9ns add


                if (setupForm != null)
                {
                    setupForm.TXAF = txaf;

                    if ((mox) && ((chkMON.Checked == true) || (ckQuickPlay.Checked == true)))// && ((setupForm.chkRX2AutoMuteRX2OnVFOATX.Checked == true && setupForm.chkRX2AutoMuteRX1OnVFOBTX.Checked == true)))  // ke9ns add    (dont go into MON if in full duplex mode, leave as AF)
                    {
                        ptbAF.Value = txaf;


                    }
                }
            }
        }

        public bool DisplayAVG
        {
            get { return chkDisplayAVG.Checked; }
            set { chkDisplayAVG.Checked = value; }
        }

        public bool RX2DisplayAVG
        {
            get { return chkRX2DisplayAVG.Checked; }
            set { chkRX2DisplayAVG.Checked = value; }
        }

        private double break_in_delay = 300;
        public double BreakInDelay
        {
            get { return break_in_delay; }
            set
            {
                break_in_delay = value;
                udCWBreakInDelay.Value = (int)value;
            }
        }

        private bool cat_ptt = false;
        public bool CATPTT
        {
            get { return cat_ptt; }
            set { cat_ptt = value; }
        }

        private bool cw_auto_mode_switch = false;
        public bool CWAutoModeSwitch //  ke9ns: from setupform 
        {
            get { return cw_auto_mode_switch; }
            set { cw_auto_mode_switch = value; }
        }

        private DSPMode saved_cw_auto_switch_dsp_mode = DSPMode.FIRST;
        private void SetConsoleMox(bool b)  // ke9ns: called by a PTT of the CW key
        {
            if (disable_ptt && b) return;

            DSPMode tx_mode = dsp.GetDSPTX(0).CurrentDSPMode;

            if (cw_auto_mode_switch) // ke9ns: determined if your in AUTO mode change or not
            {
                CWAutoSwitchMode(b, tx_mode); // force a mode change
            }
            else
            {
                switch (tx_mode)
                {
                    case DSPMode.CWL:
                    case DSPMode.CWU:
                        MOX = b;
                        break;
                }
            }
        }

        private void CWAutoSwitchMode(bool b, DSPMode tx_mode)
        {
            if (b) // ke9ns: b true = auto switch mode is ON
            {
                if (saved_cw_auto_switch_dsp_mode != tx_mode) saved_cw_auto_switch_dsp_mode = tx_mode;

                switch (tx_mode)
                {
                    case DSPMode.CWL:
                    case DSPMode.CWU:
                        break; // do nothing (your already in CW mode)
                    case DSPMode.LSB:
                    case DSPMode.DIGL:
                        if (current_model == Model.FLEX5000 && FWCEEPROM.RX2OK && rx2_enabled && chkVFOBTX.Checked)
                        {
                            Invoke(new MethodInvoker(radRX2ModeCWL.Select)); // switch RX2 to CWL mode
                        }
                        else
                        {
                            Invoke(new MethodInvoker(radModeCWL.Select)); // switch RX1 to CWL mode
                                                                          //  radModeCWL.Checked = true;

                        }
                        break;
                    case DSPMode.USB:
                    case DSPMode.DIGU:
                    case DSPMode.AM:
                    case DSPMode.SAM:
                    case DSPMode.FM:
                    case DSPMode.DSB:
                    case DSPMode.DRM:
                        if (current_model == Model.FLEX5000 && FWCEEPROM.RX2OK && rx2_enabled && chkVFOBTX.Checked)
                        {
                            Invoke(new MethodInvoker(radRX2ModeCWU.Select)); // switch RX2 to CWU mode    
                        }
                        else
                        {
                            Invoke(new MethodInvoker(radModeCWU.Select)); // switch RX1 to CWU mode
                                                                          //  radModeCWU.Checked = true;

                        }
                        break;
                }

                MOX = true;
            }
            else
            {
                MOX = false;
                switch (saved_cw_auto_switch_dsp_mode)
                {
                    case DSPMode.CWL:
                    case DSPMode.CWU:
                        break; // do nothing
                    default:
                        RadioButtonTS rad = null;
                        bool rx2 = (current_model == Model.FLEX5000 && FWCEEPROM.RX2OK && rx2_enabled && chkVFOBTX.Checked);
                        switch (saved_cw_auto_switch_dsp_mode)
                        {
                            case DSPMode.LSB:
                                if (rx2) rad = radRX2ModeLSB;
                                else rad = radModeLSB;
                                break;
                            case DSPMode.USB:
                                if (rx2) rad = radRX2ModeUSB;
                                else rad = radModeUSB;
                                break;
                            case DSPMode.DSB:
                                if (rx2) rad = radRX2ModeDSB;
                                else rad = radModeDSB;
                                break;
                            case DSPMode.FM:
                                if (rx2) rad = radRX2ModeFMN;
                                else rad = radModeFMN;
                                break;
                            case DSPMode.AM:
                                if (rx2) rad = radRX2ModeAM;
                                else rad = radModeAM;
                                break;
                            case DSPMode.SAM:
                                if (rx2) rad = radRX2ModeSAM;
                                else rad = radModeSAM;
                                break;
                            case DSPMode.DIGL:
                                if (rx2) rad = radRX2ModeDIGL;
                                else rad = radModeDIGL;
                                break;
                            case DSPMode.DIGU:
                                if (rx2) rad = radRX2ModeDIGU;
                                else rad = radModeDIGU;
                                break;
                            case DSPMode.DRM:
                                if (rx2) rad = radRX2ModeDRM;
                                else rad = radModeDRM;
                                break;
                        }

                        if (rad != null)
                            Invoke(new MethodInvoker(rad.Select));
                        break;
                }
            }
        }

        private void SetTRMute(bool b)
        {
            if (!b) // RX
            {
                switch (dsp.GetDSPTX(0).CurrentDSPMode)
                {
                    case DSPMode.CWL:
                    case DSPMode.CWU:
                        Audio.MuteOutput = false;
                        break;
                    default:
                        USBHID.WriteI2C2Value(0x30, 0x25, 0xC0);
                        break;
                }
            }
            else // TX
            {
                USBHID.WriteI2C2Value(0x30, 0x25, 0xC0);
            }
        }

        public bool MOX
        {
            get
            {
                return chkMOX.Checked;
            }
            set
            {

                chkMOX.Checked = value;
            }

        }

        public bool MOXEnabled
        {
            get { return chkMOX.Enabled; }
            set { chkMOX.Enabled = value; }
        }

        private bool monback = false;
        public bool MON
        {
            get
            {
                monback = chkMON.Checked;
                return chkMON.Checked;
            }
            set { chkMON.Checked = value; }
        }

        public byte MONINIT // ke9ns add
        {
            get { return moninit; }
            set { moninit = value; }
        }
        public bool MUT
        {
            get { return chkMUT.Checked; }

            set
            {

                chkMUT.Checked = value;


                if (chkMUT.Checked) // ke9ns add
                {
                    chkMUT.BackColor = button_selected_color;
                }
                else
                {
                    chkMUT.BackColor = SystemColors.Control;
                }
            }
        }

        public bool MUT2
        {
            get { return chkRX2Mute.Checked; }
            set { chkRX2Mute.Checked = value; }
        }

        public bool TUN
        {
            get { return chkTUN.Checked; }
            set { chkTUN.Checked = value; }
        }

        public bool TUNEnabled
        {
            get { return chkTUN.Enabled; }
            set { chkTUN.Enabled = value; }
        }

        public int RX1FilterLow
        {
            get { return (int)udFilterLow.Value; }
            set { udFilterLow.Value = value; }
        }

        public int RX1FilterHigh
        {
            get { return (int)udFilterHigh.Value; }
            set { udFilterHigh.Value = value; }
        }

        public int RX2FilterLow
        {
            get { return (int)udRX2FilterLow.Value; }
            set { udRX2FilterLow.Value = value; }
        }

        public int RX2FilterHigh
        {
            get { return (int)udRX2FilterHigh.Value; }
            set { udRX2FilterHigh.Value = value; }
        }

        public int FilterShiftValue
        {
            get { return ptbFilterShift.Value; }
            set { ptbFilterShift.Value = value; }
        }

        private PreampMode rx2_preamp_mode = PreampMode.HIGH;
        public PreampMode RX2PreampMode
        {
            get { return rx2_preamp_mode; }
            set
            {
                if (!fwc_init || current_model != Model.FLEX5000) return;

                rx2_preamp_mode = value;

                if (initializing) return;

                //   Debug.WriteLine("RX2PREAMP mode " + value);


                switch (rx2_preamp_mode)
                {
                    case PreampMode.OFF:
                        FWCRX2Preamp = false;
                        chkRX2Preamp.Checked = false;
                        break;
                    case PreampMode.HIGH:
                        FWCRX2Preamp = true;
                        //   chkRX2Preamp.Checked = true; // ke9ns mod .205 remove
                        break;
                }

                SetWBIRRX2Mu();  // tell DSP about the premap amount

                Display.RX2PreampOffset = rx2_preamp_offset[(int)rx2_preamp_mode];

                //  Debug.WriteLine("preamp rx2 " + rx2_preamp_mode);  // ke9ns rx2 preamp issue  pos 14 when it should be -14
                // Debug.WriteLine("offset " + Display.RX2PreampOffset);

                if (chkRX2Squelch.Checked)
                    ptbRX2Squelch_Scroll(this, EventArgs.Empty);
            } // set

        } // rx2preampmode




        public int PREAMP_G = 0; // ke9ns add for AGCT line on pan feature add
        public int LPF_G = 0; // ke9ns add for AGCT line on pan feature add


        private PreampMode rx1_preamp_mode = PreampMode.HIGH;
        public PreampMode RX1PreampMode
        {
            get { return rx1_preamp_mode; }
            set
            {
                rx1_preamp_mode = value;
                if (initializing) return;
                switch (current_model)
                {
                    case Model.FLEX5000:
                        if (!fwc_init) return;
                        switch (rx1_preamp_mode)
                        {
                            case PreampMode.OFF:
                            case PreampMode.LOW:
                                FWCRX1Preamp = false;
                                chkRX1Preamp.Checked = false;
                                PREAMP_G = 0; // ke9ns dB

                                break;
                            case PreampMode.MED:
                            case PreampMode.HIGH:
                                FWCRX1Preamp = true;
                                chkRX1Preamp.Checked = true;
                                PREAMP_G = 26; // ke9ns dB
                                break;
                        }
                        break;
                    case Model.FLEX3000:
                        if (!fwc_init) return;
                        switch (rx1_preamp_mode)
                        {
                            case PreampMode.OFF: // -20dB
                                FWCRX1Preamp = false;
                                FWCRX1Attn = true;

                                PREAMP_G = -20; // ke9ns dB
                                break;
                            case PreampMode.LOW: // 0dB
                                FWCRX1Preamp = false;
                                FWCRX1Attn = false;
                                PREAMP_G = 0; // ke9ns dB
                                break;
                            case PreampMode.MED: // +12 dB?
                                FWCRX1Preamp = true;
                                FWCRX1Attn = true;
                                PREAMP_G = 12; // ke9ns dB
                                break;
                            case PreampMode.HIGH: // +26dB
                                FWCRX1Preamp = true;
                                FWCRX1Attn = false;

                                PREAMP_G = 26; // ke9ns dB
                                break;
                        }
                        break;
                    case Model.FLEX1500:
                        if (!hid_init) return;
                        USBHID.SetPreamp((FLEX1500PreampMode)rx1_preamp_mode);

                        if (rx1_preamp_mode == 0) PREAMP_G = -10; // ke9ns dB
                        else if (rx1_preamp_mode == 0) PREAMP_G = 0; // ke9ns dB
                        else if (rx1_preamp_mode == 0) PREAMP_G = 10; // ke9ns dB
                        else if (rx1_preamp_mode == 0) PREAMP_G = 20; // ke9ns dB
                        else if (rx1_preamp_mode == 0) PREAMP_G = 30; // ke9ns dB
                        else PREAMP_G = 0; // ke9ns dB

                        break;
                    case Model.SDR1000:
                        switch (rx1_preamp_mode)
                        {
                            case PreampMode.OFF:
                                Hdw.Attn = true;
                                Hdw.GainRelay = true;   // 0dB
                                PREAMP_G = 0; // ke9ns dB
                                break;
                            case PreampMode.LOW:
                                Hdw.Attn = false;
                                Hdw.GainRelay = true;   // +6dB
                                PREAMP_G = 6; // ke9ns dB
                                break;
                            case PreampMode.MED:
                                Hdw.Attn = true;
                                Hdw.GainRelay = false;	// 26dB
                                PREAMP_G = 26; // ke9ns dB
                                break;
                            case PreampMode.HIGH:
                                Hdw.Attn = false;
                                Hdw.GainRelay = false;
                                PREAMP_G = 30; // ke9ns dB
                                break;
                        }
                        break;
                }

                Debug.WriteLine("PREAMP_G " + PREAMP_G);

                switch (current_model)
                {
                    case Model.FLEX5000: // do nothing here -- handled above
                        break;
                    case Model.FLEX3000:
                        switch (rx1_preamp_mode)
                        {
                            case PreampMode.OFF:
                                comboPreamp.Text = "Attn";
                                break;
                            case PreampMode.LOW:
                                comboPreamp.Text = "Off";
                                break;
                            case PreampMode.MED:
                                comboPreamp.Text = "Pre1";
                                break;
                            case PreampMode.HIGH:
                                comboPreamp.Text = "Pre2";
                                break;
                        }
                        break;
                    case Model.FLEX1500:
                        switch ((FLEX1500PreampMode)rx1_preamp_mode)
                        {
                            case FLEX1500PreampMode.MINUS_10:
                                comboPreamp.Text = "-10";
                                break;
                            case FLEX1500PreampMode.ZERO:
                                comboPreamp.Text = "  0";
                                break;
                            case FLEX1500PreampMode.PLUS_10:
                                comboPreamp.Text = "+10";
                                break;
                            case FLEX1500PreampMode.PLUS_20:
                                comboPreamp.Text = "+20";
                                break;
                            case FLEX1500PreampMode.PLUS_30:
                                comboPreamp.Text = "+30";
                                break;
                        }
                        break;
                    default:
                        switch (rx1_preamp_mode)
                        {
                            case PreampMode.OFF:
                                comboPreamp.Text = "Off";
                                break;
                            case PreampMode.LOW:
                                comboPreamp.Text = "Low";
                                break;
                            case PreampMode.MED:
                                comboPreamp.Text = "Med";
                                break;
                            case PreampMode.HIGH:
                                comboPreamp.Text = "High";
                                break;
                        }
                        break;
                }

                SetWBIRRX1Mu();

                Display.RX1PreampOffset = rx1_preamp_offset[(int)rx1_preamp_mode];

                if (chkSquelch.Checked)
                    ptbSquelch_Scroll(this, EventArgs.Empty);

                //Debug.WriteLine("RX1PreampMode: " + rx1_preamp_mode);
            }
        }

        public int Squelch
        {
            get { return ptbSquelch.Value; }
            set
            {
                ptbSquelch.Value = value;
                if (chkSquelch.Checked)
                    ptbSquelch_Scroll(this, EventArgs.Empty);
            }
        }

        public int Squelch2
        {
            get
            {
                if (FWCEEPROM.RX2OK)
                    return ptbRX2Squelch.Value;
                else
                    return -1;
            }
            set
            {
                if (FWCEEPROM.RX2OK)
                {
                    ptbRX2Squelch.Value = value;
                    if (chkRX2Squelch.Checked)
                        ptbRX2Squelch_Scroll(this, EventArgs.Empty);
                }
            }
        }


        public int Zoom // CAT commands come here
        {
            get { return ptbDisplayZoom.Value; }
            set
            {
                ptbDisplayZoom.Value = value;
                ptbDisplayZoom_Scroll(this, EventArgs.Empty);
            }
        } // Zoom

        public int Zoom2 // CAT commands come here (.221 add RX2)
        {
            get { return ptbDisplayZoom2.Value; }
            set
            {
                ptbDisplayZoom2.Value = value;
                ptbDisplayZoom_Scroll(this, EventArgs.Empty);
            }
        } // Zoom2
        public int Pan
        {
            get { return ptbDisplayPan.Value; }
            set
            {
                ptbDisplayPan.Value = value;
                ptbDisplayPan_Scroll(this, EventArgs.Empty);
            }
        } //Pan

        public int Pan2 // .221 add RX2
        {
            get { return ptbDisplayPan2.Value; }
            set
            {
                ptbDisplayPan2.Value = value;
                ptbDisplayPan2_Scroll(this, EventArgs.Empty);
            }
        } // Pan2

        public AGCMode RX1AGCMode
        {
            get { return (AGCMode)comboAGC.SelectedIndex; }
            set { comboAGC.SelectedIndex = (int)value; }
        }

        public AGCMode RX2AGCMode
        {
            get
            {
                if (!fwc_init || current_model != Model.FLEX5000) return AGCMode.FIRST;
                return (AGCMode)comboRX2AGC.SelectedIndex;
            }
            set
            {
                if (!fwc_init || current_model != Model.FLEX5000) return;
                comboRX2AGC.SelectedIndex = (int)value;
            }
        }

        public bool VFOSplit
        {
            get { return chkVFOSplit.Checked; }
            set { chkVFOSplit.Checked = value; }
        }

        public bool RIT
        {
            get { return chkRIT.Checked; }
            set { chkRIT.Checked = value; }
        }

        public bool RITOn
        {
            get { return chkRIT.Checked; }
            set { chkRIT.Checked = value; }
        }

        public int RITValue
        {
            get { return (int)udRIT.Value; }
            set
            {
                int n = 0;
                if (value <= 0)
                    n = Math.Max(-99999, value);
                else
                    n = Math.Min(99999, value);
                udRIT.Value = n;
            }
        }

        public bool XITOn
        {
            get { return chkXIT.Checked; }
            set { chkXIT.Checked = value; }
        }

        public int XITValue
        {
            get { return (int)udXIT.Value; }
            set { udXIT.Value = value; }
        }

        private int tx_filter_high = 3100;
        public int TXFilterHigh
        {
            get { return tx_filter_high; }
            set
            {
                tx_filter_high = value;

                //   Debug.WriteLine("TXH HIGH-LOW: " + tx_filter_low + " , " + tx_filter_high + " mode: " + rx1_dsp_mode + " band: " + rx1_band + " Tband: " + tx_band);
                SetTXFilters(rx1_dsp_mode, tx_filter_low, tx_filter_high);

                if (Display.DrawTXFilter && !chkPower.Checked)
                {
                    switch (Display.CurrentDisplayMode)
                    {
                        case DisplayMode.PANADAPTER:
                        case DisplayMode.SPECTRUM:
                        case DisplayMode.HISTOGRAM:
                        case DisplayMode.WATERFALL:
                        case DisplayMode.PANAFALL:
                        case DisplayMode.PANASCOPE:
                            Display.DrawBackground();
                            break;
                    }
                }
            }
        }

        private int tx_filter_low = 200;
        public int TXFilterLow
        {
            get { return tx_filter_low; }
            set
            {
                tx_filter_low = value;

                //   Debug.WriteLine("TXL HIGH-LOW: " + tx_filter_high + " , " + tx_filter_low + " mode: " + rx1_dsp_mode + " band: " + rx1_band + " Tband: " + tx_band);
                SetTXFilters(rx1_dsp_mode, tx_filter_low, tx_filter_high);

                if (Display.DrawTXFilter && !chkPower.Checked)
                {
                    switch (Display.CurrentDisplayMode)
                    {
                        case DisplayMode.PANADAPTER:
                        case DisplayMode.SPECTRUM:
                        case DisplayMode.HISTOGRAM:
                        case DisplayMode.WATERFALL:
                        case DisplayMode.PANAFALL:
                        case DisplayMode.PANASCOPE:
                            Display.DrawBackground();
                            break;
                    }
                }
            }
        }

        private delegate void SetTimerDel(System.Windows.Forms.Timer t, bool enable);
        private void SetTimer(System.Windows.Forms.Timer t, bool enable)
        {
            t.Enabled = enable;
        }

        private bool high_swr = false;
        public bool HighSWR
        {
            get { return high_swr; }
            set
            {
                high_swr = value;
                Display.HighSWR = value;
                //Display.DrawBackground();
            }
        }

        private bool disable_ptt = false;
        public bool DisablePTT
        {
            get { return disable_ptt; }
            set { disable_ptt = value; }
        }

        public bool PowerOn
        {
            get
            {
                return chkPower.Checked;
            }
            set
            {

                chkPower.Checked = value;
            }
        }

        public bool PowerEnabled
        {
            get { return chkPower.Enabled; }
            set { chkPower.Enabled = value; }
        }

        private bool second_sound_card_stereo = false;
        public bool SecondSoundCardStereo
        {
            get { return second_sound_card_stereo; }
            set
            {
                second_sound_card_stereo = value;
                Audio.VACStereo = value;
            }
        }

        // w4tme
        private bool third_sound_card_stereo = false;
        public bool ThirdSoundCardStereo
        {
            get { return third_sound_card_stereo; }
            set
            {
                third_sound_card_stereo = value;
                Audio.VAC2Stereo = value;
            }
        }

        private bool vac_enabled = false;
        public bool VACEnabled
        {
            get { return vac_enabled; }
            set
            {
                vac_enabled = value;
                Audio.VACEnabled = value;
                if (chkVAC1 != null) chkVAC1.Checked = value;
            }
        }

        private bool vac_enabledB = false; // .204
        public bool VACEnabledB
        {
            get { return vac_enabledB; }
            set
            {
                vac_enabledB = value;
                Audio.VACEnabled = value;
                if (chkVAC1 != null) chkVAC1.Checked = value;
            }
        }

        private bool vac2_enabled = false;
        public bool VAC2Enabled // called by setup.cs
        {
            get { return vac2_enabled; }
            set
            {
                // if ((current_model == Model.FLEX5000 && FWCEEPROM.RX2OK) )   // ke9ns mod to allow all models to use VAC2
                //  {
                vac2_enabled = value;
                Audio.VAC2Enabled = value;
                if (chkVAC2 != null) chkVAC2.Checked = value;
                //  }
            }
        }

        private int audio_driver_index1 = 0;
        public int AudioDriverIndex1
        {
            get { return audio_driver_index1; }
            set { audio_driver_index1 = value; }
        }

        private int audio_driver_index2 = 0;
        public int AudioDriverIndex2
        {
            get { return audio_driver_index2; }
            set { audio_driver_index2 = value; }
        }

        private int audio_driver_index3 = 0;
        public int AudioDriverIndex3
        {
            get { return audio_driver_index3; }
            set { audio_driver_index3 = value; }
        }

        private int audio_input_index1 = 0;
        public int AudioInputIndex1
        {
            get { return audio_input_index1; }
            set { audio_input_index1 = value; }
        }

        private int audio_input_index2 = 0;
        public int AudioInputIndex2
        {
            get { return audio_input_index2; }
            set { audio_input_index2 = value; }
        }

        private int audio_input_index3 = 0;
        public int AudioInputIndex3
        {
            get { return audio_input_index3; }
            set { audio_input_index3 = value; }
        }

        private int audio_output_index1 = 0;
        public int AudioOutputIndex1
        {
            get { return audio_output_index1; }
            set { audio_output_index1 = value; }
        }

        private int audio_output_index2 = 0;
        public int AudioOutputIndex2
        {
            get { return audio_output_index2; }
            set { audio_output_index2 = value; }
        }

        private int audio_output_index3 = 0;
        public int AudioOutputIndex3
        {
            get { return audio_output_index3; }
            set { audio_output_index3 = value; }
        }

        private double audio_volts1 = 2.23;
        public double AudioVolts1
        {
            get { return audio_volts1; }
            set
            {
                audio_volts1 = value;
                Audio.AudioVolts1 = audio_volts1;
                ptbPWR_Scroll(this, EventArgs.Empty);
            }
        }

        private int mixer_id1 = 0;
        public int MixerID1
        {
            get { return mixer_id1; }
            set { mixer_id1 = value; }
        }

        private int mixer_id2 = 0;
        public int MixerID2
        {
            get { return mixer_id2; }
            set { mixer_id2 = value; }
        }

        private int mixer_rx_mux_id1 = 0;
        public int MixerRXMuxID1
        {
            get { return mixer_rx_mux_id1; }
            set { mixer_rx_mux_id1 = value; }
        }

        private int mixer_tx_mux_id1 = 0;
        public int MixerTXMuxID1
        {
            get { return mixer_tx_mux_id1; }
            set { mixer_tx_mux_id1 = value; }
        }

        private int mixer_rx_mux_id2 = 0;
        public int MixerRXMuxID2
        {
            get { return mixer_rx_mux_id2; }
            set { mixer_rx_mux_id2 = value; }
        }

        private int mixer_tx_mux_id2 = 0;
        public int MixerTXMuxID2
        {
            get { return mixer_tx_mux_id2; }
            set { mixer_tx_mux_id2 = value; }
        }

        private int sample_rate1 = 48000;
        public int SampleRate1         //ke9ns used only by wave.cs
        {
            get { return sample_rate1; }
            set
            {
                sample_rate1 = value;
                DSP.SampleRate = value;
                Audio.SampleRate1 = value;
                Display.SampleRate = value;
                CWSynth.SampleRate = value;
                switch (rx1_dsp_mode)
                {
                    case DSPMode.SPEC:
                        SetRX1Mode(DSPMode.SPEC);
                        break;
                }

                switch (Display.CurrentDisplayMode)
                {
                    case DisplayMode.PANADAPTER:
                    case DisplayMode.WATERFALL:
                    case DisplayMode.PANAFALL:
                    case DisplayMode.PANASCOPE:

                        if (CTUN == false) CalcDisplayFreq(); // ke9ns mod
                        btnDisplayPanCenter.PerformClick();
                        break;
                }
            }
        } // SampleRate1

        private int sample_rate2 = 48000;
        public int SampleRate2
        {
            get { return sample_rate2; }
            set
            {
                sample_rate2 = value;
                Audio.SampleRate2 = value;
            }
        }

        private int sample_rate3 = 48000;
        public int SampleRate3
        {
            get { return sample_rate3; }
            set
            {
                sample_rate3 = value;
                Audio.SampleRate3 = value;
            }
        }

        private int num_channels = 2;
        public int NumChannels
        {
            get { return num_channels; }
            set { num_channels = value; }
        }

        private int block_size1;
        public int BlockSize1
        {
            get { return block_size1; }
            set
            {
                block_size1 = value;
                Audio.BlockSize = value;
                dsp.GetDSPRX(0, 0).AudioSize = value;
            }
        }

        private int block_size2;
        public int BlockSize2
        {
            get { return block_size2; }
            set
            {
                block_size2 = value;
                Audio.BlockSizeVAC = value;
            }
        }

        private int block_size3;
        public int BlockSize3
        {
            get { return block_size3; }
            set
            {
                block_size3 = value;
                Audio.BlockSizeVAC2 = value;
            }
        }

        private int peak_text_delay = 500;
        public int PeakTextDelay
        {
            get { return peak_text_delay; }
            set
            {
                peak_text_delay = value;
                timer_peak_text.Interval = value;
            }
        }

        private int meter_delay = 100;
        public int MeterDelay
        {
            get { return meter_delay; }
            set
            {
                meter_delay = value;
                MultimeterPeakHoldTime = MultimeterPeakHoldTime;
            }
        }

        private int meter_dig_delay = 500;
        public int MeterDigDelay
        {
            get { return meter_dig_delay; }
            set { meter_dig_delay = value; }
        }

        private int cpu_meter_delay = 1000;
        public int CPUMeterDelay
        {
            get { return cpu_meter_delay; }
            set
            {
                cpu_meter_delay = value;
                timer_cpu_meter.Interval = value;
            }
        }

        private int display_fps = 15;
        private int display_delay = 1000 / 15;
        public int DisplayFPS
        {
            get { return display_fps; }
            set
            {
                display_fps = value;
                display_delay = 1000 / display_fps;
            }
        }

        private int multimeter_peak_hold_time = 1000;
        private int multimeter_peak_hold_samples = 10;
        public int MultimeterPeakHoldTime
        {
            get { return multimeter_peak_hold_time; }
            set
            {
                multimeter_peak_hold_time = value;
                multimeter_peak_hold_samples = value / meter_delay;
            }
        }

        private int multimeter_text_peak_time = 500;
        private int multimeter_text_peak_samples = 5;
        public int MultimeterTextPeakTime
        {
            get { return multimeter_text_peak_time; }
            set
            {
                multimeter_text_peak_time = value;
                multimeter_text_peak_samples = value / meter_delay;
                if (multimeter_text_peak_samples > meter_text_history.Length)
                {
                    float[] temp = new float[multimeter_text_peak_samples];
                    for (int i = 0; i < meter_text_history.Length; i++)
                        temp[i] = meter_text_history[i];
                    meter_text_history = temp;
                }
            }
        }

        private static Color vfo_text_light_color = Color.Yellow;
        public Color VFOTextLightColor
        {
            get { return vfo_text_light_color; }
            set
            {
                if (chkPower.Checked)
                {
                    txtVFOAFreq.ForeColor = value;
                    txtVFOAMSD.ForeColor = value;
                }

                vfo_text_light_color = value;
            }
        }

        bool vfoopenfont = false; // ke9ns add

        public bool VFOOpenFont
        {
            get { return false; }

            set
            {
                vfoopenfont = value;


            }


        } // VFOOpenFont


        //===============================================================
        // ke9ns add to allow swapping fonts for VFO
        private Font Hold1 = null;
        private Font Hold2 = null;

        private int boldfont = 4;  // ke9ns adjustment for mouse hover digit select
        private int boldfont1 = -5;// ke9ns adjustment for mouse hover digit select

        public bool VFOBoldFont
        {
            get { return false; }
            set
            {


                if (Hold1 == null)
                {
                    Hold1 = txtVFOAFreq.Font; // store original font for VFOA/B BOLD FOnt
                    Hold2 = txtVFOALSD.Font;


                }

                if (value == true)
                {

                    if (vfoopenfont == true)
                    {
                        txtVFOAFreq.Font = ff9; // ke9ns add embedded Swis721 B and I
                        txtVFOBFreq.Font = ff9; // ke9ns add embedded Swis721
                        txtVFOAMSD.Font = ff9; // ke9ns add embedded Swis721
                        txtVFOBMSD.Font = ff9; // ke9ns add embedded Swis721

                        txtVFOALSD.Font = ff9a; // ke9ns add embedded Swis721
                        txtVFOBLSD.Font = ff9a; // ke9ns add embedded Swis721

                        boldfont = 4;
                        boldfont1 = -5;
                    }
                    else
                    {
                        txtVFOAFreq.Font = ff6; // ke9ns add embedded Swis721 B and I
                        txtVFOBFreq.Font = ff6; // ke9ns add embedded Swis721
                        txtVFOAMSD.Font = ff6; // ke9ns add embedded Swis721
                        txtVFOBMSD.Font = ff6; // ke9ns add embedded Swis721

                        txtVFOALSD.Font = ff7; // ke9ns add embedded Swis721
                        txtVFOBLSD.Font = ff7; // ke9ns add embedded Swis721

                        boldfont = 6;
                        boldfont1 = -5;
                    }



                }
                else
                {
                    if (Hold1 != null)
                    {
                        txtVFOAFreq.Font = Hold1; // ke9ns add  put back standard MS sans Serif
                        txtVFOBFreq.Font = Hold1; // 
                        txtVFOAMSD.Font = Hold1; //  
                        txtVFOBMSD.Font = Hold1; // 
                        txtVFOALSD.Font = Hold2; // 
                        txtVFOBLSD.Font = Hold2; // 

                        boldfont = 4;
                        boldfont1 = -5;
                    }

                }

                GetVFOCharWidth(); // ke9ns update widths based on new font

            } // set

        } // VFOBoldFont



        private static Color vfo_text_dark_color = Color.Olive;

        public Color VFOTextDarkColor
        {
            get { return vfo_text_dark_color; }
            set
            {

                if (!chkPower.Checked)
                {

                    txtVFOAFreq.ForeColor = value;
                    txtVFOAMSD.ForeColor = value;
                    txtVFOALSD.ForeColor = value;
                }
                if (!chkVFOSplit.Checked)
                {
                    txtVFOBFreq.ForeColor = value;
                    txtVFOBMSD.ForeColor = value;
                    txtVFOBLSD.ForeColor = value;
                }

                vfo_text_dark_color = value;
            }
        }

        private static Color band_text_light_color = Color.Lime;
        public Color BandTextLightColor
        {
            get { return band_text_light_color; }
            set
            {
                if (chkPower.Checked)
                    txtVFOABand.ForeColor = value;
                if (chkVFOSplit.Checked)
                    txtVFOBBand.ForeColor = value;

                band_text_light_color = value;
            }
        }

        private static Color band_text_dark_color = Color.Green;
        public Color BandTextDarkColor
        {
            get { return band_text_dark_color; }
            set
            {
                if (!chkPower.Checked)
                    txtVFOABand.ForeColor = value;
                if (!chkVFOSplit.Checked)
                    txtVFOBBand.ForeColor = value;

                band_text_dark_color = value;
            }
        }

        private static Color peak_text_color = Color.DodgerBlue;
        public Color PeakTextColor
        {
            get { return peak_text_color; }
            set
            {
                peak_text_color = value;
                txtDisplayCursorOffset.ForeColor = value;
                txtDisplayCursorPower.ForeColor = value;
                txtDisplayCursorFreq.ForeColor = value;
                txtDisplayPeakOffset.ForeColor = value;
                txtDisplayPeakPower.ForeColor = value;
                txtDisplayPeakFreq.ForeColor = value;
            }
        }

        private static Color out_of_band_color = Color.DimGray;
        public Color OutOfBandColor
        {
            get { return out_of_band_color; }
            set
            {
                out_of_band_color = value;
                if (setupForm != null)
                    txtVFOAFreq_LostFocus(this, EventArgs.Empty);
            }
        }

        private static Color button_selected_color = Color.Yellow;
        public Color ButtonSelectedColor
        {
            get { return button_selected_color; }
            set
            {
                button_selected_color = value;
                if (!fwc_init || current_model != Model.FLEX5000 || !FWCEEPROM.RX2OK)
                    rx1_band_color = button_selected_color;
                CheckSelectedButtonColor();
            }
        }

        //=================================================================
        // ke9ns old ORIGINAL meter colors

        private static Color meter_left_color = Color.Green;
        public Color MeterLeftColor
        {
            get { return meter_left_color; }
            set
            {
                meter_left_color = value;
                picMultiMeterDigital.Invalidate();
            }
        }

        private static Color meter_right_color = Color.Lime;
        public Color MeterRightColor
        {
            get { return meter_right_color; }
            set
            {
                meter_right_color = value;
                picMultiMeterDigital.Invalidate();
            }
        }

        //=======================================================================

        private static Color rx1_band_color = Color.Yellow;
        public Color RX1BandColor
        {
            get { return rx1_band_color; }
            set
            {
                rx1_band_color = value;
            }
        }

        private static Color rx2_band_color = Color.Green;
        public Color RX2BandColor
        {
            get { return rx2_band_color; }
            set
            {
                rx2_band_color = value;
            }
        }

        private static Color tx_band_color = Color.Red;
        public Color TXBandColor
        {
            get { return tx_band_color; }
            set
            {
                tx_band_color = value;
            }
        }

        private Keys key_tune_up_1 = Keys.Q;
        public Keys KeyTuneUp1
        {
            get { return key_tune_up_1; }
            set { key_tune_up_1 = value; }
        }

        private Keys key_tune_down_1 = Keys.A;
        public Keys KeyTuneDown1
        {
            get { return key_tune_down_1; }
            set { key_tune_down_1 = value; }
        }

        private Keys key_tune_up_2 = Keys.W;
        public Keys KeyTuneUp2
        {
            get { return key_tune_up_2; }
            set { key_tune_up_2 = value; }
        }

        private Keys key_tune_down_2 = Keys.S;
        public Keys KeyTuneDown2
        {
            get { return key_tune_down_2; }
            set { key_tune_down_2 = value; }
        }

        private Keys key_tune_up_3 = Keys.E;
        public Keys KeyTuneUp3
        {
            get { return key_tune_up_3; }
            set { key_tune_up_3 = value; }
        }

        private Keys key_tune_down_3 = Keys.D;
        public Keys KeyTuneDown3
        {
            get { return key_tune_down_3; }
            set { key_tune_down_3 = value; }
        }

        private Keys key_tune_up_4 = Keys.R;
        public Keys KeyTuneUp4
        {
            get { return key_tune_up_4; }
            set { key_tune_up_4 = value; }
        }

        private Keys key_tune_down_4 = Keys.F;
        public Keys KeyTuneDown4
        {
            get { return key_tune_down_4; }
            set { key_tune_down_4 = value; }
        }

        private Keys key_tune_up_5 = Keys.T;
        public Keys KeyTuneUp5
        {
            get { return key_tune_up_5; }
            set { key_tune_up_5 = value; }
        }

        private Keys key_tune_down_5 = Keys.G;
        public Keys KeyTuneDown5
        {
            get { return key_tune_down_5; }
            set { key_tune_down_5 = value; }
        }

        private Keys key_tune_up_6 = Keys.Y;
        public Keys KeyTuneUp6
        {
            get { return key_tune_up_6; }
            set { key_tune_up_6 = value; }
        }

        private Keys key_tune_down_6 = Keys.H;
        public Keys KeyTuneDown6
        {
            get { return key_tune_down_6; }
            set { key_tune_down_6 = value; }
        }

        private Keys key_tune_up_7 = Keys.U;
        public Keys KeyTuneUp7
        {
            get { return key_tune_up_7; }
            set { key_tune_up_7 = value; }
        }

        private Keys key_tune_down_7 = Keys.J;
        public Keys KeyTuneDown7
        {
            get { return key_tune_down_7; }
            set { key_tune_down_7 = value; }
        }

        private Keys key_rit_up = Keys.O;
        public Keys KeyRITUp
        {
            get { return key_rit_up; }
            set { key_rit_up = value; }
        }

        private Keys key_rit_down = Keys.I;
        public Keys KeyRITDown
        {
            get { return key_rit_down; }
            set { key_rit_down = value; }
        }

        private int rit_step_rate = 50;
        public int RITStepRate
        {
            get { return rit_step_rate; }
            set { rit_step_rate = value; }
        }

        private Keys key_xit_up = Keys.OemOpenBrackets;
        public Keys KeyXITUp
        {
            get { return key_xit_up; }
            set { key_xit_up = value; }
        }

        private Keys key_xit_down = Keys.P;
        public Keys KeyXITDown
        {
            get { return key_xit_down; }
            set { key_xit_down = value; }
        }

        private int xit_step_rate = 50;
        public int XITStepRate
        {
            get { return xit_step_rate; }
            set { xit_step_rate = value; }
        }

        private Keys key_band_up = Keys.M;
        public Keys KeyBandUp
        {
            get { return key_band_up; }
            set { key_band_up = value; }
        }

        private Keys key_band_down = Keys.N;
        public Keys KeyBandDown
        {
            get { return key_band_down; }
            set { key_band_down = value; }
        }

        private Keys key_filter_up = Keys.B;
        public Keys KeyFilterUp
        {
            get { return key_filter_up; }
            set { key_filter_up = value; }
        }

        private Keys key_filter_down = Keys.V;
        public Keys KeyFilterDown
        {
            get { return key_filter_down; }
            set { key_filter_down = value; }
        }

        private Keys key_mode_up = Keys.X;
        public Keys KeyModeUp
        {
            get { return key_mode_up; }
            set { key_mode_up = value; }
        }

        private Keys key_mode_down = Keys.Z;
        public Keys KeyModeDown
        {
            get { return key_mode_down; }
            set { key_mode_down = value; }
        }

        private Keys key_cw_dot = Keys.OemPeriod;
        public Keys KeyCWDot
        {
            get { return key_cw_dot; }
            set { key_cw_dot = value; }
        }

        private Keys key_cw_dash = Keys.OemQuestion;
        public Keys KeyCWDash
        {
            get { return key_cw_dash; }
            set { key_cw_dash = value; }
        }

        private bool rfe_pa_tr_enable = false;
        public bool RFE_PA_TR_enable
        {
            get { return rfe_pa_tr_enable; }
            set
            {
                rfe_pa_tr_enable = value;
                if (setupForm != null)
                    setupForm.RFE_PA_TR = value;
            }
        }

        private bool xvtr_present = false;
        public bool XVTRPresent
        {
            get { return xvtr_present; }
            set
            {
                xvtr_present = value;

                radBand2.Enabled = value; // ke9ns: this button is now 630m band button (was 2m). I beleive this was for SDR-1000 only

                Hdw.XVTRPresent = value;

                if (value) MaxFreq = 146.0;// ke9ns:  I beleive this was for SDR-1000 only
                else MaxFreq = 75.0;  // .240 was 65 now 75
            }
        }

        private bool pa_present = false;
        public bool PAPresent
        {
            get { return pa_present; }
            set
            {
                pa_present = value;
                if (current_model != Model.SDR1000) return;

                Hdw.PAPresent = value;
                if (pa_present)
                {
                    if (!comboMeterTXMode.Items.Contains("Ref Pwr"))
                        comboMeterTXMode.Items.Insert(1, "Ref Pwr");
                    if (!comboMeterTXMode.Items.Contains("SWR"))
                        comboMeterTXMode.Items.Insert(2, "SWR");

                    if (comboMeterTXMode.SelectedIndex < 0)
                        comboMeterTXMode.SelectedIndex = 0;

                    // ke9ns add below for 2nd tx meter
                    if (!comboMeterTX1Mode.Items.Contains("Ref Pwr"))
                        comboMeterTX1Mode.Items.Insert(1, "Ref Pwr");
                    if (!comboMeterTX1Mode.Items.Contains("SWR"))
                        comboMeterTX1Mode.Items.Insert(2, "SWR");

                    if (!comboMeterTX1Mode.Items.Contains("Combo")) //ke9ns add
                        comboMeterTX1Mode.Items.Insert(2, "Combo");

                    if (comboMeterTX1Mode.SelectedIndex < 0)
                        comboMeterTX1Mode.SelectedIndex = 0;



                }
                else
                {
                    string cur_txt = comboMeterTXMode.Text;
                    if (comboMeterTXMode.Items.Contains("Ref Pwr"))
                        comboMeterTXMode.Items.Remove("Ref Pwr");
                    if (comboMeterTXMode.Items.Contains("SWR"))
                        comboMeterTXMode.Items.Remove("SWR");

                    comboMeterTXMode.Text = cur_txt;
                    if (comboMeterTXMode.SelectedIndex < 0 &&
                        comboMeterTXMode.Items.Count > 0)
                        comboMeterTXMode.SelectedIndex = 0;

                    // ke9ns add below
                    cur_txt = comboMeterTX1Mode.Text;
                    if (comboMeterTX1Mode.Items.Contains("Ref Pwr"))
                        comboMeterTX1Mode.Items.Remove("Ref Pwr");

                    if (comboMeterTX1Mode.Items.Contains("SWR"))
                        comboMeterTX1Mode.Items.Remove("SWR");

                    if (comboMeterTX1Mode.Items.Contains("Combo")) // ke9ns add for combo meter
                        comboMeterTX1Mode.Items.Remove("Combo");

                    comboMeterTX1Mode.Text = cur_txt;
                    if (comboMeterTX1Mode.SelectedIndex < 0 &&
                        comboMeterTX1Mode.Items.Count > 0)
                        comboMeterTX1Mode.SelectedIndex = 0;


                }
                ptbPWR_Scroll(this, EventArgs.Empty);
            }
        } // PAPresent

        private bool atu_present = false;
        public bool ATUPresent
        {
            get { return atu_present; }
            set
            {
                atu_present = value;
                if (current_model != Model.SDR1000) return;
                comboTuneMode.Visible = atu_present;
                comboTuneMode.SelectedIndex = 0;
            }
        }

        private bool usb_present = false;
        public bool USBPresent
        {
            get { return usb_present; }
            set
            {
                usb_present = value;
                if (current_model != Model.SDR1000) return;
                Hdw.USBPresent = value;
                if (setupForm != null)
                    setupForm.USBPresent = value;
            }
        }

        private PerformanceCounter cpu_usage;
        public float CpuUsage
        {
            get
            {
                try
                {
                    if (cpu_usage == null)
                    {
                        cpu_usage = new PerformanceCounter(
                            "Processor", "% Processor Time", "_Total", true);
                    }
                    return cpu_usage.NextValue();
                }
                catch (Exception)
                {
                    timer_cpu_meter.Enabled = false;
                    lblCPUMeter.Visible = false;

                    return 0.0f;
                }
            }
        }

        private int scope_time = 50;
        public int ScopeTime
        {
            get { return scope_time; }
            set
            {
                scope_time = value;
                Display.ScopeTime = value;
            }
        }

        // Added 6/11/05 BT to support CAT
        public float MultiMeterCalOffset
        {
            get { return rx1_meter_cal_offset; }
        }

        //Added 7/11/2010 BT to support CAT
        public float RX2MeterCalOffset
        {
            get { return rx2_meter_cal_offset; }
        }

        public float PreampOffset
        {
            get { return rx1_preamp_offset[(int)rx1_preamp_mode]; }
        }

        public bool RXEQ
        {
            get
            {
                if (chkRXEQ != null) return chkRXEQ.Checked;
                else return false;
            }
            set
            {
                if (chkRXEQ != null) chkRXEQ.Checked = value;
            }
        }

        public bool TXEQ
        {
            get
            {
                if (chkTXEQ != null) return chkTXEQ.Checked;
                else return false;
            }
            set
            {
                if (chkTXEQ != null) chkTXEQ.Checked = value;
            }
        }

        private bool disable_split_on_bandchange = true;
        public bool DisableSplitOnBandchange
        {
            get { return disable_split_on_bandchange; }
            set { disable_split_on_bandchange = value; }
        }

        private bool disable_split_on_modechange = false;
        public bool DisableSplitOnModeChange
        {
            get { return disable_split_on_modechange; }
            set { disable_split_on_modechange = value; }
        }

        private bool spacenav_controlvfos = true;
        public bool SpaceNavControlVFOs
        {
            get { return spacenav_controlvfos; }
            set { spacenav_controlvfos = value; }
        }

        private bool spacenav_flypanadapter = false;
        public bool SpaceNavFlyPanadapter
        {
            get { return spacenav_flypanadapter; }
            set { spacenav_flypanadapter = value; }
        }

        private bool enable_vu_power_curve = true;
        public bool Enable_VU_Power_Curve
        {
            get { return enable_vu_power_curve; }
            set { enable_vu_power_curve = value; }
        }

        private string current_skin = "Default";
        public string CurrentSkin
        {
            get { return current_skin; }
            set
            {
                current_skin = value;
            }
        }

        private bool radar_color_update = false;
        public bool RadarColorUpdate
        {
            get { return radar_color_update; }
            set
            {
                radar_color_update = value;
            }
        }

        private double fm_tx_offset_mhz = 0;
        public double FMTXOffsetMHz
        {
            get { return fm_tx_offset_mhz; }
            set
            {
                fm_tx_offset_mhz = value;
                if (udFMOffset.Value != (decimal)fm_tx_offset_mhz)
                    udFMOffset.Value = (decimal)fm_tx_offset_mhz;
            }
        }

        private FMTXMode current_fm_tx_mode = FMTXMode.Simplex;
        public FMTXMode CurrentFMTXMode
        {
            get { return current_fm_tx_mode; }
            set
            {
                current_fm_tx_mode = value;
                switch (current_fm_tx_mode)
                {
                    case FMTXMode.High:
                        if (!chkFMTXHigh.Checked)
                            chkFMTXHigh.Checked = true;
                        break;
                    case FMTXMode.Simplex:
                        if (!chkFMTXSimplex.Checked)
                            chkFMTXSimplex.Checked = true;
                        break;
                    case FMTXMode.Low:
                        if (!chkFMTXLow.Checked)
                            chkFMTXLow.Checked = true;
                        break;
                }
                txtVFOAFreq_LostFocus(this, EventArgs.Empty);
            }
        }

        private int fm_deviation_hz = 5000; // 5k is the standard wide deviation with 8k tx/rx filters, 2.5k is narrow with 4k tx/rx filters
        public int FMDeviation_Hz
        {
            get { return fm_deviation_hz; }
            set
            {
                fm_deviation_hz = value;

                if (fm_deviation_hz == FMDataDeviation) // ke9ns add WFM
                {
                    radFMDeviation2kHz.Checked = false;
                    radFMDeviation5kHz.Checked = false;
                }
                else if (fm_deviation_hz == 5000)
                {
                    radFMDeviation2kHz.Checked = false;
                    radFMDeviation5kHz.Checked = true;
                }
                else if (fm_deviation_hz == 2500)
                {
                    radFMDeviation5kHz.Checked = false;
                    radFMDeviation2kHz.Checked = true;
                }
            }
        }

        #endregion

        #region Display Routines

        public void UpdateDisplay()
        {


            switch (current_display_engine)
            {
                case DisplayEngine.GDI_PLUS:

                    picDisplay.Invalidate();


                    break;
                    /*case DisplayEngine.DIRECT_X:
						Display.RenderDirectX();
						break;
						*/
            }
        }

        //   public static int continuum_peak = 0;

        //==================================================
        // ke9ns   those  peak digital values in the lower right corner of the panadapter (also used by continuum)

        private void UpdatePeakText()
        {

            if (txtVFOAFreq.Text == "" || txtVFOAFreq.Text == "." || txtVFOAFreq.Text == ",") return;

            // update peak value
            float x = PixelToHz(Display.MaxX);
            float y = PixelToDb(Display.MaxY);
            y = Display.MaxY; // ke9ns used in continuum mode

            //   continuum_peak = (int)(Math.Abs(y)); // ke9ns add

            double freq = double.Parse(txtVFOAFreq.Text) + (double)x * 0.0000010;

            if (rx1_dsp_mode == DSPMode.CWL) freq += (double)cw_pitch * 0.0000010;
            else if (rx1_dsp_mode == DSPMode.CWU) freq -= (double)cw_pitch * 0.0000010;

            Display.MaxY = picDisplay.Height;

            if (Display.continuum == 1) // ke9ns add
            {
                float tempf = (Display.RXDisplayHigh - Display.RXDisplayLow) / 1000; // find width that your looking over
                autoBrightBox.Text = tempf.ToString("f0") + " KHz";

            }
            else
            {
                //  autoBrightBox.Text = "Auto Wtr Level";
            }


            if (peak1 == 0)  // ke9ns ADD:  turn off peak value on screen if you click on them
            {
                txtDisplayPeakOffset.Text = x.ToString("f1") + "Hz";

                txtDisplayPeakPower.Text = y.ToString("f1") + "dBm"; // ke9ns: this value can be used in Continuum mode waterfall

                string temp_text = freq.ToString("f6" ) + " MHz";
                int jper = temp_text.IndexOf(separator) + 4;
                txtDisplayPeakFreq.Text = String.Copy(temp_text.Insert(jper, " "));


            }
            else
            {
                txtDisplayPeakOffset.Text = "";  // ke9ns ADD
                txtDisplayPeakPower.Text = "";
                txtDisplayPeakFreq.Text = "";
                // autoBrightBox.Text = "Auto Wtr Level";

            }

        } //UpdatePeakText()




        public float PixelToHz(float x)
        {
            int low, high;
            if (!mox)
            {
                low = Display.RXDisplayLow;
                high = Display.RXDisplayHigh;

            }
            else
            {

                low = Display.TXDisplayLow;
                high = Display.TXDisplayHigh;

            }

            if (!chkMOX.Checked)
            {
                if (chkRIT.Checked)
                {
                    int offset = (int)udRIT.Value;
                    low += offset;
                    high += offset;
                }
            }
            else
            {
                if (chkXIT.Checked)
                {
                    int offset = (int)udXIT.Value;
                    low += offset;
                    high += offset;
                }
            }

            int width = high - low;
            return (float)(low + (double)x / (double)picDisplay.Width * (double)width);

        } //PixelToHz(float x)


        public float PixelToHz2(float x) //.219 add
        {
            int low, high;
            if (!mox)
            {
                low = Display.RXDisplayLow2;
                high = Display.RXDisplayHigh2;


            }
            else
            {

                low = Display.TXDisplayLow2;
                high = Display.TXDisplayHigh2;

            }

            if (!chkMOX.Checked)
            {
                if (chkRIT.Checked)
                {
                    int offset = (int)udRIT.Value;
                    low += offset;
                    high += offset;
                }
            }
            else
            {
                if (chkXIT.Checked)
                {
                    int offset = (int)udXIT.Value;
                    low += offset;
                    high += offset;
                }
            }

            int width = high - low;
            return (float)(low + (double)x / (double)picDisplay.Width * (double)width);

        } //PixelToHz2(float x)

        private int HzToPixel(float freq)
        {
            int low, high;
            if (!mox)
            {
                low = Display.RXDisplayLow;
                high = Display.RXDisplayHigh;
            }
            else
            {
                low = Display.TXDisplayLow;
                high = Display.TXDisplayHigh;
            }

            int width = high - low;
            return (int)((double)(freq - low) / (double)width * (double)picDisplay.Width);
            //return picDisplay.Width/2+(int)(freq/(high-low)*picDisplay.Width);

        } //HzToPixel(float freq)

        private int HzToPixel2(float freq) //.219
        {
            int low, high;
            if (!mox)
            {
                low = Display.RXDisplayLow2;
                high = Display.RXDisplayHigh2;
            }
            else
            {
                low = Display.TXDisplayLow2;
                high = Display.TXDisplayHigh2;
            }

            int width = high - low;
            return (int)((double)(freq - low) / (double)width * (double)picDisplay.Width);
            //return picDisplay.Width/2+(int)(freq/(high-low)*picDisplay.Width);

        } //HzToPixel(float freq)


        // ke9ns mod 
        public float PixelToDb(float y)
        {
            if (chkSplitDisplay.Checked || Display.CurrentDisplayMode == DisplayMode.PANAFALL ||   // ke9ns pan
                Display.CurrentDisplayMode == DisplayMode.PANASCOPE)
            {
                //     if(y <=  picDisplay.Height/2) y = y * 2.0f; 
                //     else y = (y- picDisplay.Height/2) * 2.0f;

                if (y <= H7) y = y * H9; // ke9ns account for new proportions of rx1 and rx2 areas
                else y = (y - H7) * H9;

            }
            return (float)(Display.SpectrumGridMax - y * (double)(Display.SpectrumGridMax - Display.SpectrumGridMin) / picDisplay.Height);
        }


        // ke9ns mod
        private float WaterfallPixelToTime(float y)
        {
            if (chkSplitDisplay.Checked || Display.CurrentDisplayMode == DisplayMode.PANAFALL)    // ke9ns pan
            {
                //     if(y <=  picDisplay.Height/2) y = y * 2.0f; 
                //     else y = (y- picDisplay.Height/2) * 2.0f;



                if (y <= H7) y = y * 1.0f; // ke9ns account for new proportions of rx1 and rx2 areas
                else y = (y - H7) * 1.0f;

            }

            if (y < 16) return 0f;

            int i;
            for (i = 1; i * display_delay < Display.WaterfallUpdatePeriod; i++)
            {

            }
            return (y - 16) * i * display_delay; // ke9ns msec of waterfall history above cursor, based on cursor position in waterfall history and speed of watefall

        } // WaterfallPixelToTime

        #endregion

        #region Paint Event Handlers
        // ======================================================
        // Paint Event Handlers
        // ======================================================


        PaintEventArgs PD;

        private void picDisplay_Paint(object sender, PaintEventArgs e) //System.Windows.Forms.PaintEventArgs
        {
            PD = e;

            //   if (FirstDown == true) return;

            //  this.pictureBox1.Image = global::PowerSDR.Properties.Resources.blue1;


            //  PD.Graphics.TextRenderingHint = TextRenderingHint.ClearTypeGridFit;
            //  PD.Graphics.CompositingMode = CompositingMode.SourceOver;
            //  PD.Graphics.CompositingQuality = CompositingQuality.HighQuality;
            //   PD.Graphics.InterpolationMode = InterpolationMode.HighQualityBicubic;
            //   PD.Graphics.SmoothingMode = SmoothingMode.HighQuality;
            //   PD.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;


            //  Debug.WriteLine("picDisplay Paint here");

            if (panelTSBandStack.Enabled == true) // ke9ns add:  if the bandstack window is OPEN, then reduce the Panadapter display width
            {
                if (MeterTop == false) // ke9ns add .153
                    picDisplay.Width = panelDisplay.Width - panelTSBandStack.Width - 18;

            }

            if (panelTSRadar.Enabled == true) //.246
            {

            }

            switch (current_display_engine)
            {
                case DisplayEngine.GDI_PLUS:
                    Display.RenderGDIPlus(ref PD);  // System.Windows.Forms.PaintEventArgs
                    break;
                case DisplayEngine.DIRECT_X:
                    /*Thread t = new Thread(new ThreadStart(Display.RenderDirectX));
						t.Name = "DirectX Background Update";
						t.IsBackground = true;
						t.Priority = ThreadPriority.Normal;
						t.Start();*/
                    break;
            }

        } //picDisplay_paint



        //========================================================================================
        //========================================================================================
        //========================================================================================
        // ke9ns add

        Point[] dest =  // ke9ns add rotation points for meter pointer in both RX1 and RX2 using small PNG pointers
        {
            new Point(0,0), // upper left
            new Point(0,0), // upper right
            new Point(0,0) // lower left (lower right is extrapolated automatically)
        };

        // signal is the radian version of the angle

        //  var x1 = 82.0;  //(double)Origin_x; // original line 82
        //  var y1 = 118.0; // (double)Origin_y; // original line 118 (below the visable area of the meter)
        // fact is H * 1.25 or 1.65
        const double offsetpix = 5.0; // half of pointer image width

        int x1p = 0;
        int x2p = 0;
        int x3p = 0;

        int y1p = 0;
        int y2p = 0;
        int y3p = 0;

        double Vect = 0;
        double x2 = 0;
        double y2 = 0;

        private void RotatePointer(double signal, double fact, double x1, double y1)
        {
            if (meterPause == true)
            {
                Debug.WriteLine("ROTATE SKIPPED panel change");
                return; // dont waste time rotating pointer if updating images of buttons on console window
            }

            if (Skin.meterPause == true)
            {
                Debug.WriteLine("ROTATE SKIPPED button push");

                return;
            }

            x2 = x1 - fact * Math.Cos(signal);  // 1.25 convert signal to arc
            y2 = y1 - fact * Math.Sin(signal);   // 1.25

            Vect = Math.Sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); // get vector for parallel linesdd

            x1p = (int)(x1 - offsetpix * (y2 - y1) / Vect); // bottom x parallel line (to the left)
            y1p = (int)(y1 - offsetpix * (x1 - x2) / Vect); // bottom y
            x2p = (int)(x2 - offsetpix * (y2 - y1) / Vect); // top x
            y2p = (int)(y2 - offsetpix * (x1 - x2) / Vect); // top y

            x3p = (int)(x1 + offsetpix * (y2 - y1) / Vect); // bottom x parallel line (to the right)
            y3p = (int)(y1 + offsetpix * (x1 - x2) / Vect); // bottom y


            dest[0] = new Point(x1p, y1p); // upper left
            dest[1] = new Point(x3p, y3p); // upper right
            dest[2] = new Point(x2p, y2p); // lower left       (lower right is extrapolated automatically by drawimage)


        } // RotatePointer

        //========================================================================================
        // ke9ns add works but is slow

        Graphics g1; // ke9ns add for rotateimage routine



        Bitmap rotatedImage = new Bitmap(164, 79); // ke9ns add output of rotated image
        double angle = 0; // ke9ns add needs this: float angle = (float)signal - 90;

        //  RotateImage(red, angle);
        //  g.DrawImageUnscaled(rotatedImage, 0, 0);



        private void RotateImage(int z, double angle, int y)
        {


            if (meterPause == true)
            {
                Debug.WriteLine("ROTATE SKIPPED panel change");
                return; // dont waste time rotating pointer if updating images of buttons on console window
            }

            if (Skin.meterPause == true)
            {
                Debug.WriteLine("ROTATE SKIPPED button push");

                return;
            }

            rotatedImage = new Bitmap(164, 79); // reset the frame to the start position
            g1 = Graphics.FromImage(rotatedImage); // create a new 

            g1.TextRenderingHint = TextRenderingHint.ClearTypeGridFit;
            //   g1.CompositingMode = CompositingMode.SourceOver;
            //   g1.CompositingQuality = CompositingQuality.HighQuality;
            g1.InterpolationMode = InterpolationMode.HighQualityBicubic;
            g1.SmoothingMode = SmoothingMode.HighQuality;
            g1.PixelOffsetMode = PixelOffsetMode.HighQuality;



            g1.TranslateTransform(82, y); //set the rotation point as the center into the matrix
            g1.RotateTransform((float)angle - 90.0F); //rotate
            g1.TranslateTransform(-82, -y); //restore rotation point into the matrix

            // png is 11 pixels wide
            if (z == 0) g1.DrawImageUnscaled(white1, 77, 10); // insert pointer into rotated transparent background, creating a rotatedimage bitmap
            else if (z == 1) g1.DrawImageUnscaled(yell1, 77, 10);
            else if (z == 2) g1.DrawImageUnscaled(black1, 77, 10);
            else g1.DrawImageUnscaled(red1, 76, 10);


            //  return rotatedImage;

        } // RotateImage




        //=========================================================================================
        public double avg_num = -130.0; // signal strength adjusted

        public double FREQA = 0; // ke9ns ADD used for S9 meter correction (-93db above 30mhz)
        public double FREQB = 0; // ke9ns ADD used for S9 meter correction (-93db above 30mhz)

        static Pen low_brush1;  // white
        static Pen high_brush2; // blue
        static Pen high_brush1; // red
        static Pen high_brush3; // yellow
        static Pen high_brush5; // 
        static Pen high_brush4; // 
        static Pen high_brush7; // green

        static Pen line_pen;
        static Pen line_dark_pen; // edge meter shadow around needle
                                  //  static Pen line_dark_pen1; // ke9ns add analog meter shadow around needle
                                  //  static Pen line_dark_pen2; // ke9ns add analog meter shadow around needle


        //  static int shadow = 0;   // ke9ns add amount of shadow


        //   static Pen MBC; // ke9ns meter background color

        static SolidBrush b;
        static SolidBrush low_brush; // white
        static SolidBrush high_brush; // red

        // for SWR only EDGE meter
        static SolidBrush grn_brush = new SolidBrush(Color.Green); // green ke9ns add
        static SolidBrush yel_brush = new SolidBrush(Color.Goldenrod); // yellow ke9ns add
        static SolidBrush red_brush = new SolidBrush(Color.Red); // red ke9ns add

        // for SWR only curved analog meter
        static Pen grn_pen = new Pen(Color.Green); // ke9ns add
        static Pen yel_pen = new Pen(Color.Goldenrod); // ke9ns add
        static Pen red_pen = new Pen(Color.Red); // ke9ns add


        static double signal = 0;


        const float arc_thick = 2.0F; // ke9ns add for new analog meters
        const float arc_thick1 = 2.4F;
        const float tick_thin = 1.5F; // 1.0F
        const float tick_thick = 2.0F; //1.5F;

        static int DTM = 0;
        static int DTMx = 82; //-58/2;
        static int DTMy = 151;
        static int DTMa = 90;
        static int DTMs = 35;

        const int CirX = 64; // ke9ns add: meter virtual circle dia beyond W (width of the meter opening)
        const int CirXL = 52; // ke9ns add: lower line diameter
        const int CirXH = 32; // ke9ns add normal line pos
        const int CirXS = 26; // ke9ns add lower line pos
        const int CirY = 37; // ke9ns add: shift meter circle down by this amoun (normal line pos)
        const int CirYS = 43; // ke9na add: lower line pos

        //=================================================================================================
        private void picMultiMeterDigital_Paint(object sender, System.Windows.Forms.PaintEventArgs e)
        {


            if (setupForm != null && setupForm.chkBoxPM1.Checked) //ke9ns .212
            {
                if (setupForm.PMON == true)
                {
                    pwrMstWatts.Text = "W: " + pm.Watts1.ToString();

                    pwrMstSWR.Text = "S: " + pm.SWR.ToString();
                }
            }


            int H = picMultiMeterDigital.ClientSize.Height;
            int W = picMultiMeterDigital.ClientSize.Width;

            Graphics g = e.Graphics; // so everything we add to g here will go to paint the meter
            double num;


            line_dark_pen = new Pen( // this causes a shadow color around the needle of the EDGE meters
                         Color.FromArgb((edge_avg_color.R + edge_meter_background_color.R) / 2, // red
                         (edge_avg_color.G + edge_meter_background_color.G) / 2, // green
                         (edge_avg_color.B + edge_meter_background_color.B) / 2)); // blue



            int pixel_x = 0;
            int pixel_x1 = 0; // ke9ns ADD for peak routine
            string output = "";

            //  Debug.WriteLine("freqA " + FREQA);
            //  Debug.WriteLine("freqB " + FREQB);

            g.TextRenderingHint = TextRenderingHint.ClearTypeGridFit;
            //   g.CompositingMode = CompositingMode.SourceOver;
            //   g.CompositingQuality = CompositingQuality.HighQuality;
            g.InterpolationMode = InterpolationMode.HighQualityBicubic;
            g.SmoothingMode = SmoothingMode.HighQuality;
            g.PixelOffsetMode = PixelOffsetMode.HighQuality;

            const float slam = 5.0f;  //-10.0f; // RX signal which is considered not a real value


            int CirR = (W + CirX) / 2; // ke9ns add: 114  virtual meter circle radius
            const double CirA = Math.PI / 180; // ke9ns add


            switch (current_meter_display_mode)
            {

                //=============================================================
                //=============================================================
                // KE9NS mod 1 RX1 BAR GRAPH METERS
                //=============================================================
                //=============================================================

                case MultiMeterDisplayMode.Bar:  // lblRX2Meter is the text for RX2 bar graph (lblMultiSMeter is for RX1)
                    #region Bar


                    if (meter_data_ready)
                    {
                        if ((!mox) && (new_meter_data > slam)) // ke9ns: if in RX and new meter data is too strong (Slamming) to be real, then ignore it
                        {
                            meter_peak_value = new_meter_data = -150.0f;
                        }

                        current_meter_data = new_meter_data;
                        meter_data_ready = false;
                    }

                    if (!mox)
                    {
                        num = current_meter_data;

                        switch (current_meter_rx_mode)
                        {
                            case MeterRXMode.SIGNAL_STRENGTH:
                            case MeterRXMode.SIGNAL_AVERAGE:
                            case MeterRXMode.SIGNAL_PEAK:

                                switch ((int)g.DpiX)
                                {
                                    case 96:

                                        if (FREQA < 30)
                                        {
                                            double s = (num + 127) / 6;

                                            if (s <= 9.0F)
                                            {
                                                pixel_x = (int)((s * 7.5) + 2);
                                            }
                                            else
                                            {
                                                double over_s9 = num + 73;
                                                pixel_x = 69 + (int)(over_s9 * 1.05);
                                            }
                                        }
                                        else // vhf
                                        {

                                            //  Debug.WriteLine("VHF96====");
                                            if (num > -93)
                                            {
                                                pixel_x = (int)(W * 0.5 + (93 + num) / 63.0 * (W * 0.5 - 3));
                                            }
                                            else
                                            {
                                                pixel_x = (int)((num + 133.0) / 40.0 * (W * 0.5));
                                            }

                                        } // VHF


                                        break;
                                    case 120:

                                        if (FREQA < 30)
                                        {
                                            if (num <= -97.0f)
                                                pixel_x = (int)(0 + (num + 100.0) / 3.0 * 10);
                                            else if (num <= -91.0f)
                                                pixel_x = (int)(10 + (num + 97.0) / 6.0 * 17);
                                            else if (num <= -85.0f)
                                                pixel_x = (int)(27 + (num + 91.0) / 6.0 * 16);
                                            else if (num <= -79.0f)
                                                pixel_x = (int)(43 + (num + 85.0) / 6.0 * 17);
                                            else if (num <= -73.0f)
                                                pixel_x = (int)(60 + (num + 79.0) / 6.0 * 16);
                                            else if (num <= -53.0f)
                                                pixel_x = (int)(76 + (num + 73.0) / 20.0 * 24);
                                            else if (num <= -33.0f)
                                                pixel_x = (int)(100 + (num + 53.0) / 20.0 * 24);
                                            else if (num <= -13.0f)
                                                pixel_x = (int)(124 + (num + 33.0) / 20.0 * 24);
                                            else
                                                pixel_x = (int)(148 + (num + 13.0) / 20.0 * 19);

                                        }
                                        else
                                        {
                                            // Debug.WriteLine("VHF120====");

                                            if (num <= -117.0f) pixel_x = (int)(0 + (num + 100.0) / 3.0 * 10);
                                            else if (num <= -111.0f) pixel_x = (int)(10 + (num + 97.0) / 6.0 * 17);
                                            else if (num <= -105.0f) pixel_x = (int)(27 + (num + 91.0) / 6.0 * 16);
                                            else if (num <= -99.0f) pixel_x = (int)(43 + (num + 85.0) / 6.0 * 17);
                                            else if (num <= -93.0f) pixel_x = (int)(60 + (num + 79.0) / 6.0 * 16);
                                            else if (num <= -73.0f) pixel_x = (int)(76 + (num + 73.0) / 20.0 * 24);
                                            else if (num <= -53.0f) pixel_x = (int)(100 + (num + 53.0) / 20.0 * 24);
                                            else if (num <= -33.0f) pixel_x = (int)(124 + (num + 33.0) / 20.0 * 24);
                                            else pixel_x = (int)(148 + (num + 13.0) / 20.0 * 19);

                                        }
                                        break;
                                }
                                break;
                            case MeterRXMode.ADC_L:
                            case MeterRXMode.ADC_R:
                                switch ((int)g.DpiX)
                                {
                                    case 96:
                                        pixel_x = (int)(((num + 100) * 1.2) + 12);
                                        break;
                                    case 120:
                                        if (num <= -100.0f)
                                            pixel_x = (int)(0 + (num + 110.0) / 10.0 * 14);
                                        else if (num <= -80.0f)
                                            pixel_x = (int)(14 + (num + 100.0) / 20.0 * 27);
                                        else if (num <= -60.0f)
                                            pixel_x = (int)(41 + (num + 80.0) / 20.0 * 28);
                                        else if (num <= -40.0f)
                                            pixel_x = (int)(69 + (num + 60.0) / 20.0 * 28);
                                        else if (num <= -20.0f)
                                            pixel_x = (int)(97 + (num + 40.0) / 20.0 * 27);
                                        else if (num <= 0.0f)
                                            pixel_x = (int)(124 + (num + 20.0) / 20.0 * 24);
                                        else
                                            pixel_x = (int)(148 + (num - 0.0) / 10.0 * 19);
                                        break;
                                }
                                break;
                            case MeterRXMode.OFF:
                                break;
                        }
                    }
                    else
                    {
                        num = current_meter_data;

                        MeterTXMode mode = current_meter_tx_mode;
                        if (chkTUN.Checked) mode = tune_meter_tx_mode;
                        switch (mode)
                        {
                            case MeterTXMode.MIC:
                            case MeterTXMode.EQ:
                            case MeterTXMode.LEVELER:
                            case MeterTXMode.CPDR:
                            case MeterTXMode.ALC:
                                //num += 3.0;  // number no longer has fudge factor added in the dsp, must be remove
                                switch ((int)g.DpiX)
                                {
                                    case 96:
                                        if (num <= -20.0f)
                                            pixel_x = (int)(0 + (num + 25.0) / 5.0 * 9);
                                        else if (num <= -10.0f)
                                            pixel_x = (int)(9 + (num + 20.0) / 10.0 * 27);
                                        else if (num <= -5.0f)
                                            pixel_x = (int)(36 + (num + 10.0) / 5.0 * 27);
                                        else if (num <= 0.0f)
                                            pixel_x = (int)(63 + (num + 5.0) / 5.0 * 24);
                                        else if (num <= 1.0f)
                                            pixel_x = (int)(87 + (num - 0.0) / 1.0 * 15);
                                        else if (num <= 2.0f)
                                            pixel_x = (int)(102 + (num - 1.0) / 1.0 * 15);
                                        else if (num <= 3.0f)
                                            pixel_x = (int)(117 + (num - 2.0) / 1.0 * 15);
                                        else
                                            pixel_x = (int)(132 + (num - 3.0) / 0.5 * 8);
                                        break;
                                    case 120:
                                        if (num <= -20.0f)
                                            pixel_x = (int)(0 + (num + 25.0) / 5.0 * 10);
                                        else if (num <= -10.0f)
                                            pixel_x = (int)(10 + (num + 20.0) / 10.0 * 30);
                                        else if (num <= -5.0f)
                                            pixel_x = (int)(40 + (num + 10.0) / 5.0 * 30);
                                        else if (num <= 0.0f)
                                            pixel_x = (int)(70 + (num + 5.0) / 5.0 * 27);
                                        else if (num <= 1.0f)
                                            pixel_x = (int)(97 + (num - 0.0) / 1.0 * 17);
                                        else if (num <= 2.0f)
                                            pixel_x = (int)(114 + (num - 1.0) / 1.0 * 17);
                                        else if (num <= 3.0f)
                                            pixel_x = (int)(131 + (num - 2.0) / 1.0 * 17);
                                        else
                                            pixel_x = (int)(148 + (num - 3.0) / 0.5 * 23);
                                        break;
                                }
                                break;
                            case MeterTXMode.FORWARD_POWER:
                            case MeterTXMode.REVERSE_POWER:
                                switch ((int)g.DpiX)
                                {
                                    case 96:
                                        if (num <= 1.0f)
                                            pixel_x = (int)(0 + num * 2);
                                        else if (num <= 5.0f)
                                            pixel_x = (int)(2 + (num - 1) / 4 * 24);
                                        else if (num <= 10.0f)
                                            pixel_x = (int)(26 + (num - 5) / 5 * 24);
                                        else if (num <= 50.0f)
                                            pixel_x = (int)(50 + (num - 10) / 40 * 24);
                                        else if (num <= 100.0f)
                                            pixel_x = (int)(74 + (num - 50) / 50 * 24);
                                        else if (num <= 120.0f)
                                            pixel_x = (int)(98 + (num - 100) / 20 * 24);
                                        else
                                            pixel_x = (int)(122 + (num - 120) / 20 * 16);
                                        break;
                                    case 120:
                                        if (num <= 1.0f)
                                            pixel_x = (int)(0 + num * 3);
                                        else if (num <= 5.0f)
                                            pixel_x = (int)(3 + (num - 1) / 4 * 26);
                                        else if (num <= 10.0f)
                                            pixel_x = (int)(29 + (num - 5) / 5 * 26);
                                        else if (num <= 50.0f)
                                            pixel_x = (int)(55 + (num - 10) / 40 * 27);
                                        else if (num <= 100.0f)
                                            pixel_x = (int)(82 + (num - 50) / 50 * 28);
                                        else if (num <= 120.0f)
                                            pixel_x = (int)(110 + (num - 100) / 20 * 27);
                                        else
                                            pixel_x = (int)(137 + (num - 120) / 20 * 30);
                                        break;
                                }
                                break;
                            case MeterTXMode.SWR:
                                switch ((int)g.DpiX)
                                {
                                    case 96:
                                        if (double.IsInfinity(num))
                                            pixel_x = 200;
                                        else if (num <= 1.0f)
                                            pixel_x = (int)(0 + num * 3);
                                        else if (num <= 1.5f)
                                            pixel_x = (int)(3 + (num - 1.0) / 0.5 * 27);
                                        else if (num <= 2.0f)
                                            pixel_x = (int)(30 + (num - 1.5) / 0.5 * 20);
                                        else if (num <= 3.0f)
                                            pixel_x = (int)(50 + (num - 2.0) / 1.0 * 21);
                                        else if (num <= 5.0f)
                                            pixel_x = (int)(71 + (num - 3.0) / 2.0 * 21);
                                        else if (num <= 10.0f)
                                            pixel_x = (int)(92 + (num - 5.0) / 5.0 * 21);
                                        else
                                            pixel_x = (int)(113 + (num - 10.0) / 15.0 * 26);
                                        break;
                                    case 120:
                                        if (double.IsInfinity(num))
                                            pixel_x = 200;
                                        else if (num <= 1.0f)
                                            pixel_x = (int)(0 + num * 3);
                                        else if (num <= 1.5f)
                                            pixel_x = (int)(3 + (num - 1.0) / 0.5 * 31);
                                        else if (num <= 2.0f)
                                            pixel_x = (int)(34 + (num - 1.5) / 0.5 * 22);
                                        else if (num <= 3.0f)
                                            pixel_x = (int)(56 + (num - 2.0) / 1.0 * 22);
                                        else if (num <= 5.0f)
                                            pixel_x = (int)(78 + (num - 3.0) / 2.0 * 23);
                                        else if (num <= 10.0f)
                                            pixel_x = (int)(101 + (num - 5.0) / 5.0 * 23);
                                        else
                                            pixel_x = (int)(124 + (num - 10.0) / 15.0 * 43);
                                        break;
                                }
                                break;
                            case MeterTXMode.ALC_G:
                            case MeterTXMode.LVL_G:
                                switch ((int)g.DpiX)
                                {
                                    case 96:
                                        if (num <= 0.0f)
                                            pixel_x = 3;
                                        else if (num <= 5.0f)
                                            pixel_x = (int)(3 + (num - 0.0) / 5.0 * 28);
                                        else if (num <= 10.0f)
                                            pixel_x = (int)(31 + (num - 5.0) / 5.0 * 29);
                                        else if (num <= 15.0f)
                                            pixel_x = (int)(60 + (num - 10.0) / 5.0 * 30);
                                        else if (num <= 20.0f)
                                            pixel_x = (int)(90 + (num - 15.0) / 5.0 * 31);
                                        else
                                            pixel_x = (int)(121 + (num - 20.0) / 5.0 * 29);
                                        break;
                                    case 120:
                                        if (num <= 0.0f)
                                            pixel_x = 3;
                                        else if (num <= 5.0f)
                                            pixel_x = (int)(3 + (num - 0.0) / 5.0 * 31);
                                        else if (num <= 10.0f)
                                            pixel_x = (int)(34 + (num - 5.0) / 5.0 * 33);
                                        else if (num <= 15.0f)
                                            pixel_x = (int)(77 + (num - 10.0) / 5.0 * 33);
                                        else if (num <= 20.0f)
                                            pixel_x = (int)(110 + (num - 15.0) / 5.0 * 35);
                                        else
                                            pixel_x = (int)(145 + (num - 20.0) / 5.0 * 32);
                                        break;
                                }
                                break;
                            case MeterTXMode.OFF:
                                break;
                        }
                    }

                    switch ((int)g.DpiX)
                    {
                        case 96:
                            if (pixel_x > 139) pixel_x = 139;
                            break;
                        case 120:
                            if (pixel_x > 167) pixel_x = 167;
                            break;
                    }

                    if ((!mox && current_meter_rx_mode != MeterRXMode.OFF) ||
                        (mox && current_meter_tx_mode != MeterTXMode.OFF))
                    {
                        if (pixel_x <= 0) pixel_x = 1;

                        LinearGradientBrush brush = new LinearGradientBrush(new Rectangle(0, 0, pixel_x, H),
                            meter_left_color, meter_right_color, LinearGradientMode.Horizontal);

                        g.FillRectangle(brush, 0, 0, pixel_x, H);

                        for (int i = 0; i < 21; i++)
                            g.DrawLine(new Pen(meter_background_color), 6 + i * 8, 0, 6 + i * 8, H);

                        g.DrawLine(new Pen(Color.Red), pixel_x, 0, pixel_x, H);
                        g.FillRectangle(new SolidBrush(meter_background_color), pixel_x + 1, 0, W - pixel_x, H);

                        if (pixel_x >= meter_peak_value)
                        {
                            meter_peak_count = 0;
                            meter_peak_value = pixel_x;
                        }
                        else
                        {
                            if (meter_peak_count++ >= multimeter_peak_hold_samples)
                            {
                                meter_peak_count = 0;
                                meter_peak_value = pixel_x;
                            }
                            else
                            {
                                g.DrawLine(new Pen(Color.Red), meter_peak_value, 0, meter_peak_value, H);
                                g.DrawLine(new Pen(Color.Red), meter_peak_value - 1, 0, meter_peak_value - 1, H);
                            }
                        }
                    }

                    meter_timer.Stop();

                    string format = "f0";
                    if (meter_detail) format = "f1";

                    if (meter_timer.DurationMsec >= meter_dig_delay)
                    {
                        if (!mox)
                        {
                            switch (current_meter_rx_mode)
                            {
                                case MeterRXMode.SIGNAL_STRENGTH:
                                case MeterRXMode.SIGNAL_AVERAGE:
                                case MeterRXMode.SIGNAL_PEAK:
                                    output = num.ToString(format) + " dBm ";
                                    break;
                                case MeterRXMode.ADC_L:
                                case MeterRXMode.ADC_R:
                                    output = num.ToString("f1") + " dBFS ";
                                    break;
                                case MeterRXMode.OFF:
                                    output = "";
                                    break;
                            }
                        }
                        else
                        {
                            MeterTXMode mode = current_meter_tx_mode;
                            if (chkTUN.Checked) mode = tune_meter_tx_mode;
                            switch (mode)
                            {
                                case MeterTXMode.MIC:
                                case MeterTXMode.LEVELER:
                                case MeterTXMode.LVL_G:
                                case MeterTXMode.EQ:
                                case MeterTXMode.CPDR:
                                case MeterTXMode.ALC:
                                case MeterTXMode.ALC_G:
                                    if (!mox) output = "-30 dB ";
                                    else output = num.ToString(format) + " dB ";
                                    break;
                                case MeterTXMode.FORWARD_POWER:
                                case MeterTXMode.REVERSE_POWER:
                                    switch (current_model)
                                    {
                                        case Model.SDR1000:
                                            if (pa_present && VFOAFreq < 30.0)
                                                output = num.ToString("f0") + " W";
                                            else output = (num * 1000).ToString("f0") + " mW";
                                            break;
                                        case Model.FLEX5000:
                                        case Model.FLEX3000:
                                            if (num < 0) num = 0;
                                            if (!mox) output = "0 W ";
                                            else output = num.ToString("f0") + " W ";
                                            break;
                                        case Model.FLEX1500:
                                            if (num < 0) num = 0;
                                            if (!mox) output = "0 % ";
                                            else output = num.ToString("f0") + " % ";
                                            break;
                                    }
                                    break;
                                case MeterTXMode.SWR:
                                    if (num < 0) num = 0;
                                    if (!mox) output = "0 : 1 ";
                                    else output = num.ToString("f1") + " : 1 ";
                                    break;
                                case MeterTXMode.OFF:
                                    output = "";
                                    break;
                            }
                        }
                        txtMultiText.Text = output;
                        meter_timer.Start();
                    }

                    if (meter_data_ready)
                    {
                        meter_data_ready = false;  //We do NOT want to do this before we have consumed it!!!! so do it here.
                    }
                    break; // bar meter 

                #endregion 





                //=============================================================
                //=============================================================
                // KE9NS mod 1 RX1 ANALOG TR7 METERS
                //=============================================================
                //=============================================================


                case MultiMeterDisplayMode.Original:
                    #region AnalogTR7


                    if (meter_data_ready)
                    {
                        if ((!mox) && (new_meter_data > slam)) // ke9ns add: if in RX and new meter data is too strong (Slamming) to be real, then ignore it
                        {
                            meter_peak_value = new_meter_data = -150.0f;
                        }

                        current_meter_data = new_meter_data;
                        meter_data_ready = false;
                    }



                    if (avg_num == Display.CLEAR_FLAG) // reset average -- just use new value
                    {
                        num = avg_num = current_meter_data; // ke9ns mod was _data
                    }
                    else
                    {
                        if (current_meter_data > avg_num)
                            num = avg_num = current_meter_data * 0.8 + avg_num * 0.2; // fast rise
                        else
                            num = avg_num = current_meter_data * 0.2 + avg_num * 0.8; // slow decay
                    }




                    g.DrawRectangle(new Pen(meter_background_color), 0, 0, W, H); // ke9ns refresh meter background for next needle update

                    low_brush = new SolidBrush(edge_low_color); // white
                    high_brush = new SolidBrush(edge_high_color); // red




                    //=============================================
                    // Receiver meters ke9ns10
                    //=============================================

                    if (!mox)
                    {
                        switch (current_meter_rx_mode)
                        {
                            case MeterRXMode.SIGNAL_STRENGTH:
                            case MeterRXMode.SIGNAL_AVERAGE:
                            case MeterRXMode.SIGNAL_PEAK:       // ke9ns ADD

                                //=================================================================


                                int Origin_x = W / 2;
                                int Origin_y = (int)((double)(H * 1.5)); //1.5=118 1.4 slightly below meter window area (where virtual meter adjustment screw would be)


                                low_brush1 = new Pen(edge_low_color);  // white

                                high_brush2 = new Pen(Brushes.Red); // blue

                                high_brush1 = new Pen(Brushes.Red); // red
                                double spacing;
                                double string_height = 0;

                                //=======================================
                                // meter image TR7
                                //=======================================

                                //  Image src = new Bitmap(meter_image);

                                // Image src = new Bitmap("Met3.jpg"); // local image only, but now embeded resource

                                g.DrawImage(TR7, new Rectangle(0, 5, W, H));  // rectangle to show bitmap image in


                                if (FREQA < 30) // ke9ns add  (too much gain over S9) too little gain under S9
                                {
                                    if (num > -73) // at or over S9
                                    {
                                        pixel_x = (int)(W * 0.5 + (73.0 + num) / 63.0 * (W * 0.475 - 3));                  //  pixel_x = (int)(W * 0.5 + (73.0 + num) / 63.0 * (W * 0.5 - 3));
                                        pixel_x1 = (int)(W * 0.5 + (73.0 + meter_peak_value) / 63.0 * (W * 0.475 - 3));
                                    }
                                    else // under S9
                                    {
                                        pixel_x = (int)((num + 133.0) / 60.0 * (W * 0.475));                                      //   pixel_x = (int)((num + 133.0) / 60.0 * (W * 0.5));
                                        pixel_x1 = (int)((meter_peak_value + 133.0) / 60.0 * (W * 0.475));
                                    }
                                } // < 30 mhz
                                else // correction for freq > 29 mhz
                                {
                                    if (num > -93) // ke9ns ADD correct S9 above 30mhz
                                    {
                                        pixel_x = (int)(W * 0.5 + (93.0 + num) / 43.0 * (W * 0.475 - 3));                    //  pixel_x = (int)(W * 0.5 + (93.0 + num) / 43.0 * (W * 0.5 - 3));
                                        pixel_x1 = (int)(W * 0.5 + (93.0 + meter_peak_value) / 43.0 * (W * 0.475 - 3));
                                    }
                                    else
                                    {
                                        pixel_x = (int)((num + 133.0) / 40.0 * (W * 0.475));                           //  pixel_x = (int)((num + 133.0) / 40.0 * (W * 0.5));
                                        pixel_x1 = (int)((meter_peak_value + 133.0) / 40.0 * (W * 0.475));// was 133 but should be 153 but chose to instead drop 60.0 down to 40.0
                                    }

                                } // > 29 mhz


                                break; // case MeterRXMode.SIGNAL_AVERAGE

                            //===================================TR7
                            case MeterRXMode.ADC_L:
                            case MeterRXMode.ADC_R:
                            case MeterRXMode.ADC2_L:
                            case MeterRXMode.ADC2_R:

                                spacing = ((double)W - 5.0) / 6.0;
                                g.FillRectangle(low_brush, 0, H - 4, (int)(W - 3.0 - spacing), 2);
                                g.FillRectangle(high_brush, (int)(W - 3.0 - spacing), H - 4, (int)spacing, 2);
                                for (int i = 1; i < 7; i++)
                                {
                                    b = low_brush;
                                    if (i == 6) b = high_brush;
                                    g.FillRectangle(b, (int)(i * spacing - spacing / 2), H - 8 - 3 - 3, 1, 6);
                                    g.FillRectangle(b, (int)(i * spacing), H - 8 - 6 - 6, 2, 12);

                                    //    Font f = new Font("Swis721 BlkEx BT", 7.0f, FontStyle.Bold | FontStyle.Italic); // was 7

                                    string s = (-120 + i * 20).ToString();
                                    SizeF size = g.MeasureString(s, ff, 1, StringFormat.GenericTypographic);
                                    double string_width = size.Width - 2.0;
                                    size = g.MeasureString("0", ff, 1, StringFormat.GenericTypographic);
                                    string_height = size.Height - 2.0;

                                    g.DrawString(s, ff, b, (int)(i * spacing - (int)string_width * (s.Length)), (int)(H - 8 - 12 - 3 - string_height));
                                }

                                pixel_x = (int)((num + 120.0) / 120.0 * (W - 5.0));
                                break; // case MeterRXMode.ADC2_R:


                            case MeterRXMode.OFF:
                                break;
                        } // switch (current_meter_rx_mode)
                    } // !mox

                    //=============================================
                    // Transmitter meters TR7
                    //=============================================

                    else
                    {
                        MeterTXMode mode = current_meter_tx_mode;
                        if (chkTUN.Checked) mode = tune_meter_tx_mode;
                        switch (mode)
                        {
                            case MeterTXMode.MIC:
                            case MeterTXMode.EQ:
                            case MeterTXMode.LEVELER:
                            case MeterTXMode.CPDR:
                            case MeterTXMode.ALC:

                                //=================================================================
                                // Draw curved meter movement for signal strength
                                //=================================================================

                                double line1 = 0;
                                int angle_start = 45;
                                int angle_span = 90;

                                int Origin_x = W / 2;
                                int Origin_y = (int)((double)(H * 1.5)); // 1.4 slightly below meter window area (where virtual meter adjustment screw would be)

                                low_brush1 = new Pen(edge_low_color);  // white
                                high_brush2 = new Pen(Brushes.Blue); // blue
                                high_brush1 = new Pen(Brushes.Red); // red
                                high_brush3 = new Pen(Brushes.Yellow); // yellow
                                                                       //   high_brush4 = new Pen(Brushes.BurlyWood); //  
                                high_brush5 = new Pen(Brushes.Green); // 
                                high_brush4 = new Pen(Brushes.DarkSlateGray); // 


                                double spacing = (W * 0.665 - 2.0) / 3.0;
                                double string_height = 0;

                                //======================================
                                // Draw WHITE arc line
                                // upper left corner x,y , width,height, start angle, sweep angle

                                low_brush1.Width = arc_thick;
                                g.DrawArc(low_brush1, 0, 37, W, W, -75, -61); // draw OUTER arc


                                //======================================
                                // Draw Red arc line
                                // upper left corner x,y , width,height, start angle, sweep angle

                                high_brush1.Width = arc_thick;
                                g.DrawArc(high_brush1, 0, 37, W, W, -44, -27); // draw OUTER arc  -31

                                //======================================
                                // Draw GREEN full arc line under white/red 
                                // upper left corner x,y , width,height, start angle, sweep angle

                                high_brush5.Width = arc_thick1;
                                g.DrawArc(high_brush5, 6, 43, W - 12, W - 12, -43, -94); // draw INNER arc


                                //======================================
                                // WHITE  tick marks and text

                                for (double i = 1; i < 4; i++)
                                {

                                    line1 = i * spacing - spacing * 0.5;

                                    double line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    int POSW = (int)((double)(H * 1.15) * Math.Cos(line));  // convert signal to arc
                                    int POSH = (int)((double)(H * 1.15) * Math.Sin(line));

                                    int POSW_BOT = (int)((double)(H * 1.05) * Math.Cos(line));  // convert signal to arc
                                    int POSH_BOT = (int)((double)(H * 1.05) * Math.Sin(line));

                                    low_brush1.Width = tick_thin;
                                    g.DrawLine(low_brush1, Origin_x - POSW_BOT, Origin_y - POSH_BOT, Origin_x - POSW, Origin_y - POSH);  // draw meter 

                                    line1 = i * spacing;

                                    line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    POSW = (int)((double)(H * 1.25) * Math.Cos(line));  // convert signal to arc
                                    POSH = (int)((double)(H * 1.25) * Math.Sin(line));

                                    POSW_BOT = (int)((double)(H * 1.05) * Math.Cos(line));  // convert signal to arc
                                    POSH_BOT = (int)((double)(H * 1.05) * Math.Sin(line));

                                    low_brush1.Width = tick_thick;
                                    g.DrawLine(low_brush1, Origin_x - POSW_BOT, Origin_y - POSH_BOT, Origin_x - POSW, Origin_y - POSH);  // draw meter 


                                    //===============================================
                                    // Draw white numbers


                                    //  Font f = new Font("Swis721 BlkEx BT", 6.9f, FontStyle.Bold | FontStyle.Italic); // was 7

                                    SizeF size = g.MeasureString("0", ff1, 1, StringFormat.GenericTypographic);

                                    double string_width = size.Width - 2.0;
                                    string_height = size.Height - 2.0;

                                    line1 = (i * spacing - string_width + (i / 5));

                                    line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    POSW = (int)((double)(H * 1.4) * Math.Cos(line));  // convert signal to arc
                                    POSH = (int)((double)(H * (1.48 - (.010 * (i - 1)))) * Math.Sin(line));

                                    g.DrawString((-30 + i * 10).ToString(), ff1, low_brush, Origin_x - POSW, Origin_y - POSH);


                                } // white ticks and test


                                // =======================
                                // RED tick marks and text

                                spacing = (W * 0.335 - 2.0 - 3.0) / 3.0;

                                for (double i = 1; i < 4; i++) //red
                                {

                                    line1 = W * 0.665 + i * spacing - spacing * 0.5;

                                    double line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    int POSW = (int)((double)(H * 1.15) * Math.Cos(line));  // convert signal to arc
                                    int POSH = (int)((double)(H * 1.15) * Math.Sin(line));

                                    int POSW_BOT = (int)((double)(H * 1.05) * Math.Cos(line));  // convert signal to arc
                                    int POSH_BOT = (int)((double)(H * 1.05) * Math.Sin(line));

                                    high_brush1.Width = tick_thin;
                                    g.DrawLine(high_brush1, Origin_x - POSW_BOT, Origin_y - POSH_BOT, Origin_x - POSW, Origin_y - POSH);  // draw meter 

                                    line1 = W * 0.665 + i * spacing;

                                    line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    POSW = (int)((double)(H * 1.25) * Math.Cos(line));  // convert signal to arc
                                    POSH = (int)((double)(H * 1.25) * Math.Sin(line));

                                    POSW_BOT = (int)((double)(H * 1.05) * Math.Cos(line));  // convert signal to arc
                                    POSH_BOT = (int)((double)(H * 1.05) * Math.Sin(line));

                                    high_brush1.Width = tick_thick;
                                    g.DrawLine(high_brush1, Origin_x - POSW_BOT, Origin_y - POSH_BOT, Origin_x - POSW, Origin_y - POSH);  // draw meter 

                                    //==========================================
                                    // draw red text

                                    //  Font f = new Font("swis721blkexbt", 5.6f, FontStyle.Bold | FontStyle.Italic); // was 7

                                    SizeF size = g.MeasureString(i.ToString(), ff2, 3, StringFormat.GenericTypographic);
                                    double string_width = size.Width - 2.0;

                                    line1 = (W * 0.665 + i * spacing - (int)string_width);

                                    line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    POSW = (int)((double)(H * 1.4) * Math.Cos(line));  // convert signal to arc
                                    POSH = (int)((double)(H * (1.4 - (.05 * (i - 1)))) * Math.Sin(line));


                                    g.DrawString(i.ToString(), ff2, high_brush, Origin_x - POSW, Origin_y - POSH);

                                } // red ticks and text


                                if (num > 0.0) // high area
                                {
                                    pixel_x = (int)(W * 0.665 + num / 3.0 * (W * 0.335 - 4));
                                }
                                else
                                {
                                    pixel_x = (int)((num + 30.0) / 30.0 * (W * 0.665 - 1.0));
                                }
                                break; // ALC TR7 rx1

                            //===========================================TR7

                            case MeterTXMode.FORWARD_POWER:
                            case MeterTXMode.REVERSE_POWER:

                                if (pa_present || (fwc_init && (current_model == Model.FLEX5000 || current_model == Model.FLEX3000)) ||
                                      (hid_init && current_model == Model.FLEX1500))
                                {
                                    g.FillRectangle(low_brush, 0, H - 4, (int)(W * 0.75), 2);
                                    g.FillRectangle(high_brush, (int)(W * 0.75), H - 4, (int)(W * 0.25) - 10, 2);
                                    spacing = (W * 0.75 - 2.0) / 4.0;
                                    string_height = 0;
                                    //   string[] list = { "5", "10", "50", "100" };

                                    //  Image src = new Bitmap(meter_image); // tr7 met3

                                    g.DrawImage(TR7, new Rectangle(0, 5, W, H));  // rectangle to show bitmap image in

                                    //====================================TR7
                                    // redone to work with TR7 scale ke9ns scale
                                    // 19pixel = 0watts on scale
                                    // 50px = 10watts (jumps 5px from 0 to 10)
                                    // 92px = 50watts (jumps 10px from 10watts to 50w)
                                    // 108px = 90watts (jumps 3px form 50 to 100w)


                                    spacing = (W * 0.75 - 2.0) / 4.0;                //  (W * 0.75 - 2.0) / 4.0; = 28.5

                                    if (num <= 9.0)
                                    {
                                        pixel_x = (int)(num / 9.0 * (int)spacing);          // pixel_x = (int)(num / 5.0 * (int)spacing);
                                    }
                                    else if (num <= 50.0)
                                    {

                                        pixel_x = (int)(spacing + (num - 9.0) / 22.0 * spacing);// pixel_x = (int)(spacing + (num - 5.0) / 5.0 * spacing);
                                    }
                                    else
                                    {
                                        pixel_x = (int)((1.863 * spacing) + spacing + (num - 50.0) / 80.0 * spacing);
                                    }

                                    pixel_x = pixel_x + 19; // zero point


                                } // 100watt TR7 scale


                                else // 1W version
                                {
                                    g.FillRectangle(low_brush, 0, H - 4, (int)(W * 0.75), 2);
                                    g.FillRectangle(high_brush, (int)(W * 0.75), H - 4, (int)(W * 0.25) - 9, 2);
                                    spacing = (W * 0.75 - 2.0) / 4.0;
                                    string_height = 0;
                                    string[] list = { "100", "250", "500", "800", "1000" };



                                    for (int i = 1; i < 5; i++)
                                    {
                                        g.FillRectangle(low_brush, (int)(i * spacing - spacing * 0.5), H - 4 - 3, 1, 3);
                                        g.FillRectangle(low_brush, (int)(i * spacing), H - 4 - 6, 2, 6);

                                        string s = list[i - 1];
                                        // Font f = new Font("swis721blkexbt", 7.0f, FontStyle.Bold | FontStyle.Italic); // was 7

                                        SizeF size = g.MeasureString("0", ff, 1, StringFormat.GenericTypographic);
                                        double string_width = size.Width - 2.0;
                                        string_height = size.Height - 2.0;

                                        g.DrawString(s, ff, low_brush, (int)(i * spacing - string_width * s.Length + 1.0 + (int)(i / 2) - (int)(i / 4)), (int)(H - 4 - 8 - string_height));
                                    }
                                    spacing = (W * 0.25 - 2.0 - 9.0) / 1.0;
                                    for (int i = 1; i < 2; i++)
                                    {
                                        g.FillRectangle(high_brush, (int)((double)W * 0.75 + i * spacing - spacing * 0.5), H - 4 - 3, 1, 3);
                                        g.FillRectangle(high_brush, (int)((double)W * 0.75 + i * spacing), H - 4 - 6, 2, 6);

                                        //  Font f = new Font("swis721blkexbt", 7.0f, FontStyle.Bold | FontStyle.Italic); // was 7

                                        SizeF size = g.MeasureString("0", ff, 3, StringFormat.GenericTypographic);
                                        double string_width = size.Width - 2.0;

                                        g.DrawString("1000", ff, high_brush, (int)(W * 0.75 + 2 + i * spacing - (int)4.0 * string_width), (int)(H - 4 - 8 - string_height));
                                    }



                                    num *= 1000;
                                    if (num < 801.0) // low area
                                    {
                                        spacing = (W * 0.75 - 2.0) / 4.0;
                                        if (num <= 100.0)
                                            pixel_x = (int)(num / 100.0 * spacing);
                                        else if (num <= 250.0)
                                            pixel_x = (int)(spacing + (num - 100.0) / 150.0 * spacing);
                                        else if (num <= 500.0)
                                            pixel_x = (int)(2 * spacing + (num - 250.0) / 250.0 * spacing);
                                        else
                                            pixel_x = (int)(3 * spacing + (num - 500.0) / 300.0 * spacing);
                                    }
                                    else
                                    {
                                        spacing = (W * 0.25 - 2.0 - 9.0) / 1.0;
                                        pixel_x = (int)(W * 0.75 + (num - 800.0) / 200.0 * spacing);
                                    }
                                } // 1 watt version




                                break; //POWER RX1 TR7

                            //==========================================TR7

                            case MeterTXMode.SWR: // RX1 analog swr meter  SWRCOLOR


                                //=================================================================
                                // Draw curved meter movement for SWR
                                //=================================================================

                                line1 = 0;
                                angle_start = 45;
                                angle_span = 90;

                                Origin_x = W / 2;
                                Origin_y = (int)((double)(H * 1.5)); // 118.5 1.4 slightly below meter window area (where virtual meter adjustment screw would be)

                                low_brush1 = new Pen(edge_low_color);  // white
                                high_brush2 = new Pen(Brushes.Red); // blue
                                high_brush1 = new Pen(Brushes.Red); // red
                                high_brush3 = new Pen(Brushes.Yellow); // yellow
                                high_brush4 = new Pen(Brushes.AntiqueWhite); // 



                                //======================================
                                // Draw WHITE arc line
                                // upper left corner x,y , width,height, start angle, sweep angle

                                //    low_brush1.Width = arc_thick;
                                //    g.DrawArc(low_brush1, 0, 37, W, W, -88, -48); // draw OUTER arc -75  -61

                                grn_pen.Width = arc_thick;
                                g.DrawArc(grn_pen, 0, 37, W, W, -110, -26); // draw GREEN OUTER arc keep angle sum = 136deg

                                //======================================
                                // Draw YELLOW arc line
                                // upper left corner x,y , width,height, start angle, sweep angle


                                yel_pen.Width = arc_thick;
                                g.DrawArc(yel_pen, 0, 37, W, W, -93, -17); // draw YELLOW OUTER arc -94, -42

                                //======================================
                                // Draw Red arc line
                                // upper left corner x,y , width,height, start angle, sweep angle

                                //   high_brush1.Width = arc_thick;
                                //   g.DrawArc(high_brush1, 0, 37, W, W, -44, -41); // draw OUTER arc -41

                                red_pen.Width = arc_thick;
                                g.DrawArc(red_pen, 0, 37, W, W, -43, -51); // draw RED OUTER arc -44 -41 keep angle sum = 85deg



                                //======================================
                                // Draw Yellow full arc line under white/red 
                                // upper left corner x,y , width,height, start angle, sweep angle

                                high_brush3.Width = arc_thick1;
                                g.DrawArc(high_brush3, 6, 43, W - 12, W - 12, -43, -94); // draw INNER arc

                                //======================================
                                // WHITE  tick marks and text


                                spacing = (W * 0.75 - 2.0) / 4.0;
                                string_height = 0;
                                string[] swr_list = { "1.5", "2", "5", "10", "20" };

                                for (double i = 1; i < 5; i++)
                                {

                                    line1 = i * spacing - spacing * 0.5;

                                    double line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    int POSW = (int)((double)(H * 1.15) * Math.Cos(line));  // convert signal to arc
                                    int POSH = (int)((double)(H * 1.15) * Math.Sin(line));

                                    int POSW_BOT = (int)((double)(H * 1.05) * Math.Cos(line));  // convert signal to arc
                                    int POSH_BOT = (int)((double)(H * 1.05) * Math.Sin(line));

                                    low_brush1.Width = tick_thin;
                                    g.DrawLine(low_brush1, Origin_x - POSW_BOT, Origin_y - POSH_BOT, Origin_x - POSW, Origin_y - POSH);  // draw meter 

                                    line1 = i * spacing;

                                    line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    POSW = (int)((double)(H * 1.25) * Math.Cos(line));  // convert signal to arc
                                    POSH = (int)((double)(H * 1.25) * Math.Sin(line));

                                    POSW_BOT = (int)((double)(H * 1.05) * Math.Cos(line));  // convert signal to arc
                                    POSH_BOT = (int)((double)(H * 1.05) * Math.Sin(line));

                                    low_brush1.Width = tick_thick;
                                    g.DrawLine(low_brush1, Origin_x - POSW_BOT, Origin_y - POSH_BOT, Origin_x - POSW, Origin_y - POSH);  // draw meter 


                                    //===============================================
                                    // Draw white numbers  SWR TR7 RX1

                                    string s = swr_list[(int)i - 1];

                                    //   Font f = new Font("swis721blkexbt", 6.9f, FontStyle.Bold | FontStyle.Italic); // was 7

                                    SizeF size = g.MeasureString("0", ff1, 1, StringFormat.GenericTypographic);
                                    double string_width = size.Width - 2.0;
                                    string_height = size.Height - 2.0;


                                    line1 = i * spacing - string_width * s.Length + 2.0 - 2 * (int)(i / 2) + 3 * (int)(i / 4);

                                    if (i == 1) line1 = line1 + 10;


                                    line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    if (i == 1)
                                    {
                                        POSW = (int)((double)(H * 1.50) * Math.Cos(line));  // convert signal to arc
                                        POSH = (int)((double)(H * (1.50 - (.010 * (i - 1)))) * Math.Sin(line));
                                    }
                                    else
                                    {
                                        POSW = (int)((double)(H * 1.44) * Math.Cos(line));  // convert signal to arc
                                        POSH = (int)((double)(H * (1.44 - (.010 * (i - 1)))) * Math.Sin(line));
                                    }

                                    g.DrawString(s, ff1, low_brush, Origin_x - POSW, Origin_y - POSH);



                                } // white ticks and test

                                // =======================
                                // RED tick marks and text

                                spacing = (W * 0.25 - 2.0 - 9.0) / 1.0;

                                for (double i = 1; i < 2; i++) //red
                                {

                                    line1 = (double)W * 0.75 + i * spacing - spacing * 0.5;

                                    double line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    int POSW = (int)((double)(H * 1.15) * Math.Cos(line));  // convert signal to arc
                                    int POSH = (int)((double)(H * 1.15) * Math.Sin(line));

                                    int POSW_BOT = (int)((double)(H * 1.05) * Math.Cos(line));  // convert signal to arc
                                    int POSH_BOT = (int)((double)(H * 1.05) * Math.Sin(line));

                                    high_brush1.Width = tick_thin;
                                    g.DrawLine(high_brush2, Origin_x - POSW_BOT, Origin_y - POSH_BOT, Origin_x - POSW, Origin_y - POSH);  // draw meter 

                                    line1 = (double)W * 0.75 + i * spacing;

                                    line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    POSW = (int)((double)(H * 1.25) * Math.Cos(line));  // convert signal to arc
                                    POSH = (int)((double)(H * 1.25) * Math.Sin(line));

                                    POSW_BOT = (int)((double)(H * 1.05) * Math.Cos(line));  // convert signal to arc
                                    POSH_BOT = (int)((double)(H * 1.05) * Math.Sin(line));

                                    high_brush1.Width = tick_thick;
                                    g.DrawLine(high_brush1, Origin_x - POSW_BOT, Origin_y - POSH_BOT, Origin_x - POSW, Origin_y - POSH);  // draw meter 

                                    //==========================================
                                    // draw red text

                                    //  Font f = new Font("swis721blkexbt", 5.6f, FontStyle.Bold | FontStyle.Italic); // was 7

                                    SizeF size = g.MeasureString("0", ff2, 3, StringFormat.GenericTypographic);
                                    double string_width = size.Width - 2.0;

                                    line1 = W * 0.75 + i * spacing - (int)3.5 * string_width;

                                    line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    POSW = (int)((double)(H * 1.4) * Math.Cos(line));  // convert signal to arc
                                    POSH = (int)((double)(H * (1.4 - (.05 * (i - 1)))) * Math.Sin(line));

                                    g.DrawString("20+", ff2, high_brush, Origin_x - POSW, Origin_y - POSH);

                                } // red ticks and text




                                if (num < 10.0) // low area
                                {
                                    spacing = (W * 0.75 - 2.0) / 4.0;
                                    if (num <= 1.5)
                                        pixel_x = (int)((num - 1.0) / 0.5 * spacing);
                                    else if (num <= 2.0)
                                        pixel_x = (int)(spacing + (num - 1.5) / 0.5 * spacing);
                                    else if (num <= 5.0)
                                        pixel_x = (int)(2 * spacing + (num - 2.0) / 3.0 * spacing);
                                    else
                                        pixel_x = (int)(3 * spacing + (num - 5.0) / 5.0 * spacing);
                                }
                                else
                                {
                                    spacing = (W * 0.25 - 2.0 - 9.0) / 1.0;
                                    pixel_x = (int)(W * 0.75 + (num - 10.0) / 10.0 * spacing);
                                }
                                if (double.IsInfinity(num)) pixel_x = W - 2;

                                break;// case MeterTXMode.SWR:

                            case MeterTXMode.ALC_G:
                            case MeterTXMode.LVL_G:


                                //=================================================================
                                // Draw curved meter movement for signal strength tr7
                                //=================================================================

                                line1 = 0;
                                angle_start = 45;
                                angle_span = 90;

                                Origin_x = W / 2;
                                Origin_y = (int)((double)(H * 1.5)); // 1.4 slightly below meter window area (where virtual meter adjustment screw would be)

                                low_brush1 = new Pen(edge_low_color);  // white
                                high_brush2 = new Pen(Brushes.Blue); // blue
                                high_brush1 = new Pen(Brushes.Red); // red
                                high_brush3 = new Pen(Brushes.Yellow); // yellow
                                                                       //  high_brush4 = new Pen(Brushes.BurlyWood); //  
                                high_brush5 = new Pen(Brushes.Green); // 
                                high_brush4 = new Pen(Brushes.DarkSlateGray); // 


                                spacing = (W * 0.75 - 2.0) / 4.0;
                                string_height = 0;
                                string[] gain_list = { "5", "10", "15", "20", "25" };


                                //=================================================================
                                // Draw curved meter movement for Power
                                //=================================================================

                                //======================================
                                // Draw WHITE arc line
                                // upper left corner x,y , width,height, start angle, sweep angle

                                low_brush1.Width = arc_thick;
                                g.DrawArc(low_brush1, 0, 37, W, W, -67, -68); // draw OUTER arc


                                //======================================
                                // Draw Red arc line
                                // upper left corner x,y , width,height, start angle, sweep angle

                                high_brush1.Width = arc_thick;
                                g.DrawArc(high_brush1, 0, 37, W, W, -44, -20); // draw OUTER arc -24

                                //======================================
                                // Draw GREEN full arc line under white/red 
                                // upper left corner x,y , width,height, start angle, sweep angle

                                high_brush5.Width = arc_thick1;
                                g.DrawArc(high_brush5, 6, 43, W - 12, W - 12, -43, -94); // draw INNER arc


                                //======================================
                                // WHITE  tick marks and text

                                for (double i = 1; i < 5; i++)
                                {

                                    line1 = i * spacing - spacing * 0.5;

                                    double line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    int POSW = (int)((double)(H * 1.15) * Math.Cos(line));  // convert signal to arc
                                    int POSH = (int)((double)(H * 1.15) * Math.Sin(line));

                                    int POSW_BOT = (int)((double)(H * 1.05) * Math.Cos(line));  // convert signal to arc
                                    int POSH_BOT = (int)((double)(H * 1.05) * Math.Sin(line));

                                    low_brush1.Width = tick_thin;
                                    g.DrawLine(low_brush1, Origin_x - POSW_BOT, Origin_y - POSH_BOT, Origin_x - POSW, Origin_y - POSH);  // draw meter 

                                    line1 = i * spacing;

                                    line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    POSW = (int)((double)(H * 1.25) * Math.Cos(line));  // convert signal to arc
                                    POSH = (int)((double)(H * 1.25) * Math.Sin(line));

                                    POSW_BOT = (int)((double)(H * 1.05) * Math.Cos(line));  // convert signal to arc
                                    POSH_BOT = (int)((double)(H * 1.05) * Math.Sin(line));

                                    low_brush1.Width = tick_thick;
                                    g.DrawLine(low_brush1, Origin_x - POSW_BOT, Origin_y - POSH_BOT, Origin_x - POSW, Origin_y - POSH);  // draw meter 


                                    //===============================================
                                    // Draw white numbers

                                    string s = gain_list[(int)i - 1];
                                    //  Font f = new Font("swis721blkexbt", 6.9f, FontStyle.Bold | FontStyle.Italic); // was 7

                                    SizeF size = g.MeasureString("0", ff1, 1, StringFormat.GenericTypographic);
                                    double string_width = size.Width - 2.0;
                                    string_height = size.Height - 2.0;

                                    line1 = (i * spacing - string_width + (i / 5));

                                    line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    POSW = (int)((double)(H * 1.4) * Math.Cos(line));  // convert signal to arc
                                    POSH = (int)((double)(H * (1.48 - (.010 * (i - 1)))) * Math.Sin(line));

                                    g.DrawString((-30 + i * 10).ToString(), ff1, low_brush, Origin_x - POSW, Origin_y - POSH);
                                    g.DrawString(s, ff1, low_brush, Origin_x - POSW, Origin_y - POSH);


                                } // white ticks and test


                                // =======================
                                // RED tick marks and text

                                spacing = (W * 0.25 - 2.0 - 9.0) / 1.0;

                                for (double i = 1; i < 2; i++) //red
                                {

                                    line1 = W * 0.75 + i * spacing - spacing * 0.5;

                                    double line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    int POSW = (int)((double)(H * 1.15) * Math.Cos(line));  // convert signal to arc
                                    int POSH = (int)((double)(H * 1.15) * Math.Sin(line));

                                    int POSW_BOT = (int)((double)(H * 1.05) * Math.Cos(line));  // convert signal to arc
                                    int POSH_BOT = (int)((double)(H * 1.05) * Math.Sin(line));

                                    high_brush1.Width = tick_thin;
                                    g.DrawLine(high_brush1, Origin_x - POSW_BOT, Origin_y - POSH_BOT, Origin_x - POSW, Origin_y - POSH);  // draw meter 

                                    line1 = W * 0.75 + i * spacing;

                                    line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    POSW = (int)((double)(H * 1.25) * Math.Cos(line));  // convert signal to arc
                                    POSH = (int)((double)(H * 1.25) * Math.Sin(line));

                                    POSW_BOT = (int)((double)(H * 1.05) * Math.Cos(line));  // convert signal to arc
                                    POSH_BOT = (int)((double)(H * 1.05) * Math.Sin(line));

                                    high_brush1.Width = tick_thick;
                                    g.DrawLine(high_brush1, Origin_x - POSW_BOT, Origin_y - POSH_BOT, Origin_x - POSW, Origin_y - POSH);  // draw meter 

                                    //==========================================
                                    // draw red text

                                    //   Font f = new Font("swis721blkexbt", 5.6f, FontStyle.Bold | FontStyle.Italic); // was 7

                                    SizeF size = g.MeasureString("0", ff2, 3, StringFormat.GenericTypographic);
                                    double string_width = size.Width - 2.0;


                                    line1 = (W * 0.75 + i * spacing - (int)2.5 * string_width);

                                    line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    POSW = (int)((double)(H * 1.4) * Math.Cos(line));  // convert signal to arc
                                    POSH = (int)((double)(H * (1.4 - (.05 * (i - 1)))) * Math.Sin(line));


                                    g.DrawString("25+", ff2, high_brush, Origin_x - POSW, Origin_y - POSH);

                                } // red ticks and text

                                spacing = (W * 0.75 - 2.0) / 4.0;
                                pixel_x = (int)(num / 5.0 * spacing);


                                break;// case MeterTXMode.LVL_G:
                            case MeterTXMode.OFF:
                                break;
                        } // switch (mode)
                    } // mox


                    //=============================================
                    // ke9ns needle movement TR7 rx1 
                    //=============================================

                    if (  // EDGE meter movement here
                            (((current_meter_rx_mode == MeterRXMode.ADC2_R) || (current_meter_rx_mode == MeterRXMode.ADC2_L) ||
                            (current_meter_rx_mode == MeterRXMode.ADC_R) || (current_meter_rx_mode == MeterRXMode.ADC_L)) && (!mox && current_meter_rx_mode != MeterRXMode.OFF))
                        || ((mox && current_meter_tx_mode != MeterTXMode.OFF) && (current_meter_tx_mode != MeterTXMode.LVL_G) && (current_meter_tx_mode != MeterTXMode.ALC_G) && (current_meter_tx_mode != MeterTXMode.CPDR) && (current_meter_tx_mode != MeterTXMode.LEVELER) && (current_meter_tx_mode != MeterTXMode.EQ) && (current_meter_tx_mode != MeterTXMode.MIC) && (current_meter_tx_mode != MeterTXMode.ALC) && (current_meter_tx_mode != MeterTXMode.SWR) && (current_meter_tx_mode != MeterTXMode.FORWARD_POWER) && (current_meter_tx_mode != MeterTXMode.REVERSE_POWER))
                         )
                    // if meter is ON in RX or TX mode, then draw line
                    {
                        pixel_x = Math.Max(0, pixel_x);
                        pixel_x = Math.Min(W - 3, pixel_x);

                        line_pen = new Pen(edge_avg_color);

                        //   line_dark_pen = new Pen(
                        //       Color.FromArgb((edge_avg_color.R + edge_meter_background_color.R) / 2,
                        //       (edge_avg_color.G + edge_meter_background_color.G) / 2,
                        //      (edge_avg_color.B + edge_meter_background_color.B) / 2));


                        g.DrawLine(line_dark_pen, pixel_x - 1, 0, pixel_x - 1, H); // rx1 tr7 edge
                        g.DrawLine(line_pen, pixel_x, 0, pixel_x, H);
                        g.DrawLine(line_dark_pen, pixel_x + 1, 0, pixel_x + 1, H);


                    }
                    else if (  // TX meter movments
                                 ((mox && current_meter_tx_mode != MeterTXMode.OFF) && ((current_meter_tx_mode == MeterTXMode.LVL_G) ||
                                 (current_meter_tx_mode == MeterTXMode.ALC_G) || (current_meter_tx_mode == MeterTXMode.EQ) ||
                                 (current_meter_tx_mode == MeterTXMode.MIC) || (current_meter_tx_mode == MeterTXMode.ALC) ||
                                 (current_meter_tx_mode == MeterTXMode.SWR)))
                            )

                    {

                        // pixel_x (i.e. signal) goes from 0 to W  Width 
                        // posx = originx + (2 * D * cos (angle))
                        // posy = originy + (2 * D * sin (angle))
                        // for a meter of 45deg to 135deg = 90deg total span :   
                        // but sin and cos in radians not degs.
                        // posx = originx + (2 * D * cos (angle*PI/180))

                        //  box dimensions:
                        //  0,0   W,0
                        //  0,H   W,H

                        pixel_x = Math.Max(0, pixel_x);
                        pixel_x = Math.Min(W - 3, pixel_x);                                             // define limits of X dimension



                        line_pen = new Pen(Color.Blue);
                        line_pen.Width = 2.8F;


                        int Origin_x = W / 2;
                        int Origin_y = (int)((double)(H * 1.5)); // 1.4 slightly below meter window area (where virtual meter adjustment screw would be)

                        double angle_start = 45;
                        double angle_span = 90;
                        angle = signal = (angle_start + ((double)pixel_x * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                        signal = signal * CirA;                                                // convert angle to radians for cos/sin math

                        int POSW = (int)((double)(H * 1.25) * Math.Cos(signal));  // convert signal to arc
                        int POSH = (int)((double)(H * 1.25) * Math.Sin(signal));

                        g.DrawLine(line_pen, Origin_x, Origin_y, Origin_x - POSW, Origin_y - POSH);  // draw meter needle movement (by flipping result around since inc values go down not up)




                    } // SWR TX curved needle Tr7

                    // POWER ONLY===TR7========================================================================================= ke9ns scale
                    else if (
                        ((mox && current_meter_tx_mode != MeterTXMode.OFF) && ((current_meter_tx_mode == MeterTXMode.FORWARD_POWER) ||
                        (current_meter_tx_mode == MeterTXMode.REVERSE_POWER)))
                        )
                    {

                        pixel_x = Math.Max(0, pixel_x);
                        pixel_x = Math.Min(W - 3, pixel_x);                                             // define limits of X dimension

                        line_pen = new Pen(Color.Red); // rx 


                        // 54 = 10 watts" 
                        // 80 = 40 watts


                        int Origin_x = (W / 2) - 1;
                        int Origin_y = (int)((double)(H * 1.84)); //1.90  1.4 slightly below meter window area (where virtual meter adjustment screw would be)


                        double angle_start = 45;
                        double angle_span = 89;


                        angle = signal = (angle_start + ((double)pixel_x * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                        signal = signal * CirA;                                                // convert angle to radians for cos/sin math

                        int POSW = (int)((double)(H * 1.6) * Math.Cos(signal));  // 1.65 convert signal to arc
                        int POSH = (int)((double)(H * 1.6) * Math.Sin(signal));


                        line_pen.Width = 2.8F; // 2.5f

                        g.DrawLine(line_pen, Origin_x, Origin_y, Origin_x - POSW, Origin_y - POSH);  // draw meter needle movement (by flipping result around since inc values go down not up)


                    } // power
                      // SIGNAL ONLY===TR7==RX1=========================================================================================================
                      // this should be SIGNAL, AVG SIGNAL, PEAK SIGNAL
                    else if (
                                (((current_meter_rx_mode == MeterRXMode.SIGNAL_STRENGTH) || (current_meter_rx_mode == MeterRXMode.SIGNAL_AVERAGE) ||
                                    (current_meter_rx_mode == MeterRXMode.SIGNAL_PEAK)) && (!mox && current_meter_rx_mode != MeterRXMode.OFF))
                       )
                    {
                        // SIGNAL ONLY

                        pixel_x = Math.Max(0, pixel_x);
                        pixel_x = Math.Min(W - 3, pixel_x);                                             // define limits of X dimension

                        pixel_x1 = Math.Max(0, pixel_x1);
                        pixel_x1 = Math.Min(W - 3, pixel_x1);                                             // define limits of X dimension

                        line_pen = new Pen(Color.Yellow); // rx 


                        int Origin_x = (W / 2) - 3;
                        int Origin_y = (int)((double)(H * 1.9)); // 1.84 slightly below meter window area (where virtual meter adjustment screw would be)

                        double angle_start = 45;
                        double angle_span = 89;


                        if ((current_meter_rx_mode == MeterRXMode.SIGNAL_PEAK) && (!mox && current_meter_rx_mode != MeterRXMode.OFF)) // ke9ns ADD
                        {

                            angle = signal = (angle_start + ((double)pixel_x1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                            signal = signal * CirA;                                                // convert angle to radians for cos/sin math


                            if ((meterPointer == true)) // Dark meter background, so needle shadow is light
                            {
                                RotateImage(red, angle, Origin_y);
                                g.DrawImageUnscaled(rotatedImage, 0, 0);

                                //   RotatePointer(signal, H * 1.6, Origin_x, Origin_y); // come up with vector to rotate image pointer
                                //   g.DrawImage(red1, dest);            // draw rotated image pointer
                            }
                            else
                            {

                                int POSW1 = (int)((double)(H * 1.65) * Math.Cos(signal));  // convert signal to arc 1.6
                                int POSH1 = (int)((double)(H * 1.65) * Math.Sin(signal));

                                line_pen = new Pen(Color.Red);
                                line_pen.Width = 3.0F;
                                g.DrawLine(line_pen, Origin_x, Origin_y, Origin_x - POSW1, Origin_y - POSH1);  // draw meter needle movement (by flipping result around since inc values go down not up)
                            }


                        } // peak

                        angle = signal = (angle_start + ((double)pixel_x * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                        signal = signal * CirA;                                                // convert angle to radians for cos/sin math


                        if ((meterPointer == true)) // Dark meter background, so needle shadow is light
                        {
                            RotateImage(yell, angle, Origin_y);
                            g.DrawImageUnscaled(rotatedImage, 0, 0);

                            //  RotatePointer(signal, H * 1.65, Origin_x, Origin_y);
                            //  g.DrawImage(yell1, dest);            // draw rotated image
                        }

                        else
                        {

                            int POSW = (int)((double)(H * 1.65) * Math.Cos(signal));  // convert signal to arc 1.6 is length of needle
                            int POSH = (int)((double)(H * 1.65) * Math.Sin(signal));

                            line_pen = new Pen(Color.Yellow);
                            line_pen.Width = 2.6F; // 2.5

                            g.DrawLine(line_pen, Origin_x, Origin_y, Origin_x - POSW, Origin_y - POSH);  // draw meter needle movement (by flipping result around since inc values go down not up)

                        }



                    } //   if meter is ON in RX or TX mode, then draw line



                    //=============================================
                    // Type NUMBERS in dbM above meter movement
                    //=============================================
                    meter_timer.Stop();

                    //string
                    format = "f0";
                    if (meter_detail) format = "f1";

                    if (meter_timer.DurationMsec >= meter_dig_delay)
                    {
                        if (!mox)
                        {
                            switch (current_meter_rx_mode)
                            {
                                case MeterRXMode.SIGNAL_STRENGTH:

                                case MeterRXMode.SIGNAL_AVERAGE:
                                    output = num.ToString(format) + " dBm ";
                                    break;
                                case MeterRXMode.SIGNAL_PEAK: // ke9ns ADD 
                                    output = meter_peak_value.ToString(format) + " dBm ";
                                    break;
                                case MeterRXMode.ADC_L:
                                case MeterRXMode.ADC_R:
                                case MeterRXMode.ADC2_L:
                                case MeterRXMode.ADC2_R:
                                    output = num.ToString("f1") + " dBFS ";
                                    break;
                                case MeterRXMode.OFF:
                                    output = "";
                                    break;
                            }// switch (current_meter_rx_mode)
                        }// mox
                        else
                        {
                            MeterTXMode mode = current_meter_tx_mode;
                            if (chkTUN.Checked) mode = tune_meter_tx_mode;
                            switch (mode)
                            {
                                case MeterTXMode.MIC:
                                case MeterTXMode.LEVELER:
                                case MeterTXMode.LVL_G:
                                case MeterTXMode.EQ:
                                case MeterTXMode.CPDR:
                                case MeterTXMode.ALC:
                                case MeterTXMode.ALC_G:
                                    output = num.ToString(format) + " dB ";
                                    break;
                                case MeterTXMode.FORWARD_POWER:
                                case MeterTXMode.REVERSE_POWER:
                                    switch (current_model)
                                    {
                                        case Model.SDR1000:
                                            if (pa_present && VFOAFreq < 30.0)
                                                output = num.ToString("f0") + " W ";
                                            else output = (num * 1000).ToString("f0") + " mW ";
                                            break;
                                        case Model.FLEX5000:
                                        case Model.FLEX3000:
                                            output = num.ToString("f0") + " W ";
                                            break;
                                        case Model.FLEX1500:
                                            output = num.ToString("f0") + " % ";
                                            break;
                                    }
                                    break;
                                case MeterTXMode.SWR:
                                    output = num.ToString("f1") + " : 1 ";
                                    break;
                                case MeterTXMode.OFF:
                                    output = "";
                                    break;

                            }// switch mode
                        }//mox

                        txtMultiText.Text = output;
                        meter_timer.Start();

                    }// if (meter_timer.DurationMsec >= meter_dig_delay)

                    if (meter_data_ready)
                    {
                        meter_data_ready = false;  //We do NOT want to do this before we have consumed it!!!! so do it here.
                    }

                    #endregion //analogTR7                    

                    break; // original

                //=============================================================
                //=============================================================
                // KE9NS 2 RX1 EDGE meter
                //=============================================================
                //=============================================================

                case MultiMeterDisplayMode.Edge:
                    #region Edges

                    //  string format = "f0";


                    if (meter_data_ready)
                    {
                        if ((!mox) && (new_meter_data > slam)) // ke9ns add: if in RX and new meter data is too strong (Slamming) to be real, then ignore it
                        {
                            meter_peak_value = new_meter_data = -150.0f;
                        }

                        current_meter_data = new_meter_data;
                        meter_data_ready = false;
                    }

                    if (avg_num == Display.CLEAR_FLAG) // reset average -- just use new value
                    {
                        num = avg_num = current_meter_data;
                    }
                    else
                    {
                        if (current_meter_data > avg_num)
                            num = avg_num = current_meter_data * 0.8 + avg_num * 0.2; // fast rise
                        else
                            num = avg_num = current_meter_data * 0.2 + avg_num * 0.8; // slow decay
                    }

                    g.DrawRectangle(new Pen(edge_meter_background_color), 0, 0, W, H); // clear out meter to be redrawn
                    low_brush = new SolidBrush(edge_low_color);
                    high_brush = new SolidBrush(edge_high_color);


                    if (!mox)
                    {
                        switch (current_meter_rx_mode)
                        {
                            case MeterRXMode.SIGNAL_STRENGTH:
                            case MeterRXMode.SIGNAL_AVERAGE:
                            case MeterRXMode.SIGNAL_PEAK:    // ke9ns ADD

                                g.FillRectangle(low_brush, 0, H - 8, (int)(W * 0.5), 2);                    // draw line at bottom of meter white 
                                g.FillRectangle(high_brush, (int)(W * 0.5), H - 8, (int)(W * 0.5) - 4, 2);      // draw line at bottom of meter red

                                double spacing = (W * 0.5 - 2.0) / 5.0;
                                double string_height = 0;

                                for (int i = 1; i < 6; i++)                                                 // white tick marks and white Signal strength numbers
                                {
                                    g.FillRectangle(low_brush, (int)(i * spacing - spacing * 0.5), H - 8 - 3 - 3, 1, 6);
                                    g.FillRectangle(low_brush, (int)(i * spacing), H - 8 - 6 - 6, 2, 12);

                                    //   Font f = new Font("Swis721 BlkEx BT", 7.0f, FontStyle.Bold | FontStyle.Italic); // was 7

                                    SizeF size = g.MeasureString((-1 + i * 2).ToString(), ff, 1, StringFormat.GenericTypographic);
                                    double string_width = size.Width - 2.0;
                                    string_height = size.Height - 2.0;

                                    //  g.TextRenderingHint = TextRenderingHint.AntiAlias;
                                    //  g.SmoothingMode = SmoothingMode.AntiAlias;

                                    g.DrawString((-1 + i * 2).ToString(), ff, low_brush, (int)(i * spacing - string_width + (int)(i / 5)), (int)(H - 8 - 12 - 3 - string_height));

                                    //  g.SmoothingMode = SmoothingMode.None;
                                } // for i


                                spacing = ((double)W * 0.5 - 2.0 - 4.0) / 3.0;
                                for (int i = 1; i < 4; i++)                                              // Red tick marks and white Signal strength numbers
                                {
                                    g.FillRectangle(high_brush, (int)((double)W * 0.5 + i * spacing - spacing * 0.5), H - 8 - 3 - 3, 1, 6);
                                    g.FillRectangle(high_brush, (int)((double)W * 0.5 + i * spacing), H - 8 - 6 - 6, 2, 12);

                                    //   Font f = new Font("swis721blkexbt", 5.5f, FontStyle.Bold | FontStyle.Italic); // was 7

                                    SizeF size = g.MeasureString("+" + (i * 20).ToString(), ff2, 3, StringFormat.GenericTypographic);
                                    double string_width = size.Width - 2.0;

                                    //g.TextRenderingHint = TextRenderingHint.SystemDefault;
                                    g.DrawString("+" + (i * 20).ToString(), ff2, high_brush, (int)(W * 0.5 + i * spacing - (int)string_width * 3 - i / 3 * 2), (int)(H - 8 - 12 - 3 - string_height));
                                }

                                if (FREQA < 30)
                                {
                                    if (num > -73)
                                    {
                                        pixel_x = (int)(W * 0.5 + (73.0 + num) / 63.0 * (W * 0.5 - 3));
                                        pixel_x1 = (int)(W * 0.5 + (73.0 + meter_peak_value) / 63.0 * (W * 0.5 - 3));
                                    }
                                    else
                                    {
                                        pixel_x = (int)((num + 133.0) / 60.0 * (W * 0.5));
                                        pixel_x1 = (int)((meter_peak_value + 133.0) / 60.0 * (W * 0.5));
                                    }
                                } // < 30 mhz
                                else // correction for freq > 29 mhz
                                {
                                    if (num > -93) // ke9ns ADD correct S9 above 30mhz
                                    {
                                        pixel_x = (int)(W * 0.5 + (93.0 + num) / 43.0 * (W * 0.5 - 3));
                                        pixel_x1 = (int)(W * 0.5 + (93.0 + meter_peak_value) / 43.0 * (W * 0.5 - 3));
                                    }
                                    else
                                    {
                                        pixel_x = (int)((num + 133.0) / 40.0 * (W * 0.5));
                                        pixel_x1 = (int)((meter_peak_value + 133.0) / 40.0 * (W * 0.5));
                                    }
                                } // > 29 mhz

                                break; // signal RX1

                            case MeterRXMode.ADC_L:
                            case MeterRXMode.ADC_R:
                            case MeterRXMode.ADC2_L:
                            case MeterRXMode.ADC2_R:
                                spacing = ((double)W - 5.0) / 6.0;
                                g.FillRectangle(low_brush, 0, H - 8, (int)(W - 3.0 - spacing), 2);
                                g.FillRectangle(high_brush, (int)(W - 3.0 - spacing), H - 8, (int)spacing, 2);

                                for (int i = 1; i < 7; i++)
                                {
                                    b = low_brush;
                                    if (i == 6) b = high_brush;
                                    g.FillRectangle(b, (int)(i * spacing - spacing / 2), H - 8 - 3 - 3, 1, 6);
                                    g.FillRectangle(b, (int)(i * spacing), H - 8 - 6 - 6, 2, 12);

                                    //   Font f = new Font("swis721blkexbt", 7.0f, FontStyle.Bold | FontStyle.Italic); // was 7

                                    string s = (-120 + i * 20).ToString();
                                    SizeF size = g.MeasureString(s, ff, 1, StringFormat.GenericTypographic);
                                    double string_width = size.Width - 2.0;
                                    size = g.MeasureString("0", ff, 1, StringFormat.GenericTypographic);
                                    string_height = size.Height - 2.0;

                                    g.DrawString(s, ff, b, (int)(i * spacing - (int)string_width * (s.Length)), (int)(H - 8 - 12 - 3 - string_height));
                                }

                                pixel_x = (int)((num + 120.0) / 120.0 * (W - 5.0));
                                break;
                            case MeterRXMode.OFF:
                                break;
                        }
                    } // !mox
                    else
                    {
                        MeterTXMode mode = current_meter_tx_mode;
                        if (chkTUN.Checked) mode = tune_meter_tx_mode;
                        switch (mode)
                        {
                            case MeterTXMode.MIC:
                            case MeterTXMode.EQ:
                            case MeterTXMode.LEVELER:
                            case MeterTXMode.CPDR:
                            case MeterTXMode.ALC:
                                g.FillRectangle(low_brush, 0, H - 8, (int)(W * 0.665), 2);
                                g.FillRectangle(high_brush, (int)(W * 0.665), H - 8, (int)(W * 0.335) - 2, 2);
                                double spacing = (W * 0.665 - 2.0) / 3.0;
                                double string_height = 0;
                                for (int i = 1; i < 4; i++)
                                {
                                    g.FillRectangle(low_brush, (int)(i * spacing - spacing * 0.5), H - 8 - 3 - 3, 1, 6);
                                    g.FillRectangle(low_brush, (int)(i * spacing), H - 8 - 6 - 6, 2, 12);

                                    string s = (-30 + i * 10).ToString();
                                    //   Font f = new Font("swis721blkexbt", 7.0f, FontStyle.Bold | FontStyle.Italic); // was 7

                                    SizeF size = g.MeasureString("0", ff, 1, StringFormat.GenericTypographic);
                                    double string_width = size.Width - 2.0;
                                    string_height = size.Height - 2.0;

                                    //  g.TextRenderingHint = TextRenderingHint.AntiAlias;
                                    //  g.SmoothingMode = SmoothingMode.AntiAlias;

                                    g.DrawString(s, ff, low_brush, (int)(i * spacing - string_width * s.Length + 1.0 - (int)(i / 2) + (int)(i / 3)), (int)(H - 8 - 12 - 3 - string_height));

                                }
                                spacing = (W * 0.335 - 2.0 - 3.0) / 3.0;
                                for (int i = 1; i < 4; i++)
                                {
                                    g.FillRectangle(high_brush, (int)((double)W * 0.665 + i * spacing - spacing * 0.5), H - 8 - 3 - 3, 1, 6);
                                    g.FillRectangle(high_brush, (int)((double)W * 0.665 + i * spacing), H - 8 - 6 - 6, 2, 12);

                                    //   Font f = new Font("swis721blkexbt", 7.0f, FontStyle.Bold | FontStyle.Italic); // was 7

                                    SizeF size = g.MeasureString(i.ToString(), ff, 3, StringFormat.GenericTypographic);
                                    double string_width = size.Width - 2.0;

                                    //  g.TextRenderingHint = TextRenderingHint.SystemDefault;
                                    g.DrawString(i.ToString(), ff, high_brush, (int)(W * 0.665 + i * spacing - (int)string_width), (int)(H - 8 - 12 - 3 - string_height));
                                }

                                if (num > 0.0) // high area
                                {
                                    pixel_x = (int)(W * 0.665 + num / 3.0 * (W * 0.335 - 4));
                                }
                                else
                                {
                                    pixel_x = (int)((num + 30.0) / 30.0 * (W * 0.665 - 1.0));
                                }
                                break;

                            case MeterTXMode.FORWARD_POWER:
                            case MeterTXMode.REVERSE_POWER:
                                if (pa_present || (fwc_init && (current_model == Model.FLEX5000 || current_model == Model.FLEX3000)) ||
                                    (hid_init && current_model == Model.FLEX1500))
                                {
                                    g.FillRectangle(low_brush, 0, H - 8, (int)(W * 0.75), 2);
                                    g.FillRectangle(high_brush, (int)(W * 0.75), H - 8, (int)(W * 0.25) - 10, 2);
                                    spacing = (W * 0.75 - 2.0) / 4.0;
                                    string_height = 0;
                                    string[] list = { "5", "10", "50", "100" };
                                    for (int i = 1; i < 5; i++)
                                    {
                                        g.FillRectangle(low_brush, (int)(i * spacing - spacing * 0.5), H - 8 - 3 - 3, 1, 6);
                                        g.FillRectangle(low_brush, (int)(i * spacing), H - 8 - 6 - 6, 2, 12);

                                        string s = list[i - 1];
                                        //   Font f = new Font("swis721blkexbt", 7.0f, FontStyle.Bold | FontStyle.Italic); // was 7

                                        SizeF size = g.MeasureString("0", ff, 1, StringFormat.GenericTypographic);
                                        double string_width = size.Width - 2.0;
                                        string_height = size.Height - 2.0;

                                        g.DrawString(s, ff, low_brush, (int)(i * spacing - string_width * s.Length + (int)(i / 3) + (int)(i / 4)), (int)(H - 8 - 12 - 3 - string_height));

                                    }
                                    spacing = (W * 0.25 - 2.0 - 10.0) / 1.0;
                                    for (int i = 1; i < 2; i++)
                                    {
                                        g.FillRectangle(high_brush, (int)((double)W * 0.75 + i * spacing - spacing * 0.5), H - 8 - 3 - 3, 1, 6);
                                        g.FillRectangle(high_brush, (int)((double)W * 0.75 + i * spacing), H - 8 - 6 - 6, 2, 12);

                                        //   Font f = new Font("swis721blkexbt", 7.0f, FontStyle.Bold | FontStyle.Italic); // was 7

                                        SizeF size = g.MeasureString("0", ff, 3, StringFormat.GenericTypographic);
                                        double string_width = size.Width - 2.0;

                                        //   g.TextRenderingHint = TextRenderingHint.SystemDefault;
                                        g.DrawString("120+", ff, high_brush, (int)(W * 0.75 + i * spacing - (int)3.5 * string_width), (int)(H - 8 - 12 - 3 - string_height));
                                    }

                                    if (num <= 100.0) // low area
                                    {
                                        spacing = (W * 0.75 - 2.0) / 4.0;
                                        if (num <= 5.0)
                                            pixel_x = (int)(num / 5.0 * (int)spacing);
                                        else if (num <= 10.0)
                                            pixel_x = (int)(spacing + (num - 5.0) / 5.0 * spacing);
                                        else if (num <= 50.0)
                                            pixel_x = (int)(2 * spacing + (num - 10.0) / 40.0 * spacing);
                                        else
                                            pixel_x = (int)(3 * spacing + (num - 50.0) / 50.0 * spacing);
                                    }
                                    else
                                    {
                                        spacing = (W * 0.25 - 2.0 - 10.0) / 1.0;
                                        if (num <= 120.0)
                                            pixel_x = (int)(W * 0.75 + (num - 100.0) / 20.0 * spacing);
                                        else
                                            pixel_x = (int)(W * 0.75 + spacing + (num - 120.0) / 60.0 * spacing);
                                    }
                                }
                                else // 1W version
                                {
                                    g.FillRectangle(low_brush, 0, H - 8, (int)(W * 0.75), 2);
                                    g.FillRectangle(high_brush, (int)(W * 0.75), H - 8, (int)(W * 0.25) - 9, 2);
                                    spacing = (W * 0.75 - 2.0) / 4.0;
                                    string_height = 0;
                                    string[] list = { "100", "250", "500", "800", "1000" };
                                    for (int i = 1; i < 5; i++)
                                    {
                                        g.FillRectangle(low_brush, (int)(i * spacing - spacing * 0.5), H - 8 - 3 - 3, 1, 6);
                                        g.FillRectangle(low_brush, (int)(i * spacing), H - 8 - 6 - 6, 2, 12);

                                        string s = list[i - 1];
                                        //  Font f = new Font("swis721blkexbt", 7.0f, FontStyle.Bold | FontStyle.Italic); // was 7

                                        SizeF size = g.MeasureString("0", ff, 1, StringFormat.GenericTypographic);
                                        double string_width = size.Width - 2.0;
                                        string_height = size.Height - 2.0;

                                        //g.TextRenderingHint = TextRenderingHint.AntiAlias;
                                        //g.SmoothingMode = SmoothingMode.AntiAlias;
                                        g.DrawString(s, ff, low_brush, (int)(i * spacing - string_width * s.Length + 1.0 + (int)(i / 2) - (int)(i / 4)), (int)(H - 8 - 12 - 3 - string_height));
                                        //g.SmoothingMode = SmoothingMode.None;
                                    }
                                    spacing = (W * 0.25 - 2.0 - 9.0) / 1.0;
                                    for (int i = 1; i < 2; i++)
                                    {
                                        g.FillRectangle(high_brush, (int)((double)W * 0.75 + i * spacing - spacing * 0.5), H - 8 - 3 - 3, 1, 6);
                                        g.FillRectangle(high_brush, (int)((double)W * 0.75 + i * spacing), H - 8 - 6 - 6, 2, 12);

                                        //  Font f = new Font("swis721blkexbt", 7.0f, FontStyle.Bold | FontStyle.Italic); // was 7

                                        SizeF size = g.MeasureString("0", ff, 3, StringFormat.GenericTypographic);
                                        double string_width = size.Width - 2.0;

                                        //g.TextRenderingHint = TextRenderingHint.SystemDefault;
                                        g.DrawString("1000", ff, high_brush, (int)(W * 0.75 + 2 + i * spacing - (int)4.0 * string_width), (int)(H - 8 - 12 - 3 - string_height));
                                    }

                                    num *= 1000;
                                    if (num < 801.0) // low area
                                    {
                                        spacing = (W * 0.75 - 2.0) / 4.0;
                                        if (num <= 100.0)
                                            pixel_x = (int)(num / 100.0 * spacing);
                                        else if (num <= 250.0)
                                            pixel_x = (int)(spacing + (num - 100.0) / 150.0 * spacing);
                                        else if (num <= 500.0)
                                            pixel_x = (int)(2 * spacing + (num - 250.0) / 250.0 * spacing);
                                        else
                                            pixel_x = (int)(3 * spacing + (num - 500.0) / 300.0 * spacing);
                                    }
                                    else
                                    {
                                        spacing = (W * 0.25 - 2.0 - 9.0) / 1.0;
                                        pixel_x = (int)(W * 0.75 + (num - 800.0) / 200.0 * spacing);
                                    }
                                }
                                break;

                            case MeterTXMode.SWR:  // EDGE RX1 W= 164

                                //   g.FillRectangle(low_brush, 0, H - 8, (int)(W * 0.75), 2); // start at 0 span to 123
                                //    g.FillRectangle(high_brush, (int)(W * 0.75), H - 8, (int)(W * 0.25) - 9, 2); // start at 123 and span 41-9


                                g.FillRectangle(grn_brush, 0, H - 8, 45, 2); // ke9ns mod
                                g.FillRectangle(yel_brush, 45, H - 8, 31, 2); // ke9ns mod
                                g.FillRectangle(red_brush, 76, H - 8, 79, 2); // ke9ns mod

                                spacing = (W * 0.75 - 2.0) / 4.0;
                                string_height = 0;
                                string[] swr_list = { "1.5", "2", "5", "10", "20" };

                                for (int i = 1; i < 5; i++)
                                {
                                    g.FillRectangle(low_brush, (int)(i * spacing - spacing * 0.5), H - 8 - 3 - 3, 1, 6);
                                    g.FillRectangle(low_brush, (int)(i * spacing), H - 8 - 6 - 6, 2, 12);

                                    string s = swr_list[i - 1];
                                    //  Font f = new Font("swis721blkexbt", 7.0f, FontStyle.Bold | FontStyle.Italic); // was 7

                                    SizeF size = g.MeasureString("0", ff, 1, StringFormat.GenericTypographic);
                                    double string_width = size.Width - 2.0;
                                    string_height = size.Height - 2.0;

                                    //g.TextRenderingHint = TextRenderingHint.AntiAlias;
                                    //g.SmoothingMode = SmoothingMode.AntiAlias;
                                    g.DrawString(s, ff, low_brush, (int)(i * spacing - string_width * s.Length + 2.0 - 2 * (int)(i / 2) + 3 * (int)(i / 4)), (int)(H - 8 - 12 - 3 - string_height));
                                    //g.SmoothingMode = SmoothingMode.None;
                                }
                                spacing = (W * 0.25 - 2.0 - 9.0) / 1.0;
                                for (int i = 1; i < 2; i++)
                                {
                                    g.FillRectangle(high_brush, (int)((double)W * 0.75 + i * spacing - spacing * 0.5), H - 8 - 3 - 3, 1, 6);
                                    g.FillRectangle(high_brush, (int)((double)W * 0.75 + i * spacing), H - 8 - 6 - 6, 2, 12);


                                    SizeF size = g.MeasureString("0", ff, 3, StringFormat.GenericTypographic);
                                    double string_width = size.Width - 2.0;


                                    g.DrawString("20+", ff, high_brush, (int)(W * 0.75 + i * spacing - (int)2.5 * string_width), (int)(H - 8 - 12 - 3 - string_height));
                                }

                                if (num < 10.0) // low area
                                {
                                    spacing = (W * 0.75 - 2.0) / 4.0;
                                    if (num <= 1.5)
                                        pixel_x = (int)((num - 1.0) / 0.5 * spacing);
                                    else if (num <= 2.0)
                                        pixel_x = (int)(spacing + (num - 1.5) / 0.5 * spacing);
                                    else if (num <= 5.0)
                                        pixel_x = (int)(2 * spacing + (num - 2.0) / 3.0 * spacing);
                                    else
                                        pixel_x = (int)(3 * spacing + (num - 5.0) / 5.0 * spacing);
                                }
                                else
                                {
                                    spacing = (W * 0.25 - 2.0 - 9.0) / 1.0;
                                    pixel_x = (int)(W * 0.75 + (num - 10.0) / 10.0 * spacing);
                                }
                                if (double.IsInfinity(num)) pixel_x = W - 2;
                                break;

                            case MeterTXMode.ALC_G:
                            case MeterTXMode.LVL_G:
                                g.FillRectangle(low_brush, 0, H - 8, (int)(W * 0.75), 2);
                                g.FillRectangle(high_brush, (int)(W * 0.75), H - 8, (int)(W * 0.25) - 9, 2);
                                spacing = (W * 0.75 - 2.0) / 4.0;
                                string_height = 0;
                                string[] gain_list = { "5", "10", "15", "20", "25" };

                                for (int i = 1; i < 5; i++)
                                {
                                    g.FillRectangle(low_brush, (int)(i * spacing - spacing * 0.5), H - 8 - 3 - 3, 1, 6);
                                    g.FillRectangle(low_brush, (int)(i * spacing), H - 8 - 6 - 6, 2, 12);

                                    string s = gain_list[i - 1];
                                    //   Font f = new Font("swis721blkexbt", 7.0f, FontStyle.Bold | FontStyle.Italic); // was 7

                                    SizeF size = g.MeasureString("0", ff, 1, StringFormat.GenericTypographic);
                                    double string_width = size.Width - 2.0;
                                    string_height = size.Height - 2.0;

                                    //g.TextRenderingHint = TextRenderingHint.AntiAlias;
                                    //g.SmoothingMode = SmoothingMode.AntiAlias;
                                    g.DrawString(s, ff, low_brush, (int)(i * spacing - string_width * s.Length + (int)(i / 3)), (int)(H - 8 - 12 - 3 - string_height));
                                    //g.SmoothingMode = SmoothingMode.None;
                                }
                                spacing = (W * 0.25 - 2.0 - 9.0) / 1.0;
                                for (int i = 1; i < 2; i++)
                                {
                                    g.FillRectangle(high_brush, (int)((double)W * 0.75 + i * spacing - spacing * 0.5), H - 8 - 3 - 3, 1, 6);
                                    g.FillRectangle(high_brush, (int)((double)W * 0.75 + i * spacing), H - 8 - 6 - 6, 2, 12);

                                    //  Font f = new Font("swis721blkexbt", 7.0f, FontStyle.Bold | FontStyle.Italic); // was 7

                                    SizeF size = g.MeasureString("0", ff, 3, StringFormat.GenericTypographic);
                                    double string_width = size.Width - 2.0;

                                    //g.TextRenderingHint = TextRenderingHint.SystemDefault;
                                    g.DrawString("25+", ff, high_brush, (int)(W * 0.75 + i * spacing - (int)2.5 * string_width), (int)(H - 8 - 12 - 3 - string_height));
                                }

                                spacing = (W * 0.75 - 2.0) / 4.0;
                                pixel_x = (int)(num / 5.0 * spacing);

                                break;
                            case MeterTXMode.OFF:
                                break;
                        }
                    } // MOX


                    //=============edge meter movement RX1

                    if ((!mox && current_meter_rx_mode != MeterRXMode.OFF) ||
                        (mox && current_meter_tx_mode != MeterTXMode.OFF))
                    {
                        pixel_x = Math.Max(0, pixel_x);
                        pixel_x = Math.Min(W - 3, pixel_x);

                        pixel_x1 = Math.Max(0, pixel_x1);
                        pixel_x1 = Math.Min(W - 3, pixel_x1);

                        line_pen = new Pen(edge_avg_color);

                        //  line_dark_pen = new Pen(
                        //	Color.FromArgb((edge_avg_color.R+edge_meter_background_color.R)/2,
                        //	(edge_avg_color.G+edge_meter_background_color.G)/2,
                        //	(edge_avg_color.B+edge_meter_background_color.B)/2));


                        if ((current_meter_rx_mode == MeterRXMode.SIGNAL_PEAK) && (!mox && current_meter_rx_mode != MeterRXMode.OFF))  // ke9ns ADD
                        {
                            line_pen = new Pen(Color.Red);
                            line_pen.Width = 3.0F;
                            g.DrawLine(line_pen, pixel_x1, 0, pixel_x1, H);

                        } // peak

                        line_pen = new Pen(edge_avg_color);

                        g.DrawLine(line_dark_pen, pixel_x - 1, 0, pixel_x - 1, H); // rx1 edge needle
                        g.DrawLine(line_pen, pixel_x, 0, pixel_x, H);
                        g.DrawLine(line_dark_pen, pixel_x + 1, 0, pixel_x + 1, H);


                    }



                    //===================================================
                    meter_timer.Stop();

                    format = "f0";
                    if (meter_detail) format = "f1";

                    if (meter_timer.DurationMsec >= meter_dig_delay)
                    {
                        if (!mox)
                        {
                            switch (current_meter_rx_mode)
                            {
                                case MeterRXMode.SIGNAL_STRENGTH:

                                case MeterRXMode.SIGNAL_AVERAGE:
                                    output = num.ToString(format) + " dBm ";
                                    break;
                                case MeterRXMode.SIGNAL_PEAK: // ke9ns2 ADD 
                                    output = meter_peak_value.ToString(format) + " dBm ";
                                    break;
                                case MeterRXMode.ADC_L:
                                case MeterRXMode.ADC_R:
                                case MeterRXMode.ADC2_L:
                                case MeterRXMode.ADC2_R:
                                    output = num.ToString("f1") + " dBFS ";
                                    break;
                                case MeterRXMode.OFF:
                                    output = "";
                                    break;
                            }
                        }
                        else
                        {
                            MeterTXMode mode = current_meter_tx_mode;
                            if (chkTUN.Checked) mode = tune_meter_tx_mode;
                            switch (mode)
                            {
                                case MeterTXMode.MIC:
                                case MeterTXMode.LEVELER:
                                case MeterTXMode.LVL_G:
                                case MeterTXMode.EQ:
                                case MeterTXMode.CPDR:
                                case MeterTXMode.ALC:
                                case MeterTXMode.ALC_G:
                                    output = num.ToString(format) + " dB ";
                                    break;
                                case MeterTXMode.FORWARD_POWER:
                                case MeterTXMode.REVERSE_POWER:
                                    switch (current_model)
                                    {
                                        case Model.SDR1000:
                                            if (pa_present && VFOAFreq < 30.0)
                                                output = num.ToString("f0") + " W ";
                                            else output = (num * 1000).ToString("f0") + " mW ";
                                            break;
                                        case Model.FLEX5000:
                                        case Model.FLEX3000:
                                            output = num.ToString("f0") + " W ";
                                            break;
                                        case Model.FLEX1500:
                                            output = num.ToString("f0") + " % ";
                                            break;
                                    }
                                    break;
                                case MeterTXMode.SWR:
                                    output = num.ToString("f1") + " : 1 ";
                                    break;
                                case MeterTXMode.OFF:
                                    output = "";
                                    break;
                            }
                        }
                        txtMultiText.Text = output;
                        meter_timer.Start();
                    }

                    if (meter_data_ready)
                    {
                        meter_data_ready = false;  //We do NOT want to do this before we have consumed it!!!! so do it here.
                    }



                    #endregion // edge

                    break; // case edge

                //=============================================================
                //=============================================================
                //  KE9NS 3 RX1 ANALOG meter
                //=============================================================
                //=============================================================

                case MultiMeterDisplayMode.Analog:
                    #region Analog


                    if (meter_data_ready)
                    {
                        if ((!mox) && (new_meter_data > slam)) // ke9ns add: if in RX and new meter data is too strong(Slamming) to be real, then ignore it
                        {
                            meter_peak_value = new_meter_data = -150.0f;
                        }
                        current_meter_data = new_meter_data; //test
                        meter_data_ready = false;
                    }



                    if (avg_num == Display.CLEAR_FLAG) // reset average -- just use new value
                    {
                        num = avg_num = current_meter_data;
                    }
                    else
                    {
                        if (current_meter_data > avg_num)
                            num = avg_num = current_meter_data * 0.8 + avg_num * 0.2; // fast rise
                        else
                            num = avg_num = current_meter_data * 0.2 + avg_num * 0.8; // slow decay
                    }


                    high_brush = new SolidBrush(analog_high_color); // red


                    //--------------------------------------------------------
                    // ke9ns add below


                    if (meterLMB == true)
                    {
                        low_brush = new SolidBrush(Color.Black); // white text
                        low_brush1 = new Pen(Color.Black);  // white

                        g.DrawImageUnscaled(meterback1, 0, 0); // new Rectangle(0, 0, W, H));  // ke9ns light meter image rectangle to show bitmap image in

                        //  txtMultiText.ForeColor = Color.Black;
                        //  txtMultiText.BackColor = Color.FromArgb(0xff, 0xff, 0xe4);

                    }
                    else if (meterDMB == true)
                    {
                        low_brush = new SolidBrush(Color.Black); // white text
                        low_brush1 = new Pen(Color.Black);  // white

                        g.DrawImageUnscaled(meterback2, 0, 0); // new Rectangle(0, 0, W, H));  // ke9ns dark meter image rectangle to show bitmap image in

                        //   txtMultiText.ForeColor = Color.Black;
                        //  txtMultiText.BackColor = Color.FromArgb(146, 146, 140);

                    }

                    else
                    {
                        low_brush = new SolidBrush(analog_low_color); // white text
                        low_brush1 = new Pen(analog_low_color);  // white

                        g.DrawRectangle(new Pen(analog_meter_background_color), 0, 0, W, H); // black background

                        //  txtMultiText.ForeColor = MeterDigitalTextColor;
                        //  txtMultiText.BackColor = MeterDigitalBackgroundColor;

                    }



                    //=============================================
                    // Receiver meters  ke9ns12 analog RX1
                    //=============================================

                    if (!mox)
                    {
                        switch (current_meter_rx_mode)
                        {
                            case MeterRXMode.SIGNAL_STRENGTH:
                            case MeterRXMode.SIGNAL_AVERAGE:
                            case MeterRXMode.SIGNAL_PEAK:       // ke9ns ADD

                                //=================================================================
                                // Draw curved meter movement for signal strength
                                //=================================================================

                                double line1 = 0;
                                const double angle_start = 55; // ke9ns mod: meter curve is flatter now 45
                                const double angle_span = 70;  // 90


                                int Origin_x = (W + CirX) / 2 - (CirX / 2);  // ke9ns mod: 82 was = (W) / 2;  center of virtual meter circle
                                int Origin_y = (W + CirX) / 2 + CirY;  // ke9ns mod: 151 was (int)((double)((H) * 1.5));  this is the height of the numbers and tick marks with respect to curved line 1.4 slightly below meter window area (where virtual meter adjustment screw would be)

                                //   low_brush1 = new Pen(analog_low_color);  // white


                                high_brush1 = new Pen(analog_high_color); // red Brushes.Red
                                // ke9ns lines under numbers to signify the type of meter
                                high_brush2 = new Pen(Brushes.Blue); // blue
                                high_brush3 = new Pen(Brushes.Yellow); // yellow
                                high_brush4 = new Pen(Brushes.DarkSlateGray); //  

                                double spacing = ((double)(W) * 0.5 - 2.0) / 5.0;
                                double string_height = 0;



                                //======================================
                                // Draw WHITE arc line
                                // upper left corner x,y , width,height, start angle, sweep angle

                                low_brush1.Width = arc_thick; // 3.0
                                                              // g.DrawArc(low_brush1, 0, 37, W, W, -90, -47); // draw OUTER arc (original ke9ns)  ( pen, x, y, wid, hei, start ang, sweep ang )
                                g.DrawArc(low_brush1, -CirXH, CirY, W + CirX, W + CirX, -90, -35);

                                low_brush1.Width = 7.0F;
                                g.DrawArc(low_brush1, -(CirXH + 4), CirY - 3, W + CirX + 8, W + CirX + 8, -118, -5); // -120 -5

                                //======================================
                                // Draw Red arc line
                                // upper left corner x,y , width,height, start angle, sweep angle

                                high_brush1.Width = arc_thick; // 3.0
                                //  g.DrawArc(high_brush1, 0, 37, W, W, -44, -43); // draw OUTER arc was -47 (original ke9ns)
                                g.DrawArc(high_brush1, -CirXH, CirY, W + CirX, W + CirX, -55, -34); // radius = 114


                                //======================================
                                // Draw WHITE full arc line under white/red 
                                // upper left corner x,y , width,height, start angle, sweep angle

                                high_brush4.Width = arc_thick1; // 3.0
                                g.DrawArc(high_brush4, -CirXS, CirYS, W + CirXL, W + CirXL, -55, -70); // draw INNER arc

                                // the virtual center of this circle is W=164  centerX= (W+64)/2 - 32 = 82, centerY = (W+64)/2 + 37 = 151

                                //   g.DrawArc(high_brush4, DTMx,  DTMy , W+DTM , W+DTM , DTMa ,DTMs); // draw INNER arc

                                //======================================
                                // Draw Meter Name text behind needle // 8880
                                //      if (current_meter_rx_mode == MeterRXMode.SIGNAL_STRENGTH) g.DrawString("SIG", ff8, low_brush, W * 0.39F, H * 0.75F); // DDAA
                                //     else if (current_meter_rx_mode == MeterRXMode.SIGNAL_AVERAGE) g.DrawString("AVG", ff8, low_brush, W * 0.39F, H * 0.75F); // DDAA
                                //     else if (current_meter_rx_mode == MeterRXMode.SIGNAL_PEAK) g.DrawString("SIG", ff8, low_brush, W * 0.39F, H * 0.75F); // DDAA

                                //======================================
                                // WHITE  tick marks and text

                                for (double i = 1; i < 6; i++)
                                {

                                    line1 = i * spacing - spacing * 0.5;

                                    double line = (angle_start + ((double)line1 * angle_span / (double)(W)));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    // Cx = 82, Cy=151, R=(W+64)/2= 114

                                    int POSW = (int)((double)(CirR + 8) * Math.Cos(line));  // convert signal to arc
                                    int POSH = (int)((double)(CirR + 8) * Math.Sin(line));

                                    int POSW_BOT = (int)((double)(CirR + 2) * Math.Cos(line));  // convert signal to arc (little tick marks)
                                    int POSH_BOT = (int)((double)(CirR + 2) * Math.Sin(line));


                                    low_brush1.Width = tick_thin;
                                    g.DrawLine(low_brush1, Origin_x - POSW_BOT, Origin_y - POSH_BOT, Origin_x - POSW, Origin_y - POSH);  // draw meter 

                                    line1 = i * spacing;

                                    line = (angle_start + ((double)line1 * angle_span / (double)(W)));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    POSW = (int)((double)(CirR + 14) * Math.Cos(line));  // convert signal to arc
                                    POSH = (int)((double)(CirR + 14) * Math.Sin(line));

                                    POSW_BOT = (int)((double)(CirR + 2) * Math.Cos(line));  // convert signal to arc (big tick marks)
                                    POSH_BOT = (int)((double)(CirR + 2) * Math.Sin(line));

                                    low_brush1.Width = tick_thick;
                                    g.DrawLine(low_brush1, Origin_x - POSW_BOT, Origin_y - POSH_BOT, Origin_x - POSW, Origin_y - POSH);  // draw meter 

                                    //9990

                                    //===============================================
                                    // Draw white numbers

                                    // Font f = new Font("Arial", 8.0f, FontStyle.Bold | FontStyle.Italic); // was 7
                                    //   Font f = new Font("swis721blkexbt", 6.9f, FontStyle.Bold | FontStyle.Italic); // was 7

                                    SizeF size = g.MeasureString((-1 + i * 2).ToString(), ff1, 1, StringFormat.GenericTypographic);
                                    double string_width = size.Width - 2.0;
                                    string_height = size.Height - 2.0;

                                    line1 = (i * spacing - string_width + (i / 5));

                                    line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math


                                    POSW = (int)((double)(CirR + 28) * Math.Cos(line));  // convert signal to arc
                                    POSH = (int)((double)(CirR + 28) * Math.Sin(line));  // was 1.45


                                    g.DrawString((-1 + i * 2).ToString(), ff1, low_brush, Origin_x - POSW, Origin_y - POSH);


                                } // white ticks and test


                                // =======================
                                // RED tick marks and text

                                spacing = ((double)W * 0.5 - 2.0 - 4.0) / 3.0;

                                for (double i = 1; i < 4; i++) //red
                                {

                                    line1 = W * 0.5 + i * spacing - spacing * 0.5;

                                    double line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    int POSW = (int)((double)(CirR + 8) * Math.Cos(line));  // convert signal to arc
                                    int POSH = (int)((double)(CirR + 8) * Math.Sin(line));

                                    int POSW_BOT = (int)((double)(CirR + 2) * Math.Cos(line));  // convert signal to arc
                                    int POSH_BOT = (int)((double)(CirR + 2) * Math.Sin(line));

                                    high_brush1.Width = tick_thin;
                                    g.DrawLine(high_brush1, Origin_x - POSW_BOT, Origin_y - POSH_BOT, Origin_x - POSW, Origin_y - POSH);  // draw meter 

                                    line1 = W * 0.5 + i * spacing;

                                    line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    POSW = (int)((double)(CirR + 14) * Math.Cos(line));  // convert signal to arc
                                    POSH = (int)((double)(CirR + 14) * Math.Sin(line));

                                    POSW_BOT = (int)((double)(CirR + 2) * Math.Cos(line));  // convert signal to arc
                                    POSH_BOT = (int)((double)(CirR + 2) * Math.Sin(line));

                                    high_brush1.Width = tick_thick;
                                    g.DrawLine(high_brush1, Origin_x - POSW_BOT, Origin_y - POSH_BOT, Origin_x - POSW, Origin_y - POSH);  // draw meter 

                                    //==========================================
                                    // draw red text


                                    SizeF size = g.MeasureString("+" + (i * 20).ToString(), ff2, 3, StringFormat.GenericTypographic);
                                    double string_width = size.Width - 2.0;

                                    line1 = (W * 0.5 + i * spacing - string_width * 3 - i / 3 * 2);

                                    line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    POSW = (int)((double)(CirR + 22) * Math.Cos(line));  // convert signal to arc
                                    POSH = (int)((double)(CirR + 22) * Math.Sin(line));


                                    g.DrawString("+" + (i * 20).ToString(), ff2, high_brush, Origin_x - POSW, Origin_y - POSH);
                                    if (i == 3)
                                    {
                                        g.DrawString("dB", ff2, high_brush, (Origin_x - POSW) + 5, (Origin_y - POSH) - 12);
                                    }

                                } // red ticks and text


                                //--------------------------------------
                                //ke9ns add
                                //--------------------------------------

                                //   Image src = new Bitmap(meter1_image);
                                //  g.DrawImage(src, new Rectangle(45, 70, 65, 30));  // rectangle to show bitmap image in

                                //---------------------------------------------

                                if (FREQA < 30)
                                {
                                    if (num > -73)
                                    {
                                        pixel_x = (int)(W * 0.5 + (73.0 + num) / 63.0 * (W * 0.5 - 3));
                                        pixel_x1 = (int)(W * 0.5 + (73.0 + meter_peak_value) / 63.0 * (W * 0.5 - 3));
                                    }
                                    else
                                    {
                                        pixel_x = (int)((num + 133.0) / 60.0 * (W * 0.5));
                                        pixel_x1 = (int)((meter_peak_value + 133.0) / 60.0 * (W * 0.5));
                                    }
                                } // < 30 mhz
                                else // correction for freq > 29 mhz
                                {
                                    if (num > -93) // ke9ns ADD correct S9 above 30mhz
                                    {
                                        pixel_x = (int)(W * 0.5 + (93.0 + num) / 43.0 * (W * 0.5 - 3));
                                        pixel_x1 = (int)(W * 0.5 + (93.0 + meter_peak_value) / 43.0 * (W * 0.5 - 3));
                                    }
                                    else
                                    {
                                        pixel_x = (int)((num + 133.0) / 40.0 * (W * 0.5));
                                        pixel_x1 = (int)((meter_peak_value + 133.0) / 40.0 * (W * 0.5));
                                    }
                                } // > 29 mhz


                                break; // case MeterRXMode.SIGNAL_AVERAGE

                            //=================================== ke9ns this is still ananlog section of code, but used edge for ADC meters
                            case MeterRXMode.ADC_L:
                            case MeterRXMode.ADC_R:
                            case MeterRXMode.ADC2_L:
                            case MeterRXMode.ADC2_R:


                                spacing = ((double)W - 5.0) / 6.0;
                                g.FillRectangle(low_brush, 0, H - 4, (int)(W - 3.0 - spacing), 2);
                                g.FillRectangle(high_brush, (int)(W - 3.0 - spacing), H - 4, (int)spacing, 2);
                                for (int i = 1; i < 7; i++)
                                {
                                    b = low_brush;
                                    if (i == 6) b = high_brush;
                                    g.FillRectangle(b, (int)(i * spacing - spacing / 2), H - 8 - 3 - 3, 1, 6);
                                    g.FillRectangle(b, (int)(i * spacing), H - 8 - 6 - 6, 2, 12);

                                    //  Font f = new Font("swis721blkexbt", 7.0f, FontStyle.Bold | FontStyle.Italic); // was 7

                                    string s = (-120 + i * 20).ToString();
                                    SizeF size = g.MeasureString(s, ff, 1, StringFormat.GenericTypographic);
                                    double string_width = size.Width - 2.0;
                                    size = g.MeasureString("0", ff, 1, StringFormat.GenericTypographic);
                                    string_height = size.Height - 2.0;

                                    g.DrawString(s, ff, b, (int)(i * spacing - (int)string_width * (s.Length)), (int)(H - 8 - 12 - 3 - string_height));
                                }

                                pixel_x = (int)((num + 120.0) / 120.0 * (W - 5.0));
                                break; // case MeterRXMode.ADC2_R:


                            case MeterRXMode.OFF:
                                break;
                        } // switch (current_meter_rx_mode)
                    } // !mox

                    //=============================================
                    // Transmitter meters ke9ns12tx RX1 analog
                    //=============================================

                    else
                    {
                        MeterTXMode mode = current_meter_tx_mode;
                        if (chkTUN.Checked) mode = tune_meter_tx_mode;
                        switch (mode)
                        {
                            case MeterTXMode.MIC:
                            case MeterTXMode.EQ:
                            case MeterTXMode.LEVELER:
                            case MeterTXMode.CPDR:
                            case MeterTXMode.ALC:

                                //=================================================================
                                // Draw curved meter movement for signal strength
                                //=================================================================

                                double line1 = 0;
                                const double angle_start = 55; //45
                                const double angle_span = 70; // 90

                                int Origin_x = (W + CirX) / 2 - (CirX / 2);  // ke9ns mod: 82 was = (W) / 2;  center of virtual meter circle
                                int Origin_y = (W + CirX) / 2 + CirY;  // ke9ns mod: 151 was (int)((double)((H) * 1.5));  this is the height of the numbers and tick marks with respect to curved line 1.4 slightly below meter window area (where virtual meter adjustment screw would be)


                                //  low_brush1 = new Pen(analog_low_color);  // white
                                high_brush1 = new Pen(analog_high_color); // red

                                high_brush2 = new Pen(Brushes.Blue); // blue
                                high_brush3 = new Pen(Brushes.Yellow); // yellow
                                high_brush5 = new Pen(Brushes.Green); // 
                                high_brush4 = new Pen(Brushes.DarkSlateGray); // 

                                double spacing = (W * 0.665 - 2.0) / 3.0;
                                double string_height = 0;

                                //======================================
                                // Draw WHITE arc line
                                // upper left corner x,y , width,height, start angle, sweep angle

                                low_brush1.Width = arc_thick;
                                //  g.DrawArc(low_brush1, 0, 37, W, W, -75, -61); // draw OUTER arc
                                g.DrawArc(low_brush1, -CirXH, CirY, W + CirX, W + CirX, -75, -50);
                                //   g.DrawArc(high_brush4, DTMx,  DTMy , W+DTM , W+DTM , DTMa ,DTMs); // draw INNER arc

                                //======================================
                                // Draw Red arc line
                                // upper left corner x,y , width,height, start angle, sweep angle

                                high_brush1.Width = arc_thick;
                                //  g.DrawArc(high_brush1, 0, 37, W, W, -44, -27); // draw OUTER arc -31
                                g.DrawArc(high_brush1, -CirXH, CirY, W + CirX, W + CirX, -55, -20); // radius = 114

                                //======================================
                                // Draw GREEN full arc line under white/red 
                                // upper left corner x,y , width,height, start angle, sweep angle

                                high_brush5.Width = arc_thick1;
                                // g.DrawArc(high_brush5, 6, 43, W - 12, W - 12, -43, -94); // draw INNER arc
                                g.DrawArc(high_brush5, -CirXS, CirYS, W + CirXL, W + CirXL, -55, -70); // draw INNER arc


                                //====================================== //8880
                                // Draw TX Meter Name text
                                //   if (current_meter_tx_mode == MeterTXMode.CPDR) g.DrawString("CPDR", ff8, low_brush, W * 0.35F, H * 0.75F); // DDAA
                                //   else if (current_meter_tx_mode == MeterTXMode.LEVELER) g.DrawString("LVL", ff8, low_brush, W * 0.39F, H * 0.75F); // DDAA
                                //   else if (current_meter_tx_mode == MeterTXMode.EQ) g.DrawString("EQ", ff8, low_brush, W * 0.405F, H * 0.75F); // DDAA
                                //   else if (current_meter_tx_mode == MeterTXMode.MIC) g.DrawString("MIC", ff8, low_brush, W * 0.39F, H * 0.75F); // DDAA
                                //   else if (current_meter_tx_mode == MeterTXMode.ALC) g.DrawString("ALC", ff8, low_brush, W * 0.39F, H * 0.75F); // DDAA

                                //======================================
                                // WHITE  tick marks and text

                                for (double i = 1; i < 4; i++)
                                {

                                    line1 = i * spacing - spacing * 0.5;

                                    double line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    int POSW = (int)((double)(CirR + 8) * Math.Cos(line));  // convert signal to arc
                                    int POSH = (int)((double)(CirR + 8) * Math.Sin(line));

                                    int POSW_BOT = (int)((double)(CirR + 2) * Math.Cos(line));  // convert signal to arc
                                    int POSH_BOT = (int)((double)(CirR + 2) * Math.Sin(line));

                                    low_brush1.Width = tick_thin;
                                    g.DrawLine(low_brush1, Origin_x - POSW_BOT, Origin_y - POSH_BOT, Origin_x - POSW, Origin_y - POSH);  // draw meter 

                                    line1 = i * spacing;

                                    line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    POSW = (int)((double)(CirR + 14) * Math.Cos(line));  // convert signal to arc
                                    POSH = (int)((double)(CirR + 14) * Math.Sin(line));

                                    POSW_BOT = (int)((double)(CirR + 2) * Math.Cos(line));  // convert signal to arc
                                    POSH_BOT = (int)((double)(CirR + 2) * Math.Sin(line));

                                    low_brush1.Width = tick_thick;
                                    g.DrawLine(low_brush1, Origin_x - POSW_BOT, Origin_y - POSH_BOT, Origin_x - POSW, Origin_y - POSH);  // draw meter 



                                    //===============================================
                                    // Draw white numbers ALC RX1 analog


                                    SizeF size = g.MeasureString("0", ff1, 1, StringFormat.GenericTypographic);
                                    double string_width = size.Width - 2.0;
                                    string_height = size.Height - 2.0;

                                    line1 = (i * spacing - string_width + (i / 5));

                                    line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    if (i == 1)
                                    {
                                        POSW = (int)((double)(CirR + 30) * Math.Cos(line));  // convert signal to arc
                                        POSH = (int)((double)(CirR + 30) * Math.Sin(line));
                                    }
                                    else
                                    {
                                        POSW = (int)((double)(CirR + 28) * Math.Cos(line));  // 1.4 convert signal to arc
                                        POSH = (int)((double)(CirR + 28) * Math.Sin(line));  // 1.48
                                    }
                                    g.DrawString((-30 + i * 10).ToString(), ff1, low_brush, Origin_x - POSW - 3, Origin_y - POSH);


                                } // white ticks and test


                                // =======================
                                // RED tick marks and text

                                spacing = (W * 0.335 - 2.0 - 3.0) / 3.0;

                                for (double i = 1; i < 4; i++) //red
                                {

                                    line1 = W * 0.665 + i * spacing - spacing * 0.5;

                                    double line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    int POSW = (int)((double)(CirR + 8) * Math.Cos(line));  // convert signal to arc
                                    int POSH = (int)((double)(CirR + 8) * Math.Sin(line));

                                    int POSW_BOT = (int)((double)(CirR + 2) * Math.Cos(line));  // convert signal to arc
                                    int POSH_BOT = (int)((double)(CirR + 2) * Math.Sin(line));

                                    high_brush1.Width = tick_thin;
                                    g.DrawLine(high_brush1, Origin_x - POSW_BOT, Origin_y - POSH_BOT, Origin_x - POSW, Origin_y - POSH);  // draw meter 

                                    line1 = W * 0.665 + i * spacing;

                                    line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    POSW = (int)((double)(CirR + 14) * Math.Cos(line));  // convert signal to arc
                                    POSH = (int)((double)(CirR + 14) * Math.Sin(line));

                                    POSW_BOT = (int)((double)(CirR + 2) * Math.Cos(line));  // convert signal to arc
                                    POSH_BOT = (int)((double)(CirR + 2) * Math.Sin(line));

                                    high_brush1.Width = tick_thick;
                                    g.DrawLine(high_brush1, Origin_x - POSW_BOT, Origin_y - POSH_BOT, Origin_x - POSW, Origin_y - POSH);  // draw meter 

                                    //==========================================
                                    // draw red text alc rx1 analog


                                    SizeF size = g.MeasureString(i.ToString(), ff2, 3, StringFormat.GenericTypographic);
                                    double string_width = size.Width - 2.0;

                                    line1 = (W * 0.665 + i * spacing - (int)string_width);

                                    line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    POSW = (int)((double)(CirR + 22) * Math.Cos(line));  // convert signal to arc
                                    POSH = (int)((double)(CirR + 22) * Math.Sin(line));


                                    g.DrawString(i.ToString(), ff2, high_brush, Origin_x - POSW, Origin_y - POSH);

                                } // red ticks and text


                                if (num > 0.0) // high area
                                {
                                    pixel_x = (int)(W * 0.665 + num / 3.0 * (W * 0.335 - 4));
                                }
                                else
                                {
                                    pixel_x = (int)((num + 30.0) / 30.0 * (W * 0.665 - 1.0));
                                }
                                break; // case MeterTXMode.ALC:

                            //===========================================

                            case MeterTXMode.FORWARD_POWER:
                            case MeterTXMode.REVERSE_POWER:

                                line1 = 0;

                                //  angle_start = 55; //45
                                //   angle_span = 70; // 90

                                Origin_x = (W + CirX) / 2 - (CirX / 2);  // ke9ns mod: 82 was = (W) / 2;  center of virtual meter circle
                                Origin_y = (W + CirX) / 2 + CirY;  // ke9ns mod: 151 was (int)((double)((H) * 1.5));  this is the height of the numbers and tick marks with respect to curved line 1.4 slightly below meter window area (where virtual meter adjustment screw would be)


                                //   low_brush1 = new Pen(analog_low_color);  // white
                                high_brush1 = new Pen(analog_high_color); // red

                                high_brush2 = new Pen(Brushes.Blue); // blue
                                high_brush3 = new Pen(Brushes.Yellow); // yellow
                                high_brush4 = new Pen(Brushes.DarkSlateGray); // 

                                if (pa_present || (fwc_init && (current_model == Model.FLEX5000 || current_model == Model.FLEX3000)) ||
                                    (hid_init && current_model == Model.FLEX1500))
                                {

                                    //=================================================================
                                    // Draw curved meter movement for Power
                                    //=================================================================

                                    //======================================
                                    // Draw WHITE arc line
                                    // upper left corner x,y , width,height, start angle, sweep angle

                                    low_brush1.Width = arc_thick;
                                    //  g.DrawArc(low_brush1, 0, 37, W, W, -67, -68); // draw OUTER arc
                                    g.DrawArc(low_brush1, -CirXH, CirY, W + CirX, W + CirX, -75, -50);
                                    //   g.DrawArc(high_brush4, DTMx,  DTMy , W+DTM , W+DTM , DTMa ,DTMs); // draw INNER arc

                                    //======================================
                                    // Draw Red arc line
                                    // upper left corner x,y , width,height, start angle, sweep angle

                                    high_brush1.Width = arc_thick;
                                    //   g.DrawArc(high_brush1, 0, 37, W, W, -44, -20); // draw OUTER arc -24
                                    g.DrawArc(high_brush1, -CirXH, CirY, W + CirX, W + CirX, -55, -20); // radius = 114

                                    //======================================
                                    // Draw BLUE full arc line under white/red 
                                    // upper left corner x,y , width,height, start angle, sweep angle

                                    high_brush2.Width = arc_thick1;
                                    //   g.DrawArc(high_brush2, 6, 43, W - 12, W - 12, -43, -94); // draw INNER arc
                                    g.DrawArc(high_brush2, -CirXS, CirYS, W + CirXL, W + CirXL, -55, -70); // draw INNER arc



                                    //======================================
                                    // Draw TX Meter Name text
                                    //    if (current_meter_tx_mode == MeterTXMode.FORWARD_POWER) g.DrawString("FWD", ff8, low_brush, W * 0.375F, H * 0.75F); // DDAA
                                    //    else if (current_meter_tx_mode == MeterTXMode.REVERSE_POWER) g.DrawString("REV", ff8, low_brush, W * 0.38F, H * 0.75F); // DDAA

                                    //======================================
                                    // WHITE  tick marks and text


                                    spacing = (W * 0.75 - 2.0) / 4.0;
                                    string_height = 0;
                                    string[] list = { "5", "10", "50", "100" };

                                    for (double i = 1; i < 5; i++)
                                    {

                                        line1 = i * spacing - spacing * 0.5;

                                        double line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                        line = line * CirA;                                                // convert angle to radians for cos/sin math

                                        int POSW = (int)((double)(CirR + 8) * Math.Cos(line));  // convert signal to arc
                                        int POSH = (int)((double)(CirR + 8) * Math.Sin(line));

                                        int POSW_BOT = (int)((double)(CirR + 2) * Math.Cos(line));  // convert signal to arc
                                        int POSH_BOT = (int)((double)(CirR + 2) * Math.Sin(line));

                                        low_brush1.Width = tick_thin;
                                        g.DrawLine(low_brush1, Origin_x - POSW_BOT, Origin_y - POSH_BOT, Origin_x - POSW, Origin_y - POSH);  // draw meter 

                                        line1 = i * spacing;

                                        line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                        line = line * CirA;                                                // convert angle to radians for cos/sin math

                                        POSW = (int)((double)(CirR + 14) * Math.Cos(line));  // convert signal to arc
                                        POSH = (int)((double)(CirR + 14) * Math.Sin(line));

                                        POSW_BOT = (int)((double)(CirR + 2) * Math.Cos(line));  // convert signal to arc
                                        POSH_BOT = (int)((double)(CirR + 2) * Math.Sin(line));

                                        low_brush1.Width = tick_thick;
                                        g.DrawLine(low_brush1, Origin_x - POSW_BOT, Origin_y - POSH_BOT, Origin_x - POSW, Origin_y - POSH);  // draw meter 



                                        //===============================================
                                        // Draw white numbers fwd rx1 analog

                                        string s = list[(int)i - 1];

                                        SizeF size = g.MeasureString("0", ff1, 1, StringFormat.GenericTypographic);
                                        double string_width = size.Width - 2.0;
                                        string_height = size.Height - 2.0;

                                        line1 = i * spacing - string_width * s.Length + (int)(i / 3) + (int)(i / 4);

                                        line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                        line = line * CirA;                                                // convert angle to radians for cos/sin math

                                        if (i == 1)
                                        {
                                            POSW = (int)((double)(CirR + 29) * Math.Cos(line));  // convert signal to arc
                                            POSH = (int)((double)(CirR + 29) * Math.Sin(line));
                                        }
                                        else
                                        {
                                            POSW = (int)((double)(CirR + 27) * Math.Cos(line));  //1.4  convert signal to arc
                                            POSH = (int)((double)(CirR + 27) * Math.Sin(line));  // 1.48
                                        }
                                        g.DrawString(s, ff1, low_brush, Origin_x - POSW, Origin_y - POSH);


                                    } // white ticks and test

                                    // =======================
                                    // RED tick marks and text

                                    spacing = (W * 0.25 - 2.0 - 10.0) / 1.0;

                                    for (double i = 1; i < 2; i++) //red
                                    {

                                        line1 = (double)W * 0.75 + i * spacing - spacing * 0.5;

                                        double line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                        line = line * CirA;                                                // convert angle to radians for cos/sin math

                                        int POSW = (int)((double)(CirR + 8) * Math.Cos(line));  // convert signal to arc
                                        int POSH = (int)((double)(CirR + 8) * Math.Sin(line));

                                        int POSW_BOT = (int)((double)(CirR + 2) * Math.Cos(line));  // convert signal to arc
                                        int POSH_BOT = (int)((double)(CirR + 2) * Math.Sin(line));

                                        high_brush1.Width = tick_thin;

                                        g.DrawLine(high_brush1, Origin_x - POSW_BOT, Origin_y - POSH_BOT, Origin_x - POSW, Origin_y - POSH);  // draw meter 

                                        line1 = (double)W * 0.75 + i * spacing;

                                        line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                        line = line * CirA;                                                // convert angle to radians for cos/sin math

                                        POSW = (int)((double)(CirR + 14) * Math.Cos(line));  // convert signal to arc
                                        POSH = (int)((double)(CirR + 14) * Math.Sin(line));

                                        POSW_BOT = (int)((double)(CirR + 2) * Math.Cos(line));  // convert signal to arc
                                        POSH_BOT = (int)((double)(CirR + 2) * Math.Sin(line));

                                        high_brush1.Width = tick_thick;
                                        g.DrawLine(high_brush1, Origin_x - POSW_BOT, Origin_y - POSH_BOT, Origin_x - POSW, Origin_y - POSH);  // draw meter 

                                        //==========================================
                                        // draw red text fwd analog


                                        SizeF size = g.MeasureString("0", ff2, 3, StringFormat.GenericTypographic);
                                        double string_width = size.Width - 2.0;

                                        line1 = W * 0.75 + i * spacing - (int)3.5 * string_width;

                                        line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                        line = line * CirA;                                                // convert angle to radians for cos/sin math

                                        POSW = (int)((double)(CirR + 22) * Math.Cos(line));  // convert signal to arc
                                        POSH = (int)((double)(CirR + 22) * Math.Sin(line));


                                        g.DrawString("120+", ff2, high_brush, Origin_x - POSW, Origin_y - POSH);

                                    } // red ticks and text


                                    if (num <= 100.0) // low area
                                    {
                                        spacing = (W * 0.75 - 2.0) / 4.0;
                                        if (num <= 5.0)
                                            pixel_x = (int)(num / 5.0 * (int)spacing);
                                        else if (num <= 10.0)
                                            pixel_x = (int)(spacing + (num - 5.0) / 5.0 * spacing);
                                        else if (num <= 50.0)
                                            pixel_x = (int)(2 * spacing + (num - 10.0) / 40.0 * spacing);
                                        else
                                            pixel_x = (int)(3 * spacing + (num - 50.0) / 50.0 * spacing);
                                    }
                                    else
                                    {
                                        spacing = (W * 0.25 - 2.0 - 10.0) / 1.0;
                                        if (num <= 120.0)
                                            pixel_x = (int)(W * 0.75 + (num - 100.0) / 20.0 * spacing);
                                        else
                                            pixel_x = (int)(W * 0.75 + spacing + (num - 120.0) / 60.0 * spacing);
                                    }
                                } //



                                break; //case MeterTXMode.REVERSE_POWER:

                            //==========================================
                            #region analog SWR
                            case MeterTXMode.SWR: // analog meter

                                //=================================================================
                                // Draw curved meter movement for SWR
                                //=================================================================

                                line1 = 0;
                                //  angle_start = 45;
                                //  angle_span = 90;

                                Origin_x = (W + CirX) / 2 - (CirX / 2);  // ke9ns mod: 82 was = (W) / 2;  center of virtual meter circle
                                Origin_y = (W + CirX) / 2 + CirY;  // ke9ns mod: 151 was (int)((double)((H) * 1.5));  this is the height of the numbers and tick marks with respect to curved line 1.4 slightly below meter window area (where virtual meter adjustment screw would be)



                                //   low_brush1 = new Pen(analog_low_color);  // white
                                high_brush7 = new Pen(Brushes.Green); // green
                                high_brush2 = new Pen(Brushes.Red); // red
                                high_brush1 = new Pen(analog_high_color); // red
                                high_brush3 = new Pen(Brushes.Yellow); // yellow
                                high_brush4 = new Pen(Brushes.AntiqueWhite); // 


                                // startang, sweepang
                                // -90, 0 would be top side half circle (horizontal) with -45 being middle

                                //======================================
                                // Draw WHITE arc line
                                // upper left corner x,y , width,height, start angle, sweep angle


                                grn_pen.Width = arc_thick;
                                //  g.DrawArc(grn_pen, 0, 37, W, W, -110, -26); // draw OUTER arc 
                                g.DrawArc(grn_pen, -CirXH, CirY, W + CirX, W + CirX, -105, -20); // -100 , -20
                                //   g.DrawArc(high_brush4, DTMx,  DTMy , W+DTM , W+DTM , DTMa ,DTMs); // draw INNER arc

                                //======================================
                                // Draw yel arc line

                                yel_pen.Width = arc_thick;
                                //  g.DrawArc(yel_pen, 0, 37, W, W, -93, -17); // draw OUTER arc 
                                g.DrawArc(yel_pen, -CirXH, CirY, W + CirX, W + CirX, -93, -12); // -85 -10

                                //======================================
                                // Draw Red arc line
                                // upper left corner x,y , width,height, start angle, sweep angle

                                red_pen.Width = arc_thick;
                                //  g.DrawArc(red_pen, 0, 37, W, W, -43, -51); // draw OUTER arc 
                                g.DrawArc(red_pen, -CirXH, CirY, W + CirX, W + CirX, -55, -38); // radius = 114


                                //======================================
                                // Draw Yellow full arc line under white/red 
                                // upper left corner x,y , width,height, start angle, sweep angle

                                high_brush3.Width = arc_thick1;
                                //  g.DrawArc(high_brush3, 6, 43, W - 12, W - 12, -43, -94); // draw INNER arc
                                g.DrawArc(high_brush3, -CirXS, CirYS, W + CirXL, W + CirXL, -55, -70); // draw INNER arc


                                //======================================//8880
                                // Draw TX Meter Name text
                                //   if (current_meter_tx_mode == MeterTXMode.SWR) g.DrawString("SWR", ff8, low_brush, W * 0.375F, H * 0.75F); // DDAA

                                //======================================
                                // WHITE  tick marks and text SWR


                                spacing = (W * 0.75 - 2.0) / 4.0;
                                string_height = 0;
                                string[] swr_list = { "1.5", "2", "5", "10", "20" };

                                for (double i = 1; i < 5; i++)
                                {

                                    line1 = i * spacing - spacing * 0.5;

                                    double line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    int POSW = (int)((double)(CirR + 8) * Math.Cos(line));  // convert signal to arc
                                    int POSH = (int)((double)(CirR + 8) * Math.Sin(line));

                                    int POSW_BOT = (int)((double)(CirR + 2) * Math.Cos(line));  // convert signal to arc
                                    int POSH_BOT = (int)((double)(CirR + 2) * Math.Sin(line));

                                    low_brush1.Width = tick_thin;
                                    g.DrawLine(low_brush1, Origin_x - POSW_BOT, Origin_y - POSH_BOT, Origin_x - POSW, Origin_y - POSH);  // draw meter 

                                    line1 = i * spacing;

                                    line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    POSW = (int)((double)(CirR + 14) * Math.Cos(line));  // convert signal to arc
                                    POSH = (int)((double)(CirR + 14) * Math.Sin(line));

                                    POSW_BOT = (int)((double)(CirR + 2) * Math.Cos(line));  // convert signal to arc
                                    POSH_BOT = (int)((double)(CirR + 2) * Math.Sin(line));

                                    low_brush1.Width = tick_thick;
                                    g.DrawLine(low_brush1, Origin_x - POSW_BOT, Origin_y - POSH_BOT, Origin_x - POSW, Origin_y - POSH);  // draw meter 


                                    //===============================================
                                    // Draw white numbers rx1 swr analog

                                    string s = swr_list[(int)i - 1];


                                    SizeF size = g.MeasureString("0", ff1, 1, StringFormat.GenericTypographic);
                                    double string_width = size.Width - 2.0;
                                    string_height = size.Height - 2.0;


                                    line1 = i * spacing - string_width * s.Length + 2.0 - 2 * (int)(i / 2) + 3 * (int)(i / 4);

                                    if (i == 1) line1 = line1 + 10;


                                    line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    if (i == 1)
                                    {
                                        POSW = (int)((double)(CirR + 31) * Math.Cos(line));  // convert signal to arc
                                        POSH = (int)((double)(CirR + 31) * Math.Sin(line));
                                    }
                                    else
                                    {
                                        POSW = (int)((double)(CirR + 28) * Math.Cos(line));  // convert signal to arc
                                        POSH = (int)((double)(CirR + 28) * Math.Sin(line));
                                    }

                                    g.DrawString(s, ff1, low_brush, Origin_x - POSW, Origin_y - POSH);


                                } // white ticks and text

                                // =======================
                                // RED tick marks and text

                                spacing = (W * 0.25 - 2.0 - 9.0) / 1.0;

                                for (double i = 1; i < 2; i++) //red
                                {

                                    line1 = (double)W * 0.75 + i * spacing - spacing * 0.5;

                                    double line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    int POSW = (int)((double)(CirR + 8) * Math.Cos(line));  // convert signal to arc
                                    int POSH = (int)((double)(CirR + 8) * Math.Sin(line));

                                    int POSW_BOT = (int)((double)(CirR + 2) * Math.Cos(line));  // convert signal to arc
                                    int POSH_BOT = (int)((double)(CirR + 2) * Math.Sin(line));

                                    high_brush1.Width = tick_thin;
                                    g.DrawLine(high_brush1, Origin_x - POSW_BOT, Origin_y - POSH_BOT, Origin_x - POSW, Origin_y - POSH);  // draw meter 

                                    line1 = (double)W * 0.75 + i * spacing;

                                    line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    POSW = (int)((double)(CirR + 14) * Math.Cos(line));  // convert signal to arc
                                    POSH = (int)((double)(CirR + 14) * Math.Sin(line));

                                    POSW_BOT = (int)((double)(CirR + 2) * Math.Cos(line));  // convert signal to arc
                                    POSH_BOT = (int)((double)(CirR + 2) * Math.Sin(line));

                                    high_brush1.Width = tick_thick;
                                    g.DrawLine(high_brush1, Origin_x - POSW_BOT, Origin_y - POSH_BOT, Origin_x - POSW, Origin_y - POSH);  // draw meter 

                                    //==========================================
                                    // draw red text


                                    SizeF size = g.MeasureString("0", ff2, 3, StringFormat.GenericTypographic);
                                    double string_width = size.Width - 2.0;

                                    line1 = W * 0.75 + i * spacing - (int)3.5 * string_width;

                                    line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    POSW = (int)((double)(CirR + 23) * Math.Cos(line));  // convert signal to arc
                                    POSH = (int)((double)(CirR + 23) * Math.Sin(line));

                                    g.DrawString("20+", ff2, high_brush, Origin_x - POSW, Origin_y - POSH);

                                } // red ticks and text



                                if (num < 10.0) // low area
                                {
                                    spacing = (W * 0.75 - 2.0) / 4.0;
                                    if (num <= 1.5)
                                        pixel_x = (int)((num - 1.0) / 0.5 * spacing);
                                    else if (num <= 2.0)
                                        pixel_x = (int)(spacing + (num - 1.5) / 0.5 * spacing);
                                    else if (num <= 5.0)
                                        pixel_x = (int)(2 * spacing + (num - 2.0) / 3.0 * spacing);
                                    else
                                        pixel_x = (int)(3 * spacing + (num - 5.0) / 5.0 * spacing);
                                }
                                else
                                {
                                    spacing = (W * 0.25 - 2.0 - 9.0) / 1.0;
                                    pixel_x = (int)(W * 0.75 + (num - 10.0) / 10.0 * spacing);
                                }
                                if (double.IsInfinity(num)) pixel_x = W - 2;

                                break;// case MeterTXMode.SWR:
                            #endregion // SWR

                            case MeterTXMode.ALC_G:
                            case MeterTXMode.LVL_G:

                                //=================================================================
                                // Draw curved meter movement for signal strength
                                //=================================================================

                                line1 = 0;
                                //  angle_start = 45;
                                //  angle_span = 90;

                                Origin_x = (W + CirX) / 2 - (CirX / 2);  // ke9ns mod: 82 was = (W) / 2;  center of virtual meter circle
                                Origin_y = (W + CirX) / 2 + CirY;  // ke9ns mod: 151 was (int)((double)((H) * 1.5));  this is the height of the numbers and tick marks with respect to curved line 1.4 slightly below meter window area (where virtual meter adjustment screw would be)


                                //     low_brush1 = new Pen(analog_low_color);  // white


                                high_brush2 = new Pen(Brushes.Blue); // blue
                                high_brush1 = new Pen(analog_high_color); // red
                                high_brush3 = new Pen(Brushes.Yellow); // yellow
                                high_brush5 = new Pen(Brushes.Green); // 
                                high_brush4 = new Pen(Brushes.DarkSlateGray); // 


                                spacing = (W * 0.75 - 2.0) / 4.0;
                                string_height = 0;
                                string[] gain_list = { "5", "10", "15", "20", "25" };


                                //=================================================================
                                // Draw curved meter movement for Power
                                //=================================================================

                                //======================================
                                // Draw WHITE arc line
                                // upper left corner x,y , width,height, start angle, sweep angle

                                low_brush1.Width = arc_thick;
                                //  g.DrawArc(low_brush1, 0, 37, W, W, -67, -68); // draw OUTER arc
                                g.DrawArc(low_brush1, -CirXH, CirY, W + CirX, W + CirX, -75, -50);
                                //   g.DrawArc(high_brush4, DTMx,  DTMy , W+DTM , W+DTM , DTMa ,DTMs); // draw INNER arc

                                //======================================
                                // Draw Red arc line
                                // upper left corner x,y , width,height, start angle, sweep angle

                                high_brush1.Width = arc_thick;
                                //  g.DrawArc(high_brush1, 0, 37, W, W, -44, -20); // draw OUTER arc -24
                                g.DrawArc(high_brush1, -CirXH, CirY, W + CirX, W + CirX, -55, -20); // radius = 114

                                //======================================
                                // Draw Green full arc line under white/red 
                                // upper left corner x,y , width,height, start angle, sweep angle

                                high_brush5.Width = arc_thick1;
                                //  g.DrawArc(high_brush5, 6, 43, W - 12, W - 12, -43, -94); // draw INNER arc
                                g.DrawArc(high_brush5, -CirXS, CirYS, W + CirXL, W + CirXL, -55, -70); // draw INNER arc


                                //====================================== //8880
                                // Draw TX Meter Name text
                                //   if (current_meter_tx_mode == MeterTXMode.LVL_G) g.DrawString("LVLG", ff8, low_brush, W * 0.35F, H * 0.75F); // DDAA
                                //   else if (current_meter_tx_mode == MeterTXMode.ALC_G) g.DrawString("ALCG", ff8, low_brush, W * 0.35F, H * 0.75F); // DDAA

                                //======================================
                                // WHITE  tick marks and text

                                for (double i = 1; i < 5; i++)
                                {

                                    line1 = i * spacing - spacing * 0.5;

                                    double line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    int POSW = (int)((double)(CirR + 8) * Math.Cos(line));  // convert signal to arc
                                    int POSH = (int)((double)(CirR + 8) * Math.Sin(line));

                                    int POSW_BOT = (int)((double)(CirR + 2) * Math.Cos(line));  // convert signal to arc
                                    int POSH_BOT = (int)((double)(CirR + 2) * Math.Sin(line));

                                    low_brush1.Width = tick_thin;
                                    g.DrawLine(low_brush1, Origin_x - POSW_BOT, Origin_y - POSH_BOT, Origin_x - POSW, Origin_y - POSH);  // draw meter 

                                    line1 = i * spacing;

                                    line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    POSW = (int)((double)(CirR + 14) * Math.Cos(line));  // convert signal to arc
                                    POSH = (int)((double)(CirR + 14) * Math.Sin(line));

                                    POSW_BOT = (int)((double)(CirR + 2) * Math.Cos(line));  // convert signal to arc
                                    POSH_BOT = (int)((double)(CirR + 2) * Math.Sin(line));

                                    low_brush1.Width = tick_thick;
                                    g.DrawLine(low_brush1, Origin_x - POSW_BOT, Origin_y - POSH_BOT, Origin_x - POSW, Origin_y - POSH);  // draw meter 


                                    //===============================================
                                    // Draw white numbers

                                    string s = gain_list[(int)i - 1];
                                    //   Font f = new Font("swis721blkexbt", 6.9f, FontStyle.Bold | FontStyle.Italic); // was 7

                                    SizeF size = g.MeasureString("0", ff1, 1, StringFormat.GenericTypographic);
                                    double string_width = size.Width - 2.0;
                                    string_height = size.Height - 2.0;

                                    line1 = (i * spacing - string_width + (i / 5));

                                    line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    if (i == 1)
                                    {
                                        POSW = (int)((double)(CirR + 29) * Math.Cos(line));  // convert signal to arc
                                        POSH = (int)((double)(CirR + 29) * Math.Sin(line));
                                    }
                                    else
                                    {
                                        POSW = (int)((double)(CirR + 27) * Math.Cos(line));  // convert signal to arc
                                        POSH = (int)((double)(CirR + 27) * Math.Sin(line));

                                    }
                                    g.DrawString(s, ff1, low_brush, Origin_x - POSW, Origin_y - POSH);

                                } // white ticks and test



                                // =======================
                                // RED tick marks and text

                                spacing = (W * 0.25 - 2.0 - 9.0) / 1.0;

                                for (double i = 1; i < 2; i++) //red
                                {

                                    line1 = W * 0.75 + i * spacing - spacing * 0.5;

                                    double line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    int POSW = (int)((double)(CirR + 8) * Math.Cos(line));  // convert signal to arc
                                    int POSH = (int)((double)(CirR + 8) * Math.Sin(line));

                                    int POSW_BOT = (int)((double)(CirR + 2) * Math.Cos(line));  // convert signal to arc
                                    int POSH_BOT = (int)((double)(CirR + 2) * Math.Sin(line));

                                    high_brush1.Width = tick_thin;
                                    g.DrawLine(high_brush1, Origin_x - POSW_BOT, Origin_y - POSH_BOT, Origin_x - POSW, Origin_y - POSH);  // draw meter 

                                    line1 = W * 0.75 + i * spacing;

                                    line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    POSW = (int)((double)(CirR + 14) * Math.Cos(line));  // convert signal to arc
                                    POSH = (int)((double)(CirR + 14) * Math.Sin(line));

                                    POSW_BOT = (int)((double)(CirR + 2) * Math.Cos(line));  // convert signal to arc
                                    POSH_BOT = (int)((double)(CirR + 2) * Math.Sin(line));

                                    high_brush1.Width = tick_thick;
                                    g.DrawLine(high_brush1, Origin_x - POSW_BOT, Origin_y - POSH_BOT, Origin_x - POSW, Origin_y - POSH);  // draw meter 

                                    //==========================================
                                    // draw red text


                                    SizeF size = g.MeasureString("0", ff2, 3, StringFormat.GenericTypographic);
                                    double string_width = size.Width - 2.0;


                                    line1 = (W * 0.75 + i * spacing - (int)2.5 * string_width);

                                    line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    POSW = (int)((double)(CirR + 23) * Math.Cos(line));  // convert signal to arc
                                    POSH = (int)((double)(CirR + 23) * Math.Sin(line));


                                    g.DrawString("25+", ff2, high_brush, Origin_x - POSW, Origin_y - POSH);

                                } // red ticks and text

                                spacing = (W * 0.75 - 2.0) / 4.0;
                                pixel_x = (int)(num / 5.0 * spacing);

                                break;// case MeterTXMode.LVL_G:




                            case MeterTXMode.OFF:
                                break;
                        } // switch (mode)
                    } // mox


                    //=============================================
                    // ke9ns Needle movement RX1 ANALOG ke9ns12
                    //=============================================


                    if (                  //edge needle if not one of my meter movements
                            (((current_meter_rx_mode == MeterRXMode.ADC2_R) || (current_meter_rx_mode == MeterRXMode.ADC2_L) ||
                            (current_meter_rx_mode == MeterRXMode.ADC_R) || (current_meter_rx_mode == MeterRXMode.ADC_L)) &&
                            (!mox && current_meter_rx_mode != MeterRXMode.OFF))
                       )

                    {
                        pixel_x = Math.Max(0, pixel_x);
                        pixel_x = Math.Min(W - 3, pixel_x);

                        line_pen = new Pen(edge_avg_color); // yellow


                        //  line_dark_pen = new Pen(
                        //       Color.FromArgb((edge_avg_color.R + edge_meter_background_color.R) / 2,
                        //       (edge_avg_color.G + edge_meter_background_color.G) / 2,
                        //       (edge_avg_color.B + edge_meter_background_color.B) / 2));



                        g.DrawLine(line_dark_pen, pixel_x - 1, 0, pixel_x - 1, H); // rx1 analog edge needle
                        g.DrawLine(line_pen, pixel_x, 0, pixel_x, H);
                        g.DrawLine(line_dark_pen, pixel_x + 1, 0, pixel_x + 1, H);


                    } // edge needle

                    else if (  // TX meter movements
                                 ((mox && current_meter_tx_mode != MeterTXMode.OFF) && ((current_meter_tx_mode == MeterTXMode.LVL_G) ||
                                 (current_meter_tx_mode == MeterTXMode.ALC_G) || (current_meter_tx_mode == MeterTXMode.CPDR) ||
                                 (current_meter_tx_mode == MeterTXMode.LEVELER) || (current_meter_tx_mode == MeterTXMode.EQ) ||
                                 (current_meter_tx_mode == MeterTXMode.MIC) || (current_meter_tx_mode == MeterTXMode.ALC) ||
                                 (current_meter_tx_mode == MeterTXMode.SWR) || (current_meter_tx_mode == MeterTXMode.FORWARD_POWER) ||
                                 (current_meter_tx_mode == MeterTXMode.REVERSE_POWER)))
                            )
                    {

                        // pixel_x (i.e. signal) goes from 0 to W  Width 
                        // posx = originx + (2 * D * cos (angle))
                        // posy = originy + (2 * D * sin (angle))
                        // for a meter of 45deg to 135deg = 90deg total span :   
                        // but sin and cos in radians not degs.
                        // posx = originx + (2 * D * cos (angle*PI/180))

                        //  box dimensions:
                        //  0,0   W,0
                        //  0,H   W,H

                        pixel_x = Math.Max(0, pixel_x);
                        pixel_x = Math.Min(W - 3, pixel_x);                                             // define limits of X dimension

                        //  line_pen = new Pen(analog_avg_color);

                        line_pen = new Pen(analog_high_color); // Color.Red

                        line_pen.Width = 2.8F; // was 2.8F

                        int Origin_x = W / 2;
                        int Origin_y = (W + CirX) / 2 + CirY;


                        const double angle_start = 55; // 45
                        const double angle_span = 70; // 90

                        angle = signal = (angle_start + ((double)pixel_x * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                        signal = signal * CirA;                                                // convert angle to radians for cos/sin math


                        if ((meterDMB == true) || (meterPointer == true)) // Dark meter background, so needle shadow is light
                        {

                            if ((meterPointer == true))
                            {
                                RotateImage(yell, angle, Origin_y);
                                g.DrawImageUnscaled(rotatedImage, 0, 0);


                                //  RotatePointer(signal, H * 1.25, Origin_x, Origin_y);
                                //  g.DrawImage(yell1, dest);            // draw rotated image
                            }
                            else
                            {
                                RotateImage(white, angle, Origin_y);
                                g.DrawImageUnscaled(rotatedImage, 0, 0);


                                //  RotatePointer(signal, H * 1.25, Origin_x, Origin_y);
                                //  g.DrawImage(white1, dest);            // draw rotated image

                            }


                        }
                        else if (meterLMB == true) // Dark meter background, so needle shadow is light
                        {
                            RotateImage(black, angle, Origin_y);
                            g.DrawImageUnscaled(rotatedImage, 0, 0);

                            //  RotatePointer(signal, H * 1.25, Origin_x, Origin_y);
                            //  g.DrawImage(black1, dest);            // draw rotated image
                        }
                        else
                        {
                            line_pen = new Pen(analog_avg_color);
                            line_pen.Width = 2.4F; // was 2.6F

                            int POSW = (int)((double)(CirR + 16) * Math.Cos(signal));  // convert signal to arc
                            int POSH = (int)((double)(CirR + 16) * Math.Sin(signal));


                            g.DrawLine(line_pen, Origin_x, Origin_y, Origin_x - POSW, Origin_y - POSH);  // draw meter needle movement (by flipping result around since inc values go down not up)

                        }
                        // 8880

                        //  Debug.WriteLine("Signal " + signal);

                        //====================================== //8881
                        // Draw TX Meter Name text in front of needle
                        if (current_meter_tx_mode == MeterTXMode.LVL_G) g.DrawString("LVLG", ff8, low_brush, W * 0.35F, H * 0.75F); //DDAA
                        else if (current_meter_tx_mode == MeterTXMode.ALC_G) g.DrawString("ALCG", ff8, low_brush, W * 0.35F, H * 0.75F); // DDAA
                        else if (current_meter_tx_mode == MeterTXMode.CPDR) g.DrawString("CPDR", ff8, low_brush, W * 0.35F, H * 0.75F); // DDAA
                        else if (current_meter_tx_mode == MeterTXMode.LEVELER) g.DrawString("LVL", ff8, low_brush, W * 0.39F, H * 0.75F); // DDAA
                        else if (current_meter_tx_mode == MeterTXMode.EQ) g.DrawString("EQ", ff8, low_brush, W * 0.42F, H * 0.75F); // DDAA
                        else if (current_meter_tx_mode == MeterTXMode.MIC) g.DrawString("MIC", ff8, low_brush, W * 0.39F, H * 0.75F); // DDAA
                        else if (current_meter_tx_mode == MeterTXMode.ALC) g.DrawString("ALC", ff8, low_brush, W * 0.39F, H * 0.75F); // DDAA
                        else if (current_meter_tx_mode == MeterTXMode.SWR) g.DrawString("SWR", ff8, low_brush, W * 0.385F, H * 0.75F); // DDAA
                        else if (current_meter_tx_mode == MeterTXMode.FORWARD_POWER) g.DrawString("FWD", ff8, low_brush, W * 0.385F, H * 0.75F); // DDAA
                        else if (current_meter_tx_mode == MeterTXMode.REVERSE_POWER) g.DrawString("REV", ff8, low_brush, W * 0.385F, H * 0.75F); // DDAA


                    } // TX curved needle

                    else if (  // SIGNAL, AVG SIGNAL, SIGNAL PEAK rx1 ANALOG
                                 (((current_meter_rx_mode == MeterRXMode.SIGNAL_STRENGTH) || (current_meter_rx_mode == MeterRXMode.SIGNAL_AVERAGE) ||
                                     (current_meter_rx_mode == MeterRXMode.SIGNAL_PEAK)) && (!mox && current_meter_rx_mode != MeterRXMode.OFF))
                        )
                    {
                        // pixel_x (i.e. signal) goes from 0 to W  Width 
                        // posx = originx + (2 * D * cos (angle))
                        // posy = originy + (2 * D * sin (angle))
                        // for a meter of 45deg to 135deg = 90deg total span :   
                        // but sin and cos in radians not degs.
                        // posx = originx + (2 * D * cos (angle*PI/180))

                        //  box dimensions:
                        //  0,0   W,0
                        //  0,H   W,H

                        pixel_x = Math.Max(0, pixel_x);
                        pixel_x = Math.Min(W - 3, pixel_x);                                             // define limits of X dimension

                        pixel_x1 = Math.Max(0, pixel_x1);
                        pixel_x1 = Math.Min(W - 3, pixel_x1);

                        line_pen = new Pen(analog_avg_color);



                        int Origin_x = W / 2;
                        //  int Origin_y = (int)((double)(H * 1.5)); // 1.4 slightly below meter window area (where virtual meter adjustment screw would be)
                        int Origin_y = (W + CirX) / 2 + CirY;


                        const double angle_start = 55; //  45;
                        const double angle_span = 70; //  90;


                        if ((current_meter_rx_mode == MeterRXMode.SIGNAL_PEAK) && (!mox && current_meter_rx_mode != MeterRXMode.OFF))  // ke9ns ADD
                        {

                            angle = signal = (angle_start + ((double)pixel_x1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                            signal = signal * CirA;                                                // convert angle to radians for cos/sin math


                            if ((meterDMB == true) || (meterLMB == true) || (meterPointer == true)) // Dark meter background, so needle shadow is light
                            {
                                RotateImage(red, angle, Origin_y);
                                g.DrawImageUnscaled(rotatedImage, 0, 0);

                                //  RotatePointer(signal, H * 1.25, Origin_x, Origin_y);
                                //   g.DrawImage(red1, dest);            // draw rotated image
                            }
                            else
                            {


                                int POSW1 = (int)((double)(CirR + 16) * Math.Cos(signal));  // convert signal to arc
                                int POSH1 = (int)((double)(CirR + 16) * Math.Sin(signal));

                                line_pen = new Pen(analog_high_color); // Color.Red
                                line_pen.Width = 2.6F;

                                g.DrawLine(line_pen, Origin_x, Origin_y, Origin_x - POSW1, Origin_y - POSH1);  // draw meter needle movement (by flipping result around since inc values go down not up)
                            }


                        } // peak


                        angle = signal = (angle_start + ((double)pixel_x * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                        signal = signal * CirA;                                                // convert angle to radians for cos/sin math


                        // Analog meter

                        if ((meterDMB == true) || (meterPointer == true)) // Dark meter background, so needle shadow is light
                        {
                            if ((meterPointer == true))
                            {
                                RotateImage(yell, angle, Origin_y);
                                g.DrawImageUnscaled(rotatedImage, 0, 0);

                                //  RotatePointer(signal, H * 1.25, Origin_x, Origin_y);
                                //   g.DrawImage(yell1, dest);            // draw rotated image

                            }
                            else
                            {
                                RotateImage(white, angle, Origin_y);
                                g.DrawImageUnscaled(rotatedImage, 0, 0);

                                //  RotatePointer(signal, H * 1.25, Origin_x, Origin_y);
                                //  g.DrawImage(white1, dest);            // draw rotated image

                            }


                        }
                        else if (meterLMB == true) // Dark meter background, so needle shadow is light
                        {
                            RotateImage(black, angle, Origin_y);
                            g.DrawImageUnscaled(rotatedImage, 0, 0);

                            //  RotatePointer(signal, H * 1.25, Origin_x, Origin_y);
                            //  g.DrawImage(black1, dest);            // draw rotated image
                        }
                        else
                        {
                            line_pen = new Pen(analog_avg_color);
                            line_pen.Width = 2.4F; // was 2.6F

                            int POSW = (int)((double)(CirR + 16) * Math.Cos(signal));  // convert signal to arc
                            int POSH = (int)((double)(CirR + 16) * Math.Sin(signal));

                            g.DrawLine(line_pen, Origin_x, Origin_y, Origin_x - POSW, Origin_y - POSH);  // draw meter needle movement (by flipping result around since inc values go down not up)


                        }

                        //======================================
                        // Draw RX Meter Name text in front of needle  //8881
                        if (chkRX2.Checked) // .203
                        {
                            if (current_meter_rx_mode == MeterRXMode.SIGNAL_STRENGTH) g.DrawString("VFOA SIG", ff8, low_brush, W * 0.27F, H * 0.75F); // DDAA
                            else if (current_meter_rx_mode == MeterRXMode.SIGNAL_AVERAGE) g.DrawString("VFOA AVG", ff8, low_brush, W * 0.27F, H * 0.75F); // DDAA
                            else if (current_meter_rx_mode == MeterRXMode.SIGNAL_PEAK) g.DrawString("VFOA SIG", ff8, low_brush, W * 0.27F, H * 0.75F); // DDAA

                        }
                        else
                        {
                            if (current_meter_rx_mode == MeterRXMode.SIGNAL_STRENGTH) g.DrawString("SIG", ff8, low_brush, W * 0.39F, H * 0.75F); // DDAA
                            else if (current_meter_rx_mode == MeterRXMode.SIGNAL_AVERAGE) g.DrawString("AVG", ff8, low_brush, W * 0.39F, H * 0.75F); // DDAA
                            else if (current_meter_rx_mode == MeterRXMode.SIGNAL_PEAK) g.DrawString("SIG", ff8, low_brush, W * 0.39F, H * 0.75F); // DDAA
                        }


                    } //   if meter is ON in RX or TX mode, then draw line



                    //=============================================
                    // Type NUMBERS in dbM above meter movement
                    //=============================================
                    meter_timer.Stop();

                    format = "f0";
                    if (meter_detail) format = "f1";

                    if (meter_timer.DurationMsec >= meter_dig_delay)
                    {
                        if (!mox)
                        {
                            switch (current_meter_rx_mode)
                            {
                                case MeterRXMode.SIGNAL_STRENGTH:

                                case MeterRXMode.SIGNAL_AVERAGE:
                                    output = num.ToString(format) + " dBm ";
                                    break;
                                case MeterRXMode.SIGNAL_PEAK: // ke9ns2 ADD 
                                    output = meter_peak_value.ToString(format) + " dBm ";
                                    break;
                                case MeterRXMode.ADC_L:
                                case MeterRXMode.ADC_R:
                                case MeterRXMode.ADC2_L:
                                case MeterRXMode.ADC2_R:
                                    output = num.ToString("f1") + " dBFS ";
                                    break;
                                case MeterRXMode.OFF:
                                    output = "";
                                    break;
                            }// switch (current_meter_rx_mode)
                        }// mox
                        else
                        {
                            MeterTXMode mode = current_meter_tx_mode;
                            if (chkTUN.Checked) mode = tune_meter_tx_mode;
                            switch (mode)
                            {
                                case MeterTXMode.MIC:
                                case MeterTXMode.LEVELER:
                                case MeterTXMode.LVL_G:
                                case MeterTXMode.EQ:
                                case MeterTXMode.CPDR:
                                case MeterTXMode.ALC:
                                case MeterTXMode.ALC_G:
                                    output = num.ToString(format) + " dB ";
                                    break;
                                case MeterTXMode.FORWARD_POWER:
                                case MeterTXMode.REVERSE_POWER:
                                    switch (current_model)
                                    {
                                        case Model.SDR1000:
                                            if (pa_present && VFOAFreq < 30.0)
                                                output = num.ToString("f0") + " W ";
                                            else output = (num * 1000).ToString("f0") + " mW ";
                                            break;
                                        case Model.FLEX5000:
                                        case Model.FLEX3000:
                                            output = num.ToString("f0") + " W ";
                                            break;
                                        case Model.FLEX1500:
                                            output = num.ToString("f0") + " % ";
                                            break;
                                    }
                                    break;
                                case MeterTXMode.SWR:
                                    output = num.ToString("f1") + " : 1 ";
                                    break;
                                case MeterTXMode.OFF:
                                    output = "";
                                    break;

                            }// switch mode
                        }//mox

                        txtMultiText.Text = output;
                        meter_timer.Start();

                    }// if (meter_timer.DurationMsec >= meter_dig_delay)

                    if (meter_data_ready)
                    {
                        meter_data_ready = false;  //We do NOT want to do this before we have consumed it!!!! so do it here.
                    }


                    #endregion //analog
                    break; // RX1 analog


            } // switch(current_meter_display_mode)

        } //  picMultiMeterDigital_Paint

        //=============================================================
        //=============================================================
        //=============================================================
        //=============================================================
        //=============================================================
        // ke9ns COMBO meter routine fake like its a 3rd meter, instead of the 2nd

        private void picRX3Meter_Click(object sender, EventArgs e)
        {
            meterCombo = false; // ke9ns: when you click on the 2nd meter turn off combo (if its on)
            CurrentMeterTX1Mode = MeterTXMode.ALC; // ke9ns: restore to non-combo meter when the meter moves up/down to prevent issues

        }


        //--------------------------------------------------------------
        // POWER, SWR, ALC, MIC
        // ke9ns add below to draw combo meter gradient lines
        static LinearGradientBrush pwr_Brush = new LinearGradientBrush(new Rectangle(0, 0, 164, 5), Color.Black, Color.Black, 0, false);
        static ColorBlend pwr_cb = new ColorBlend();
        static int pwr_out = 161;
        static double pwr_num = 0;
        static double tx2_meter_current_data_pwr = 0;
        static double tx2_meter_new_data_pwr = 0;
        static double tx2_meter_peak_pwr = 0;
        static int tx2_meter_peak4_pwr = 0;
        static int tx2_meter_peak5_pwr = 0;


        static LinearGradientBrush swr_Brush = new LinearGradientBrush(new Rectangle(0, 0, 164, 5), Color.Black, Color.Black, 0, false);
        static ColorBlend swr_cb = new ColorBlend();
        static int swr_out = 161;
        static double swr_num = 0;
        static float tx2_meter_current_data_swr = 0;
        static float tx2_meter_new_data_swr = 0;
        static float tx2_meter_peak_swr = 0;
        static int tx2_meter_peak4_swr = 0;
        static int tx2_meter_peak5_swr = 0;

        static LinearGradientBrush alc_Brush = new LinearGradientBrush(new Rectangle(0, 0, 164, 5), Color.Black, Color.Black, 0, false);
        static ColorBlend alc_cb = new ColorBlend();
        static int alc_out = 161;
        static int alcG_out = 161;
        static double alc_num = 0;
        static double tx2_meter_current_data_alc = 0;
        static double tx2_meter_current_data_alcG = 0;
        static double tx2_meter_new_data_alc = 0;
        static double tx2_meter_new_data_alcG = 0;
        static double tx2_meter_peak_alc = 0;
        static int tx2_meter_peak4_alc = 0;
        static int tx2_meter_peak5_alc = 0;

        static LinearGradientBrush mic_Brush = new LinearGradientBrush(new Rectangle(0, 0, 164, 5), Color.Black, Color.Black, 0, false);
        static ColorBlend mic_cb = new ColorBlend();
        static int mic_out = 161;
        static double mic_num = 0;
        static double tx2_meter_current_data_mic = 0;
        static double tx2_meter_new_data_mic = 0;
        static double tx2_meter_peak_mic = 0;
        static int tx2_meter_peak4_mic = 0;
        static int tx2_meter_peak5_mic = 0;

        static double comboW = 160; // ke9ns add for width of combo meter
        static double spacingW = 0;

        // ke9ns add
        private double tx2_avg_pwr_num = -130.0;
        private double tx2_avg_swr_num = -130.0;
        private double tx2_avg_alc_num = -130.0;
        private double tx2_avg_mic_num = -130.0;

        // ke9ns add (for combo meter of 2nd meter only)
        private void picRX3Meter_Paint(object sender, System.Windows.Forms.PaintEventArgs e)
        {

            int H = picRX3Meter.ClientSize.Height;
            int W = picRX3Meter.ClientSize.Width;
            Graphics g = e.Graphics;

            //  double num;
            //   int pixel_x = 0;
            //  int pixel_x1 = 0; // ke9ns ADD for new meters
            //  string output = "";


            //   g.TextRenderingHint = TextRenderingHint.ClearTypeGridFit;
            //   g.CompositingMode = CompositingMode.SourceOver;
            //   g.CompositingQuality = CompositingQuality.HighQuality;
            g.InterpolationMode = InterpolationMode.HighQualityBicubic;
            g.SmoothingMode = SmoothingMode.HighQuality;
            g.PixelOffsetMode = PixelOffsetMode.HighQuality;

            line_dark_pen = new Pen( // this causes a shadow color around the needle of the EDGE meters
                        Color.FromArgb((edge_avg_color.R + edge_meter_background_color.R) / 2, // red
                        (edge_avg_color.G + edge_meter_background_color.G) / 2, // green
                        (edge_avg_color.B + edge_meter_background_color.B) / 2)); // blue



            //---------------------------------------------------------------------------------------------
            // ke9ns combo

            if (meterCombo == true)
            {
                g.DrawRectangle(new Pen(edge_meter_background_color), 0, 0, W, H);

                //  low_brush = new SolidBrush(edge_low_color);
                //  high_brush = new SolidBrush(edge_high_color);

                MeterTXMode mode = current_meter_tx1_mode;

                if (rx2_meter_data_ready)
                {
                    // rx2_meter_current_data = rx2_meter_new_data;

                    tx2_meter_current_data_pwr = tx2_meter_new_data_pwr;
                    tx2_meter_current_data_swr = tx2_meter_new_data_swr;
                    tx2_meter_current_data_alc = tx2_meter_new_data_alc;
                    tx2_meter_current_data_alcG = tx2_meter_new_data_alcG;
                    tx2_meter_current_data_mic = tx2_meter_new_data_mic;

                    rx2_meter_data_ready = false;
                }

                //--------------------------------------------------------------
                // POWER
                //  LinearGradientBrush pwr_Brush = new LinearGradientBrush(new Rectangle(0,0,160,5), Color.Black, Color.Black, 0, false);
                //  ColorBlend pwr_cb = new ColorBlend();
                pwr_cb.Positions = new[] { 0, 0.8f, 0.85f, 0.9f, 1 }; // 
                pwr_cb.Colors = new[] { Color.Green, Color.Yellow, Color.Orange, Color.Red, Color.DarkRed }; // 4 colors
                pwr_Brush.InterpolationColors = pwr_cb;



                if (tx2_avg_pwr_num == Display.CLEAR_FLAG) // reset average -- just use new value
                {
                    pwr_num = tx2_avg_pwr_num = tx2_meter_current_data_pwr;
                }
                else
                {
                    if (tx2_meter_current_data_pwr > tx2_avg_pwr_num)
                        pwr_num = tx2_avg_pwr_num = tx2_meter_current_data_pwr * 0.8 + tx2_avg_pwr_num * 0.2; // fast rise
                    else
                        pwr_num = tx2_avg_pwr_num = tx2_meter_current_data_pwr * 0.8 + tx2_avg_pwr_num * 0.2; // slow decay
                }

                // ke9nsSWR
                //--------------------------------------------------------------
                // SWR
                //  LinearGradientBrush swr_Brush = new LinearGradientBrush(new Rectangle(0, 0, 160, 5), Color.Black, Color.Black, 0, false);
                //   ColorBlend swr_cb = new ColorBlend();

                swr_cb.Positions = new[] { 0, 0.4f, 0.45f, 0.50f, 1 };
                swr_cb.Colors = new[] { Color.Green, Color.Yellow, Color.Orange, Color.Red, Color.DarkRed }; // 4 colors
                swr_Brush.InterpolationColors = swr_cb;


                if (tx2_avg_swr_num == Display.CLEAR_FLAG) // reset average -- just use new value
                {
                    swr_num = tx2_avg_swr_num = tx2_meter_current_data_swr;
                }
                else
                {
                    if (tx2_meter_current_data_swr > tx2_avg_swr_num)
                        swr_num = tx2_avg_swr_num = tx2_meter_current_data_swr * 0.8 + tx2_avg_swr_num * 0.2; // fast rise
                    else
                        swr_num = tx2_avg_swr_num = tx2_meter_current_data_swr * 0.8 + tx2_avg_swr_num * 0.2; // slow decay
                }

                //    Debug.WriteLine("1SWR COMBO " + tx2_meter_current_data_swr + " , " + swr_num);


                //--------------------------------------------------------------
                // ALC
                //  LinearGradientBrush alc_Brush = new LinearGradientBrush(new Rectangle(0, 0, 160, 5), Color.Black, Color.Black, 0, false);
                //   ColorBlend alc_cb = new ColorBlend();
                alc_cb.Positions = new[] { 0, 0.5f, 0.75f, 0.8f, 1 };
                alc_cb.Colors = new[] { Color.Yellow, Color.Green, Color.Orange, Color.Red, Color.DarkRed }; // 5 colors
                alc_Brush.InterpolationColors = alc_cb;


                if (tx2_avg_alc_num == Display.CLEAR_FLAG) // reset average -- just use new value
                {
                    alc_num = tx2_avg_alc_num = tx2_meter_current_data_alc;
                }
                else
                {
                    if (tx2_meter_current_data_alc > tx2_avg_alc_num)
                        alc_num = tx2_avg_alc_num = tx2_meter_current_data_alc * 0.8 + tx2_avg_alc_num * 0.2; // fast rise
                    else
                        alc_num = tx2_avg_alc_num = tx2_meter_current_data_alc * 0.8 + tx2_avg_alc_num * 0.2; // slow decay
                }




                //--------------------------------------------------------------
                // MIC
                // LinearGradientBrush mic_Brush = new LinearGradientBrush(new Rectangle(0, 0, 160, 5), Color.Black, Color.Black, 0, false);
                //  ColorBlend mic_cb = new ColorBlend();
                mic_cb.Positions = new[] { 0, 0.5f, 0.75f, 0.8f, 1 };
                mic_cb.Colors = new[] { Color.Yellow, Color.Green, Color.Orange, Color.Red, Color.DarkRed }; // 4 colors
                mic_Brush.InterpolationColors = mic_cb;



                if (tx2_avg_mic_num == Display.CLEAR_FLAG) // reset average -- just use new value
                {
                    mic_num = tx2_avg_mic_num = tx2_meter_current_data_mic;
                }
                else
                {
                    if (tx2_meter_current_data_alc > tx2_avg_alc_num)
                        mic_num = tx2_avg_mic_num = tx2_meter_current_data_mic * 0.8 + tx2_avg_mic_num * 0.2; // fast rise
                    else
                        mic_num = tx2_avg_mic_num = tx2_meter_current_data_mic * 0.8 + tx2_avg_mic_num * 0.2; // slow decay
                }

                //  Debug.WriteLine("POWER, SWR, ALC, MIC : " + pwr_num + " , " + swr_num + " , " + alc_num + " , " + mic_num);

                if (pwr_num < 0)
                {
                    pwr_num = 0;

                }
                else if (pwr_num > 200)
                {
                    pwr_num = 200;
                }

                if (swr_num < 0)
                {
                    swr_num = 0;

                }
                else if (swr_num > 50)
                {
                    swr_num = 50;
                }


                if (alc_num < -60)
                {
                    alc_num = -60;

                }
                else if (alc_num > 60)
                {
                    alc_num = 60;
                }

                if (mic_num < -60)
                {
                    mic_num = -60;

                }
                else if (mic_num > 60)
                {
                    mic_num = 60;
                }



                //----------------------------------------------------------------
                g.DrawImageUnscaled(meterback4, 0, 0); // new Rectangle(0, 0, W, H));  // rectangle to show bitmap image in

                //   txtRX2Meter.ForeColor = Color.Black;
                //   txtRX2Meter.BackColor = Color.FromArgb(0xff, 0xff, 0xe4);


                //-------------------------------------------------------------------------------
                // Power
                //combo meter


                if (pwr_num <= 100.0) // low area
                {
                    spacingW = (comboW * 0.75 - 2.0) / 4.0;

                    if (pwr_num <= 5.0) pwr_out = (int)(pwr_num / 5.0 * (int)spacingW);
                    else if (pwr_num <= 10.0) pwr_out = (int)(spacingW + (pwr_num - 5.0) / 5.0 * spacingW);
                    else if (pwr_num <= 50.0) pwr_out = (int)(2 * spacingW + (pwr_num - 10.0) / 40.0 * spacingW);
                    else pwr_out = (int)(3 * spacingW + (pwr_num - 50.0) / 50.0 * spacingW);
                }
                else
                {
                    spacingW = (comboW * 0.25 - 2.0 - 10.0) / 1.0;
                    if (pwr_num <= 120.0) pwr_out = (int)(comboW * 0.75 + (pwr_num - 100.0) / 20.0 * spacingW);
                    else pwr_out = (int)(comboW * 0.75 + spacingW + (pwr_num - 120.0) / 60.0 * spacingW);
                }


                g.FillRectangle(pwr_Brush, new Rectangle(5, 17, pwr_out, 4));     // x,y, width,height

                //-------------------------------------------------------------
                // peak hold value for PWR
                pwr_num = tx2_meter_peak_pwr;

                if (pwr_num <= 100.0) // low area
                {
                    spacingW = (comboW * 0.75 - 2.0) / 4.0;

                    if (pwr_num <= 5.0) pwr_out = (int)(pwr_num / 5.0 * (int)spacingW);
                    else if (pwr_num <= 10.0) pwr_out = (int)(spacingW + (pwr_num - 5.0) / 5.0 * spacingW);
                    else if (pwr_num <= 50.0) pwr_out = (int)(2 * spacingW + (pwr_num - 10.0) / 40.0 * spacingW);
                    else pwr_out = (int)(3 * spacingW + (pwr_num - 50.0) / 50.0 * spacingW);
                }
                else
                {
                    spacingW = (comboW * 0.25 - 2.0 - 10.0) / 1.0;
                    if (pwr_num <= 120.0) pwr_out = (int)(comboW * 0.75 + (pwr_num - 100.0) / 20.0 * spacingW);
                    else pwr_out = (int)(comboW * 0.75 + spacingW + (pwr_num - 120.0) / 60.0 * spacingW);
                }


                g.FillRectangle(pwr_Brush, new Rectangle(pwr_out - 2, 17, 4, 4));     // x,y, width,height



                //-------------------------------------------------------------------------------
                // SWR


                if (swr_num < 10.0) // low area
                {

                    spacingW = (comboW * 0.75 - 2.0) / 4.0; // comboW = 160

                    if (swr_num <= 1.5) swr_out = (int)((swr_num - 1.0) / 0.5 * spacingW);
                    else if (swr_num <= 2.0) swr_out = (int)(spacingW + (swr_num - 1.5) / 0.5 * spacingW);
                    else if (swr_num <= 5.0) swr_out = (int)(2 * spacingW + (swr_num - 2.0) / 3.0 * spacingW);
                    else swr_out = (int)(3 * spacingW + (swr_num - 5.0) / 5.0 * spacingW);


                }
                else
                {
                    spacingW = (comboW * 0.25 - 2.0 - 9.0) / 1.0;
                    swr_out = (int)(comboW * 0.75 + (swr_num - 10.0) / 10.0 * spacingW);

                }



                if (double.IsInfinity(swr_num)) swr_out = (int)(comboW - 2);

                if (swr_out < 0) swr_out = swr_out * -1;


                //  Debug.WriteLine("SWR " + swr_out);
                g.FillRectangle(swr_Brush, new Rectangle(5, 45, swr_out, 4));


                //-------------------------------------------
                // Peak hold value for SWR
                swr_num = tx2_meter_peak_swr;

                if (swr_num < 10.0) // low area
                {
                    spacingW = (comboW * 0.75 - 2.0) / 4.0;

                    if (swr_num <= 1.5) swr_out = (int)((swr_num - 1.0) / 0.5 * spacingW);
                    else if (swr_num <= 2.0) swr_out = (int)(spacingW + (swr_num - 1.5) / 0.5 * spacingW);
                    else if (swr_num <= 5.0) swr_out = (int)(2 * spacingW + (swr_num - 2.0) / 3.0 * spacingW);
                    else swr_out = (int)(3 * spacingW + (swr_num - 5.0) / 5.0 * spacingW);
                }
                else
                {
                    spacingW = (comboW * 0.25 - 2.0 - 9.0) / 1.0;
                    swr_out = (int)(comboW * 0.75 + (swr_num - 10.0) / 10.0 * spacingW);
                }
                if (double.IsInfinity(swr_num)) swr_out = (int)(comboW - 2);

                if (swr_out < 0) swr_out = swr_out * -1;

                if (swr_out - 2 < 0) swr_out = 2;

                //  Debug.WriteLine("SWRP " + swr_out);

                g.FillRectangle(swr_Brush, new Rectangle(swr_out - 2, 45, 4, 4));

                //-------------------------------------------------------------------------------
                // ALC


                if (alc_num > 0.0) // high area
                {
                    alc_out = (int)(comboW * 0.665 + alc_num / 3.0 * (160 * 0.335 - 4));
                }
                else
                {
                    alc_out = (int)((alc_num + 30.0) / 30.0 * (comboW * 0.665 - 1.0));
                }

                spacingW = (comboW * 0.75 - 2.0) / 4.0;
                alcG_out = (int)(alc_num / 5.0 * spacingW);


                g.FillRectangle(alc_Brush, new Rectangle(5, 74, alc_out, 4));

                //-------------------------------------------
                // Peak hold value for ALC
                alc_num = tx2_meter_peak_alc;


                if (alc_num > 0.0) // high area
                {
                    alc_out = (int)(comboW * 0.665 + alc_num / 3.0 * (160 * 0.335 - 4));
                }
                else
                {
                    alc_out = (int)((alc_num + 30.0) / 30.0 * (comboW * 0.665 - 1.0));
                }

                spacingW = (comboW * 0.75 - 2.0) / 4.0;
                alcG_out = (int)(alc_num / 5.0 * spacingW);

                if (alc_out - 2 < 0) alc_out = 2;

                g.FillRectangle(alc_Brush, new Rectangle(alc_out - 2, 74, 4, 4));

                //   Debug.WriteLine("ALC " + alc_out);

                //-------------------------------------------------------------------------------
                // MIC

                if (mic_num > 0.0) // high area
                {
                    mic_out = (int)(comboW * 0.665 + mic_num / 3.0 * (160 * 0.335 - 4));
                }
                else
                {
                    mic_out = (int)((mic_num + 30.0) / 30.0 * (comboW * 0.665 - 1.0));
                }

                g.FillRectangle(mic_Brush, new Rectangle(5, 101, mic_out, 4));


                //-------------------------------------------
                // Peak hold value for Mic
                mic_num = tx2_meter_peak_mic;

                if (mic_num > 0.0) // high area
                {
                    mic_out = (int)(comboW * 0.665 + mic_num / 3.0 * (160 * 0.335 - 4));
                }
                else
                {
                    mic_out = (int)((mic_num + 30.0) / 30.0 * (comboW * 0.665 - 1.0));
                }

                if (mic_out - 2 < 0) mic_out = 2;

                g.FillRectangle(mic_Brush, new Rectangle(mic_out - 2, 101, 4, 4));


                //  Debug.WriteLine("MIC " + mic_out);

            } //  if (meterCombo == true)

        } //picRX3Meter_Paint (for TX1 meter)



        //========================================================
        //========================================================
        //========================================================
        //========================================================
        // RX2 meters  (RX3 is the combo that draws over this meter)
        //========================================================
        //========================================================
        //========================================================
        //========================================================
        private double rx2_avg_num = -130.0;

        private void picRX2Meter_Paint(object sender, System.Windows.Forms.PaintEventArgs e)
        {
            int H = picRX2Meter.ClientSize.Height;
            int W = picRX2Meter.ClientSize.Width;
            Graphics g = e.Graphics;

            double num;
            int pixel_x = 0;
            int pixel_x1 = 0; // ke9ns ADD for new meters
            string output = "";

            g.TextRenderingHint = TextRenderingHint.ClearTypeGridFit;
            //  g.CompositingMode = CompositingMode.SourceOver;
            //   g.CompositingQuality = CompositingQuality.HighQuality;
            g.InterpolationMode = InterpolationMode.HighQualityBicubic;
            g.SmoothingMode = SmoothingMode.HighQuality;
            g.PixelOffsetMode = PixelOffsetMode.HighQuality;

            line_dark_pen = new Pen( // this causes a shadow color around the needle of the EDGE meters
                        Color.FromArgb((edge_avg_color.R + edge_meter_background_color.R) / 2, // red
                        (edge_avg_color.G + edge_meter_background_color.G) / 2, // green
                        (edge_avg_color.B + edge_meter_background_color.B) / 2)); // blue


            int CirR = (W + CirX) / 2; // ke9ns add: 114  virtual meter circle radius
            const double CirA = Math.PI / 180; // ke9ns add

            //---------------------------------------------------------------------------------------------
            bool mox2 = false; // ke9ns add  false = rx    true = 2nd tx meter active

            //---------------------------
            // ke9ns add
            if ((setupForm != null) && (setupForm.chkRX2AutoMuteRX2OnVFOATX.Checked == false) || (TXMeter2 == false) || ((TXMeter2 == true) && (!MOX))) // ke9ns do RX2 if in duplex mode and not in special 2nd TX meter mode
            {
                if ((!FWCEEPROM.RX2OK) || (FWCEEPROM.RX2OK && chkRX2.Checked == false)) mox2 = true; // ke9ns keep meter set for the TX type you wanted all the time
                else mox2 = false; // receiving on RX2 or dont want 2nd tX meter

                if ((mox2 == true) && (current_meter_tx1_mode == MeterTXMode.MIC))
                {
                    rx2_meter_new_data = (float)tx2_meter_new_data;
                }
            }
            else
            {
                mox2 = true; // transmitting and want 2nd tx meter to function
            }

            //---------------------------------------------------------------------------------------------
            // ke9ns combo


            switch (current_meter_display_mode) // ke9ns which meter type is selected
            {


                //=============================================================
                //=============================================================
                // KE9NS 4 RX2 BAR GRAPH meter
                //=============================================================
                //=============================================================

                case MultiMeterDisplayMode.Bar:   // lblRX2Meter is the text for RX2 bar graph (lblMultiSMeter is for RX1)
                    #region Bar

                    if (rx2_meter_data_ready)
                    {

                        rx2_meter_current_data = rx2_meter_new_data;
                        rx2_meter_data_ready = false;
                    }


                    if (!mox2) // if RX2 is ON and running and in RX mode
                    {
                        num = rx2_meter_current_data;

                        switch (rx2_meter_mode)
                        {
                            case MeterRXMode.SIGNAL_STRENGTH:
                            case MeterRXMode.SIGNAL_AVERAGE:
                            case MeterRXMode.SIGNAL_PEAK:

                                switch ((int)g.DpiX)
                                {
                                    case 96:

                                        if (FREQA < 30)
                                        {
                                            double s = (num + 127) / 6;

                                            if (s <= 9.0F)
                                            {
                                                pixel_x = (int)((s * 7.5) + 2);
                                            }
                                            else
                                            {
                                                double over_s9 = num + 73;
                                                pixel_x = 69 + (int)(over_s9 * 1.05);
                                            }
                                        }
                                        else // vhf
                                        {
                                            //  Debug.WriteLine("VHF96====");
                                            if (num > -93)
                                            {
                                                pixel_x = (int)(W * 0.5 + (93 + num) / 63.0 * (W * 0.5 - 3));

                                            }
                                            else
                                            {
                                                pixel_x = (int)((num + 133.0) / 40.0 * (W * 0.5));

                                            }
                                        } // vhf
                                        break;
                                    case 120:
                                        if (FREQA < 30)
                                        {
                                            if (num <= -97.0f)
                                                pixel_x = (int)(0 + (num + 100.0) / 3.0 * 10);
                                            else if (num <= -91.0f)
                                                pixel_x = (int)(10 + (num + 97.0) / 6.0 * 17);
                                            else if (num <= -85.0f)
                                                pixel_x = (int)(27 + (num + 91.0) / 6.0 * 16);
                                            else if (num <= -79.0f)
                                                pixel_x = (int)(43 + (num + 85.0) / 6.0 * 17);
                                            else if (num <= -73.0f)
                                                pixel_x = (int)(60 + (num + 79.0) / 6.0 * 16);
                                            else if (num <= -53.0f)
                                                pixel_x = (int)(76 + (num + 73.0) / 20.0 * 24);
                                            else if (num <= -33.0f)
                                                pixel_x = (int)(100 + (num + 53.0) / 20.0 * 24);
                                            else if (num <= -13.0f)
                                                pixel_x = (int)(124 + (num + 33.0) / 20.0 * 24);
                                            else
                                                pixel_x = (int)(148 + (num + 13.0) / 20.0 * 19);

                                        }
                                        else
                                        {
                                            // Debug.WriteLine("VHF120====");

                                            if (num <= -117.0f) pixel_x = (int)(0 + (num + 100.0) / 3.0 * 10);
                                            else if (num <= -111.0f) pixel_x = (int)(10 + (num + 97.0) / 6.0 * 17);
                                            else if (num <= -105.0f) pixel_x = (int)(27 + (num + 91.0) / 6.0 * 16);
                                            else if (num <= -99.0f) pixel_x = (int)(43 + (num + 85.0) / 6.0 * 17);
                                            else if (num <= -93.0f) pixel_x = (int)(60 + (num + 79.0) / 6.0 * 16);
                                            else if (num <= -73.0f) pixel_x = (int)(76 + (num + 73.0) / 20.0 * 24);
                                            else if (num <= -53.0f) pixel_x = (int)(100 + (num + 53.0) / 20.0 * 24);
                                            else if (num <= -33.0f) pixel_x = (int)(124 + (num + 33.0) / 20.0 * 24);
                                            else pixel_x = (int)(148 + (num + 13.0) / 20.0 * 19);

                                        }
                                        break;
                                }
                                break;
                            case MeterRXMode.ADC_L:
                            case MeterRXMode.ADC_R:
                                switch ((int)g.DpiX)
                                {
                                    case 96:
                                        pixel_x = (int)(((num + 100) * 1.2) + 12);
                                        break;
                                    case 120:
                                        if (num <= -100.0f)
                                            pixel_x = (int)(0 + (num + 110.0) / 10.0 * 14);
                                        else if (num <= -80.0f)
                                            pixel_x = (int)(14 + (num + 100.0) / 20.0 * 27);
                                        else if (num <= -60.0f)
                                            pixel_x = (int)(41 + (num + 80.0) / 20.0 * 28);
                                        else if (num <= -40.0f)
                                            pixel_x = (int)(69 + (num + 60.0) / 20.0 * 28);
                                        else if (num <= -20.0f)
                                            pixel_x = (int)(97 + (num + 40.0) / 20.0 * 27);
                                        else if (num <= 0.0f)
                                            pixel_x = (int)(124 + (num + 20.0) / 20.0 * 24);
                                        else
                                            pixel_x = (int)(148 + (num - 0.0) / 10.0 * 19);
                                        break;
                                }
                                break;
                            case MeterRXMode.OFF:
                                break;

                        } //  switch (rx2_meter_mode)

                    } // !MOX2
                    else
                    {

                        num = rx2_meter_current_data;

                        MeterTXMode mode = current_meter_tx1_mode;

                        //   if (chkTUN.Checked) mode = tune_meter_tx_mode; // .191 remove

                        switch (mode)
                        {
                            case MeterTXMode.MIC:
                            case MeterTXMode.EQ:
                            case MeterTXMode.LEVELER:
                            case MeterTXMode.CPDR:
                            case MeterTXMode.ALC:
                                //num += 3.0;  // number no longer has fudge factor added in the dsp, must be remove
                                switch ((int)g.DpiX)
                                {
                                    case 96:
                                        if (num <= -20.0f)
                                            pixel_x = (int)(0 + (num + 25.0) / 5.0 * 9);
                                        else if (num <= -10.0f)
                                            pixel_x = (int)(9 + (num + 20.0) / 10.0 * 27);
                                        else if (num <= -5.0f)
                                            pixel_x = (int)(36 + (num + 10.0) / 5.0 * 27);
                                        else if (num <= 0.0f)
                                            pixel_x = (int)(63 + (num + 5.0) / 5.0 * 24);
                                        else if (num <= 1.0f)
                                            pixel_x = (int)(87 + (num - 0.0) / 1.0 * 15);
                                        else if (num <= 2.0f)
                                            pixel_x = (int)(102 + (num - 1.0) / 1.0 * 15);
                                        else if (num <= 3.0f)
                                            pixel_x = (int)(117 + (num - 2.0) / 1.0 * 15);
                                        else
                                            pixel_x = (int)(132 + (num - 3.0) / 0.5 * 8);
                                        break;
                                    case 120:
                                        if (num <= -20.0f)
                                            pixel_x = (int)(0 + (num + 25.0) / 5.0 * 10);
                                        else if (num <= -10.0f)
                                            pixel_x = (int)(10 + (num + 20.0) / 10.0 * 30);
                                        else if (num <= -5.0f)
                                            pixel_x = (int)(40 + (num + 10.0) / 5.0 * 30);
                                        else if (num <= 0.0f)
                                            pixel_x = (int)(70 + (num + 5.0) / 5.0 * 27);
                                        else if (num <= 1.0f)
                                            pixel_x = (int)(97 + (num - 0.0) / 1.0 * 17);
                                        else if (num <= 2.0f)
                                            pixel_x = (int)(114 + (num - 1.0) / 1.0 * 17);
                                        else if (num <= 3.0f)
                                            pixel_x = (int)(131 + (num - 2.0) / 1.0 * 17);
                                        else
                                            pixel_x = (int)(148 + (num - 3.0) / 0.5 * 23);
                                        break;
                                }
                                break;
                            case MeterTXMode.FORWARD_POWER:
                            case MeterTXMode.REVERSE_POWER:
                                switch ((int)g.DpiX)
                                {
                                    case 96:
                                        if (num <= 1.0f)
                                            pixel_x = (int)(0 + num * 2);
                                        else if (num <= 5.0f)
                                            pixel_x = (int)(2 + (num - 1) / 4 * 24);
                                        else if (num <= 10.0f)
                                            pixel_x = (int)(26 + (num - 5) / 5 * 24);
                                        else if (num <= 50.0f)
                                            pixel_x = (int)(50 + (num - 10) / 40 * 24);
                                        else if (num <= 100.0f)
                                            pixel_x = (int)(74 + (num - 50) / 50 * 24);
                                        else if (num <= 120.0f)
                                            pixel_x = (int)(98 + (num - 100) / 20 * 24);
                                        else
                                            pixel_x = (int)(122 + (num - 120) / 20 * 16);
                                        break;
                                    case 120:
                                        if (num <= 1.0f)
                                            pixel_x = (int)(0 + num * 3);
                                        else if (num <= 5.0f)
                                            pixel_x = (int)(3 + (num - 1) / 4 * 26);
                                        else if (num <= 10.0f)
                                            pixel_x = (int)(29 + (num - 5) / 5 * 26);
                                        else if (num <= 50.0f)
                                            pixel_x = (int)(55 + (num - 10) / 40 * 27);
                                        else if (num <= 100.0f)
                                            pixel_x = (int)(82 + (num - 50) / 50 * 28);
                                        else if (num <= 120.0f)
                                            pixel_x = (int)(110 + (num - 100) / 20 * 27);
                                        else
                                            pixel_x = (int)(137 + (num - 120) / 20 * 30);
                                        break;
                                }
                                break;
                            case MeterTXMode.SWR:
                                switch ((int)g.DpiX)
                                {
                                    case 96:
                                        if (double.IsInfinity(num))
                                            pixel_x = 200;
                                        else if (num <= 1.0f)
                                            pixel_x = (int)(0 + num * 3);
                                        else if (num <= 1.5f)
                                            pixel_x = (int)(3 + (num - 1.0) / 0.5 * 27);
                                        else if (num <= 2.0f)
                                            pixel_x = (int)(30 + (num - 1.5) / 0.5 * 20);
                                        else if (num <= 3.0f)
                                            pixel_x = (int)(50 + (num - 2.0) / 1.0 * 21);
                                        else if (num <= 5.0f)
                                            pixel_x = (int)(71 + (num - 3.0) / 2.0 * 21);
                                        else if (num <= 10.0f)
                                            pixel_x = (int)(92 + (num - 5.0) / 5.0 * 21);
                                        else
                                            pixel_x = (int)(113 + (num - 10.0) / 15.0 * 26);
                                        break;
                                    case 120:
                                        if (double.IsInfinity(num))
                                            pixel_x = 200;
                                        else if (num <= 1.0f)
                                            pixel_x = (int)(0 + num * 3);
                                        else if (num <= 1.5f)
                                            pixel_x = (int)(3 + (num - 1.0) / 0.5 * 31);
                                        else if (num <= 2.0f)
                                            pixel_x = (int)(34 + (num - 1.5) / 0.5 * 22);
                                        else if (num <= 3.0f)
                                            pixel_x = (int)(56 + (num - 2.0) / 1.0 * 22);
                                        else if (num <= 5.0f)
                                            pixel_x = (int)(78 + (num - 3.0) / 2.0 * 23);
                                        else if (num <= 10.0f)
                                            pixel_x = (int)(101 + (num - 5.0) / 5.0 * 23);
                                        else
                                            pixel_x = (int)(124 + (num - 10.0) / 15.0 * 43);
                                        break;
                                }
                                break;
                            case MeterTXMode.ALC_G:
                            case MeterTXMode.LVL_G:
                                switch ((int)g.DpiX)
                                {
                                    case 96:
                                        if (num <= 0.0f)
                                            pixel_x = 3;
                                        else if (num <= 5.0f)
                                            pixel_x = (int)(3 + (num - 0.0) / 5.0 * 28);
                                        else if (num <= 10.0f)
                                            pixel_x = (int)(31 + (num - 5.0) / 5.0 * 29);
                                        else if (num <= 15.0f)
                                            pixel_x = (int)(60 + (num - 10.0) / 5.0 * 30);
                                        else if (num <= 20.0f)
                                            pixel_x = (int)(90 + (num - 15.0) / 5.0 * 31);
                                        else
                                            pixel_x = (int)(121 + (num - 20.0) / 5.0 * 29);
                                        break;
                                    case 120:
                                        if (num <= 0.0f)
                                            pixel_x = 3;
                                        else if (num <= 5.0f)
                                            pixel_x = (int)(3 + (num - 0.0) / 5.0 * 31);
                                        else if (num <= 10.0f)
                                            pixel_x = (int)(34 + (num - 5.0) / 5.0 * 33);
                                        else if (num <= 15.0f)
                                            pixel_x = (int)(77 + (num - 10.0) / 5.0 * 33);
                                        else if (num <= 20.0f)
                                            pixel_x = (int)(110 + (num - 15.0) / 5.0 * 35);
                                        else
                                            pixel_x = (int)(145 + (num - 20.0) / 5.0 * 32);
                                        break;
                                }
                                break;
                            case MeterTXMode.OFF:
                                break;
                        } // SWITCH (MODE)

                    } // MOX2



                    switch ((int)g.DpiX)
                    {
                        case 96:
                            if (pixel_x > 139) pixel_x = 139;
                            break;
                        case 120:
                            if (pixel_x > 167) pixel_x = 167;
                            break;
                    }

                    //------------------------------------------------------
                    if (((!mox2) && (rx2_meter_mode != MeterRXMode.OFF)) || ((mox2) && (current_meter_tx1_mode != MeterTXMode.OFF)))
                    {
                        if (pixel_x <= 0) pixel_x = 1;

                        LinearGradientBrush brush = new LinearGradientBrush(new Rectangle(0, 0, pixel_x, H),
                            meter_left_color, meter_right_color, LinearGradientMode.Horizontal);

                        g.FillRectangle(brush, 0, 0, pixel_x, H);

                        for (int i = 0; i < 21; i++)
                            g.DrawLine(new Pen(meter_background_color), 6 + i * 8, 0, 6 + i * 8, H);

                        g.DrawLine(new Pen(Color.Red), pixel_x, 0, pixel_x, H);
                        g.FillRectangle(new SolidBrush(meter_background_color), pixel_x + 1, 0, W - pixel_x, H);

                        if (pixel_x >= rx2_meter_peak_value)
                        {
                            rx2_meter_peak_count = 0;
                            rx2_meter_peak_value = pixel_x;
                        }
                        else
                        {
                            if (rx2_meter_peak_count++ >= multimeter_peak_hold_samples)
                            {
                                rx2_meter_peak_count = 0;
                                rx2_meter_peak_value = pixel_x;
                            }
                            else
                            {
                                g.DrawLine(new Pen(Color.Red), rx2_meter_peak_value, 0, rx2_meter_peak_value, H);
                                g.DrawLine(new Pen(Color.Red), rx2_meter_peak_value - 1, 0, rx2_meter_peak_value - 1, H);
                            }
                        }
                    } //  if (rx2_meter_mode != MeterRXMode.OFF)

                    rx2_meter_timer.Stop();

                    string format = "f0";
                    if (meter_detail) format = "f1";

                    //---------------------------------------------------------ke9ns RX2 BAR graph digital meter here

                    if (rx2_meter_timer.DurationMsec >= meter_dig_delay)
                    {

                        if (!mox2)
                        {
                            switch (rx2_meter_mode)
                            {
                                case MeterRXMode.SIGNAL_STRENGTH:
                                case MeterRXMode.SIGNAL_AVERAGE:
                                case MeterRXMode.SIGNAL_PEAK:
                                    output = num.ToString(format) + " dBm ";


                                    break;
                                case MeterRXMode.ADC_L:
                                case MeterRXMode.ADC_R:
                                    output = num.ToString("f1") + " dBFS ";
                                    break;
                                case MeterRXMode.OFF:
                                    output = "";
                                    break;
                            }
                        } // !MOX2
                        else
                        {
                            MeterTXMode mode = current_meter_tx1_mode;
                            // if (chkTUN.Checked) mode = tune_meter_tx_mode;
                            switch (mode)
                            {
                                case MeterTXMode.MIC:
                                case MeterTXMode.LEVELER:
                                case MeterTXMode.LVL_G:
                                case MeterTXMode.EQ:
                                case MeterTXMode.CPDR:
                                case MeterTXMode.ALC:
                                case MeterTXMode.ALC_G:
                                    if (!mox) output = "-30 dB ";
                                    else output = num.ToString(format) + " dB ";
                                    break;
                                case MeterTXMode.FORWARD_POWER:
                                case MeterTXMode.REVERSE_POWER:
                                    switch (current_model)
                                    {
                                        case Model.SDR1000:
                                            if (pa_present && VFOAFreq < 30.0)
                                                output = num.ToString("f0") + " W";
                                            else output = (num * 1000).ToString("f0") + " mW";
                                            break;
                                        case Model.FLEX5000:
                                        case Model.FLEX3000:
                                            if (num < 0) num = 0;

                                            if (!mox) output = "0 W ";
                                            else output = num.ToString("f0") + " W ";
                                            break;
                                        case Model.FLEX1500:
                                            if (num < 0) num = 0;
                                            if (!mox) output = "0 % ";
                                            else output = num.ToString("f0") + " % ";
                                            break;
                                    }
                                    break;
                                case MeterTXMode.SWR: // bar graph
                                    if (num < 0) num = 0;
                                    if (!mox) output = "0 : 1 ";
                                    else output = num.ToString("f1") + " : 1 ";
                                    break;
                                case MeterTXMode.OFF:
                                    output = "";
                                    break;

                            } // switch(MODE)


                        } // MOX2

                        txtRX2Meter.Text = output;
                        rx2_meter_timer.Start();
                    }

                    if (rx2_meter_data_ready)
                    {
                        rx2_meter_data_ready = false;  //We do NOT want to do this before we have consumed it!!!! so do it here.
                    }
                    break; // BAR RX2


                #endregion // BAR


                //=============================================================
                //=============================================================
                // KE9NS 4 RX2 TR7 meter
                //=============================================================
                //=============================================================

                case MultiMeterDisplayMode.Original:
                    #region AnalogTR7


                    if (rx2_meter_data_ready)
                    {
                        rx2_meter_current_data = rx2_meter_new_data;
                        rx2_meter_data_ready = false;
                    }

                    if (rx2_avg_num == Display.CLEAR_FLAG) // reset average -- just use new value
                    {
                        num = rx2_avg_num = rx2_meter_current_data;
                    }
                    else
                    {
                        if (rx2_meter_current_data > rx2_avg_num)
                            num = rx2_avg_num = rx2_meter_current_data * 0.8 + rx2_avg_num * 0.2; // fast rise
                        else
                            num = rx2_avg_num = rx2_meter_current_data * 0.2 + rx2_avg_num * 0.8; // slow decay
                    }


                    //  if ((mox2) && (!mox)) num = -100.0;  // zero the value if in 2nd tx mode but not transmitting

                    g.DrawRectangle(new Pen(meter_background_color), 0, 0, W, H);

                    low_brush = new SolidBrush(edge_low_color);
                    high_brush = new SolidBrush(edge_high_color);


                    if (!mox2)
                    {
                        switch (rx2_meter_mode)
                        {

                            //=============================================
                            // Receiver meters ke9ns10
                            //=============================================

                            case MeterRXMode.SIGNAL_STRENGTH:
                            case MeterRXMode.SIGNAL_AVERAGE:
                            case MeterRXMode.SIGNAL_PEAK:  // ke9ns ADD

                                //=================================================================


                                int Origin_x = W / 2;
                                int Origin_y = (int)((double)(H * 1.5)); // 1.4 slightly below meter window area (where virtual meter adjustment screw would be)


                                low_brush1 = new Pen(edge_low_color);  // white

                                high_brush2 = new Pen(Brushes.Red); // blue

                                high_brush1 = new Pen(Brushes.Red); // red
                                double spacing;
                                double string_height = 0;
                                //=======================================
                                // meter image TR7 rx2
                                //=======================================

                                // Image src = new Bitmap(meter_image);

                                g.DrawImage(TR7, new Rectangle(0, 5, W, H));  // rectangle to show bitmap image in

                                //========================================


                                if (FREQB < 30)
                                {
                                    if (num > -73)
                                    {
                                        pixel_x = (int)(W * 0.5 + (73.0 + num) / 63.0 * (W * 0.5 - 3));
                                        pixel_x1 = (int)(W * 0.5 + (73.0 + rx2_meter_peak_value) / 63.0 * (W * 0.5 - 3));
                                    }
                                    else
                                    {
                                        pixel_x = (int)((num + 133.0) / 60.0 * (W * 0.5));
                                        pixel_x1 = (int)((rx2_meter_peak_value + 133.0) / 60.0 * (W * 0.5));
                                    }
                                } // < 30 mhz
                                else // correction for freq > 29 mhz
                                {
                                    if (num > -93) // ke9ns ADD correct S9 above 30mhz
                                    {
                                        pixel_x = (int)(W * 0.5 + (93.0 + num) / 43.0 * (W * 0.5 - 3));
                                        pixel_x1 = (int)(W * 0.5 + (93.0 + rx2_meter_peak_value) / 43.0 * (W * 0.5 - 3));
                                    }
                                    else
                                    {
                                        pixel_x = (int)((num + 133.0) / 40.0 * (W * 0.5));
                                        pixel_x1 = (int)((rx2_meter_peak_value + 133.0) / 40.0 * (W * 0.5));
                                    }
                                } // > 29 mhz

                                break; // signal RX2


                            case MeterRXMode.ADC_L:
                            case MeterRXMode.ADC_R:
                            case MeterRXMode.ADC2_L:
                            case MeterRXMode.ADC2_R:

                                spacing = ((double)W - 5.0) / 6.0;
                                g.FillRectangle(low_brush, 0, H - 8, (int)(W - 3.0 - spacing), 2);
                                g.FillRectangle(high_brush, (int)(W - 3.0 - spacing), H - 8, (int)spacing, 2);
                                for (int i = 1; i < 7; i++)
                                {
                                    b = low_brush;
                                    if (i == 6) b = high_brush;
                                    g.FillRectangle(b, (int)(i * spacing - spacing / 2), H - 8 - 3 - 3, 1, 6);
                                    g.FillRectangle(b, (int)(i * spacing), H - 8 - 6 - 6, 2, 12);

                                    //   Font f = new Font("swis721blkexbt", 7.0f, FontStyle.Bold | FontStyle.Italic); // was 7

                                    string s = (-120 + i * 20).ToString();
                                    SizeF size = g.MeasureString(s, ff, 1, StringFormat.GenericTypographic);
                                    double string_width = size.Width - 2.0;
                                    size = g.MeasureString("0", ff, 1, StringFormat.GenericTypographic);
                                    string_height = size.Height - 2.0;

                                    g.DrawString(s, ff, b, (int)(i * spacing - (int)string_width * (s.Length)), (int)(H - 8 - 12 - 3 - string_height));
                                }

                                pixel_x = (int)((num + 120.0) / 120.0 * (W - 5.0));
                                break;
                            case MeterRXMode.OFF:
                                break;
                        } //rx2_meter_mode

                    } // !MOX2


                    //=============================================
                    // Transmitter meters TR7 RX2 mic
                    //=============================================

                    else
                    {
                        MeterTXMode mode = current_meter_tx1_mode;
                        // if (chkTUN.Checked) mode = tune_meter_tx_mode;
                        switch (mode)
                        {
                            case MeterTXMode.MIC: //9990 good
                            case MeterTXMode.EQ:
                            case MeterTXMode.LEVELER:
                            case MeterTXMode.CPDR:
                            case MeterTXMode.ALC:

                                //=================================================================
                                // Draw curved meter movement for signal strength
                                //=================================================================

                                double line1 = 0;
                                const double angle_start = 55; //  45;
                                const double angle_span = 70; //  90;


                                int Origin_x = (W + CirX) / 2 - (CirX / 2);  // ke9ns mod: 82 was = (W) / 2;  center of virtual meter circle
                                int Origin_y = (W + CirX) / 2 + CirY;  // ke9ns mod: 151 was (int)((double)((H) * 1.5));  this is the height of the numbers and tick marks with respect to curved line 1.4 slightly below meter window area (where virtual meter adjustment screw would be)


                                //   low_brush1 = new Pen(analog_low_color);  // white
                                high_brush1 = new Pen(analog_high_color); // red

                                high_brush2 = new Pen(Brushes.Blue); // blue
                                high_brush3 = new Pen(Brushes.Yellow); // yellow
                                high_brush5 = new Pen(Brushes.Green); // 
                                high_brush4 = new Pen(Brushes.DarkSlateGray); // 

                                double spacing = (W * 0.665 - 2.0) / 3.0;
                                double string_height = 0;

                                //======================================
                                // Draw WHITE arc line
                                // upper left corner x,y , width,height, start angle, sweep angle

                                low_brush1.Width = arc_thick;
                                // g.DrawArc(low_brush1, 0, 37, W, W, -75, -61); // draw OUTER arc
                                g.DrawArc(low_brush1, -CirXH, CirY, W + CirX, W + CirX, -75, -50);
                                //   g.DrawArc(high_brush4, DTMx,  DTMy , W+DTM , W+DTM , DTMa ,DTMs); // draw INNER arc

                                //======================================
                                // Draw Red arc line
                                // upper left corner x,y , width,height, start angle, sweep angle

                                high_brush1.Width = arc_thick;
                                //  g.DrawArc(high_brush1, 0, 37, W, W, -44, -27); // draw OUTER arc -31
                                g.DrawArc(high_brush1, -CirXH, CirY, W + CirX, W + CirX, -55, -20); // radius = 114
                                //======================================
                                // Draw GREEN full arc line under white/red 
                                // upper left corner x,y , width,height, start angle, sweep angle

                                high_brush5.Width = arc_thick1;
                                //  g.DrawArc(high_brush5, 6, 43, W - 12, W - 12, -43, -94); // draw INNER arc
                                g.DrawArc(high_brush5, -CirXS, CirYS, W + CirXL, W + CirXL, -55, -70); // draw INNER arc


                                //======================================
                                // Draw TX Meter Name text
                                //   if (mode == MeterTXMode.CPDR) g.DrawString("CPDR", ff8, low_brush, W * 0.35F, H * 0.75F); // DDAA
                                //   else if (mode == MeterTXMode.LEVELER) g.DrawString("LVL", ff8, low_brush, W * 0.39F, H * 0.75F); // DDAA
                                //   else if (mode == MeterTXMode.EQ) g.DrawString("EQ", ff8, low_brush, W * 0.405F, H * 0.75F); // DDAA
                                //   else if (mode == MeterTXMode.MIC) g.DrawString("MIC", ff8, low_brush, W * 0.39F, H * 0.75F); // DDAA
                                //   else if (mode == MeterTXMode.ALC) g.DrawString("ALC", ff8, low_brush, W * 0.39F, H * 0.75F); // DDAA

                                //======================================
                                // WHITE  tick marks and text

                                for (double i = 1; i < 4; i++)
                                {

                                    line1 = i * spacing - spacing * 0.5;

                                    double line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    int POSW = (int)((double)(CirR + 8) * Math.Cos(line));  // convert signal to arc
                                    int POSH = (int)((double)(CirR + 8) * Math.Sin(line));

                                    int POSW_BOT = (int)((double)(CirR) * Math.Cos(line));  // convert signal to arc
                                    int POSH_BOT = (int)((double)(CirR) * Math.Sin(line));

                                    low_brush1.Width = tick_thin;
                                    g.DrawLine(low_brush1, Origin_x - POSW_BOT, Origin_y - POSH_BOT, Origin_x - POSW, Origin_y - POSH);  // draw meter 

                                    line1 = i * spacing;

                                    line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    POSW = (int)((double)(CirR + 14) * Math.Cos(line));  // convert signal to arc
                                    POSH = (int)((double)(CirR + 14) * Math.Sin(line));

                                    POSW_BOT = (int)((double)(CirR) * Math.Cos(line));  // convert signal to arc
                                    POSH_BOT = (int)((double)(CirR) * Math.Sin(line));

                                    low_brush1.Width = tick_thick;
                                    g.DrawLine(low_brush1, Origin_x - POSW_BOT, Origin_y - POSH_BOT, Origin_x - POSW, Origin_y - POSH);  // draw meter 


                                    //===============================================
                                    // Draw white numbers ALC RX1 analog


                                    SizeF size = g.MeasureString("0", ff1, 1, StringFormat.GenericTypographic);
                                    double string_width = size.Width - 2.0;
                                    string_height = size.Height - 2.0;

                                    line1 = (i * spacing - string_width + (i / 5));

                                    line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    if (i == 1)
                                    {
                                        POSW = (int)((double)(CirR + 30) * Math.Cos(line));  // 1.4 convert signal to arc
                                        POSH = (int)((double)(CirR + 30) * Math.Sin(line));  // 1.48
                                    }
                                    else
                                    {
                                        POSW = (int)((double)(CirR + 28) * Math.Cos(line));  // 1.4 convert signal to arc
                                        POSH = (int)((double)(CirR + 28) * Math.Sin(line));  // 1.48
                                    }

                                    g.DrawString((-30 + i * 10).ToString(), ff1, low_brush, Origin_x - POSW, Origin_y - POSH);


                                } // white ticks and test


                                // =======================
                                // RED tick marks and text

                                spacing = (W * 0.335 - 2.0 - 3.0) / 3.0;

                                for (double i = 1; i < 4; i++) //red
                                {

                                    line1 = W * 0.665 + i * spacing - spacing * 0.5;

                                    double line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    int POSW = (int)((double)(CirR + 8) * Math.Cos(line));  // convert signal to arc
                                    int POSH = (int)((double)(CirR + 8) * Math.Sin(line));

                                    int POSW_BOT = (int)((double)(CirR) * Math.Cos(line));  // convert signal to arc
                                    int POSH_BOT = (int)((double)(CirR + 2) * Math.Sin(line));

                                    high_brush1.Width = tick_thin;
                                    g.DrawLine(high_brush1, Origin_x - POSW_BOT, Origin_y - POSH_BOT, Origin_x - POSW, Origin_y - POSH);  // draw meter 

                                    line1 = W * 0.665 + i * spacing;

                                    line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    POSW = (int)((double)(CirR + 14) * Math.Cos(line));  // convert signal to arc
                                    POSH = (int)((double)(CirR + 14) * Math.Sin(line));

                                    POSW_BOT = (int)((double)(CirR) * Math.Cos(line));  // convert signal to arc
                                    POSH_BOT = (int)((double)(CirR) * Math.Sin(line));

                                    high_brush1.Width = tick_thick;
                                    g.DrawLine(high_brush1, Origin_x - POSW_BOT, Origin_y - POSH_BOT, Origin_x - POSW, Origin_y - POSH);  // draw meter 

                                    //==========================================
                                    // draw red text alc rx1 analog


                                    SizeF size = g.MeasureString(i.ToString(), ff2, 3, StringFormat.GenericTypographic);
                                    double string_width = size.Width - 2.0;

                                    line1 = (W * 0.665 + i * spacing - (int)string_width);

                                    line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    POSW = (int)((double)(CirR + 22) * Math.Cos(line));  // convert signal to arc
                                    POSH = (int)((double)(CirR + 22) * Math.Sin(line));


                                    g.DrawString(i.ToString(), ff2, high_brush, Origin_x - POSW, Origin_y - POSH);

                                } // red ticks and text



                                if (num > 0.0) // high area
                                {
                                    pixel_x = (int)(W * 0.665 + num / 3.0 * (W * 0.335 - 4));
                                }
                                else
                                {
                                    pixel_x = (int)((num + 30.0) / 30.0 * (W * 0.665 - 1.0));
                                }
                                break; // case MeterTXMode.ALC:


                            //===========================================TR7

                            case MeterTXMode.FORWARD_POWER:
                            case MeterTXMode.REVERSE_POWER:

                                if (pa_present || (fwc_init && (current_model == Model.FLEX5000 || current_model == Model.FLEX3000)) ||
                                      (hid_init && current_model == Model.FLEX1500))
                                {
                                    g.FillRectangle(low_brush, 0, H - 4, (int)(W * 0.75), 2);
                                    g.FillRectangle(high_brush, (int)(W * 0.75), H - 4, (int)(W * 0.25) - 10, 2);
                                    spacing = (W * 0.75 - 2.0) / 4.0;
                                    string_height = 0;
                                    //   string[] list = { "5", "10", "50", "100" };

                                    //  Image src = new Bitmap(meter_image);

                                    g.DrawImage(TR7, new Rectangle(0, 5, W, H));  // rectangle to show bitmap image in

                                    //====================================TR7
                                    // redone to work with TR7 scale ke9ns scale
                                    // 19pixel = 0watts on scale
                                    // 50px = 10watts (jumps 5px from 0 to 10)
                                    // 92px = 50watts (jumps 10px from 10watts to 50w)
                                    // 108px = 90watts (jumps 3px form 50 to 100w)


                                    spacing = (W * 0.75 - 2.0) / 4.0;                //  (W * 0.75 - 2.0) / 4.0; = 28.5

                                    if (num <= 9.0)
                                    {
                                        pixel_x = (int)(num / 9.0 * (int)spacing);          // pixel_x = (int)(num / 5.0 * (int)spacing);
                                    }
                                    else if (num <= 50.0)
                                    {

                                        pixel_x = (int)(spacing + (num - 9.0) / 22.0 * spacing);// pixel_x = (int)(spacing + (num - 5.0) / 5.0 * spacing);
                                    }
                                    else
                                    {
                                        pixel_x = (int)((1.863 * spacing) + spacing + (num - 50.0) / 80.0 * spacing);
                                    }

                                    pixel_x = pixel_x + 19; // zero point


                                } // 100watt TR7 scale


                                else // 1W version
                                {
                                    g.FillRectangle(low_brush, 0, H - 4, (int)(W * 0.75), 2);
                                    g.FillRectangle(high_brush, (int)(W * 0.75), H - 4, (int)(W * 0.25) - 9, 2);
                                    spacing = (W * 0.75 - 2.0) / 4.0;
                                    string_height = 0;
                                    string[] list = { "100", "250", "500", "800", "1000" };



                                    for (int i = 1; i < 5; i++)
                                    {
                                        g.FillRectangle(low_brush, (int)(i * spacing - spacing * 0.5), H - 4 - 3, 1, 3);
                                        g.FillRectangle(low_brush, (int)(i * spacing), H - 4 - 6, 2, 6);

                                        string s = list[i - 1];
                                        // Font f = new Font("swis721blkexbt", 7.0f, FontStyle.Bold | FontStyle.Italic); // was 7

                                        SizeF size = g.MeasureString("0", ff, 1, StringFormat.GenericTypographic);
                                        double string_width = size.Width - 2.0;
                                        string_height = size.Height - 2.0;

                                        g.DrawString(s, ff, low_brush, (int)(i * spacing - string_width * s.Length + 1.0 + (int)(i / 2) - (int)(i / 4)), (int)(H - 4 - 8 - string_height));
                                    }
                                    spacing = (W * 0.25 - 2.0 - 9.0) / 1.0;
                                    for (int i = 1; i < 2; i++)
                                    {
                                        g.FillRectangle(high_brush, (int)((double)W * 0.75 + i * spacing - spacing * 0.5), H - 4 - 3, 1, 3);
                                        g.FillRectangle(high_brush, (int)((double)W * 0.75 + i * spacing), H - 4 - 6, 2, 6);

                                        //  Font f = new Font("swis721blkexbt", 7.0f, FontStyle.Bold | FontStyle.Italic); // was 7

                                        SizeF size = g.MeasureString("0", ff, 3, StringFormat.GenericTypographic);
                                        double string_width = size.Width - 2.0;

                                        g.DrawString("1000", ff, high_brush, (int)(W * 0.75 + 2 + i * spacing - (int)4.0 * string_width), (int)(H - 4 - 8 - string_height));
                                    }



                                    num *= 1000;
                                    if (num < 801.0) // low area
                                    {
                                        spacing = (W * 0.75 - 2.0) / 4.0;
                                        if (num <= 100.0)
                                            pixel_x = (int)(num / 100.0 * spacing);
                                        else if (num <= 250.0)
                                            pixel_x = (int)(spacing + (num - 100.0) / 150.0 * spacing);
                                        else if (num <= 500.0)
                                            pixel_x = (int)(2 * spacing + (num - 250.0) / 250.0 * spacing);
                                        else
                                            pixel_x = (int)(3 * spacing + (num - 500.0) / 300.0 * spacing);
                                    }
                                    else
                                    {
                                        spacing = (W * 0.25 - 2.0 - 9.0) / 1.0;
                                        pixel_x = (int)(W * 0.75 + (num - 800.0) / 200.0 * spacing);
                                    }
                                } // 1 watt version




                                break; //POWER RX1 TR7

                            //==========================================TR7

                            case MeterTXMode.SWR: // analog RX2 meter //9990 good

                                //=================================================================
                                // Draw curved meter movement for SWR RX2
                                //=================================================================

                                line1 = 0;
                                // angle_start = 45;
                                // angle_span = 90;


                                Origin_x = (W + CirX) / 2 - (CirX / 2);  // ke9ns mod: 82 was = (W) / 2;  center of virtual meter circle
                                Origin_y = (W + CirX) / 2 + CirY;  // ke9ns mod: 151 was (int)((double)((H) * 1.5));  this is the height of the numbers and tick marks with respect to curved line 1.4 slightly below meter window area (where virtual meter adjustment screw would be)


                                //   low_brush1 = new Pen(analog_low_color);  // white


                                high_brush2 = new Pen(Brushes.Red); // blue
                                high_brush1 = new Pen(analog_high_color); // red
                                high_brush3 = new Pen(Brushes.Yellow); // yellow
                                high_brush4 = new Pen(Brushes.AntiqueWhite); // 


                                //======================================
                                // Draw WHITE arc line
                                // upper left corner x,y , width,height, start angle, sweep angle

                                grn_pen.Width = arc_thick;
                                //  g.DrawArc(grn_pen, 0, 37, W, W, -110, -26); // draw OUTER arc 
                                g.DrawArc(grn_pen, -CirXH, CirY, W + CirX, W + CirX, -105, -20); // -100 , -20
                                //   g.DrawArc(high_brush4, DTMx,  DTMy , W+DTM , W+DTM , DTMa ,DTMs); // draw INNER arc


                                //======================================
                                // Draw yel arc line

                                yel_pen.Width = arc_thick;
                                //  g.DrawArc(yel_pen, 0, 37, W, W, -93, -17); // draw OUTER arc 
                                g.DrawArc(yel_pen, -CirXH, CirY, W + CirX, W + CirX, -93, -12); // -85 -10


                                //======================================
                                // Draw Red arc line
                                // upper left corner x,y , width,height, start angle, sweep angle

                                red_pen.Width = arc_thick;
                                //  g.DrawArc(red_pen, 0, 37, W, W, -43, -51); // draw OUTER arc 
                                g.DrawArc(red_pen, -CirXH, CirY, W + CirX, W + CirX, -55, -38); // radius = 114


                                //======================================
                                // Draw Yellow full arc line under white/red 
                                // upper left corner x,y , width,height, start angle, sweep angle

                                high_brush3.Width = arc_thick1;
                                //  g.DrawArc(high_brush3, 6, 43, W - 12, W - 12, -43, -94); // draw INNER arc
                                g.DrawArc(high_brush3, -CirXS, CirYS, W + CirXL, W + CirXL, -55, -70); // draw INNER arc



                                //======================================
                                // Draw TX Meter Name text //8880
                                //   if (mode == MeterTXMode.SWR) g.DrawString("SWR", ff8, low_brush, W * 0.375F, H * 0.75F); // DDAA

                                //======================================
                                // WHITE  tick marks and text SWR


                                spacing = (W * 0.75 - 2.0) / 4.0;
                                string_height = 0;
                                string[] swr_list = { "1.5", "2", "5", "10", "20" };

                                for (double i = 1; i < 5; i++)
                                {

                                    line1 = i * spacing - spacing * 0.5;

                                    double line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    int POSW = (int)((double)(CirR + 8) * Math.Cos(line));  // convert signal to arc
                                    int POSH = (int)((double)(CirR + 8) * Math.Sin(line));

                                    int POSW_BOT = (int)((double)(CirR + 2) * Math.Cos(line));  // convert signal to arc
                                    int POSH_BOT = (int)((double)(CirR + 2) * Math.Sin(line));

                                    low_brush1.Width = tick_thin;
                                    g.DrawLine(low_brush1, Origin_x - POSW_BOT, Origin_y - POSH_BOT, Origin_x - POSW, Origin_y - POSH);  // draw meter 

                                    line1 = i * spacing;

                                    line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    POSW = (int)((double)(CirR + 14) * Math.Cos(line));  // convert signal to arc
                                    POSH = (int)((double)(CirR + 14) * Math.Sin(line));

                                    POSW_BOT = (int)((double)(CirR + 2) * Math.Cos(line));  // convert signal to arc
                                    POSH_BOT = (int)((double)(CirR + 2) * Math.Sin(line));

                                    low_brush1.Width = tick_thick;
                                    g.DrawLine(low_brush1, Origin_x - POSW_BOT, Origin_y - POSH_BOT, Origin_x - POSW, Origin_y - POSH);  // draw meter 


                                    //===============================================
                                    // Draw white numbers rx2 swr analog

                                    string s = swr_list[(int)i - 1];

                                    //  Font f = new Font("swis721blkexbt", 6.9f, FontStyle.Bold | FontStyle.Italic); // was 7

                                    SizeF size = g.MeasureString("0", ff1, 1, StringFormat.GenericTypographic);
                                    double string_width = size.Width - 2.0;
                                    string_height = size.Height - 2.0;


                                    line1 = i * spacing - string_width * s.Length + 2.0 - 2 * (int)(i / 2) + 3 * (int)(i / 4);

                                    if (i == 1) line1 = line1 + 10;


                                    line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    if (i == 1)
                                    {
                                        POSW = (int)((double)(CirR + 30) * Math.Cos(line));  // convert signal to arc
                                        POSH = (int)((double)(CirR + 30) * Math.Sin(line));
                                    }
                                    else
                                    {
                                        POSW = (int)((double)(CirR + 28) * Math.Cos(line));  // convert signal to arc
                                        POSH = (int)((double)(CirR + 28) * Math.Sin(line));
                                    }

                                    g.DrawString(s, ff1, low_brush, Origin_x - POSW, Origin_y - POSH);


                                } // white ticks and test

                                // =======================
                                // RED tick marks and text

                                spacing = (W * 0.25 - 2.0 - 9.0) / 1.0;

                                for (double i = 1; i < 2; i++) //red
                                {

                                    line1 = (double)W * 0.75 + i * spacing - spacing * 0.5;

                                    double line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    int POSW = (int)((double)(CirR + 8) * Math.Cos(line));  // convert signal to arc
                                    int POSH = (int)((double)(CirR + 8) * Math.Sin(line));

                                    int POSW_BOT = (int)((double)(CirR + 2) * Math.Cos(line));  // convert signal to arc
                                    int POSH_BOT = (int)((double)(CirR + 2) * Math.Sin(line));

                                    high_brush1.Width = tick_thin;
                                    g.DrawLine(high_brush1, Origin_x - POSW_BOT, Origin_y - POSH_BOT, Origin_x - POSW, Origin_y - POSH);  // draw meter 

                                    line1 = (double)W * 0.75 + i * spacing;

                                    line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    POSW = (int)((double)(CirR + 14) * Math.Cos(line));  // convert signal to arc
                                    POSH = (int)((double)(CirR + 14) * Math.Sin(line));

                                    POSW_BOT = (int)((double)(CirR + 2) * Math.Cos(line));  // convert signal to arc
                                    POSH_BOT = (int)((double)(CirR + 2) * Math.Sin(line));

                                    high_brush1.Width = tick_thick;
                                    g.DrawLine(high_brush1, Origin_x - POSW_BOT, Origin_y - POSH_BOT, Origin_x - POSW, Origin_y - POSH);  // draw meter 

                                    //==========================================
                                    // draw red text

                                    //   Font f = new Font("swis721blkexbt", 5.6f, FontStyle.Bold | FontStyle.Italic); // was 7

                                    SizeF size = g.MeasureString("0", ff2, 3, StringFormat.GenericTypographic);
                                    double string_width = size.Width - 2.0;

                                    line1 = W * 0.75 + i * spacing - (int)3.5 * string_width;

                                    line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    POSW = (int)((double)(CirR + 22) * Math.Cos(line));  // convert signal to arc
                                    POSH = (int)((double)(CirR + 22) * Math.Sin(line));

                                    g.DrawString("20+", ff2, high_brush, Origin_x - POSW, Origin_y - POSH);

                                } // red ticks and text



                                if (num < 10.0) // low area
                                {
                                    spacing = (W * 0.75 - 2.0) / 4.0;
                                    if (num <= 1.5)
                                        pixel_x = (int)((num - 1.0) / 0.5 * spacing);
                                    else if (num <= 2.0)
                                        pixel_x = (int)(spacing + (num - 1.5) / 0.5 * spacing);
                                    else if (num <= 5.0)
                                        pixel_x = (int)(2 * spacing + (num - 2.0) / 3.0 * spacing);
                                    else
                                        pixel_x = (int)(3 * spacing + (num - 5.0) / 5.0 * spacing);
                                }
                                else
                                {
                                    spacing = (W * 0.25 - 2.0 - 9.0) / 1.0;
                                    pixel_x = (int)(W * 0.75 + (num - 10.0) / 10.0 * spacing);
                                }
                                if (double.IsInfinity(num)) pixel_x = W - 2;

                                break;// case MeterTXMode.SWR:

                            case MeterTXMode.ALC_G:
                            case MeterTXMode.LVL_G:

                                //=================================================================
                                // Draw curved meter movement for signal strength
                                //=================================================================

                                line1 = 0;
                                // angle_start = 45;
                                // angle_span = 90;

                                Origin_x = (W + CirX) / 2 - (CirX / 2);  // ke9ns mod: 82 was = (W) / 2;  center of virtual meter circle
                                Origin_y = (W + CirX) / 2 + CirY;  // ke9ns mod: 151 was (int)((double)((H) * 1.5));  this is the height of the numbers and tick marks with respect to curved line 1.4 slightly below meter window area (where virtual meter adjustment screw would be)


                                //   low_brush1 = new Pen(analog_low_color);  // white


                                high_brush2 = new Pen(Brushes.Blue); // blue
                                high_brush1 = new Pen(analog_high_color); // red
                                high_brush3 = new Pen(Brushes.Yellow); // yellow
                                high_brush5 = new Pen(Brushes.Green); // 
                                high_brush4 = new Pen(Brushes.DarkSlateGray); // 


                                spacing = (W * 0.75 - 2.0) / 4.0;
                                string_height = 0;
                                string[] gain_list = { "5", "10", "15", "20", "25" };


                                //=================================================================
                                // Draw curved meter movement for Power
                                //=================================================================

                                //======================================
                                // Draw WHITE arc line
                                // upper left corner x,y , width,height, start angle, sweep angle

                                low_brush1.Width = arc_thick;
                                //  g.DrawArc(low_brush1, 0, 37, W, W, -67, -68); // draw OUTER arc
                                g.DrawArc(low_brush1, -CirXH, CirY, W + CirX, W + CirX, -75, -50);
                                //   g.DrawArc(high_brush4, DTMx,  DTMy , W+DTM , W+DTM , DTMa ,DTMs); // draw INNER arc

                                //======================================
                                // Draw Red arc line
                                // upper left corner x,y , width,height, start angle, sweep angle

                                high_brush1.Width = arc_thick;
                                //   g.DrawArc(high_brush1, 0, 37, W, W, -44, -20); // draw OUTER arc -24
                                g.DrawArc(high_brush1, -CirXH, CirY, W + CirX, W + CirX, -55, -20); // radius = 114

                                //======================================
                                // Draw Green full arc line under white/red 
                                // upper left corner x,y , width,height, start angle, sweep angle

                                high_brush5.Width = arc_thick1;
                                //  g.DrawArc(high_brush5, 6, 43, W - 12, W - 12, -43, -94); // draw INNER arc
                                g.DrawArc(high_brush5, -CirXS, CirYS, W + CirXL, W + CirXL, -55, -70); // draw INNER arc



                                //======================================
                                // Draw TX Meter Name text
                                //   if (mode == MeterTXMode.LVL_G) g.DrawString("LVLG", ff8, low_brush, W * 0.35F, H * 0.75F); // DDAA
                                //    else if (mode == MeterTXMode.ALC_G) g.DrawString("ALCG", ff8, low_brush, W * 0.35F, H * 0.75F); // DDAA

                                //======================================
                                // WHITE  tick marks and text

                                for (double i = 1; i < 5; i++)
                                {

                                    line1 = i * spacing - spacing * 0.5;

                                    double line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    int POSW = (int)((double)(CirR + 8) * Math.Cos(line));  // convert signal to arc
                                    int POSH = (int)((double)(CirR + 8) * Math.Sin(line));

                                    int POSW_BOT = (int)((double)(CirR + 2) * Math.Cos(line));  // convert signal to arc
                                    int POSH_BOT = (int)((double)(CirR + 2) * Math.Sin(line));

                                    low_brush1.Width = tick_thin;
                                    g.DrawLine(low_brush1, Origin_x - POSW_BOT, Origin_y - POSH_BOT, Origin_x - POSW, Origin_y - POSH);  // draw meter 

                                    line1 = i * spacing;

                                    line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    POSW = (int)((double)(CirR + 14) * Math.Cos(line));  // convert signal to arc
                                    POSH = (int)((double)(CirR + 14) * Math.Sin(line));

                                    POSW_BOT = (int)((double)(CirR + 2) * Math.Cos(line));  // convert signal to arc
                                    POSH_BOT = (int)((double)(CirR + 2) * Math.Sin(line));

                                    low_brush1.Width = tick_thick;
                                    g.DrawLine(low_brush1, Origin_x - POSW_BOT, Origin_y - POSH_BOT, Origin_x - POSW, Origin_y - POSH);  // draw meter 


                                    //===============================================
                                    // Draw white numbers

                                    string s = gain_list[(int)i - 1];

                                    SizeF size = g.MeasureString("0", ff1, 1, StringFormat.GenericTypographic);
                                    double string_width = size.Width - 2.0;
                                    string_height = size.Height - 2.0;

                                    line1 = (i * spacing - string_width + (i / 5));

                                    line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math


                                    if (i == 1)
                                    {
                                        POSW = (int)((double)(CirR + 30) * Math.Cos(line));  // convert signal to arc
                                        POSH = (int)((double)(CirR + 30) * Math.Sin(line));
                                    }
                                    else
                                    {
                                        POSW = (int)((double)(CirR + 28) * Math.Cos(line));  // convert signal to arc
                                        POSH = (int)((double)(CirR + 28) * Math.Sin(line));
                                    }
                                    g.DrawString(s, ff1, low_brush, Origin_x - POSW, Origin_y - POSH);


                                } // white ticks and test


                                // =======================
                                // RED tick marks and text

                                spacing = (W * 0.25 - 2.0 - 9.0) / 1.0;

                                for (double i = 1; i < 2; i++) //red
                                {

                                    line1 = W * 0.75 + i * spacing - spacing * 0.5;

                                    double line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    int POSW = (int)((double)(CirR + 8) * Math.Cos(line));  // convert signal to arc
                                    int POSH = (int)((double)(CirR + 8) * Math.Sin(line));

                                    int POSW_BOT = (int)((double)(CirR + 2) * Math.Cos(line));  // convert signal to arc
                                    int POSH_BOT = (int)((double)(CirR + 2) * Math.Sin(line));

                                    high_brush1.Width = tick_thin;
                                    g.DrawLine(high_brush1, Origin_x - POSW_BOT, Origin_y - POSH_BOT, Origin_x - POSW, Origin_y - POSH);  // draw meter 

                                    line1 = W * 0.75 + i * spacing;

                                    line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    POSW = (int)((double)(CirR + 14) * Math.Cos(line));  // convert signal to arc
                                    POSH = (int)((double)(CirR + 14) * Math.Sin(line));

                                    POSW_BOT = (int)((double)(CirR + 2) * Math.Cos(line));  // convert signal to arc
                                    POSH_BOT = (int)((double)(CirR + 2) * Math.Sin(line));

                                    high_brush1.Width = tick_thick;
                                    g.DrawLine(high_brush1, Origin_x - POSW_BOT, Origin_y - POSH_BOT, Origin_x - POSW, Origin_y - POSH);  // draw meter 

                                    //==========================================
                                    // draw red text

                                    SizeF size = g.MeasureString("0", ff2, 3, StringFormat.GenericTypographic);
                                    double string_width = size.Width - 2.0;


                                    line1 = (W * 0.75 + i * spacing - (int)2.5 * string_width);

                                    line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    POSW = (int)((double)(CirR + 22) * Math.Cos(line));  // convert signal to arc
                                    POSH = (int)((double)(CirR + 22) * Math.Sin(line));


                                    g.DrawString("25+", ff2, high_brush, Origin_x - POSW, Origin_y - POSH);

                                } // red ticks and text

                                spacing = (W * 0.75 - 2.0) / 4.0;
                                pixel_x = (int)(num / 5.0 * spacing);

                                break;// case MeterTXMode.LVL_G:

                            case MeterTXMode.OFF:
                                break;
                        } // switch (mode)

                    } // mox2



                    //=============================================
                    // ke9ns needle movement TR7 rx2 
                    //=============================================

                    if (  // EDGE meter movement here
                        (((rx2_meter_mode == MeterRXMode.ADC2_R) || (rx2_meter_mode == MeterRXMode.ADC2_L) ||
                       (rx2_meter_mode == MeterRXMode.ADC_R) || (rx2_meter_mode == MeterRXMode.ADC_L)) &&
                       (!mox2 && rx2_meter_mode != MeterRXMode.OFF))
                        || ((mox2 && current_meter_tx1_mode != MeterTXMode.OFF) && (current_meter_tx1_mode != MeterTXMode.LVL_G) &&
                        (current_meter_tx1_mode != MeterTXMode.ALC_G) && (current_meter_tx1_mode != MeterTXMode.CPDR) &&
                        (current_meter_tx1_mode != MeterTXMode.LEVELER) && (current_meter_tx1_mode != MeterTXMode.EQ) &&
                        (current_meter_tx1_mode != MeterTXMode.MIC) && (current_meter_tx1_mode != MeterTXMode.ALC) &&
                        (current_meter_tx1_mode != MeterTXMode.SWR) && (current_meter_tx1_mode != MeterTXMode.FORWARD_POWER) &&
                        (current_meter_tx1_mode != MeterTXMode.REVERSE_POWER))
                         )
                    // if meter is ON in RX or TX mode, then draw line
                    {
                        pixel_x = Math.Max(0, pixel_x);
                        pixel_x = Math.Min(W - 3, pixel_x);

                        line_pen = new Pen(edge_avg_color);

                        //  line_dark_pen = new Pen(
                        //     Color.FromArgb((edge_avg_color.R + edge_meter_background_color.R) / 2,
                        //     (edge_avg_color.G + edge_meter_background_color.G) / 2,
                        //     (edge_avg_color.B + edge_meter_background_color.B) / 2));


                        g.DrawLine(line_dark_pen, pixel_x - 1, 0, pixel_x - 1, H);
                        g.DrawLine(line_pen, pixel_x, 0, pixel_x, H);
                        g.DrawLine(line_dark_pen, pixel_x + 1, 0, pixel_x + 1, H);

                    }
                    else if (  // TX TR7 meter movements
                                 ((mox2 && current_meter_tx1_mode != MeterTXMode.OFF) && ((current_meter_tx1_mode == MeterTXMode.LVL_G) ||
                                 (current_meter_tx1_mode == MeterTXMode.ALC_G) || (current_meter_tx1_mode == MeterTXMode.EQ) ||
                                 (current_meter_tx1_mode == MeterTXMode.MIC) || (current_meter_tx1_mode == MeterTXMode.ALC) ||
                                 (current_meter_tx1_mode == MeterTXMode.SWR)))
                            )

                    {

                        // pixel_x (i.e. signal) goes from 0 to W  Width 
                        // posx = originx + (2 * D * cos (angle))
                        // posy = originy + (2 * D * sin (angle))
                        // for a meter of 45deg to 135deg = 90deg total span :   
                        // but sin and cos in radians not degs.
                        // posx = originx + (2 * D * cos (angle*PI/180))

                        //  box dimensions:
                        //  0,0   W,0
                        //  0,H   W,H

                        pixel_x = Math.Max(0, pixel_x);
                        pixel_x = Math.Min(W - 3, pixel_x);                                             // define limits of X dimension




                        line_pen = new Pen(Color.Blue);
                        line_pen.Width = 2.8F;


                        int Origin_x = W / 2;
                        int Origin_y = (int)((double)(H * 1.5)); // 1.4 slightly below meter window area (where virtual meter adjustment screw would be)

                        double angle_start = 45;
                        double angle_span = 90;

                        angle = signal = (angle_start + ((double)pixel_x * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                        signal = signal * CirA;                                                // convert angle to radians for cos/sin math

                        int POSW = (int)((double)(H * 1.25) * Math.Cos(signal));  // convert signal to arc
                        int POSH = (int)((double)(H * 1.25) * Math.Sin(signal));

                        g.DrawLine(line_pen, Origin_x, Origin_y, Origin_x - POSW, Origin_y - POSH);  // draw meter needle movement (by flipping result around since inc values go down not up)





                    } // SWR TX curved needle

                    // POWER ONLY===TR7==RX2======================================================================================= ke9ns scale
                    else if (
                        ((mox2 && current_meter_tx1_mode != MeterTXMode.OFF) && ((current_meter_tx1_mode == MeterTXMode.FORWARD_POWER) ||
                        (current_meter_tx1_mode == MeterTXMode.REVERSE_POWER)))
                        )
                    {

                        pixel_x = Math.Max(0, pixel_x);
                        pixel_x = Math.Min(W - 3, pixel_x);                                             // define limits of X dimension

                        line_pen = new Pen(Color.Red); // rx 



                        // 54 = 10 watts" 
                        // 80 = 40 watts


                        int Origin_x = (W / 2) - 1;
                        int Origin_y = (int)((double)(H * 1.84)); //1.90  1.4 slightly below meter window area (where virtual meter adjustment screw would be)


                        double angle_start = 45;
                        double angle_span = 89;


                        angle = signal = (angle_start + ((double)pixel_x * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                        signal = signal * CirA;                                                // convert angle to radians for cos/sin math

                        int POSW = (int)((double)(H * 1.6) * Math.Cos(signal));  // 1.65 convert signal to arc
                        int POSH = (int)((double)(H * 1.6) * Math.Sin(signal));


                        line_pen.Width = 2.8F;
                        g.DrawLine(line_pen, Origin_x, Origin_y, Origin_x - POSW, Origin_y - POSH);  // draw meter needle movement (by flipping result around since inc values go down not up)



                    } // power
                      // SIGNAL ONLY===TR7==RX2=========================================================================================================
                      // this should be SIGNAL, AVG SIGNAL, PEAK SIGNAL
                    else if (
                            (((rx2_meter_mode == MeterRXMode.SIGNAL_STRENGTH) || (rx2_meter_mode == MeterRXMode.SIGNAL_AVERAGE) ||
                            (rx2_meter_mode == MeterRXMode.SIGNAL_PEAK)) && (!mox2 && rx2_meter_mode != MeterRXMode.OFF))
                       )
                    {
                        // SIGNAL ONLY

                        pixel_x = Math.Max(0, pixel_x);
                        pixel_x = Math.Min(W - 3, pixel_x);                                             // define limits of X dimension

                        pixel_x1 = Math.Max(0, pixel_x1);
                        pixel_x1 = Math.Min(W - 3, pixel_x1);                                             // define limits of X dimension

                        line_pen = new Pen(Color.Yellow); // rx 


                        int Origin_x = (W / 2) - 3;
                        int Origin_y = (int)((double)(H * 1.9)); // 1.84 slightly below meter window area (where virtual meter adjustment screw would be)

                        double angle_start = 45;
                        double angle_span = 89;


                        if ((rx2_meter_mode == MeterRXMode.SIGNAL_PEAK) && (!mox2 && rx2_meter_mode != MeterRXMode.OFF)) // ke9ns ADD
                        {

                            angle = signal = (angle_start + ((double)pixel_x1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                            signal = signal * CirA;                                                // convert angle to radians for cos/sin math

                            int POSW1 = (int)((double)(H * 1.65) * Math.Cos(signal));  // convert signal to arc 1.6 length of needle
                            int POSH1 = (int)((double)(H * 1.65) * Math.Sin(signal));

                            line_pen = new Pen(Color.Red);
                            line_pen.Width = 3.0F;
                            g.DrawLine(line_pen, Origin_x, Origin_y, Origin_x - POSW1, Origin_y - POSH1);  // draw meter needle movement (by flipping result around since inc values go down not up)


                        } // peak

                        angle = signal = (angle_start + ((double)pixel_x * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                        signal = signal * CirA;                                                // convert angle to radians for cos/sin math

                        int POSW = (int)((double)(H * 1.65) * Math.Cos(signal));  // convert signal to arc
                        int POSH = (int)((double)(H * 1.65) * Math.Sin(signal));

                        line_pen = new Pen(Color.Yellow);

                        line_pen.Width = 2.6F;
                        g.DrawLine(line_pen, Origin_x, Origin_y, Origin_x - POSW, Origin_y - POSH);  // draw meter needle movement (by flipping result around since inc values go down not up)



                    } //   if meter is ON in RX or TX mode, then draw line


                    //=================================================================
                    // needle RX2 TR7

                    /*
                    if ( // RX2 EDGE movement

                        ( (rx2_meter_mode == MeterRXMode.ADC2_R) || (rx2_meter_mode == MeterRXMode.ADC2_L) ||
                       (rx2_meter_mode == MeterRXMode.ADC_R) || (rx2_meter_mode == MeterRXMode.ADC_L)) && 
                       ((!mox && rx2_meter_mode != MeterRXMode.OFF) || (mox && current_meter_tx1_mode != MeterTXMode.OFF))

                       )  
                        {
                        pixel_x = Math.Max(0, pixel_x);
                        pixel_x = Math.Min(W-3, pixel_x);

                        line_pen = new Pen(edge_avg_color);
                        line_dark_pen = new Pen(
                            Color.FromArgb((edge_avg_color.R+edge_meter_background_color.R)/2,
                            (edge_avg_color.G+edge_meter_background_color.G)/2,
                            (edge_avg_color.B+edge_meter_background_color.B)/2));



                        g.DrawLine(line_dark_pen, pixel_x-1, 0, pixel_x-1, H);
                        g.DrawLine(line_pen, pixel_x, 0, pixel_x, H);
                        g.DrawLine(line_dark_pen, pixel_x+1, 0, pixel_x+1, H);


                    }


                    else if ( // RX2 SIGNAL, AVG SIGNAL, PEAK SIGNAL tr7

                            ((rx2_meter_mode == MeterRXMode.SIGNAL_STRENGTH) || (rx2_meter_mode == MeterRXMode.SIGNAL_AVERAGE) ||
                            (rx2_meter_mode == MeterRXMode.SIGNAL_PEAK)) && ( (!mox && rx2_meter_mode != MeterRXMode.OFF)
                                      || (mox && current_meter_tx1_mode != MeterTXMode.OFF) )
                        )

                    {

                        // pixel_x (i.e. signal) goes from 0 to W  Width 
                        // posx = originx + (2 * D * cos (angle))
                        // posy = originy + (2 * D * sin (angle))
                        // for a meter of 45deg to 135deg = 90deg total span :   
                        // but sin and cos in radians not degs.
                        // posx = originx + (2 * D * cos (angle*PI/180))

                        //  box dimensions:
                        //  0,0   W,0
                        //  0,H   W,H


                        pixel_x = Math.Max(0, pixel_x);
                        pixel_x = Math.Min(W - 3, pixel_x);                                             // define limits of X dimension

                        pixel_x1 = Math.Max(0, pixel_x1);
                        pixel_x1 = Math.Min(W - 3, pixel_x1);

                        line_pen = new Pen(Color.Yellow); // rx 
                      //  line_dark_pen = 
                      //  new Pen( Color.FromArgb((edge_avg_color.R + edge_meter_background_color.R) / 2,(edge_avg_color.G + edge_meter_background_color.G) / 2,(edge_avg_color.B + edge_meter_background_color.B) / 2));




                        int Origin_x = (W / 2)-3;
                        int Origin_y = (int)((double)(H * 1.84)); // 1.4 slightly below meter window area (where virtual meter adjustment screw would be)

                        double angle_start = 45;
                        double angle_span = 89;


                        if ((rx2_meter_mode == MeterRXMode.SIGNAL_PEAK) && (!mox && rx2_meter_mode != MeterRXMode.OFF)) // ke9ns ADD
                        {

                          angle =   signal = (angle_start + ((double)pixel_x1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                            signal = signal * CirA;                                                // convert angle to radians for cos/sin math

                            int POSW1 = (int)((double)(H * 1.6) * Math.Cos(signal));  // convert signal to arc
                            int POSH1 = (int)((double)(H * 1.6) * Math.Sin(signal));

                            line_pen = new Pen(Color.Red);
                            line_pen.Width = 3.5F;
                            g.DrawLine(line_pen, Origin_x, Origin_y, Origin_x - POSW1, Origin_y - POSH1);  // draw meter needle movement (by flipping result around since inc values go down not up)

                        } // peak


                       angle =   signal = (angle_start + ((double)pixel_x * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                        signal = signal * CirA;                                                // convert angle to radians for cos/sin math

                        int POSW = (int)( (double)(H*1.6) * Math.Cos(signal) );  // convert signal to arc
                        int POSH = (int)( (double)(H*1.6) * Math.Sin(signal) );

                        line_pen = new Pen(Color.Yellow);
                        line_pen.Width = 2.5F;

                        g.DrawLine(line_pen, Origin_x, Origin_y, Origin_x - POSW, Origin_y - POSH);  // draw meter needle movement (by flipping result around since inc values go down not up)






                    } //   if meter is ON in RX or TX mode, then draw line
                    */
                    //================================================================
                    rx2_meter_timer.Stop();

                    //string 
                    format = "f0";
                    if (meter_detail) format = "f1";

                    if (rx2_meter_timer.DurationMsec >= meter_dig_delay) // timer to update numbers 
                    {
                        if (!mox2) // RX
                        {

                            switch (rx2_meter_mode)
                            {
                                case MeterRXMode.SIGNAL_STRENGTH:

                                case MeterRXMode.SIGNAL_AVERAGE:
                                    output = num.ToString(format) + " dBm ";
                                    break;
                                case MeterRXMode.SIGNAL_PEAK: // ke9ns2 ADD 
                                    output = rx2_meter_peak_value.ToString(format) + " dBm ";
                                    break;
                                case MeterRXMode.ADC_L:
                                case MeterRXMode.ADC_R:
                                case MeterRXMode.ADC2_L:
                                case MeterRXMode.ADC2_R:
                                    output = num.ToString("f1") + " dBFS ";
                                    break;
                                case MeterRXMode.OFF:
                                    output = "";
                                    break;
                            }

                        }
                        else
                        {


                            MeterTXMode mode = current_meter_tx1_mode;
                            // if (chkTUN.Checked) mode = tune_meter_tx1_mode;
                            switch (mode)
                            {
                                case MeterTXMode.MIC:
                                    output = num.ToString(format) + " dB ";
                                    break;
                                case MeterTXMode.LEVELER:
                                case MeterTXMode.LVL_G:
                                case MeterTXMode.EQ:
                                case MeterTXMode.CPDR:
                                case MeterTXMode.ALC:
                                case MeterTXMode.ALC_G:
                                    if (!mox) output = "-30 dB ";
                                    else output = num.ToString(format) + " dB ";
                                    break;
                                case MeterTXMode.FORWARD_POWER:
                                case MeterTXMode.REVERSE_POWER:
                                    switch (current_model)
                                    {
                                        case Model.FLEX5000:
                                        case Model.FLEX3000:
                                            if (!mox) output = "0 W ";
                                            else output = num.ToString("f0") + " W ";
                                            break;
                                        case Model.FLEX1500:
                                            if (!mox) output = "0 % ";
                                            else output = num.ToString("f0") + " % ";
                                            break;
                                    }
                                    break;
                                case MeterTXMode.SWR:
                                    if (!mox) output = "0 : 1 ";
                                    else output = num.ToString("f1") + " : 1 ";
                                    break;
                                case MeterTXMode.OFF:
                                    output = "";
                                    break;

                            }// switch mode
                        }//mox2

                        txtRX2Meter.Text = output; //only show digital numbers if RX2 ON or 2nd Meter is ON and in TX mode

                        rx2_meter_timer.Start();
                    }

                    if (rx2_meter_data_ready)
                    {
                        rx2_meter_data_ready = false;  //We do NOT want to do this before we have consumed it!!!! so do it here.
                    }


                    #endregion
                    break; // RX2 TR7


                //=============================================================
                //=============================================================
                //KE9NS 5 RX2 EDGE
                //=============================================================
                //=============================================================

                case MultiMeterDisplayMode.Edge:

                    #region Edge


                    if (rx2_meter_data_ready)
                    {
                        rx2_meter_current_data = rx2_meter_new_data;
                        rx2_meter_data_ready = false;
                    }

                    if (rx2_avg_num == Display.CLEAR_FLAG) // reset average -- just use new value
                    {
                        num = rx2_avg_num = rx2_meter_current_data;
                    }
                    else
                    {
                        if (rx2_meter_current_data > rx2_avg_num)
                            num = rx2_avg_num = rx2_meter_current_data * 0.8 + rx2_avg_num * 0.2; // fast rise
                        else
                            num = rx2_avg_num = rx2_meter_current_data * 0.2 + rx2_avg_num * 0.8; // slow decay
                    }

                    //   if ((mox2) && (!mox)) num = 0.0;  // zero the value if in 2nd tx mode but not transmitting

                    g.DrawRectangle(new Pen(edge_meter_background_color), 0, 0, W, H);

                    low_brush = new SolidBrush(edge_low_color);
                    high_brush = new SolidBrush(edge_high_color);


                    if (!mox2)
                    {
                        switch (rx2_meter_mode)
                        {
                            case MeterRXMode.SIGNAL_STRENGTH:
                            case MeterRXMode.SIGNAL_AVERAGE:
                            case MeterRXMode.SIGNAL_PEAK:  // ke9ns ADD


                                g.FillRectangle(low_brush, 0, H - 8, (int)(W * 0.5), 2);                    // draw line at bottom of meter white 
                                g.FillRectangle(high_brush, (int)(W * 0.5), H - 8, (int)(W * 0.5) - 4, 2);      // draw line at bottom of meter red

                                double spacing = (W * 0.5 - 2.0) / 5.0;
                                double string_height = 0;

                                for (int i = 1; i < 6; i++)                                                 // white tick marks and white Signal strength numbers
                                {
                                    g.FillRectangle(low_brush, (int)(i * spacing - spacing * 0.5), H - 8 - 3 - 3, 1, 6);
                                    g.FillRectangle(low_brush, (int)(i * spacing), H - 8 - 6 - 6, 2, 12);

                                    //   Font f = new Font("swis721blkexbt", 7.0f, FontStyle.Bold | FontStyle.Italic); // was 7


                                    SizeF size = g.MeasureString((-1 + i * 2).ToString(), ff, 1, StringFormat.GenericTypographic);
                                    double string_width = size.Width - 2.0;
                                    string_height = size.Height - 2.0;

                                    // g.TextRenderingHint = TextRenderingHint.AntiAlias;
                                    //  g.SmoothingMode = SmoothingMode.AntiAlias;

                                    g.DrawString((-1 + i * 2).ToString(), ff, low_brush, (int)(i * spacing - string_width + (int)(i / 5)), (int)(H - 8 - 12 - 3 - string_height));
                                    //  g.SmoothingMode = SmoothingMode.None;
                                }


                                spacing = ((double)W * 0.5 - 2.0 - 4.0) / 3.0;
                                for (int i = 1; i < 4; i++)                                              // Red tick marks and white Signal strength numbers
                                {
                                    g.FillRectangle(high_brush, (int)((double)W * 0.5 + i * spacing - spacing * 0.5), H - 8 - 3 - 3, 1, 6);
                                    g.FillRectangle(high_brush, (int)((double)W * 0.5 + i * spacing), H - 8 - 6 - 6, 2, 12);

                                    //  Font f = new Font("swis721blkexbt", 5.5f, FontStyle.Bold | FontStyle.Italic); // was 7

                                    SizeF size = g.MeasureString("+" + (i * 20).ToString(), ff, 3, StringFormat.GenericTypographic);
                                    double string_width = size.Width - 2.0;

                                    //g.TextRenderingHint = TextRenderingHint.SystemDefault;
                                    g.DrawString("+" + (i * 20).ToString(), ff2, high_brush, (int)(W * 0.5 + i * spacing - (int)string_width * 3 - i / 3 * 2), (int)(H - 8 - 12 - 3 - string_height));
                                }




                                if (FREQB < 30)
                                {
                                    if (num > -73)
                                    {
                                        pixel_x = (int)(W * 0.5 + (73.0 + num) / 63.0 * (W * 0.5 - 3));
                                        pixel_x1 = (int)(W * 0.5 + (73.0 + rx2_meter_peak_value) / 63.0 * (W * 0.5 - 3));
                                    }
                                    else
                                    {
                                        pixel_x = (int)((num + 133.0) / 60.0 * (W * 0.5));
                                        pixel_x1 = (int)((rx2_meter_peak_value + 133.0) / 60.0 * (W * 0.5));
                                    }
                                } // < 30 mhz
                                else // correction for freq > 29 mhz
                                {
                                    if (num > -93) // ke9ns ADD correct S9 above 30mhz
                                    {
                                        pixel_x = (int)(W * 0.5 + (93.0 + num) / 43.0 * (W * 0.5 - 3));
                                        pixel_x1 = (int)(W * 0.5 + (93.0 + rx2_meter_peak_value) / 43.0 * (W * 0.5 - 3));
                                    }
                                    else
                                    {
                                        pixel_x = (int)((num + 133.0) / 40.0 * (W * 0.5));
                                        pixel_x1 = (int)((rx2_meter_peak_value + 133.0) / 40.0 * (W * 0.5));
                                    }
                                } // > 29 mhz


                                break; // signal rx2


                            case MeterRXMode.ADC_L:
                            case MeterRXMode.ADC_R:
                            case MeterRXMode.ADC2_L:
                            case MeterRXMode.ADC2_R:
                                spacing = ((double)W - 5.0) / 6.0;
                                g.FillRectangle(low_brush, 0, H - 8, (int)(W - 3.0 - spacing), 2);
                                g.FillRectangle(high_brush, (int)(W - 3.0 - spacing), H - 8, (int)spacing, 2);
                                for (int i = 1; i < 7; i++)
                                {
                                    b = low_brush;
                                    if (i == 6) b = high_brush;
                                    g.FillRectangle(b, (int)(i * spacing - spacing / 2), H - 8 - 3 - 3, 1, 6);
                                    g.FillRectangle(b, (int)(i * spacing), H - 8 - 6 - 6, 2, 12);

                                    //  Font f = new Font("swis721blkexbt", 7.0f, FontStyle.Bold | FontStyle.Italic); // was 7

                                    string s = (-120 + i * 20).ToString();
                                    SizeF size = g.MeasureString(s, ff, 1, StringFormat.GenericTypographic);
                                    double string_width = size.Width - 2.0;
                                    size = g.MeasureString("0", ff, 1, StringFormat.GenericTypographic);
                                    string_height = size.Height - 2.0;

                                    g.DrawString(s, ff, b, (int)(i * spacing - (int)string_width * (s.Length)), (int)(H - 8 - 12 - 3 - string_height));
                                }

                                pixel_x = (int)((num + 120.0) / 120.0 * (W - 5.0));
                                break;
                            case MeterRXMode.OFF:
                                break;
                        } // rx2 meter mode					
                    } // !MOX2

                    else // if MOX2 == true
                    {
                        MeterTXMode mode = current_meter_tx1_mode;
                        // if (chkTUN.Checked) mode = tune_meter_tx1_mode;
                        switch (mode)
                        {
                            case MeterTXMode.MIC:
                            case MeterTXMode.EQ:
                            case MeterTXMode.LEVELER:
                            case MeterTXMode.CPDR:
                            case MeterTXMode.ALC:
                                g.FillRectangle(low_brush, 0, H - 8, (int)(W * 0.665), 2);
                                g.FillRectangle(high_brush, (int)(W * 0.665), H - 8, (int)(W * 0.335) - 2, 2);
                                double spacing = (W * 0.665 - 2.0) / 3.0;
                                double string_height = 0;
                                for (int i = 1; i < 4; i++)
                                {
                                    g.FillRectangle(low_brush, (int)(i * spacing - spacing * 0.5), H - 8 - 3 - 3, 1, 6);
                                    g.FillRectangle(low_brush, (int)(i * spacing), H - 8 - 6 - 6, 2, 12);

                                    string s = (-30 + i * 10).ToString();
                                    //   Font f = new Font("swis721blkexbt", 7.0f, FontStyle.Bold | FontStyle.Italic); // was 7

                                    SizeF size = g.MeasureString("0", ff, 1, StringFormat.GenericTypographic);
                                    double string_width = size.Width - 2.0;
                                    string_height = size.Height - 2.0;

                                    //g.TextRenderingHint = TextRenderingHint.AntiAlias;
                                    //g.SmoothingMode = SmoothingMode.AntiAlias;
                                    g.DrawString(s, ff, low_brush, (int)(i * spacing - string_width * s.Length + 1.0 - (int)(i / 2) + (int)(i / 3)), (int)(H - 8 - 12 - 3 - string_height));
                                    //g.SmoothingMode = SmoothingMode.None;
                                }
                                spacing = (W * 0.335 - 2.0 - 3.0) / 3.0;
                                for (int i = 1; i < 4; i++)
                                {
                                    g.FillRectangle(high_brush, (int)((double)W * 0.665 + i * spacing - spacing * 0.5), H - 8 - 3 - 3, 1, 6);
                                    g.FillRectangle(high_brush, (int)((double)W * 0.665 + i * spacing), H - 8 - 6 - 6, 2, 12);

                                    //   Font f = new Font("swis721blkexbt", 7.0f, FontStyle.Bold | FontStyle.Italic); // was 7

                                    SizeF size = g.MeasureString(i.ToString(), ff, 3, StringFormat.GenericTypographic);
                                    double string_width = size.Width - 2.0;

                                    //  g.TextRenderingHint = TextRenderingHint.SystemDefault;
                                    g.DrawString(i.ToString(), ff, high_brush, (int)(W * 0.665 + i * spacing - (int)string_width), (int)(H - 8 - 12 - 3 - string_height));
                                }

                                if (num > 0.0) // high area
                                {
                                    pixel_x = (int)(W * 0.665 + num / 3.0 * (W * 0.335 - 4));
                                }
                                else
                                {
                                    pixel_x = (int)((num + 30.0) / 30.0 * (W * 0.665 - 1.0));
                                }
                                break;

                            case MeterTXMode.FORWARD_POWER:
                            case MeterTXMode.REVERSE_POWER:
                                if (pa_present || (fwc_init && (current_model == Model.FLEX5000 || current_model == Model.FLEX3000)) ||
                                    (hid_init && current_model == Model.FLEX1500))
                                {
                                    g.FillRectangle(low_brush, 0, H - 8, (int)(W * 0.75), 2);
                                    g.FillRectangle(high_brush, (int)(W * 0.75), H - 8, (int)(W * 0.25) - 10, 2);
                                    spacing = (W * 0.75 - 2.0) / 4.0;
                                    string_height = 0;
                                    string[] list = { "5", "10", "50", "100" };
                                    for (int i = 1; i < 5; i++)
                                    {
                                        g.FillRectangle(low_brush, (int)(i * spacing - spacing * 0.5), H - 8 - 3 - 3, 1, 6);
                                        g.FillRectangle(low_brush, (int)(i * spacing), H - 8 - 6 - 6, 2, 12);

                                        string s = list[i - 1];
                                        //   Font f = new Font("swis721blkexbt", 7.0f, FontStyle.Bold | FontStyle.Italic); // was 7

                                        SizeF size = g.MeasureString("0", ff, 1, StringFormat.GenericTypographic);
                                        double string_width = size.Width - 2.0;
                                        string_height = size.Height - 2.0;

                                        //g.TextRenderingHint = TextRenderingHint.AntiAlias;
                                        //g.SmoothingMode = SmoothingMode.AntiAlias;
                                        g.DrawString(s, ff, low_brush, (int)(i * spacing - string_width * s.Length + (int)(i / 3) + (int)(i / 4)), (int)(H - 8 - 12 - 3 - string_height));
                                        //g.SmoothingMode = SmoothingMode.None;
                                    }
                                    spacing = (W * 0.25 - 2.0 - 10.0) / 1.0;
                                    for (int i = 1; i < 2; i++)
                                    {
                                        g.FillRectangle(high_brush, (int)((double)W * 0.75 + i * spacing - spacing * 0.5), H - 8 - 3 - 3, 1, 6);
                                        g.FillRectangle(high_brush, (int)((double)W * 0.75 + i * spacing), H - 8 - 6 - 6, 2, 12);

                                        //   Font f = new Font("swis721blkexbt", 7.0f, FontStyle.Bold | FontStyle.Italic); // was 7

                                        SizeF size = g.MeasureString("0", ff, 3, StringFormat.GenericTypographic);
                                        double string_width = size.Width - 2.0;

                                        //    g.TextRenderingHint = TextRenderingHint.SystemDefault;
                                        g.DrawString("120+", ff, high_brush, (int)(W * 0.75 + i * spacing - (int)3.5 * string_width), (int)(H - 8 - 12 - 3 - string_height));
                                    }

                                    if (num <= 100.0) // low area
                                    {
                                        spacing = (W * 0.75 - 2.0) / 4.0;
                                        if (num <= 5.0)
                                            pixel_x = (int)(num / 5.0 * (int)spacing);
                                        else if (num <= 10.0)
                                            pixel_x = (int)(spacing + (num - 5.0) / 5.0 * spacing);
                                        else if (num <= 50.0)
                                            pixel_x = (int)(2 * spacing + (num - 10.0) / 40.0 * spacing);
                                        else
                                            pixel_x = (int)(3 * spacing + (num - 50.0) / 50.0 * spacing);
                                    }
                                    else
                                    {
                                        spacing = (W * 0.25 - 2.0 - 10.0) / 1.0;
                                        if (num <= 120.0)
                                            pixel_x = (int)(W * 0.75 + (num - 100.0) / 20.0 * spacing);
                                        else
                                            pixel_x = (int)(W * 0.75 + spacing + (num - 120.0) / 60.0 * spacing);
                                    }
                                }
                                else // 1W version
                                {
                                    g.FillRectangle(low_brush, 0, H - 8, (int)(W * 0.75), 2);
                                    g.FillRectangle(high_brush, (int)(W * 0.75), H - 8, (int)(W * 0.25) - 9, 2);
                                    spacing = (W * 0.75 - 2.0) / 4.0;
                                    string_height = 0;
                                    string[] list = { "100", "250", "500", "800", "1000" };
                                    for (int i = 1; i < 5; i++)
                                    {
                                        g.FillRectangle(low_brush, (int)(i * spacing - spacing * 0.5), H - 8 - 3 - 3, 1, 6);
                                        g.FillRectangle(low_brush, (int)(i * spacing), H - 8 - 6 - 6, 2, 12);

                                        string s = list[i - 1];
                                        //  Font f = new Font("swis721blkexbt", 7.0f, FontStyle.Bold | FontStyle.Italic); // was 7

                                        SizeF size = g.MeasureString("0", ff, 1, StringFormat.GenericTypographic);
                                        double string_width = size.Width - 2.0;
                                        string_height = size.Height - 2.0;

                                        //g.TextRenderingHint = TextRenderingHint.AntiAlias;
                                        //g.SmoothingMode = SmoothingMode.AntiAlias;
                                        g.DrawString(s, ff, low_brush, (int)(i * spacing - string_width * s.Length + 1.0 + (int)(i / 2) - (int)(i / 4)), (int)(H - 8 - 12 - 3 - string_height));
                                        //g.SmoothingMode = SmoothingMode.None;
                                    }
                                    spacing = (W * 0.25 - 2.0 - 9.0) / 1.0;
                                    for (int i = 1; i < 2; i++)
                                    {
                                        g.FillRectangle(high_brush, (int)((double)W * 0.75 + i * spacing - spacing * 0.5), H - 8 - 3 - 3, 1, 6);
                                        g.FillRectangle(high_brush, (int)((double)W * 0.75 + i * spacing), H - 8 - 6 - 6, 2, 12);

                                        //  Font f = new Font("swis721blkexbt", 7.0f, FontStyle.Bold | FontStyle.Italic); // was 7

                                        SizeF size = g.MeasureString("0", ff, 3, StringFormat.GenericTypographic);
                                        double string_width = size.Width - 2.0;

                                        //g.TextRenderingHint = TextRenderingHint.SystemDefault;
                                        g.DrawString("1000", ff, high_brush, (int)(W * 0.75 + 2 + i * spacing - (int)4.0 * string_width), (int)(H - 8 - 12 - 3 - string_height));
                                    }

                                    num *= 1000;
                                    if (num < 801.0) // low area
                                    {
                                        spacing = (W * 0.75 - 2.0) / 4.0;
                                        if (num <= 100.0)
                                            pixel_x = (int)(num / 100.0 * spacing);
                                        else if (num <= 250.0)
                                            pixel_x = (int)(spacing + (num - 100.0) / 150.0 * spacing);
                                        else if (num <= 500.0)
                                            pixel_x = (int)(2 * spacing + (num - 250.0) / 250.0 * spacing);
                                        else
                                            pixel_x = (int)(3 * spacing + (num - 500.0) / 300.0 * spacing);
                                    }
                                    else
                                    {
                                        spacing = (W * 0.25 - 2.0 - 9.0) / 1.0;
                                        pixel_x = (int)(W * 0.75 + (num - 800.0) / 200.0 * spacing);
                                    }
                                }
                                break;

                            case MeterTXMode.SWR: // edge RX2 SWR meter

                                //  g.FillRectangle(low_brush, 0, H - 8, (int)(W * 0.75), 2);
                                // g.FillRectangle(high_brush, (int)(W * 0.75), H - 8, (int)(W * 0.25) - 9, 2);

                                g.FillRectangle(grn_brush, 0, H - 8, 45, 2); // ke9ns mod
                                g.FillRectangle(yel_brush, 45, H - 8, 31, 2); // ke9ns mod
                                g.FillRectangle(red_brush, 76, H - 8, 79, 2); // ke9ns mod

                                spacing = (W * 0.75 - 2.0) / 4.0;
                                string_height = 0;
                                string[] swr_list = { "1.5", "2", "5", "10", "20" };
                                for (int i = 1; i < 5; i++)
                                {
                                    g.FillRectangle(low_brush, (int)(i * spacing - spacing * 0.5), H - 8 - 3 - 3, 1, 6);
                                    g.FillRectangle(low_brush, (int)(i * spacing), H - 8 - 6 - 6, 2, 12);

                                    string s = swr_list[i - 1];
                                    //  Font f = new Font("swis721blkexbt", 7.0f, FontStyle.Bold | FontStyle.Italic); // was 7

                                    SizeF size = g.MeasureString("0", ff, 1, StringFormat.GenericTypographic);
                                    double string_width = size.Width - 2.0;
                                    string_height = size.Height - 2.0;

                                    //g.TextRenderingHint = TextRenderingHint.AntiAlias;
                                    //g.SmoothingMode = SmoothingMode.AntiAlias;
                                    g.DrawString(s, ff, low_brush, (int)(i * spacing - string_width * s.Length + 2.0 - 2 * (int)(i / 2) + 3 * (int)(i / 4)), (int)(H - 8 - 12 - 3 - string_height));
                                    //g.SmoothingMode = SmoothingMode.None;
                                }
                                spacing = (W * 0.25 - 2.0 - 9.0) / 1.0;
                                for (int i = 1; i < 2; i++)
                                {
                                    g.FillRectangle(high_brush, (int)((double)W * 0.75 + i * spacing - spacing * 0.5), H - 8 - 3 - 3, 1, 6);
                                    g.FillRectangle(high_brush, (int)((double)W * 0.75 + i * spacing), H - 8 - 6 - 6, 2, 12);

                                    //   Font f = new Font("swis721blkexbt", 7.0f, FontStyle.Bold | FontStyle.Italic); // was 7

                                    SizeF size = g.MeasureString("0", ff, 3, StringFormat.GenericTypographic);
                                    double string_width = size.Width - 2.0;

                                    //g.TextRenderingHint = TextRenderingHint.SystemDefault;
                                    g.DrawString("20+", ff, high_brush, (int)(W * 0.75 + i * spacing - (int)2.5 * string_width), (int)(H - 8 - 12 - 3 - string_height));
                                }

                                if (num < 10.0) // low area
                                {
                                    spacing = (W * 0.75 - 2.0) / 4.0;
                                    if (num <= 1.5)
                                        pixel_x = (int)((num - 1.0) / 0.5 * spacing);
                                    else if (num <= 2.0)
                                        pixel_x = (int)(spacing + (num - 1.5) / 0.5 * spacing);
                                    else if (num <= 5.0)
                                        pixel_x = (int)(2 * spacing + (num - 2.0) / 3.0 * spacing);
                                    else
                                        pixel_x = (int)(3 * spacing + (num - 5.0) / 5.0 * spacing);
                                }
                                else
                                {
                                    spacing = (W * 0.25 - 2.0 - 9.0) / 1.0;
                                    pixel_x = (int)(W * 0.75 + (num - 10.0) / 10.0 * spacing);
                                }
                                if (double.IsInfinity(num)) pixel_x = W - 2;
                                break;

                            case MeterTXMode.ALC_G:
                            case MeterTXMode.LVL_G:
                                g.FillRectangle(low_brush, 0, H - 8, (int)(W * 0.75), 2);
                                g.FillRectangle(high_brush, (int)(W * 0.75), H - 8, (int)(W * 0.25) - 9, 2);
                                spacing = (W * 0.75 - 2.0) / 4.0;
                                string_height = 0;
                                string[] gain_list = { "5", "10", "15", "20", "25" };
                                for (int i = 1; i < 5; i++)
                                {
                                    g.FillRectangle(low_brush, (int)(i * spacing - spacing * 0.5), H - 8 - 3 - 3, 1, 6);
                                    g.FillRectangle(low_brush, (int)(i * spacing), H - 8 - 6 - 6, 2, 12);

                                    string s = gain_list[i - 1];
                                    //   Font f = new Font("swis721blkexbt", 7.0f, FontStyle.Bold | FontStyle.Italic); // was 7

                                    SizeF size = g.MeasureString("0", ff, 1, StringFormat.GenericTypographic);
                                    double string_width = size.Width - 2.0;
                                    string_height = size.Height - 2.0;

                                    //g.TextRenderingHint = TextRenderingHint.AntiAlias;
                                    //g.SmoothingMode = SmoothingMode.AntiAlias;
                                    g.DrawString(s, ff, low_brush, (int)(i * spacing - string_width * s.Length + (int)(i / 3)), (int)(H - 8 - 12 - 3 - string_height));
                                    //g.SmoothingMode = SmoothingMode.None;
                                }
                                spacing = (W * 0.25 - 2.0 - 9.0) / 1.0;
                                for (int i = 1; i < 2; i++)
                                {
                                    g.FillRectangle(high_brush, (int)((double)W * 0.75 + i * spacing - spacing * 0.5), H - 8 - 3 - 3, 1, 6);
                                    g.FillRectangle(high_brush, (int)((double)W * 0.75 + i * spacing), H - 8 - 6 - 6, 2, 12);

                                    //  Font f = new Font("swis721blkexbt", 7.0f, FontStyle.Bold | FontStyle.Italic); // was 7

                                    SizeF size = g.MeasureString("0", ff, 3, StringFormat.GenericTypographic);
                                    double string_width = size.Width - 2.0;

                                    //g.TextRenderingHint = TextRenderingHint.SystemDefault;
                                    g.DrawString("25+", ff, high_brush, (int)(W * 0.75 + i * spacing - (int)2.5 * string_width), (int)(H - 8 - 12 - 3 - string_height));
                                }

                                spacing = (W * 0.75 - 2.0) / 4.0;
                                pixel_x = (int)(num / 5.0 * spacing);
                                break;
                            case MeterTXMode.OFF:
                                break;
                        }
                    } // MOX2



                    //===================================================================================
                    if ((!mox2 && rx2_meter_mode != MeterRXMode.OFF) || (mox2 && current_meter_tx1_mode != MeterTXMode.OFF))
                    {
                        pixel_x = Math.Max(0, pixel_x);
                        pixel_x = Math.Min(W - 3, pixel_x);

                        pixel_x1 = Math.Max(0, pixel_x1);
                        pixel_x1 = Math.Min(W - 3, pixel_x1);

                        line_pen = new Pen(edge_avg_color);

                        //  line_dark_pen = new Pen(
                        //	Color.FromArgb((edge_avg_color.R+edge_meter_background_color.R)/2,
                        //	(edge_avg_color.G+edge_meter_background_color.G)/2,
                        //	(edge_avg_color.B+edge_meter_background_color.B)/2));



                        if ((rx2_meter_mode == MeterRXMode.SIGNAL_PEAK) && (!mox2 && rx2_meter_mode != MeterRXMode.OFF)) // ke9ns ADD
                        {
                            line_pen = new Pen(Color.Red);
                            line_pen.Width = 3.0F;
                            g.DrawLine(line_pen, pixel_x1, 0, pixel_x1, H);

                        } // peak

                        line_pen = new Pen(edge_avg_color);
                        g.DrawLine(line_dark_pen, pixel_x - 1, 0, pixel_x - 1, H); // rx2 edge
                        g.DrawLine(line_pen, pixel_x, 0, pixel_x, H);
                        g.DrawLine(line_dark_pen, pixel_x + 1, 0, pixel_x + 1, H);



                    }

                    //====================================================
                    rx2_meter_timer.Stop();

                    format = "f0";
                    if (meter_detail) format = "f1";

                    if (rx2_meter_timer.DurationMsec >= meter_dig_delay)
                    {
                        if (!mox2) // rx
                        {

                            switch (rx2_meter_mode)
                            {
                                case MeterRXMode.SIGNAL_STRENGTH:

                                case MeterRXMode.SIGNAL_AVERAGE:
                                    output = num.ToString(format) + " dBm ";
                                    break;
                                case MeterRXMode.SIGNAL_PEAK: // ke9ns2 ADD 
                                    output = rx2_meter_peak_value.ToString(format) + " dBm ";
                                    break;
                                case MeterRXMode.ADC_L:
                                case MeterRXMode.ADC_R:
                                case MeterRXMode.ADC2_L:
                                case MeterRXMode.ADC2_R:
                                    output = num.ToString("f1") + " dBFS ";
                                    break;
                                case MeterRXMode.OFF:
                                    output = "";
                                    break;
                            }

                        }
                        else
                        {
                            MeterTXMode mode = current_meter_tx1_mode;
                            // if (chkTUN.Checked) mode = tune_meter_tx1_mode;
                            switch (mode)
                            {
                                case MeterTXMode.MIC:
                                    output = num.ToString(format) + " dB ";
                                    break;
                                case MeterTXMode.LEVELER:
                                case MeterTXMode.LVL_G:
                                case MeterTXMode.EQ:
                                case MeterTXMode.CPDR:
                                case MeterTXMode.ALC:
                                case MeterTXMode.ALC_G:
                                    if (!mox2) output = "-30 dB ";
                                    else output = num.ToString(format) + " dB ";
                                    break;
                                case MeterTXMode.FORWARD_POWER:
                                case MeterTXMode.REVERSE_POWER:
                                    switch (current_model)
                                    {
                                        case Model.FLEX5000:
                                        case Model.FLEX3000:
                                            if (!mox) output = "0 W ";
                                            else output = num.ToString("f0") + " W ";
                                            break;
                                        case Model.FLEX1500:
                                            if (!mox) output = "0 % ";
                                            else output = num.ToString("f0") + " % ";
                                            break;
                                    }
                                    break;
                                case MeterTXMode.SWR:
                                    if (!mox) output = "0 : 1 ";
                                    else output = num.ToString("f1") + " : 1 ";
                                    break;
                                case MeterTXMode.OFF:
                                    output = "";
                                    break;

                            }// switch mode
                        }//mox2


                        txtRX2Meter.Text = output; //only show digital numbers if RX2 ON or 2nd Meter is ON and in TX mode

                        rx2_meter_timer.Start();
                    }

                    if (rx2_meter_data_ready)
                    {
                        rx2_meter_data_ready = false;  //We do NOT want to do this before we have consumed it!!!! so do it here.
                    }


                    #endregion

                    break; // RX2 edge

                //========================================mi=====================
                //=============================================================
                // KE9NS 6 RX2 ANALOG
                //=============================================================
                //=============================================================


                case MultiMeterDisplayMode.Analog:
                    #region Analog

                    //   Debug.WriteLine(rx2_meter_new_data + " dB MIC-");


                    //   Debug.WriteLine(rx2_avg_num + "  rx2_avg_num");

                    if (rx2_meter_data_ready)
                    {
                        rx2_meter_current_data = rx2_meter_new_data;
                        rx2_meter_data_ready = false;
                    }

                    if (rx2_avg_num == Display.CLEAR_FLAG) // reset average -- just use new value
                    {
                        num = rx2_avg_num = rx2_meter_current_data;
                    }
                    else
                    {
                        if (rx2_meter_current_data > rx2_avg_num)
                            num = rx2_avg_num = rx2_meter_current_data * 0.8 + rx2_avg_num * 0.2; // fast rise
                        else
                            num = rx2_avg_num = rx2_meter_current_data * 0.2 + rx2_avg_num * 0.8; // slow decay
                    }

                    //   Debug.WriteLine(num + " dB MIC--");

                    //  if ((mox2) && (!mox)) num = 0.0;  // zero the value if in 2nd tx mode but not transmitting

                    high_brush = new SolidBrush(analog_high_color);


                    //--------------------------------------------------------
                    // ke9ns add below


                    if (meterLMB == true)
                    {
                        low_brush = new SolidBrush(Color.Black); // white text
                        low_brush1 = new Pen(Color.Black);  // white


                        g.DrawImageUnscaled(meterback1, 0, 0); // new Rectangle(0, 0, W, H));  // rectangle to show bitmap image in

                        //   txtRX2Meter.ForeColor = Color.Black;
                        //   txtRX2Meter.BackColor = Color.FromArgb(0xff, 0xff, 0xe4);
                    }
                    else if (meterDMB == true)
                    {
                        low_brush = new SolidBrush(Color.Black); // white text
                        low_brush1 = new Pen(Color.Black);  // white

                        g.DrawImageUnscaled(meterback2, 0, 0); // new Rectangle(0, 0, W, H));  // rectangle to show bitmap image in

                        //  txtRX2Meter.ForeColor = Color.Black;
                        //  txtRX2Meter.BackColor = Color.FromArgb(146, 146, 140);
                    }
                    else
                    {
                        low_brush = new SolidBrush(analog_low_color); // white text
                        low_brush1 = new Pen(analog_low_color);  // white

                        g.DrawRectangle(new Pen(analog_meter_background_color), 0, 0, W, H); // black background

                        //  txtRX2Meter.ForeColor = MeterDigitalTextColor;
                        //  txtRX2Meter.BackColor = MeterDigitalBackgroundColor;
                    }

                    //===========================================================================================
                    // ke9ns add TX meter to RX2 (but only when not using RX2)

                    if (!mox2)
                    {

                        switch (rx2_meter_mode)
                        {
                            case MeterRXMode.SIGNAL_STRENGTH:
                            case MeterRXMode.SIGNAL_AVERAGE:
                            case MeterRXMode.SIGNAL_PEAK:       // ke9ns ADD

                                //=================================================================
                                // Draw curved meter movement for signal strength ke9ns12
                                //=================================================================


                                double line1 = 0;
                                const double angle_start = 55; // 45;
                                const double angle_span = 70; // 90;


                                int Origin_x = (W + CirX) / 2 - (CirX / 2);  // ke9ns mod: 82 was = (W) / 2;  center of virtual meter circle
                                int Origin_y = (W + CirX) / 2 + CirY;  // ke9ns mod: 151 was (int)((double)((H) * 1.5));  this is the height of the numbers and tick marks with respect to curved line 1.4 slightly below meter window area (where virtual meter adjustment screw would be)


                                //   low_brush1 = new Pen(analog_low_color);  // white

                                high_brush2 = new Pen(Brushes.Blue); // blue
                                high_brush1 = new Pen(analog_high_color); // red 
                                high_brush3 = new Pen(Brushes.Yellow); // yellow
                                                                       // high_brush4 = new Pen(Brushes.BurlyWood); //  
                                high_brush4 = new Pen(Brushes.DarkSlateGray); // 

                                //9990
                                double spacing = ((double)W * 0.5 - 2.0) / 5.0;
                                double string_height = 0;


                                //======================================
                                // Draw WHITE arc line

                                low_brush1.Width = arc_thick;
                                //  g.DrawArc(low_brush1, 0, 37, W, W, -90, -47); // draw OUTER arc
                                g.DrawArc(low_brush1, -CirXH, CirY, W + CirX, W + CirX, -90, -35);

                                low_brush1.Width = 7.0F;
                                g.DrawArc(low_brush1, -(CirXH + 4), CirY - 3, W + CirX + 8, W + CirX + 8, -118, -5); // -120 -5

                                //======================================
                                // Draw Red arc line

                                high_brush1.Width = arc_thick;
                                //  g.DrawArc(high_brush1, 0, 37, W, W, -44, -43); // draw OUTER arc -47
                                g.DrawArc(high_brush1, -CirXH, CirY, W + CirX, W + CirX, -55, -34); // radius = 114

                                //======================================
                                // Draw WHITE full arc line under white/red 
                                // upper left corner x,y , width,height, start angle, sweep angle

                                high_brush4.Width = arc_thick1;
                                //  g.DrawArc(high_brush4, 6, 43, W - 12, W - 12, -43, -94); // draw INNER arc
                                g.DrawArc(high_brush4, -CirXS, CirYS, W + CirXL, W + CirXL, -55, -70); // draw INNER arc



                                //======================================
                                // Draw Meter Name text behind needle //8880
                                //   if (rx2_meter_mode == MeterRXMode.SIGNAL_STRENGTH) g.DrawString("SIG", ff8, low_brush, W * 0.39F, H * 0.75F); // DDAA
                                //   else if (rx2_meter_mode == MeterRXMode.SIGNAL_AVERAGE) g.DrawString("AVG", ff8, low_brush, W * 0.39F, H * 0.75F); // DDAA
                                //   else if (rx2_meter_mode == MeterRXMode.SIGNAL_PEAK) g.DrawString("SIG", ff8, low_brush, W * 0.39F, H * 0.75F); // DDAA

                                //======================================
                                // WHITE  tick marks and text

                                for (double i = 1; i < 6; i++)
                                {

                                    line1 = i * spacing - spacing * 0.5;

                                    double line = (angle_start + ((double)line1 * angle_span / (double)(W)));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    // Cx = 82, Cy=151, R=(W+64)/2= 114

                                    int POSW = (int)((double)(CirR + 8) * Math.Cos(line));  // convert signal to arc
                                    int POSH = (int)((double)(CirR + 8) * Math.Sin(line));

                                    int POSW_BOT = (int)((double)(CirR + 2) * Math.Cos(line));  // convert signal to arc (little tick marks)
                                    int POSH_BOT = (int)((double)(CirR + 2) * Math.Sin(line));


                                    low_brush1.Width = tick_thin;
                                    g.DrawLine(low_brush1, Origin_x - POSW_BOT, Origin_y - POSH_BOT, Origin_x - POSW, Origin_y - POSH);  // draw meter 

                                    line1 = i * spacing;

                                    line = (angle_start + ((double)line1 * angle_span / (double)(W)));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    POSW = (int)((double)(CirR + 14) * Math.Cos(line));  // convert signal to arc
                                    POSH = (int)((double)(CirR + 14) * Math.Sin(line));

                                    POSW_BOT = (int)((double)(CirR + 2) * Math.Cos(line));  // convert signal to arc (big tick marks)
                                    POSH_BOT = (int)((double)(CirR + 2) * Math.Sin(line));

                                    low_brush1.Width = tick_thick;
                                    g.DrawLine(low_brush1, Origin_x - POSW_BOT, Origin_y - POSH_BOT, Origin_x - POSW, Origin_y - POSH);  // draw meter 

                                    //9990

                                    //===============================================
                                    // Draw white numbers

                                    // Font f = new Font("Arial", 8.0f, FontStyle.Bold | FontStyle.Italic); // was 7
                                    //   Font f = new Font("swis721blkexbt", 6.9f, FontStyle.Bold | FontStyle.Italic); // was 7

                                    SizeF size = g.MeasureString((-1 + i * 2).ToString(), ff1, 1, StringFormat.GenericTypographic);
                                    double string_width = size.Width - 2.0;
                                    string_height = size.Height - 2.0;

                                    line1 = (i * spacing - string_width + (i / 5));

                                    line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math


                                    POSW = (int)((double)(CirR + 28) * Math.Cos(line));  // convert signal to arc
                                    POSH = (int)((double)(CirR + 28) * Math.Sin(line));  // was 1.45


                                    g.DrawString((-1 + i * 2).ToString(), ff1, low_brush, Origin_x - POSW, Origin_y - POSH);


                                } // white ticks and test


                                // =======================
                                // RED tick marks and text

                                spacing = ((double)W * 0.5 - 2.0 - 4.0) / 3.0;

                                for (double i = 1; i < 4; i++) //red
                                {

                                    line1 = W * 0.5 + i * spacing - spacing * 0.5;

                                    double line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    int POSW = (int)((double)(CirR + 8) * Math.Cos(line));  // convert signal to arc
                                    int POSH = (int)((double)(CirR + 8) * Math.Sin(line));

                                    int POSW_BOT = (int)((double)(CirR + 2) * Math.Cos(line));  // convert signal to arc
                                    int POSH_BOT = (int)((double)(CirR + 2) * Math.Sin(line));

                                    high_brush1.Width = tick_thin;
                                    g.DrawLine(high_brush1, Origin_x - POSW_BOT, Origin_y - POSH_BOT, Origin_x - POSW, Origin_y - POSH);  // draw meter 

                                    line1 = W * 0.5 + i * spacing;

                                    line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    POSW = (int)((double)(CirR + 14) * Math.Cos(line));  // convert signal to arc
                                    POSH = (int)((double)(CirR + 14) * Math.Sin(line));

                                    POSW_BOT = (int)((double)(CirR + 2) * Math.Cos(line));  // convert signal to arc
                                    POSH_BOT = (int)((double)(CirR + 2) * Math.Sin(line));

                                    high_brush1.Width = tick_thick;
                                    g.DrawLine(high_brush1, Origin_x - POSW_BOT, Origin_y - POSH_BOT, Origin_x - POSW, Origin_y - POSH);  // draw meter 

                                    //==========================================
                                    // draw red text


                                    SizeF size = g.MeasureString("+" + (i * 20).ToString(), ff2, 3, StringFormat.GenericTypographic);
                                    double string_width = size.Width - 2.0;

                                    line1 = (W * 0.5 + i * spacing - string_width * 3 - i / 3 * 2);

                                    line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    POSW = (int)((double)(CirR + 22) * Math.Cos(line));  // convert signal to arc
                                    POSH = (int)((double)(CirR + 22) * Math.Sin(line));


                                    g.DrawString("+" + (i * 20).ToString(), ff2, high_brush, Origin_x - POSW, Origin_y - POSH);
                                    if (i == 3)
                                    {
                                        g.DrawString("dB", ff2, high_brush, (Origin_x - POSW) + 5, (Origin_y - POSH) - 12);
                                    }

                                } // red ticks and text


                                if (FREQB < 30)
                                {
                                    if (num > -73)
                                    {
                                        pixel_x = (int)(W * 0.5 + (73.0 + num) / 63.0 * (W * 0.5 - 3));
                                        pixel_x1 = (int)(W * 0.5 + (73.0 + rx2_meter_peak_value) / 63.0 * (W * 0.5 - 3));
                                    }
                                    else
                                    {
                                        pixel_x = (int)((num + 133.0) / 60.0 * (W * 0.5));
                                        pixel_x1 = (int)((rx2_meter_peak_value + 133.0) / 60.0 * (W * 0.5));
                                    }
                                } // < 30 mhz
                                else // correction for freq > 29 mhz
                                {
                                    if (num > -93) // ke9ns ADD correct S9 above 30mhz
                                    {
                                        pixel_x = (int)(W * 0.5 + (93.0 + num) / 43.0 * (W * 0.5 - 3));
                                        pixel_x1 = (int)(W * 0.5 + (93.0 + rx2_meter_peak_value) / 43.0 * (W * 0.5 - 3));
                                    }
                                    else
                                    {
                                        pixel_x = (int)((num + 133.0) / 40.0 * (W * 0.5));
                                        pixel_x1 = (int)((rx2_meter_peak_value + 133.0) / 40.0 * (W * 0.5));
                                    }
                                } // > 29 mhz



                                break; // signal RX2 analog

                            case MeterRXMode.ADC_L:
                            case MeterRXMode.ADC_R:
                            case MeterRXMode.ADC2_L:
                            case MeterRXMode.ADC2_R:
                                spacing = ((double)W - 5.0) / 6.0;
                                g.FillRectangle(low_brush, 0, H - 8, (int)(W - 3.0 - spacing), 2);
                                g.FillRectangle(high_brush, (int)(W - 3.0 - spacing), H - 8, (int)spacing, 2);
                                for (int i = 1; i < 7; i++)
                                {
                                    b = low_brush;
                                    if (i == 6) b = high_brush;
                                    g.FillRectangle(b, (int)(i * spacing - spacing / 2), H - 8 - 3 - 3, 1, 6);
                                    g.FillRectangle(b, (int)(i * spacing), H - 8 - 6 - 6, 2, 12);

                                    //  Font f = new Font("swis721blkexbt", 6.9f, FontStyle.Bold | FontStyle.Italic); // was 7

                                    string s = (-120 + i * 20).ToString();
                                    SizeF size = g.MeasureString(s, ff1, 1, StringFormat.GenericTypographic);
                                    double string_width = size.Width - 2.0;
                                    size = g.MeasureString("0", ff1, 1, StringFormat.GenericTypographic);
                                    string_height = size.Height - 2.0;

                                    g.DrawString(s, ff, b, (int)(i * spacing - (int)string_width * (s.Length)), (int)(H - 8 - 12 - 3 - string_height));
                                }

                                pixel_x = (int)((num + 120.0) / 120.0 * (W - 5.0));
                                break;
                            case MeterRXMode.OFF:
                                break;
                        }

                    } // !MOX2 (RX)

                    //=============================================
                    // Transmitter meters ke9ns12tx RX2
                    //=============================================

                    else
                    {

                        // Debug.WriteLine("MOX2T " + num);

                        MeterTXMode mode = current_meter_tx1_mode;
                        // if (chkTUN.Checked) mode = tune_meter_tx1_mode;
                        switch (mode)
                        {
                            case MeterTXMode.MIC: //9990 good
                            case MeterTXMode.EQ:
                            case MeterTXMode.LEVELER:
                            case MeterTXMode.CPDR:
                            case MeterTXMode.ALC:

                                //=================================================================
                                // Draw curved meter movement for signal strength
                                //=================================================================

                                double line1 = 0;
                                const double angle_start = 55; //  45;
                                const double angle_span = 70; //  90;


                                int Origin_x = (W + CirX) / 2 - (CirX / 2);  // ke9ns mod: 82 was = (W) / 2;  center of virtual meter circle
                                int Origin_y = (W + CirX) / 2 + CirY;  // ke9ns mod: 151 was (int)((double)((H) * 1.5));  this is the height of the numbers and tick marks with respect to curved line 1.4 slightly below meter window area (where virtual meter adjustment screw would be)


                                //   low_brush1 = new Pen(analog_low_color);  // white
                                high_brush1 = new Pen(analog_high_color); // red

                                high_brush2 = new Pen(Brushes.Blue); // blue
                                high_brush3 = new Pen(Brushes.Yellow); // yellow
                                high_brush5 = new Pen(Brushes.Green); // 
                                high_brush4 = new Pen(Brushes.DarkSlateGray); // 

                                double spacing = (W * 0.665 - 2.0) / 3.0;
                                double string_height = 0;

                                //======================================
                                // Draw WHITE arc line
                                // upper left corner x,y , width,height, start angle, sweep angle

                                low_brush1.Width = arc_thick;
                                // g.DrawArc(low_brush1, 0, 37, W, W, -75, -61); // draw OUTER arc
                                g.DrawArc(low_brush1, -CirXH, CirY, W + CirX, W + CirX, -75, -50);
                                //   g.DrawArc(high_brush4, DTMx,  DTMy , W+DTM , W+DTM , DTMa ,DTMs); // draw INNER arc

                                //======================================
                                // Draw Red arc line
                                // upper left corner x,y , width,height, start angle, sweep angle

                                high_brush1.Width = arc_thick;
                                //  g.DrawArc(high_brush1, 0, 37, W, W, -44, -27); // draw OUTER arc -31
                                g.DrawArc(high_brush1, -CirXH, CirY, W + CirX, W + CirX, -55, -20); // radius = 114
                                //======================================
                                // Draw GREEN full arc line under white/red 
                                // upper left corner x,y , width,height, start angle, sweep angle

                                high_brush5.Width = arc_thick1;
                                //  g.DrawArc(high_brush5, 6, 43, W - 12, W - 12, -43, -94); // draw INNER arc
                                g.DrawArc(high_brush5, -CirXS, CirYS, W + CirXL, W + CirXL, -55, -70); // draw INNER arc


                                //======================================
                                // Draw TX Meter Name text //8880
                                //   if (mode == MeterTXMode.CPDR) g.DrawString("CPDR", ff8, low_brush, W * 0.35F, H * 0.75F); // DDAA
                                //   else if (mode == MeterTXMode.LEVELER) g.DrawString("LVL", ff8, low_brush, W * 0.39F, H * 0.75F); // DDAA
                                //   else if (mode == MeterTXMode.EQ) g.DrawString("EQ", ff8, low_brush, W * 0.405F, H * 0.75F); // DDAA
                                //   else if (mode == MeterTXMode.MIC) g.DrawString("MIC", ff8, low_brush, W * 0.39F, H * 0.75F); // DDAA
                                //   else if (mode == MeterTXMode.ALC) g.DrawString("ALC", ff8, low_brush, W * 0.39F, H * 0.75F); // DDAA

                                //======================================
                                // WHITE  tick marks and text

                                for (double i = 1; i < 4; i++)
                                {

                                    line1 = i * spacing - spacing * 0.5;

                                    double line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    int POSW = (int)((double)(CirR + 8) * Math.Cos(line));  // convert signal to arc
                                    int POSH = (int)((double)(CirR + 8) * Math.Sin(line));

                                    int POSW_BOT = (int)((double)(CirR) * Math.Cos(line));  // convert signal to arc
                                    int POSH_BOT = (int)((double)(CirR) * Math.Sin(line));

                                    low_brush1.Width = tick_thin;
                                    g.DrawLine(low_brush1, Origin_x - POSW_BOT, Origin_y - POSH_BOT, Origin_x - POSW, Origin_y - POSH);  // draw meter 

                                    line1 = i * spacing;

                                    line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    POSW = (int)((double)(CirR + 14) * Math.Cos(line));  // convert signal to arc
                                    POSH = (int)((double)(CirR + 14) * Math.Sin(line));

                                    POSW_BOT = (int)((double)(CirR) * Math.Cos(line));  // convert signal to arc
                                    POSH_BOT = (int)((double)(CirR) * Math.Sin(line));

                                    low_brush1.Width = tick_thick;
                                    g.DrawLine(low_brush1, Origin_x - POSW_BOT, Origin_y - POSH_BOT, Origin_x - POSW, Origin_y - POSH);  // draw meter 


                                    //===============================================
                                    // Draw white numbers ALC RX1 analog


                                    SizeF size = g.MeasureString("0", ff1, 1, StringFormat.GenericTypographic);
                                    double string_width = size.Width - 2.0;
                                    string_height = size.Height - 2.0;

                                    line1 = (i * spacing - string_width + (i / 5));

                                    line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    if (i == 1)
                                    {
                                        POSW = (int)((double)(CirR + 30) * Math.Cos(line));  // 1.4 convert signal to arc
                                        POSH = (int)((double)(CirR + 30) * Math.Sin(line));  // 1.48
                                    }
                                    else
                                    {
                                        POSW = (int)((double)(CirR + 28) * Math.Cos(line));  // 1.4 convert signal to arc
                                        POSH = (int)((double)(CirR + 28) * Math.Sin(line));  // 1.48
                                    }

                                    g.DrawString((-30 + i * 10).ToString(), ff1, low_brush, Origin_x - POSW, Origin_y - POSH);


                                } // white ticks and test


                                // =======================
                                // RED tick marks and text

                                spacing = (W * 0.335 - 2.0 - 3.0) / 3.0;

                                for (double i = 1; i < 4; i++) //red
                                {

                                    line1 = W * 0.665 + i * spacing - spacing * 0.5;

                                    double line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    int POSW = (int)((double)(CirR + 8) * Math.Cos(line));  // convert signal to arc
                                    int POSH = (int)((double)(CirR + 8) * Math.Sin(line));

                                    int POSW_BOT = (int)((double)(CirR) * Math.Cos(line));  // convert signal to arc
                                    int POSH_BOT = (int)((double)(CirR + 2) * Math.Sin(line));

                                    high_brush1.Width = tick_thin;
                                    g.DrawLine(high_brush1, Origin_x - POSW_BOT, Origin_y - POSH_BOT, Origin_x - POSW, Origin_y - POSH);  // draw meter 

                                    line1 = W * 0.665 + i * spacing;

                                    line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    POSW = (int)((double)(CirR + 14) * Math.Cos(line));  // convert signal to arc
                                    POSH = (int)((double)(CirR + 14) * Math.Sin(line));

                                    POSW_BOT = (int)((double)(CirR) * Math.Cos(line));  // convert signal to arc
                                    POSH_BOT = (int)((double)(CirR) * Math.Sin(line));

                                    high_brush1.Width = tick_thick;
                                    g.DrawLine(high_brush1, Origin_x - POSW_BOT, Origin_y - POSH_BOT, Origin_x - POSW, Origin_y - POSH);  // draw meter 

                                    //==========================================
                                    // draw red text alc rx1 analog


                                    SizeF size = g.MeasureString(i.ToString(), ff2, 3, StringFormat.GenericTypographic);
                                    double string_width = size.Width - 2.0;

                                    line1 = (W * 0.665 + i * spacing - (int)string_width);

                                    line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    POSW = (int)((double)(CirR + 22) * Math.Cos(line));  // convert signal to arc
                                    POSH = (int)((double)(CirR + 22) * Math.Sin(line));


                                    g.DrawString(i.ToString(), ff2, high_brush, Origin_x - POSW, Origin_y - POSH);

                                } // red ticks and text



                                if (num > 0.0) // high area
                                {
                                    pixel_x = (int)(W * 0.665 + num / 3.0 * (W * 0.335 - 4));
                                }
                                else
                                {
                                    pixel_x = (int)((num + 30.0) / 30.0 * (W * 0.665 - 1.0));
                                }
                                break; // case MeterTXMode.ALC:

                            //===========================================

                            case MeterTXMode.FORWARD_POWER:
                            case MeterTXMode.REVERSE_POWER:

                                line1 = 0;
                                //  angle_start = 45;
                                //  angle_span = 90;



                                Origin_x = (W + CirX) / 2 - (CirX / 2);  // ke9ns mod: 82 was = (W) / 2;  center of virtual meter circle
                                Origin_y = (W + CirX) / 2 + CirY;  // ke9ns mod: 151 was (int)((double)((H) * 1.5));  this is the height of the numbers and tick marks with respect to curved line 1.4 slightly below meter window area (where virtual meter adjustment screw would be)



                                //   low_brush1 = new Pen(analog_low_color);  // white
                                high_brush1 = new Pen(analog_high_color); // red

                                high_brush2 = new Pen(Brushes.Blue); // blue
                                high_brush3 = new Pen(Brushes.Yellow); // yellow
                                high_brush4 = new Pen(Brushes.DarkSlateGray); // 

                                if (pa_present || (fwc_init && (current_model == Model.FLEX5000 || current_model == Model.FLEX3000)) ||
                                    (hid_init && current_model == Model.FLEX1500))
                                {

                                    //=================================================================
                                    // Draw curved meter movement for Power
                                    //=================================================================

                                    //======================================
                                    // Draw WHITE arc line
                                    // upper left corner x,y , width,height, start angle, sweep angle

                                    low_brush1.Width = arc_thick;
                                    //  g.DrawArc(low_brush1, 0, 37, W, W, -67, -68); // draw OUTER arc
                                    g.DrawArc(low_brush1, -CirXH, CirY, W + CirX, W + CirX, -75, -50);
                                    //======================================
                                    // Draw Red arc line
                                    // upper left corner x,y , width,height, start angle, sweep angle

                                    high_brush1.Width = arc_thick;
                                    //  g.DrawArc(high_brush1, 0, 37, W, W, -44, -20); // draw OUTER arc -24
                                    g.DrawArc(high_brush1, -CirXH, CirY, W + CirX, W + CirX, -55, -20); // radius = 114
                                    //======================================
                                    // Draw BLUE full arc line under white/red 
                                    // upper left corner x,y , width,height, start angle, sweep angle

                                    high_brush2.Width = arc_thick1;
                                    //  g.DrawArc(high_brush2, 6, 43, W - 12, W - 12, -43, -94); // draw INNER arc
                                    g.DrawArc(high_brush2, -CirXS, CirYS, W + CirXL, W + CirXL, -55, -70); // draw INNER arc


                                    //======================================
                                    // Draw TX Meter Name text
                                    //  if (mode == MeterTXMode.FORWARD_POWER) g.DrawString("FWD", ff8, low_brush, W * 0.375F, H * 0.75F); // DDAA
                                    //   else if (mode == MeterTXMode.REVERSE_POWER) g.DrawString("REV", ff8, low_brush, W * 0.38F, H * 0.75F); // DDAA


                                    //======================================
                                    // WHITE  tick marks and text


                                    spacing = (W * 0.75 - 2.0) / 4.0;
                                    string_height = 0;
                                    string[] list = { "5", "10", "50", "100" };

                                    for (double i = 1; i < 5; i++)
                                    {

                                        line1 = i * spacing - spacing * 0.5;

                                        double line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                        line = line * CirA;                                                // convert angle to radians for cos/sin math

                                        int POSW = (int)((double)(CirR + 8) * Math.Cos(line));  // convert signal to arc
                                        int POSH = (int)((double)(CirR + 8) * Math.Sin(line));

                                        int POSW_BOT = (int)((double)(CirR + 2) * Math.Cos(line));  // convert signal to arc
                                        int POSH_BOT = (int)((double)(CirR) * Math.Sin(line));

                                        low_brush1.Width = tick_thin;
                                        g.DrawLine(low_brush1, Origin_x - POSW_BOT, Origin_y - POSH_BOT, Origin_x - POSW, Origin_y - POSH);  // draw meter 

                                        line1 = i * spacing;

                                        line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                        line = line * CirA;                                                // convert angle to radians for cos/sin math

                                        POSW = (int)((double)(CirR + 14) * Math.Cos(line));  // convert signal to arc
                                        POSH = (int)((double)(CirR + 14) * Math.Sin(line));

                                        POSW_BOT = (int)((double)(CirR) * Math.Cos(line));  // convert signal to arc
                                        POSH_BOT = (int)((double)(CirR) * Math.Sin(line));

                                        low_brush1.Width = tick_thick;
                                        g.DrawLine(low_brush1, Origin_x - POSW_BOT, Origin_y - POSH_BOT, Origin_x - POSW, Origin_y - POSH);  // draw meter 


                                        //===============================================
                                        // Draw white numbers fwd rx1 analog

                                        string s = list[(int)i - 1];

                                        SizeF size = g.MeasureString("0", ff1, 1, StringFormat.GenericTypographic);
                                        double string_width = size.Width - 2.0;
                                        string_height = size.Height - 2.0;

                                        line1 = i * spacing - string_width * s.Length + (int)(i / 3) + (int)(i / 4);

                                        line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                        line = line * CirA;                                                // convert angle to radians for cos/sin math

                                        POSW = (int)((double)(CirR + 28) * Math.Cos(line));  //1.4  convert signal to arc
                                        POSH = (int)((double)(CirR + 28) * Math.Sin(line));  // 1.48

                                        g.DrawString(s, ff1, low_brush, Origin_x - POSW, Origin_y - POSH);


                                    } // white ticks and test

                                    // =======================
                                    // RED tick marks and text

                                    spacing = (W * 0.25 - 2.0 - 10.0) / 1.0;

                                    for (double i = 1; i < 2; i++) //red
                                    {

                                        line1 = (double)W * 0.75 + i * spacing - spacing * 0.5;

                                        double line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                        line = line * CirA;                                                // convert angle to radians for cos/sin math

                                        int POSW = (int)((double)(CirR + 8) * Math.Cos(line));  // convert signal to arc
                                        int POSH = (int)((double)(CirR + 8) * Math.Sin(line));

                                        int POSW_BOT = (int)((double)(CirR + 2) * Math.Cos(line));  // convert signal to arc
                                        int POSH_BOT = (int)((double)(CirR + 2) * Math.Sin(line));

                                        high_brush1.Width = tick_thin;
                                        g.DrawLine(high_brush1, Origin_x - POSW_BOT, Origin_y - POSH_BOT, Origin_x - POSW, Origin_y - POSH);  // draw meter 

                                        line1 = (double)W * 0.75 + i * spacing;

                                        line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                        line = line * CirA;                                                // convert angle to radians for cos/sin math

                                        POSW = (int)((double)(CirR + 14) * Math.Cos(line));  // convert signal to arc
                                        POSH = (int)((double)(CirR + 14) * Math.Sin(line));

                                        POSW_BOT = (int)((double)(CirR + 2) * Math.Cos(line));  // convert signal to arc
                                        POSH_BOT = (int)((double)(CirR + 2) * Math.Sin(line));

                                        high_brush1.Width = tick_thick;
                                        g.DrawLine(high_brush1, Origin_x - POSW_BOT, Origin_y - POSH_BOT, Origin_x - POSW, Origin_y - POSH);  // draw meter 

                                        //==========================================
                                        // draw red text fwd analog


                                        SizeF size = g.MeasureString("0", ff2, 3, StringFormat.GenericTypographic);
                                        double string_width = size.Width - 2.0;

                                        line1 = W * 0.75 + i * spacing - (int)3.5 * string_width;

                                        line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                        line = line * CirA;                                                // convert angle to radians for cos/sin math

                                        POSW = (int)((double)(CirR + 22) * Math.Cos(line));  // convert signal to arc
                                        POSH = (int)((double)(CirR + 22) * Math.Sin(line));

                                        g.DrawString("120+", ff2, high_brush, Origin_x - POSW, Origin_y - POSH);

                                    } // red ticks and text


                                    if (num <= 100.0) // low area
                                    {
                                        spacing = (W * 0.75 - 2.0) / 4.0;
                                        if (num <= 5.0)
                                            pixel_x = (int)(num / 5.0 * (int)spacing);
                                        else if (num <= 10.0)
                                            pixel_x = (int)(spacing + (num - 5.0) / 5.0 * spacing);
                                        else if (num <= 50.0)
                                            pixel_x = (int)(2 * spacing + (num - 10.0) / 40.0 * spacing);
                                        else
                                            pixel_x = (int)(3 * spacing + (num - 50.0) / 50.0 * spacing);
                                    }
                                    else
                                    {
                                        spacing = (W * 0.25 - 2.0 - 10.0) / 1.0;
                                        if (num <= 120.0)
                                            pixel_x = (int)(W * 0.75 + (num - 100.0) / 20.0 * spacing);
                                        else
                                            pixel_x = (int)(W * 0.75 + spacing + (num - 120.0) / 60.0 * spacing);
                                    }
                                } //



                                break; //case MeterTXMode.REVERSE_POWER:

                            //==========================================

                            case MeterTXMode.SWR: // analog RX2 meter //9990 good

                                //=================================================================
                                // Draw curved meter movement for SWR RX2
                                //=================================================================

                                line1 = 0;
                                // angle_start = 45;
                                // angle_span = 90;


                                Origin_x = (W + CirX) / 2 - (CirX / 2);  // ke9ns mod: 82 was = (W) / 2;  center of virtual meter circle
                                Origin_y = (W + CirX) / 2 + CirY;  // ke9ns mod: 151 was (int)((double)((H) * 1.5));  this is the height of the numbers and tick marks with respect to curved line 1.4 slightly below meter window area (where virtual meter adjustment screw would be)


                                //   low_brush1 = new Pen(analog_low_color);  // white


                                high_brush2 = new Pen(Brushes.Red); // blue
                                high_brush1 = new Pen(analog_high_color); // red
                                high_brush3 = new Pen(Brushes.Yellow); // yellow
                                high_brush4 = new Pen(Brushes.AntiqueWhite); // 


                                //======================================
                                // Draw WHITE arc line
                                // upper left corner x,y , width,height, start angle, sweep angle

                                grn_pen.Width = arc_thick;
                                //  g.DrawArc(grn_pen, 0, 37, W, W, -110, -26); // draw OUTER arc 
                                g.DrawArc(grn_pen, -CirXH, CirY, W + CirX, W + CirX, -105, -20); // -100 , -20
                                //   g.DrawArc(high_brush4, DTMx,  DTMy , W+DTM , W+DTM , DTMa ,DTMs); // draw INNER arc


                                //======================================
                                // Draw yel arc line

                                yel_pen.Width = arc_thick;
                                //  g.DrawArc(yel_pen, 0, 37, W, W, -93, -17); // draw OUTER arc 
                                g.DrawArc(yel_pen, -CirXH, CirY, W + CirX, W + CirX, -93, -12); // -85 -10


                                //======================================
                                // Draw Red arc line
                                // upper left corner x,y , width,height, start angle, sweep angle

                                red_pen.Width = arc_thick;
                                //  g.DrawArc(red_pen, 0, 37, W, W, -43, -51); // draw OUTER arc 
                                g.DrawArc(red_pen, -CirXH, CirY, W + CirX, W + CirX, -55, -38); // radius = 114


                                //======================================
                                // Draw Yellow full arc line under white/red 
                                // upper left corner x,y , width,height, start angle, sweep angle

                                high_brush3.Width = arc_thick1;
                                //  g.DrawArc(high_brush3, 6, 43, W - 12, W - 12, -43, -94); // draw INNER arc
                                g.DrawArc(high_brush3, -CirXS, CirYS, W + CirXL, W + CirXL, -55, -70); // draw INNER arc



                                //======================================
                                // Draw TX Meter Name text
                                //   if (mode == MeterTXMode.SWR) g.DrawString("SWR", ff8, low_brush, W * 0.375F, H * 0.75F); // DDAA

                                //======================================
                                // WHITE  tick marks and text SWR


                                spacing = (W * 0.75 - 2.0) / 4.0;
                                string_height = 0;
                                string[] swr_list = { "1.5", "2", "5", "10", "20" };

                                for (double i = 1; i < 5; i++)
                                {

                                    line1 = i * spacing - spacing * 0.5;

                                    double line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    int POSW = (int)((double)(CirR + 8) * Math.Cos(line));  // convert signal to arc
                                    int POSH = (int)((double)(CirR + 8) * Math.Sin(line));

                                    int POSW_BOT = (int)((double)(CirR + 2) * Math.Cos(line));  // convert signal to arc
                                    int POSH_BOT = (int)((double)(CirR + 2) * Math.Sin(line));

                                    low_brush1.Width = tick_thin;
                                    g.DrawLine(low_brush1, Origin_x - POSW_BOT, Origin_y - POSH_BOT, Origin_x - POSW, Origin_y - POSH);  // draw meter 

                                    line1 = i * spacing;

                                    line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    POSW = (int)((double)(CirR + 14) * Math.Cos(line));  // convert signal to arc
                                    POSH = (int)((double)(CirR + 14) * Math.Sin(line));

                                    POSW_BOT = (int)((double)(CirR + 2) * Math.Cos(line));  // convert signal to arc
                                    POSH_BOT = (int)((double)(CirR + 2) * Math.Sin(line));

                                    low_brush1.Width = tick_thick;
                                    g.DrawLine(low_brush1, Origin_x - POSW_BOT, Origin_y - POSH_BOT, Origin_x - POSW, Origin_y - POSH);  // draw meter 


                                    //===============================================
                                    // Draw white numbers rx2 swr analog

                                    string s = swr_list[(int)i - 1];

                                    //  Font f = new Font("swis721blkexbt", 6.9f, FontStyle.Bold | FontStyle.Italic); // was 7

                                    SizeF size = g.MeasureString("0", ff1, 1, StringFormat.GenericTypographic);
                                    double string_width = size.Width - 2.0;
                                    string_height = size.Height - 2.0;


                                    line1 = i * spacing - string_width * s.Length + 2.0 - 2 * (int)(i / 2) + 3 * (int)(i / 4);

                                    if (i == 1) line1 = line1 + 10;


                                    line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    if (i == 1)
                                    {
                                        POSW = (int)((double)(CirR + 30) * Math.Cos(line));  // convert signal to arc
                                        POSH = (int)((double)(CirR + 30) * Math.Sin(line));
                                    }
                                    else
                                    {
                                        POSW = (int)((double)(CirR + 28) * Math.Cos(line));  // convert signal to arc
                                        POSH = (int)((double)(CirR + 28) * Math.Sin(line));
                                    }

                                    g.DrawString(s, ff1, low_brush, Origin_x - POSW, Origin_y - POSH);


                                } // white ticks and test

                                // =======================
                                // RED tick marks and text

                                spacing = (W * 0.25 - 2.0 - 9.0) / 1.0;

                                for (double i = 1; i < 2; i++) //red
                                {

                                    line1 = (double)W * 0.75 + i * spacing - spacing * 0.5;

                                    double line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    int POSW = (int)((double)(CirR + 8) * Math.Cos(line));  // convert signal to arc
                                    int POSH = (int)((double)(CirR + 8) * Math.Sin(line));

                                    int POSW_BOT = (int)((double)(CirR + 2) * Math.Cos(line));  // convert signal to arc
                                    int POSH_BOT = (int)((double)(CirR + 2) * Math.Sin(line));

                                    high_brush1.Width = tick_thin;
                                    g.DrawLine(high_brush1, Origin_x - POSW_BOT, Origin_y - POSH_BOT, Origin_x - POSW, Origin_y - POSH);  // draw meter 

                                    line1 = (double)W * 0.75 + i * spacing;

                                    line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    POSW = (int)((double)(CirR + 14) * Math.Cos(line));  // convert signal to arc
                                    POSH = (int)((double)(CirR + 14) * Math.Sin(line));

                                    POSW_BOT = (int)((double)(CirR + 2) * Math.Cos(line));  // convert signal to arc
                                    POSH_BOT = (int)((double)(CirR + 2) * Math.Sin(line));

                                    high_brush1.Width = tick_thick;
                                    g.DrawLine(high_brush1, Origin_x - POSW_BOT, Origin_y - POSH_BOT, Origin_x - POSW, Origin_y - POSH);  // draw meter 

                                    //==========================================
                                    // draw red text

                                    //   Font f = new Font("swis721blkexbt", 5.6f, FontStyle.Bold | FontStyle.Italic); // was 7

                                    SizeF size = g.MeasureString("0", ff2, 3, StringFormat.GenericTypographic);
                                    double string_width = size.Width - 2.0;

                                    line1 = W * 0.75 + i * spacing - (int)3.5 * string_width;

                                    line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    POSW = (int)((double)(CirR + 22) * Math.Cos(line));  // convert signal to arc
                                    POSH = (int)((double)(CirR + 22) * Math.Sin(line));

                                    g.DrawString("20+", ff2, high_brush, Origin_x - POSW, Origin_y - POSH);

                                } // red ticks and text



                                if (num < 10.0) // low area
                                {
                                    spacing = (W * 0.75 - 2.0) / 4.0;
                                    if (num <= 1.5)
                                        pixel_x = (int)((num - 1.0) / 0.5 * spacing);
                                    else if (num <= 2.0)
                                        pixel_x = (int)(spacing + (num - 1.5) / 0.5 * spacing);
                                    else if (num <= 5.0)
                                        pixel_x = (int)(2 * spacing + (num - 2.0) / 3.0 * spacing);
                                    else
                                        pixel_x = (int)(3 * spacing + (num - 5.0) / 5.0 * spacing);
                                }
                                else
                                {
                                    spacing = (W * 0.25 - 2.0 - 9.0) / 1.0;
                                    pixel_x = (int)(W * 0.75 + (num - 10.0) / 10.0 * spacing);
                                }
                                if (double.IsInfinity(num)) pixel_x = W - 2;

                                break;// case MeterTXMode.SWR:

                            case MeterTXMode.ALC_G:
                            case MeterTXMode.LVL_G:

                                //=================================================================
                                // Draw curved meter movement for signal strength
                                //=================================================================

                                line1 = 0;
                                // angle_start = 45;
                                // angle_span = 90;

                                Origin_x = (W + CirX) / 2 - (CirX / 2);  // ke9ns mod: 82 was = (W) / 2;  center of virtual meter circle
                                Origin_y = (W + CirX) / 2 + CirY;  // ke9ns mod: 151 was (int)((double)((H) * 1.5));  this is the height of the numbers and tick marks with respect to curved line 1.4 slightly below meter window area (where virtual meter adjustment screw would be)


                                //   low_brush1 = new Pen(analog_low_color);  // white


                                high_brush2 = new Pen(Brushes.Blue); // blue
                                high_brush1 = new Pen(analog_high_color); // red
                                high_brush3 = new Pen(Brushes.Yellow); // yellow
                                high_brush5 = new Pen(Brushes.Green); // 
                                high_brush4 = new Pen(Brushes.DarkSlateGray); // 


                                spacing = (W * 0.75 - 2.0) / 4.0;
                                string_height = 0;
                                string[] gain_list = { "5", "10", "15", "20", "25" };


                                //=================================================================
                                // Draw curved meter movement for Power
                                //=================================================================

                                //======================================
                                // Draw WHITE arc line
                                // upper left corner x,y , width,height, start angle, sweep angle

                                low_brush1.Width = arc_thick;
                                //  g.DrawArc(low_brush1, 0, 37, W, W, -67, -68); // draw OUTER arc
                                g.DrawArc(low_brush1, -CirXH, CirY, W + CirX, W + CirX, -75, -50);
                                //   g.DrawArc(high_brush4, DTMx,  DTMy , W+DTM , W+DTM , DTMa ,DTMs); // draw INNER arc

                                //======================================
                                // Draw Red arc line
                                // upper left corner x,y , width,height, start angle, sweep angle

                                high_brush1.Width = arc_thick;
                                //   g.DrawArc(high_brush1, 0, 37, W, W, -44, -20); // draw OUTER arc -24
                                g.DrawArc(high_brush1, -CirXH, CirY, W + CirX, W + CirX, -55, -20); // radius = 114

                                //======================================
                                // Draw Green full arc line under white/red 
                                // upper left corner x,y , width,height, start angle, sweep angle

                                high_brush5.Width = arc_thick1;
                                //  g.DrawArc(high_brush5, 6, 43, W - 12, W - 12, -43, -94); // draw INNER arc
                                g.DrawArc(high_brush5, -CirXS, CirYS, W + CirXL, W + CirXL, -55, -70); // draw INNER arc



                                //======================================
                                // Draw TX Meter Name text
                                //   if (mode == MeterTXMode.LVL_G) g.DrawString("LVLG", ff8, low_brush, W * 0.35F, H * 0.75F); // DDAA
                                //    else if (mode == MeterTXMode.ALC_G) g.DrawString("ALCG", ff8, low_brush, W * 0.35F, H * 0.75F); // DDAA

                                //======================================
                                // WHITE  tick marks and text

                                for (double i = 1; i < 5; i++)
                                {

                                    line1 = i * spacing - spacing * 0.5;

                                    double line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    int POSW = (int)((double)(CirR + 8) * Math.Cos(line));  // convert signal to arc
                                    int POSH = (int)((double)(CirR + 8) * Math.Sin(line));

                                    int POSW_BOT = (int)((double)(CirR + 2) * Math.Cos(line));  // convert signal to arc
                                    int POSH_BOT = (int)((double)(CirR + 2) * Math.Sin(line));

                                    low_brush1.Width = tick_thin;
                                    g.DrawLine(low_brush1, Origin_x - POSW_BOT, Origin_y - POSH_BOT, Origin_x - POSW, Origin_y - POSH);  // draw meter 

                                    line1 = i * spacing;

                                    line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    POSW = (int)((double)(CirR + 14) * Math.Cos(line));  // convert signal to arc
                                    POSH = (int)((double)(CirR + 14) * Math.Sin(line));

                                    POSW_BOT = (int)((double)(CirR + 2) * Math.Cos(line));  // convert signal to arc
                                    POSH_BOT = (int)((double)(CirR + 2) * Math.Sin(line));

                                    low_brush1.Width = tick_thick;
                                    g.DrawLine(low_brush1, Origin_x - POSW_BOT, Origin_y - POSH_BOT, Origin_x - POSW, Origin_y - POSH);  // draw meter 


                                    //===============================================
                                    // Draw white numbers

                                    string s = gain_list[(int)i - 1];

                                    SizeF size = g.MeasureString("0", ff1, 1, StringFormat.GenericTypographic);
                                    double string_width = size.Width - 2.0;
                                    string_height = size.Height - 2.0;

                                    line1 = (i * spacing - string_width + (i / 5));

                                    line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math


                                    if (i == 1)
                                    {
                                        POSW = (int)((double)(CirR + 30) * Math.Cos(line));  // convert signal to arc
                                        POSH = (int)((double)(CirR + 30) * Math.Sin(line));
                                    }
                                    else
                                    {
                                        POSW = (int)((double)(CirR + 28) * Math.Cos(line));  // convert signal to arc
                                        POSH = (int)((double)(CirR + 28) * Math.Sin(line));
                                    }
                                    g.DrawString(s, ff1, low_brush, Origin_x - POSW, Origin_y - POSH);


                                } // white ticks and test


                                // =======================
                                // RED tick marks and text

                                spacing = (W * 0.25 - 2.0 - 9.0) / 1.0;

                                for (double i = 1; i < 2; i++) //red
                                {

                                    line1 = W * 0.75 + i * spacing - spacing * 0.5;

                                    double line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    int POSW = (int)((double)(CirR + 8) * Math.Cos(line));  // convert signal to arc
                                    int POSH = (int)((double)(CirR + 8) * Math.Sin(line));

                                    int POSW_BOT = (int)((double)(CirR + 2) * Math.Cos(line));  // convert signal to arc
                                    int POSH_BOT = (int)((double)(CirR + 2) * Math.Sin(line));

                                    high_brush1.Width = tick_thin;
                                    g.DrawLine(high_brush1, Origin_x - POSW_BOT, Origin_y - POSH_BOT, Origin_x - POSW, Origin_y - POSH);  // draw meter 

                                    line1 = W * 0.75 + i * spacing;

                                    line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    POSW = (int)((double)(CirR + 14) * Math.Cos(line));  // convert signal to arc
                                    POSH = (int)((double)(CirR + 14) * Math.Sin(line));

                                    POSW_BOT = (int)((double)(CirR + 2) * Math.Cos(line));  // convert signal to arc
                                    POSH_BOT = (int)((double)(CirR + 2) * Math.Sin(line));

                                    high_brush1.Width = tick_thick;
                                    g.DrawLine(high_brush1, Origin_x - POSW_BOT, Origin_y - POSH_BOT, Origin_x - POSW, Origin_y - POSH);  // draw meter 

                                    //==========================================
                                    // draw red text

                                    SizeF size = g.MeasureString("0", ff2, 3, StringFormat.GenericTypographic);
                                    double string_width = size.Width - 2.0;


                                    line1 = (W * 0.75 + i * spacing - (int)2.5 * string_width);

                                    line = (angle_start + ((double)line1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                                    line = line * CirA;                                                // convert angle to radians for cos/sin math

                                    POSW = (int)((double)(CirR + 22) * Math.Cos(line));  // convert signal to arc
                                    POSH = (int)((double)(CirR + 22) * Math.Sin(line));


                                    g.DrawString("25+", ff2, high_brush, Origin_x - POSW, Origin_y - POSH);

                                } // red ticks and text

                                spacing = (W * 0.75 - 2.0) / 4.0;
                                pixel_x = (int)(num / 5.0 * spacing);

                                break;// case MeterTXMode.LVL_G:




                            case MeterTXMode.OFF:
                                break;
                        } // switch (mode)

                    } // mox2 (TX)


                    //--------------------------------------------------------------------------------

                    //============================
                    // needle meter movement RX2 ANALOG ke9ns12
                    //=============================


                    if ( // EDGE rx2 METER MOVEMENT
                         ((rx2_meter_mode == MeterRXMode.ADC2_R) || (rx2_meter_mode == MeterRXMode.ADC2_L) ||
                        (rx2_meter_mode == MeterRXMode.ADC_R) || (rx2_meter_mode == MeterRXMode.ADC_L))
                        && ((!mox2 && rx2_meter_mode != MeterRXMode.OFF) || (mox2 && current_meter_tx1_mode != MeterTXMode.OFF))

                        )

                    {
                        pixel_x = Math.Max(0, pixel_x);
                        pixel_x = Math.Min(W - 3, pixel_x);

                        line_pen = new Pen(edge_avg_color); // yellow

                        //	line_dark_pen = new Pen(
                        //	Color.FromArgb((analog_avg_color.R+edge_meter_background_color.R)/2,
                        //	(edge_avg_color.G+edge_meter_background_color.G)/2,
                        //	(edge_avg_color.B+edge_meter_background_color.B)/2));


                        g.DrawLine(line_dark_pen, pixel_x - 1, 0, pixel_x - 1, H); // rx2 analog edge
                        g.DrawLine(line_pen, pixel_x, 0, pixel_x, H);
                        g.DrawLine(line_dark_pen, pixel_x + 1, 0, pixel_x + 1, H);

                    }

                    else if (  // TX meter movements
                               ((mox2 && current_meter_tx1_mode != MeterTXMode.OFF) && ((current_meter_tx1_mode == MeterTXMode.LVL_G) ||
                               (current_meter_tx1_mode == MeterTXMode.ALC_G) || (current_meter_tx1_mode == MeterTXMode.CPDR) ||
                               (current_meter_tx1_mode == MeterTXMode.LEVELER) || (current_meter_tx1_mode == MeterTXMode.EQ) ||
                               (current_meter_tx1_mode == MeterTXMode.MIC) || (current_meter_tx1_mode == MeterTXMode.ALC) ||
                               (current_meter_tx1_mode == MeterTXMode.SWR) || (current_meter_tx1_mode == MeterTXMode.FORWARD_POWER) ||
                               (current_meter_tx1_mode == MeterTXMode.REVERSE_POWER)))
                          )
                    {


                        // pixel_x (i.e. signal) goes from 0 to W  Width 
                        // posx = originx + (2 * D * cos (angle))
                        // posy = originy + (2 * D * sin (angle))
                        // for a meter of 45deg to 135deg = 90deg total span :   
                        // but sin and cos in radians not degs.
                        // posx = originx + (2 * D * cos (angle*PI/180))

                        //  box dimensions:
                        //  0,0   W,0
                        //  0,H   W,H

                        pixel_x = Math.Max(0, pixel_x);
                        pixel_x = Math.Min(W - 3, pixel_x);                                             // define limits of X dimension

                        line_pen = new Pen(analog_avg_color);
                        line_pen = new Pen(analog_high_color); // Color.Red

                        line_pen.Width = 2.8F;


                        int Origin_x = W / 2;

                        int Origin_y = (W + CirX) / 2 + CirY;  // ke9ns mod: 151 was (int)((double)((H) * 1.5));  this is the height of the numbers and tick marks with respect to curved line 1.4 slightly below meter window area (where virtual meter adjustment screw would be)

                        const double angle_start = 55; // 45;
                        const double angle_span = 70; // 90;

                        angle = signal = (angle_start + ((double)pixel_x * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                        signal = signal * CirA;                                                // convert angle to radians for cos/sin math

                        if ((meterDMB == true) || (meterPointer == true)) // Dark meter background, so needle shadow is light
                        {
                            if ((meterPointer == true))
                            {
                                RotateImage(yell, angle, Origin_y);
                                g.DrawImageUnscaled(rotatedImage, 0, 0);

                                //  RotatePointer(signal, H * 1.25, Origin_x, Origin_y);
                                //  g.DrawImage(yell1, dest);            // draw rotated image

                            }
                            else
                            {
                                RotateImage(white, angle, Origin_y);
                                g.DrawImageUnscaled(rotatedImage, 0, 0);

                                // RotatePointer(signal, H * 1.25, Origin_x, Origin_y);
                                //  g.DrawImage(white1, dest);            // draw rotated image

                            }


                        }
                        else if (meterLMB == true) // Dark meter background, so needle shadow is light
                        {
                            RotateImage(black, angle, Origin_y);
                            g.DrawImageUnscaled(rotatedImage, 0, 0);

                            //  RotatePointer(signal, H * 1.25, Origin_x, Origin_y);
                            //  g.DrawImage(black1, dest);            // draw rotated image

                        }
                        else
                        {
                            line_pen = new Pen(analog_avg_color);
                            line_pen.Width = 2.4F; // was 2.6F

                            int POSW = (int)((double)(CirR + 16) * Math.Cos(signal));  // convert signal to arc
                            int POSH = (int)((double)(CirR + 16) * Math.Sin(signal));

                            g.DrawLine(line_pen, Origin_x, Origin_y, Origin_x - POSW, Origin_y - POSH);  // draw meter needle movement (by flipping result around since inc values go down not up)

                        }


                        //  Debug.WriteLine("Signal " + signal);

                        //======================================
                        // Draw TX Meter Name text
                        if (current_meter_tx1_mode == MeterTXMode.CPDR) g.DrawString("CPDR", ff8, low_brush, W * 0.35F, H * 0.75F); // DDAA
                        else if (current_meter_tx1_mode == MeterTXMode.LEVELER) g.DrawString("LVL", ff8, low_brush, W * 0.39F, H * 0.75F); // DDAA
                        else if (current_meter_tx1_mode == MeterTXMode.EQ) g.DrawString("EQ", ff8, low_brush, W * 0.405F, H * 0.75F); // DDAA
                        else if (current_meter_tx1_mode == MeterTXMode.MIC) g.DrawString("MIC", ff8, low_brush, W * 0.39F, H * 0.75F); // DDAA
                        else if (current_meter_tx1_mode == MeterTXMode.ALC) g.DrawString("ALC", ff8, low_brush, W * 0.39F, H * 0.75F); // DDAA
                        else if (current_meter_tx1_mode == MeterTXMode.SWR) g.DrawString("SWR", ff8, low_brush, W * 0.375F, H * 0.75F); // DDAA
                        else if (current_meter_tx1_mode == MeterTXMode.LVL_G) g.DrawString("LVLG", ff8, low_brush, W * 0.35F, H * 0.75F); // DDAA
                        else if (current_meter_tx1_mode == MeterTXMode.ALC_G) g.DrawString("ALCG", ff8, low_brush, W * 0.35F, H * 0.75F); // DDAA
                        else if (current_meter_tx1_mode == MeterTXMode.FORWARD_POWER) g.DrawString("FWD", ff8, low_brush, W * 0.375F, H * 0.75F); // DDAA
                        else if (current_meter_tx1_mode == MeterTXMode.REVERSE_POWER) g.DrawString("REV", ff8, low_brush, W * 0.38F, H * 0.75F); // DDAA


                    } // TX curved needle

                    else if ( //RX2 ANALOG meter movement
                         ((rx2_meter_mode == MeterRXMode.SIGNAL_STRENGTH) || (rx2_meter_mode == MeterRXMode.SIGNAL_PEAK) ||
                        (rx2_meter_mode == MeterRXMode.SIGNAL_AVERAGE)) && ((!mox2 && rx2_meter_mode != MeterRXMode.OFF) ||
                        (mox2 && current_meter_tx1_mode != MeterTXMode.OFF))

                        )

                    {
                        // pixel_x (i.e. signal) goes from 0 to W  Width 
                        // posx = originx + (2 * D * cos (angle))
                        // posy = originy + (2 * D * sin (angle))
                        // for a meter of 45deg to 135deg = 90deg total span :   
                        // but sin and cos in radians not degs.
                        // posx = originx + (2 * D * cos (angle*PI/180))

                        //  box dimensions:
                        //  0,0   W,0
                        //  0,H   W,H

                        pixel_x = Math.Max(0, pixel_x);
                        pixel_x = Math.Min(W - 3, pixel_x);                                             // define limits of X dimension

                        pixel_x1 = Math.Max(0, pixel_x1);
                        pixel_x1 = Math.Min(W - 3, pixel_x1);

                        line_pen = new Pen(analog_avg_color);

                        //  line_dark_pen1 = 
                        //  new Pen( Color.FromArgb((edge_avg_color.R + edge_meter_background_color.R) / 2,(edge_avg_color.G + edge_meter_background_color.G) / 2,(edge_avg_color.B + edge_meter_background_color.B) / 2));


                        //9990
                        int Origin_x = W / 2;
                        int Origin_y = (W + CirX) / 2 + CirY;  // ke9ns mod: 151 was (int)((double)((H) * 1.5));  this is the height of the numbers and tick marks with respect to curved line 1.4 slightly below meter window area (where virtual meter adjustment screw would be)

                        const double angle_start = 55; //  45;
                        const double angle_span = 70;  // 90;


                        if ((rx2_meter_mode == MeterRXMode.SIGNAL_PEAK) && (!mox2 && rx2_meter_mode != MeterRXMode.OFF))  // ke9ns ADD
                        {

                            angle = signal = (angle_start + ((double)pixel_x1 * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                            signal = signal * CirA;                                                // convert angle to radians for cos/sin math


                            if ((meterDMB == true) || (meterLMB == true) || (meterPointer == true)) // Dark meter background, so needle shadow is light
                            {
                                RotateImage(red, angle, Origin_y);
                                g.DrawImageUnscaled(rotatedImage, 0, 0);

                                //  RotatePointer(signal, H * 1.25, Origin_x, Origin_y);
                                //  g.DrawImage(red1, dest);            // draw rotated image
                            }
                            else
                            {

                                int POSW1 = (int)((double)(CirR + 16) * Math.Cos(signal));  // convert signal to arc
                                int POSH1 = (int)((double)(CirR + 16) * Math.Sin(signal));

                                line_pen = new Pen(analog_high_color); // Color.Red
                                line_pen.Width = 2.6F;

                                g.DrawLine(line_pen, Origin_x, Origin_y, Origin_x - POSW1, Origin_y - POSH1);  // draw meter needle movement (by flipping result around since inc values go down not up)
                            }


                        } // peak

                        angle = signal = (angle_start + ((double)pixel_x * angle_span / (double)W));     // convert signal pixel span (0 to W) int angle span of 45deg to 135deg
                        signal = signal * CirA;                                                // convert angle to radians for cos/sin math


                        if ((meterDMB == true) || (meterPointer == true)) // Dark meter background, so needle shadow is light
                        {
                            if ((meterPointer == true))
                            {
                                RotateImage(yell, angle, Origin_y);
                                g.DrawImageUnscaled(rotatedImage, 0, 0);

                                //  RotatePointer(signal, H * 1.25, Origin_x, Origin_y);
                                //  g.DrawImage(yell1, dest);            // draw rotated image
                            }

                            else
                            {
                                RotateImage(white, angle, Origin_y);
                                g.DrawImageUnscaled(rotatedImage, 0, 0);

                                //  RotatePointer(signal, H * 1.25, Origin_x, Origin_y);
                                //  g.DrawImage(white1, dest);            // draw rotated image
                            }


                        }
                        else if (meterLMB == true) // Dark meter background, so needle shadow is light
                        {
                            RotateImage(black, angle, Origin_y);
                            g.DrawImageUnscaled(rotatedImage, 0, 0);


                            //  RotatePointer(signal, H * 1.25, Origin_x, Origin_y);
                            // g.DrawImage(black1, dest);            // draw rotated image
                        }
                        else
                        {
                            line_pen = new Pen(analog_avg_color);
                            line_pen.Width = 2.4F; // was 2.6F

                            int POSW = (int)((double)(CirR + 16) * Math.Cos(signal));  // convert signal to arc
                            int POSH = (int)((double)(CirR + 16) * Math.Sin(signal));

                            g.DrawLine(line_pen, Origin_x, Origin_y, Origin_x - POSW, Origin_y - POSH);  // draw meter needle movement (by flipping result around since inc values go down not up)


                        }



                        // ke9ns 7 rx2 analog needle

                        //======================================
                        // Draw RX2  Meter Name text IN FRONT OF needle //8881

                        if (chkRX2.Checked)
                        {
                            if (rx2_meter_mode == MeterRXMode.SIGNAL_STRENGTH) g.DrawString("VFOB SIG", ff8, low_brush, W * 0.27F, H * 0.75F); // DDAA
                            else if (rx2_meter_mode == MeterRXMode.SIGNAL_AVERAGE) g.DrawString("VFOB AVG", ff8, low_brush, W * 0.27F, H * 0.75F); // DDAA
                            else if (rx2_meter_mode == MeterRXMode.SIGNAL_PEAK) g.DrawString("VFOB SIG", ff8, low_brush, W * 0.27F, H * 0.75F); // DDAA

                        }
                        else
                        {
                            if (rx2_meter_mode == MeterRXMode.SIGNAL_STRENGTH) g.DrawString("SIG", ff8, low_brush, W * 0.39F, H * 0.75F); // DDAA
                            else if (rx2_meter_mode == MeterRXMode.SIGNAL_AVERAGE) g.DrawString("AVG", ff8, low_brush, W * 0.39F, H * 0.75F); // DDAA
                            else if (rx2_meter_mode == MeterRXMode.SIGNAL_PEAK) g.DrawString("SIG", ff8, low_brush, W * 0.39F, H * 0.75F); // DDAA
                        }



                    } //   if meter is ON in RX or TX mode, then draw line


                    //=========================================================================


                    rx2_meter_timer.Stop();

                    format = "f0";
                    if (meter_detail) format = "f1";

                    if (rx2_meter_timer.DurationMsec >= meter_dig_delay)
                    {
                        if (!mox2) // rx
                        {


                            switch (rx2_meter_mode)
                            {
                                case MeterRXMode.SIGNAL_STRENGTH:

                                case MeterRXMode.SIGNAL_AVERAGE:
                                    output = num.ToString(format) + " dBm ";
                                    break;
                                case MeterRXMode.SIGNAL_PEAK: // ke9ns2 ADD 
                                    output = rx2_meter_peak_value.ToString(format) + " dBm ";
                                    break;
                                case MeterRXMode.ADC_L:
                                case MeterRXMode.ADC_R:
                                case MeterRXMode.ADC2_L:
                                case MeterRXMode.ADC2_R:
                                    output = num.ToString("f1") + " dBFS ";
                                    break;
                                case MeterRXMode.OFF:
                                    output = "";
                                    break;
                            }

                        }
                        else
                        {

                            MeterTXMode mode = current_meter_tx1_mode;
                            // if (chkTUN.Checked) mode = tune_meter_tx1_mode;
                            switch (mode)
                            {
                                case MeterTXMode.MIC:
                                    output = num.ToString(format) + " dB ";
                                    break;
                                case MeterTXMode.LEVELER:
                                case MeterTXMode.LVL_G:
                                case MeterTXMode.EQ:
                                case MeterTXMode.CPDR:
                                case MeterTXMode.ALC:
                                case MeterTXMode.ALC_G:
                                    if (!mox) output = "-30 dB ";
                                    else output = num.ToString(format) + " dB ";
                                    break;
                                case MeterTXMode.FORWARD_POWER:
                                case MeterTXMode.REVERSE_POWER:
                                    switch (current_model)
                                    {
                                        case Model.FLEX5000:
                                        case Model.FLEX3000:
                                            if (!mox) output = "0 W ";
                                            else output = num.ToString("f0") + " W ";
                                            break;
                                        case Model.FLEX1500:
                                            if (!mox) output = "0 % ";
                                            else output = num.ToString("f0") + " % ";
                                            break;
                                    }
                                    break;
                                case MeterTXMode.SWR:
                                    if (!mox) output = "0 : 1 ";
                                    else output = num.ToString("f1") + " : 1 ";
                                    break;
                                case MeterTXMode.OFF:
                                    output = "";
                                    break;

                            }// switch mode
                        }//mox2

                        txtRX2Meter.Text = output; //only show digital numbers if RX2 ON or 2nd Meter is ON and in TX mode


                        rx2_meter_timer.Start();
                    } //if(rx2_meter_timer.DurationMsec >= meter_dig_delay)


                    if (rx2_meter_data_ready)
                    {
                        rx2_meter_data_ready = false;  //We do NOT want to do this before we have consumed it!!!! so do it here.
                    }


                    #endregion
                    break;  //  RX2 Analog


            } // switch(current_meter_display_mode)


        } // picRX2Meter_Paint


        //=============================================================
        //=============================================================
        //=============================================================
        //=============================================================
        //=============================================================

        private void ResetMultiMeterPeak()  // 
        {
            meter_peak_count = multimeter_peak_hold_samples;
            avg_num = Display.CLEAR_FLAG;

            multimeter_peak = Display.CLEAR_FLAG; // ke9ns ADD peak values used by new meter
        }

        private void ResetRX2MeterPeak()        // 
        {
            rx2_meter_peak_count = multimeter_peak_hold_samples;
            rx2_meter_avg = Display.CLEAR_FLAG;

            rx2_meter_peak = Display.CLEAR_FLAG; // ke9ns ADD peak values used by new meter

        }


        private void panelVFOAHover_Paint(object sender, System.Windows.Forms.PaintEventArgs e)
        {
            if (vfoa_hover_digit < 0) return;

            int x = boldfont1; // ke9ns mod  was 0  
            int width = 0;

            if (small_lsd && txtVFOALSD.Visible)
            {
                x += (vfo_char_width + vfo_char_space) * vfoa_hover_digit;

                if (vfoa_hover_digit > 3) x += (vfo_decimal_space - vfo_char_space);

                if (vfoa_hover_digit > 6)
                {
                    x += vfo_small_char_width;
                    x += (vfo_small_char_width + vfo_small_char_space - vfo_char_width - vfo_char_space) * (vfoa_hover_digit - boldfont); // ke9ns mod was -6
                    width = x + vfo_small_char_width;
                }
                else width = x + vfo_char_width;
            }
            else
            {
                x += (vfo_char_width + vfo_char_space) * vfoa_hover_digit;

                if (vfoa_hover_digit > 3) x += (vfo_decimal_space - vfo_char_space);

                width = x + vfo_char_width;
            }

            e.Graphics.DrawLine(new Pen(txtVFOAFreq.ForeColor, 2.0f), x, 1, width, 1);

        } //panelVFOAHover_Paint


        //============================================================================================================
        private void panelVFOBHover_Paint(object sender, System.Windows.Forms.PaintEventArgs e)
        {
            if (vfob_hover_digit < 0)
                return;

            int x = boldfont1; // ke9ns mod  was 0
            int width = 0;

            if (small_lsd && txtVFOBLSD.Visible)
            {
                x += (vfo_char_width + vfo_char_space) * vfob_hover_digit;
                if (vfob_hover_digit > 3)
                    x += (vfo_decimal_space - vfo_char_space);

                if (vfob_hover_digit > 6)
                {
                    x += vfo_small_char_width;
                    x += (vfo_small_char_width + vfo_small_char_space - vfo_char_width - vfo_char_space) * (vfob_hover_digit - boldfont); // ke9ns mod was -6
                    width = x + vfo_small_char_width;
                }
                else width = x + vfo_char_width;
            }
            else
            {
                x += (vfo_char_width + vfo_char_space) * vfob_hover_digit;
                if (vfob_hover_digit > 3)
                    x += (vfo_decimal_space - vfo_char_space);
                width = x + vfo_char_width;
            }

            e.Graphics.DrawLine(new Pen(txtVFOBFreq.ForeColor, 2.0f), x, 1, width, 1);
        }


        //================================================================================================
        //  
        // buffer[] holds last new average data stream (to be used OLD data with 80% usage)
        //
        // new_data[] hold incoming new stream, but at the end of this routine is updated to hold the new avg
        //
        //  buffer[i] = new_data[i] = (float)((new_data[i] * new_mult) + (buffer[i] * old_mult));
        //================================================================================================

        double LASTVFOA = 0; // ke9ns add .251

        public void UpdateRX1DisplayAverage(float[] buffer, float[] new_data) // comment all the wjt stuff. it isnt for the Flex-5000
        {
            //  double dttsp_osc = dsp.GetDSPRX(0, 0).RXOsc; // ke9ns  = -9000 (if value)

            //    Debug.WriteLine("last vfo:  vfo: " + DDSFreq + " , " + rx1_avg_last_ddsfreq + " , " + dttsp_osc); // ke9ns = always 7 @192k

            if (buffer[0] == Display.CLEAR_FLAG) // ke9ns: only comes here when you START/STOP PowerSDR
            {
                //	Debug.WriteLine("============================Clearing average buf"); 

                //  for (int i = 0; i < Display.BUFFER_SIZE; i++) // buffer size of 4096 bytes
                //   {
                //     buffer[i] = new_data[i]; // The avg buffer is now = to current new data
                //  }

                Array.Copy(new_data, 0, buffer, 0, Display.BUFFER_SIZE);
            }
            else
            {
                // wjt added -- stop hosing the avg display when scrolling the vfo 

                /*
                  if ( (rx1_avg_last_ddsfreq != 0 && rx1_avg_last_ddsfreq != DDSFreq) ||  (current_model == Model.SOFTROCK40 && rx1_avg_last_dttsp_osc != dttsp_osc))   // vfo has changed, need to shift things around 
                  {

                    Debug.WriteLine("dttsp_osc: " + dttsp_osc + " , " + LASTVFOA + " , " + VFOAFreq + " , " + Display.WM1);

                     double delta_vfo;

                         if ( current_model != Model.SOFTROCK40 ) 
                         { 					
                             delta_vfo = DDSFreq - rx1_avg_last_ddsfreq; // ke9ns for Flex-5000
                             delta_vfo *= 1e6; // vfo in mhz moron!
                         }
                         else 
                         { 						
                             delta_vfo = dttsp_osc - rx1_avg_last_dttsp_osc; 
                             delta_vfo = -delta_vfo; 
                             Debug.WriteLine("update from dttsp delta_vfo: " + delta_vfo); 
                         } 


                     double hz_per_bin = sample_rate1 / Display.BUFFER_SIZE;   // ke9ns 192000 / 4096 = 46.875 hz per bin,   23hz/bin @ 96k, or 12hz/bin @ 48k

                     int bucket_shift = (int)(delta_vfo / hz_per_bin); // ke9ns 

                     double leftover = delta_vfo - ((double)bucket_shift * hz_per_bin);

                     leftover = leftover / hz_per_bin; // conver to fractions of bucket 

                     double total_leftover = leftover + rx1_last_bin_shift_leftover;

                     if (total_leftover < -0.5)
                     {
                         bucket_shift -= 1;
                         total_leftover += 1;
                         Debug.WriteLine("bump down"); 
                     }
                     else if (total_leftover > 0.5)
                     {
                         bucket_shift += 1;
                         total_leftover -= 1;
                             Debug.WriteLine("bump up"); 
                     }

                     rx1_last_bin_shift_leftover = total_leftover;
                     Debug.WriteLine("leftover: " + leftover + " total_leftover: " + total_leftover); 

                    //  bucket_shift = bucket_shift/2; 						
                    //  indexed_value pre_max = findMax(average_buffer, display_buffer_size); 
                    //  Debug.WriteLine("\nPre max: " + pre_max.val + " " + pre_max.idx); 
                    //  Debug.WriteLine("bshift: " + bucket_shift + " delta_vfo: " + delta_vfo); 

                     if (bucket_shift > 0) // vfo increased, need to shift avgs to the left 
                     {

                         Debug.WriteLine("VFO INC");

                         if (bucket_shift >= Display.BUFFER_SIZE)
                         {
                             buffer[0] = Display.CLEAR_FLAG;
                         }
                         else
                         {
                             for (int j = 0; j < Display.BUFFER_SIZE - bucket_shift; j++)
                                 buffer[j] = buffer[j + bucket_shift];  // wjt fix use memmove 

                             // fill avg with last good data on the end
                             for (int j = Display.BUFFER_SIZE - bucket_shift; j < Display.BUFFER_SIZE; j++)
                                 buffer[j] = buffer[Display.BUFFER_SIZE - bucket_shift - 1];
                         }
                     }
                     else if (bucket_shift < 0) // vfo decreased, move samples up 
                     {
                         Debug.WriteLine("VFO DEC");

                         if (-bucket_shift >= Display.BUFFER_SIZE)
                         {
                             buffer[0] = Display.CLEAR_FLAG;
                         }
                         else
                         {
                             for (int j = Display.BUFFER_SIZE - 1; j > -bucket_shift; j--)
                                 buffer[j] = buffer[j + bucket_shift];

                             for (int j = 0; j < -bucket_shift; j++)
                                 buffer[j] = buffer[-bucket_shift];
                         }
                     }
                     //					indexed_value post_max = findMax(average_buffer, display_buffer_size); 
                     //					Debug.WriteLine("Post max: " + post_max.val + " " + post_max.idx); 
                     //					indexed_value disp_max = findMax(display_data, display_buffer_size); 		
                     //					Debug.WriteLine("Disp max: " + disp_max.val + " " + disp_max.idx); 
                 }
                 else
                 {
                     rx1_last_bin_shift_leftover = 0; // reset, this vfo = last vfo 
                 }

                 if (buffer[0] == Display.CLEAR_FLAG)  // ke9ns =-999.999F Only does this when you hit the START/STOP button
                 {
                     rx1_avg_last_ddsfreq = 0;
                     rx1_avg_last_dttsp_osc = 0;
                    //   Debug.WriteLine("2Clearing average buf");
                 }
                 else
                 {
                     rx1_avg_last_ddsfreq = DDSFreq;
                     rx1_avg_last_dttsp_osc = dttsp_osc;
                    //   Debug.WriteLine("3Clearing average buf");
                 }

 */
                // ke9ns: dont do avg if chkavgmove enabled use routine in display.cs
                // UP1
                if (Display.PF3A != 0) return;   // && (setupForm != null && setupForm.chkAvgMove.Checked)) return; // ke9ns .251

                //........................................

                float new_mult = 0.0f;
                float old_mult = 0.0f;

                // ke9ns: get Display Average value from setup below
                // ke9ns: new_mult + old_mult must = 1.0

                switch (Display.CurrentDisplayMode)
                {
                    case DisplayMode.WATERFALL:
                        new_mult = Display.waterfall_avg_mult_new;
                        old_mult = Display.waterfall_avg_mult_old;
                        break;
                    default: // pan and panafall
                        new_mult = Display.display_avg_mult_new;  // ke9ns:  value based on setup->display->avg time (.016666)
                        old_mult = Display.display_avg_mult_old; // ke9ns: (.83333)  always at the same ratio
                                                                 //  Debug.WriteLine("AVERAGE " + new_mult + " , " + old_mult);
                        break;

                }



                //.......................................................
                // ke9ns: update buffer data  //ke9ns: new_data[i] is from Display and is new data;
                for (int i = 0; i < Display.BUFFER_SIZE; i++) // 4096up
                {
                    buffer[i] = new_data[i] = (float)((new_data[i] * new_mult) + (buffer[i] * old_mult)); // ke9ns: example 80% old data and 20% new data when averaging but changes based on setup->display->avg time
                }


            }   // DO ABOVE when NOT clearing buffer    if(buffer[0] != Display.CLEAR_FLAG)		


        } // rx1 avg display





        //==========================================================

        public void UpdateRX2DisplayAverage(float[] buffer, float[] new_data)
        {
            //  double dttsp_osc = dsp.GetDSPRX(1, 0).RXOsc;
            // Debug.WriteLine("last vfo: " + avg_last_ddsfreq + " vfo: " + DDSFreq); 


            if (buffer[0] == Display.CLEAR_FLAG)
            {
                //Debug.WriteLine("Clearing average buf"); 
                //  for (int i = 0; i < Display.BUFFER_SIZE; i++)
                //     buffer[i] = new_data[i];

                Array.Copy(new_data, 0, buffer, 0, Display.BUFFER_SIZE);
            }
            else
            {

                /*
                                // wjt added -- stop hosing the avg display when scrolling the vfo 
                                if ((rx2_avg_last_ddsfreq != 0 && rx2_avg_last_ddsfreq != DDSFreq) ||
                                    (current_model == Model.SOFTROCK40 &&
                                    rx2_avg_last_dttsp_osc != dttsp_osc))   // vfo has changed, need to shift things around 
                                {
                                    //Debug.WriteLine("dttsp_osc: " + dttsp_osc); 
                                    double delta_vfo;
                                    //	if ( current_model != Model.SOFTROCK40 ) 
                                    //	{ 					
                                    delta_vfo = DDSFreq - rx2_avg_last_ddsfreq;
                                    delta_vfo *= 1e6; // vfo in mhz moron!
                                                      //	}
                                                      //	else 
                                                      //	{ 						
                                                      //	delta_vfo = dttsp_osc - rx2_avg_last_dttsp_osc; 
                                                      //	delta_vfo = -delta_vfo; 
                                                      //Debug.WriteLine("update from dttsp delta_vfo: " + delta_vfo); 
                                                      //	} 

                                    double hz_per_bin = sample_rate1 / Display.BUFFER_SIZE;

                                    int bucket_shift = (int)(delta_vfo / hz_per_bin);
                                    double leftover = delta_vfo - ((double)bucket_shift * hz_per_bin);
                                    leftover = leftover / hz_per_bin; // conver to fractions of bucket 
                                    double total_leftover = leftover + rx2_last_bin_shift_leftover;
                                    if (total_leftover < -0.5)
                                    {
                                        bucket_shift -= 1;
                                        total_leftover += 1;
                                        //Debug.WriteLine("bump down"); 
                                    }
                                    else if (total_leftover > 0.5)
                                    {
                                        bucket_shift += 1;
                                        total_leftover -= 1;
                                        //Debug.WriteLine("bump up"); 
                                    }
                                    rx2_last_bin_shift_leftover = total_leftover;
                                    //Debug.WriteLine("leftover: " + leftover + " total_leftover: " + total_leftover); 

                                    // bucket_shift = bucket_shift/2; 						
                                    // indexed_value pre_max = findMax(average_buffer, display_buffer_size); 
                                    // Debug.WriteLine("\nPre max: " + pre_max.val + " " + pre_max.idx); 
                                    // Debug.WriteLine("bshift: " + bucket_shift + " delta_vfo: " + delta_vfo); 
                                    if (bucket_shift > 0) // vfo increased, need to shift avgs to the left 
                                    {
                                        if (bucket_shift >= Display.BUFFER_SIZE)
                                        {
                                            buffer[0] = Display.CLEAR_FLAG;
                                        }
                                        else
                                        {
                                            for (int j = 0; j < Display.BUFFER_SIZE - bucket_shift; j++)
                                                buffer[j] = buffer[j + bucket_shift];  // wjt fix use memmove 

                                            // fill avg with last good data on the end
                                            for (int j = Display.BUFFER_SIZE - bucket_shift; j < Display.BUFFER_SIZE; j++)
                                                buffer[j] = buffer[Display.BUFFER_SIZE - bucket_shift - 1];
                                        }
                                    }
                                    else if (bucket_shift < 0) // vfo decreased, move samples up 
                                    {
                                        if (-bucket_shift >= Display.BUFFER_SIZE)
                                        {
                                            buffer[0] = Display.CLEAR_FLAG;
                                        }
                                        else
                                        {
                                            for (int j = Display.BUFFER_SIZE - 1; j > -bucket_shift; j--)
                                                buffer[j] = buffer[j + bucket_shift];

                                            for (int j = 0; j < -bucket_shift; j++)
                                                buffer[j] = buffer[-bucket_shift];
                                        }
                                    }
                                    //					indexed_value post_max = findMax(average_buffer, display_buffer_size); 
                                    //					Debug.WriteLine("Post max: " + post_max.val + " " + post_max.idx); 
                                    //					indexed_value disp_max = findMax(display_data, display_buffer_size); 		
                                    //					Debug.WriteLine("Disp max: " + disp_max.val + " " + disp_max.idx); 
                                }
                                else
                                {
                                    rx2_last_bin_shift_leftover = 0; // reset, this vfo = last vfo 
                                }


                                   if (buffer[0] == Display.CLEAR_FLAG)
                            {
                                rx2_avg_last_ddsfreq = 0;
                                rx2_avg_last_dttsp_osc = 0;
                            }
                            else
                            {
                                rx2_avg_last_ddsfreq = DDSFreq;
                                rx2_avg_last_dttsp_osc = dttsp_osc;
                            }

                                */



                // ke9ns: dont do avg if chkavgmove enabled use routine in display.cs
                // UP2
                if (Display.PF3B == 1) return;    // && (setupForm != null && setupForm.chkAvgMove.Checked)) return; // ke9ns .251


                float new_mult = 0.0f;
                float old_mult = 0.0f;

                switch (Display.CurrentDisplayModeBottom)
                {
                    case DisplayMode.PANADAPTER:                    // ke9ns add to correct for RX2 in pan mode, while rx1 in panafall mode
                        new_mult = Display.display_avg_mult_new;
                        old_mult = Display.display_avg_mult_old;
                        break;
                    case DisplayMode.WATERFALL:
                        new_mult = Display.waterfall_avg_mult_new;
                        old_mult = Display.waterfall_avg_mult_old;
                        break;

                    case DisplayMode.PANAFALL:
                        new_mult = Display.display_avg_mult_new;
                        old_mult = Display.display_avg_mult_old;
                        break;

                    default:
                        new_mult = Display.display_avg_mult_new;
                        old_mult = Display.display_avg_mult_old;
                        break;
                }

                for (int i = 0; i < Display.BUFFER_SIZE; i++)
                    buffer[i] = new_data[i] = (float)((new_data[i] * new_mult) + (buffer[i] * old_mult));
            }


        }

        #endregion

        #region Thread and Timer Routines
        //==============================================================
        //==============================================================
        //==============================================================
        //==============================================================
        // Thread Routines
        //==============================================================
        //==============================================================
        //==============================================================
        // =============================================================

        public uint top_thread1 = 0; // ke9ns add
        public float[] wwvbuf = new float[Display.BUFFER_SIZE];

        public int wwvVal = -300;


        //---------------------------------------------
        // ke9ns add: to allow DttSP Restart and N1MM outside of the Display (when you minimize PowerSDR)

        public float slope = 0; // (float)num_samples / (float)W;                    // slope = number of samples need to fill left to right / width of screen in pixels
        public int W = 0;  // float max = float.MinValue;                             // max = y point determined by RX data of spectrum as you go from 0 to W
        public float dval = 0; // i * slope + start_sample_index;            // dval = how many digital values per pixel (going left to right)
        public int lindex = 0; // (int)Math.Floor(dval);                     // L index = int of dval
        public int rindex = 0; // (int)Math.Floor(dval + slope);             // R index = int of dval + slope ?
        public int start_sample_index = 0;
        public float RX1DisplayCalOffset1 = 0;
        public float RX1PreampOffset1 = 0;

        public float RX2DisplayCalOffset1 = 0; //.219 add
        public float RX2PreampOffset1 = 0; //.219 add

        public double max = 0; // ke9ns add
        public long vfoa_hz = 0;
        public long vfob_hz = 0; //.219
        public double Low = 0;
        public double High = 0; // ke9ns add n1mm
        public float max2 = 0; //ke9ns add
        public int max2lastvalue = 0; //ke9ns add
        public int lastvaluecount = 0; //ke9ns add 
        public int restartcount = 0; // ke9ns add.183
        //-------------------------------------------------------


        private void RunDisplay()
        {
#if (WRITE_FFT_TEST)
            BinaryWriter writer = new BinaryWriter(File.Open("test.fft", FileMode.OpenOrCreate, FileAccess.Write));
#endif
            //			display_running = true;
            while ((chkPower.Checked) && (Display.CurrentDisplayMode != DisplayMode.OFF))
            {
                uint top_thread = 0;
                uint bottom_thread = 2;

                if (mox)
                {
                    if (chkVFOATX.Checked || !chkRX2.Checked) top_thread = 1;
                    else if (chkVFOBTX.Checked && chkRX2.Checked) bottom_thread = 1;
                }

                if (!Display.DataReady || (chkSplitDisplay.Checked && !Display.DataReadyBottom))
                {
                    if (calibration_running)
                    {
                        calibration_mutex.WaitOne();
                        displaydidit = true;
                    }

                    if (!Display.DataReady) // ke9ns only get update from Dttsp when display indicates it already used the last data
                    {
                        //  Debug.WriteLine("UPDATE PAN DATA HERE");

                        switch (Display.CurrentDisplayMode)
                        {
                            case DisplayMode.SPECTRUM:
                            case DisplayMode.HISTOGRAM:

                                fixed (float* ptr = &Display.new_display_data[0])
                                {
                                    DttSP.GetSpectrum(top_thread, ptr);
                                }
                                break;

                            case DisplayMode.WATERFALL:
                            case DisplayMode.PANADAPTER:
                            case DisplayMode.PANAFALL:
                            case DisplayMode.PANASCOPE:


                                WWV_mutex.WaitOne();  // ke9ns: add dont allow panadapter to mess with the wwv

                                fixed (float* ptr = &Display.new_display_data[0]) //ke9ns: loads up pan data to display here
                                {
                                    DttSP.GetPanadapter(top_thread, ptr);                // ke9ns:  refers to DttSP.dll Process_Panadapter in update.c file
                                }

                                WWV_mutex.ReleaseMutex();

#if (WRITE_FFT_TEST)
                                for (int i = 0; i < Display.new_display_data.Length; i++)
                                    writer.Write(Display.new_display_data[i]);
#endif
                                break;
                            case DisplayMode.SCOPE:
                                Debug.WriteLine("===GET SCOPE NW"); // this only called 1 time when you select this view mode
                                fixed (float* ptr = &Display.new_display_data[0])
                                    DttSP.GetScope(top_thread, ptr, (int)(scope_time * 48));  // ke9ns  audio.doscope uses this
                                break;
                            case DisplayMode.PHASE:
                                fixed (float* ptr = &Display.new_display_data[0])
                                    DttSP.GetPhase(top_thread, ptr, Display.PhaseNumPts);
                                break;
                            case DisplayMode.PHASE2:
                                //Audio.phase_mutex.WaitOne();
                                for (int i = 0; i < Display.PhaseNumPts; i++)
                                {
                                    Display.new_display_data[i * 2] = Audio.phase_buf_l[i];
                                    Display.new_display_data[i * 2 + 1] = Audio.phase_buf_r[i];
                                }
                                //Audio.phase_mutex.ReleaseMutex();
                                break;
                        }

                        Display.DataReady = true; // ke9ns: dont allow screen to show next line of pan data until UPDATEOFF is clear
                                                  // but not used by getscope routine

                    } // if(!Display.DataReady)



                    if (chkSplitDisplay.Checked && !Display.DataReadyBottom)
                    {
                        switch (Display.CurrentDisplayModeBottom)
                        {
                            case DisplayMode.SPECTRUM:
                            case DisplayMode.HISTOGRAM:
                                fixed (float* ptr = &Display.new_display_data_bottom[0])
                                    DttSP.GetSpectrum(bottom_thread, ptr);
                                break;
                            case DisplayMode.WATERFALL:
                            case DisplayMode.PANADAPTER:
                            case DisplayMode.PANAFALL:                                      // ke9ns add panafall mode for rx2 added
                                fixed (float* ptr = &Display.new_display_data_bottom[0])
                                    DttSP.GetPanadapter(bottom_thread, ptr);
                                break;
                            case DisplayMode.SCOPE:
                                fixed (float* ptr = &Display.new_display_data_bottom[0])
                                    DttSP.GetScope(bottom_thread, ptr, (int)(scope_time * 48));
                                break;
                            case DisplayMode.PHASE:
                                fixed (float* ptr = &Display.new_display_data_bottom[0])
                                    DttSP.GetPhase(bottom_thread, ptr, Display.PhaseNumPts);
                                break;
                            case DisplayMode.PHASE2:
                                //Audio.phase_mutex.WaitOne();
                                for (int i = 0; i < Display.PhaseNumPts; i++)
                                {
                                    Display.new_display_data_bottom[i * 2] = Audio.phase_buf_l[i];
                                    Display.new_display_data_bottom[i * 2 + 1] = Audio.phase_buf_r[i];
                                }
                                //Audio.phase_mutex.ReleaseMutex();
                                break;
                        }
                        Display.DataReadyBottom = true;
                    }

                    if (displaydidit)
                    {
                        displaydidit = false;
                        calibration_mutex.ReleaseMutex();
                    }
                }
                else // ke9ns add: .183 (when PowerSDR is minimized) to allow detecting if DttSP locked up and N1MM spectrum.
                {
                    // CHECKMIN ?
                    if ((!mox) && chkPower.Checked && (setupForm.chkBoxRestart.Checked || (N1MM_ON == true)))
                    {
                        if (N1MM_RX2) //.219 add
                        {
                            fixed (float* ptr = &Display.PAN_DATA2[0]) //ke9ns: loads up pan data to display here
                            {
                                DttSP.GetPanadapter(bottom_thread, ptr);                // ke9ns:  refers to DttSP.dll Process_Panadapter in update.c file
                            }

                            if (setupForm.chkBoxRestart.Checked) // ke9ns add for DttSP freeze
                            {
                                max2 = 0;
                                int Y = 2000; // just look at 2000 points

                                for (int i = 0; i < Y; i++)
                                {
                                    max2 = max2 + Display.PAN_DATA2[i]; // sum up entire panadapter line (left to right)
                                }

                                //  Debug.WriteLine("DttSP check");
                                if ((int)max2 == max2lastvalue)
                                {
                                    if (lastvaluecount++ > 3) // if same exact display for 3 cycles
                                    {
                                        Debug.WriteLine("DttSP appears to be frozen. Will unfreeze");

                                        chkPower.Checked = false; // turn off

                                        lastvaluecount = 0;
                                        restartcount++;
                                        setupForm.textBoxRestart.Text = restartcount.ToString();

                                        chkPower.Checked = true; // turn back on
                                    }
                                    else
                                    {
                                        //  Debug.WriteLine("DttSP freeze value-: " + lastvaluecount);
                                    }
                                }
                                else
                                {
                                    max2lastvalue = (int)max2;
                                    lastvaluecount = 0; // reset value and counter
                                }

                            } // check for DttSP freeze
                        }
                        else
                        {
                            fixed (float* ptr = &Display.PAN_DATA[0]) //ke9ns: loads up pan data to display here
                            {
                                DttSP.GetPanadapter(top_thread, ptr);                // ke9ns:  refers to DttSP.dll Process_Panadapter in update.c file
                            }

                            if (setupForm.chkBoxRestart.Checked) // ke9ns add for DttSP freeze
                            {
                                max2 = 0;
                                int Y = 2000; // just look at 2000 points

                                for (int i = 0; i < Y; i++)
                                {
                                    max2 = max2 + Display.PAN_DATA[i]; // sum up entire panadapter line (left to right)
                                }

                                //  Debug.WriteLine("DttSP check");
                                if ((int)max2 == max2lastvalue)
                                {
                                    if (lastvaluecount++ > 3) // if same exact display for 3 cycles
                                    {
                                        Debug.WriteLine("DttSP appears to be frozen. Will unfreeze");

                                        chkPower.Checked = false; // turn off

                                        lastvaluecount = 0;
                                        restartcount++;
                                        setupForm.textBoxRestart.Text = restartcount.ToString();

                                        chkPower.Checked = true; // turn back on
                                    }
                                    else
                                    {
                                        //  Debug.WriteLine("DttSP freeze value-: " + lastvaluecount);
                                    }
                                }
                                else
                                {
                                    max2lastvalue = (int)max2;
                                    lastvaluecount = 0; // reset value and counter
                                }

                            } // check for DttSP freeze

                        } // N1MM_RX2



                        //----------------------------------------------------------------
                        // ke9ns add: n1mm when display is minimized

                        if ((N1MM_ON == true))
                        {

                            N1MM_Sample = W; //  W  literaly the width in pixels of your PAN display area


                            if (N1MM_RX2 == false)
                            {
                                long temp6 = (long)(VFOAFreq * 1000000); //vfoa_hz;// Display.VFOA;

                                Debug.WriteLine("N1MM VFO " + VFOAFreq + " , " + temp6);

                                if ((rx1_dsp_mode == DSPMode.CWL)) temp6 = temp6 + cw_pitch;
                                else if ((rx1_dsp_mode == DSPMode.CWU)) temp6 = temp6 - cw_pitch; // ke9ns: adjust pan spectrum to account for pitch

                                double Low1 = (double)(temp6 + Display.RXDisplayLow) / 1000;
                                double High1 = (double)(temp6 + Display.RXDisplayHigh) / 1000;



                                N1MM_Low = (int)(Low1) + 1;  //move up to the next full khz;

                                N1MM_High = (int)(High1); // move down to the next full khz;

                                double temp1 = W / (High1 - Low1); // gets samples / khz  
                                double temp2 = -(Low1 - N1MM_Low); // get how many                            


                                N1MM_OFFSET = (int)(temp2 * temp1); // number of samples to jump to get to next full khz


                                N1MM_Sample = W - ((int)temp1); // get how many samples to remove from the High end

                                //  Debug.WriteLine("N1MM LOW " + N1MM_Low + " , " + N1MM_High + "<>" + Low1 + " , " + High1 + " <> " +N1MM_Sample + " , "+temp1 + " , " + temp2 + " , " + N1MM_OFFSET + " , " + vfoa_hz);

                                if (chkDisplayAVG.Checked)
                                {
                                    UpdateRX1DisplayAverage(Display.rx1_average_buffer, Display.PAN_DATA); // ke9ns: put PAN_DATA buffer into rx1_avg buffer
                                }


                                RX1DisplayCalOffset1 = Display.RX1DisplayCalOffset; // get the current calibration offset and preamp settings
                                RX1PreampOffset1 = Display.RX1PreampOffset;

                                // copied from display.cs
                                for (int i = 0; i < W; i++) // pixels across the x axis of the display area last seen when it was open
                                {
                                    float max4 = float.MinValue;
                                    float dval = i * slope + start_sample_index;            // dval = how many digital values per pixel (going left to right)
                                    int lindex = (int)Math.Floor(dval);                     // L index = int of dval
                                    int rindex = (int)Math.Floor(dval + slope);             // R index = int of dval + slope ?

                                    if (slope <= 1.0 || lindex == rindex)   // if your zoom in there is less than 1 digital value per pixel so fake it.
                                    {
                                        if (chkDisplayAVG.Checked) max4 = Display.rx1_average_buffer[lindex % Display.DATA_BUFFER_SIZE] * ((float)lindex - dval + 1) + Display.rx1_average_buffer[(lindex + 1) % Display.DATA_BUFFER_SIZE] * (dval - (float)lindex);
                                        else max4 = Display.PAN_DATA[lindex % Display.DATA_BUFFER_SIZE] * ((float)lindex - dval + 1) + Display.PAN_DATA[(lindex + 1) % Display.DATA_BUFFER_SIZE] * (dval - (float)lindex);
                                    }
                                    else // otherwise there is more than 1 digital value per pixel so take the largest value ?
                                    {
                                        for (int j = lindex; j < rindex; j++)
                                        {
                                            if (chkDisplayAVG.Checked)
                                            {
                                                if (Display.rx1_average_buffer[j % Display.DATA_BUFFER_SIZE] > max4) max4 = Display.rx1_average_buffer[j % Display.DATA_BUFFER_SIZE]; // % modulus (i.e. remainder only)
                                            }
                                            else
                                            {
                                                if (Display.PAN_DATA[j % Display.DATA_BUFFER_SIZE] > max4) max4 = Display.PAN_DATA[j % Display.DATA_BUFFER_SIZE]; // % modulus (i.e. remainder only)

                                            }
                                        }
                                    }

                                    max4 += RX1DisplayCalOffset1;
                                    max4 += RX1PreampOffset1;

                                    if (i >= N1MM_OFFSET) N1MM_Data[i - N1MM_OFFSET] = (int)max4; // ke9ns: need to adjust n1mm spectrum so we can find the full khz low/high

                                    if ((int)max4 < N1MM_Floor) N1MM_Floor = (int)max4;

                                } // for i to W

                            } // N1MM_RX2 = false RX1 above
                            else
                            {
                                long temp6 = (long)(VFOBFreq * 1000000); //vfoa_hz;// Display.VFOA;

                                Debug.WriteLine("N1MM VFOB " + VFOBFreq + " , " + temp6);

                                if ((rx2_dsp_mode == DSPMode.CWL)) temp6 = temp6 + cw_pitch;
                                else if ((rx2_dsp_mode == DSPMode.CWU)) temp6 = temp6 - cw_pitch; // ke9ns: adjust pan spectrum to account for pitch

                                double Low1 = (double)(temp6 + Display.RXDisplayLow2) / 1000;
                                double High1 = (double)(temp6 + Display.RXDisplayHigh2) / 1000;



                                N1MM_Low = (int)(Low1) + 1;  //move up to the next full khz;

                                N1MM_High = (int)(High1); // move down to the next full khz;

                                double temp1 = W / (High1 - Low1); // gets samples / khz  
                                double temp2 = -(Low1 - N1MM_Low); // get how many                            


                                N1MM_OFFSET = (int)(temp2 * temp1); // number of samples to jump to get to next full khz


                                N1MM_Sample = W - ((int)temp1); // get how many samples to remove from the High end

                                //  Debug.WriteLine("N1MM LOW " + N1MM_Low + " , " + N1MM_High + "<>" + Low1 + " , " + High1 + " <> " +N1MM_Sample + " , "+temp1 + " , " + temp2 + " , " + N1MM_OFFSET + " , " + vfoa_hz);

                                if (chkRX2DisplayAVG.Checked)
                                {
                                    UpdateRX2DisplayAverage(Display.rx2_average_buffer, Display.PAN_DATA2);
                                }


                                RX2DisplayCalOffset1 = Display.RX2DisplayCalOffset; // get the current calibration offset and preamp settings
                                RX2PreampOffset1 = Display.RX2PreampOffset;

                                // copied from display.cs
                                for (int i = 0; i < W; i++) // pixels across the x axis of the display area last seen when it was open
                                {
                                    float max4 = float.MinValue;
                                    float dval = i * slope + start_sample_index;            // dval = how many digital values per pixel (going left to right)
                                    int lindex = (int)Math.Floor(dval);                     // L index = int of dval
                                    int rindex = (int)Math.Floor(dval + slope);             // R index = int of dval + slope ?

                                    if (slope <= 1.0 || lindex == rindex)   // if your zoom in there is less than 1 digital value per pixel so fake it.
                                    {
                                        if (chkRX2DisplayAVG.Checked) max4 = Display.rx2_average_buffer[lindex % Display.DATA_BUFFER_SIZE] * ((float)lindex - dval + 1) + Display.rx2_average_buffer[(lindex + 1) % Display.DATA_BUFFER_SIZE] * (dval - (float)lindex);
                                        else max4 = Display.PAN_DATA2[lindex % Display.DATA_BUFFER_SIZE] * ((float)lindex - dval + 1) + Display.PAN_DATA2[(lindex + 1) % Display.DATA_BUFFER_SIZE] * (dval - (float)lindex);
                                    }
                                    else // otherwise there is more than 1 digital value per pixel so take the largest value ?
                                    {
                                        for (int j = lindex; j < rindex; j++)
                                        {
                                            if (chkRX2DisplayAVG.Checked)
                                            {
                                                if (Display.rx2_average_buffer[j % Display.DATA_BUFFER_SIZE] > max4) max4 = Display.rx2_average_buffer[j % Display.DATA_BUFFER_SIZE]; // % modulus (i.e. remainder only)
                                            }
                                            else
                                            {
                                                if (Display.PAN_DATA2[j % Display.DATA_BUFFER_SIZE] > max4) max4 = Display.PAN_DATA2[j % Display.DATA_BUFFER_SIZE]; // % modulus (i.e. remainder only)

                                            }
                                        }
                                    }

                                    max4 += RX2DisplayCalOffset1;
                                    max4 += RX2PreampOffset1;

                                    if (i >= N1MM_OFFSET) N1MM_Data[i - N1MM_OFFSET] = (int)max4; // ke9ns: need to adjust n1mm spectrum so we can find the full khz low/high

                                    if ((int)max4 < N1MM_Floor) N1MM_Floor = (int)max4;

                                } // for i to W


                            } // N1MM_RX2 = true RX2 above



                        } // if (console.N1MM_ON == true)


                    } // check if in REC mode, Started and Either Dttsp Restart or N1mm features active


                } // Display is not ready

                UpdateDisplay(); // ke9ns 


                if (chkPower.Checked)
                {
                    // if (UPDATEOFF > 0) Thread.Sleep(display_delay/4); // ke9sn mod  increase update speed to screen for short time when CTUN is on
                    // else
                    Thread.Sleep(display_delay);
                }


            } // power on and display on	
              //			display_running = false;

#if (WRITE_FFT_TEST)
            writer.Close();
#endif
        } // RunDisplay() thread


        //===============================================================================
        //===============================================================================
        // ke9ns   this is where you update the meter signal that will be given to the draw routine up above
        //         added the peak meter signal below
        //===============================================================================
        //===============================================================================

        private HiPerfTimer meter_timer = new HiPerfTimer();
        private float multimeter_avg = Display.CLEAR_FLAG;
        private float multimeter_peak = Display.CLEAR_FLAG; // ke9ns ADD for RX1 peak meter routine
        private void UpdateMultimeter()
        {
            meter_timer.Start();
            while (chkPower.Checked)
            {

                if (!meter_data_ready)
                {

                    if (!mox) // if rx mode
                    {

                        /*if(Audio.CurrentAudioState1 != Audio.AudioState.DTTSP)
							goto end;*/

                        if (CurrentMeterTX1Mode == MeterTXMode.Combo) // ke9ns add
                        {

                            if (chkRX2.Checked == false)
                            {
                                if (picRX3Meter.Visible == false)
                                {
                                    picRX3Meter.Visible = true;  // turn on Combo if in RX mode but RX2 is not ON
                                    picRX3Meter.Enabled = true;
                                    meterCombo = true;
                                }
                            }
                            else if ((picRX3Meter.Visible == true)) // turn off combo meter when RX2 is ON in RX mode
                            {

                                picRX3Meter.Visible = false;
                                picRX3Meter.Enabled = false;
                                meterCombo = false;
                            }



                        }
                        else if ((picRX3Meter.Visible == true) && (chkRX2.Checked == true)) // turn off combo meter when RX2 is ON in RX mode
                        {

                            picRX3Meter.Visible = false;
                            picRX3Meter.Enabled = false;
                            meterCombo = false;
                        }
                        float num = 0f;

                        if (meterCombo == true) // if in RX mode (clear out PWR,SWR, use only live MIC)
                        {

                            //combo meter
                            // fwd power, swr, alc, mic

                            //-----------------------------------------------
                            // PWR

                            tx2_meter_new_data_pwr = num = 0;

                            if (tx2_meter_peak_pwr == Display.CLEAR_FLAG) tx2_meter_peak_pwr = num;


                            if (tx2_meter_peak_pwr < num) // new value larger than before
                            {
                                tx2_meter_peak_pwr = num; // new peak value
                                tx2_meter_peak5_pwr = 0;
                            }
                            else // new value smaller than before
                            {
                                if (tx2_meter_peak5_pwr == 20)
                                {
                                    // Debug.WriteLine("Peak5 " + tx2_meter_peak_pwr);
                                    if (tx2_meter_peak_pwr > num)
                                    {
                                        tx2_meter_peak_pwr = tx2_meter_peak_pwr - 1; // reduce peak slowly
                                    }
                                    else
                                    {
                                        tx2_meter_peak5_pwr = 0; // once the peak moves back down to the current value, reset the counter
                                    }
                                }
                                else tx2_meter_peak5_pwr++;
                                //  Debug.WriteLine("peak5 " + tx2_meter_peak5_pwr);


                            }

                            // ke9nsSWR
                            //-----------------------------------------------
                            // SWR this is in RX mode meter 1


                            if (lastswr > 1) // ke9ns add .191  so the needle moves down slowly
                            {
                                num = (float)(lastswr = lastswr - .2);
                            }
                            else num = 1;

                            tx2_meter_new_data_swr = num; // = 1;


                            if (tx2_meter_peak_swr == Display.CLEAR_FLAG) tx2_meter_peak_swr = num;


                            if (tx2_meter_peak_swr < num) // new value larger than before
                            {
                                tx2_meter_peak_swr = num; // new peak value
                                tx2_meter_peak5_swr = 0;
                            }
                            else // new value smaller than before
                            {
                                if (tx2_meter_peak5_swr == 20)
                                {
                                    if (tx2_meter_peak_swr > num)
                                    {
                                        tx2_meter_peak_swr = tx2_meter_peak_swr - 0.1f; // reduce peak slowly
                                    }
                                    else
                                    {
                                        tx2_meter_peak5_swr = 0; // once the peak moves back down to the current value, reset the counter
                                    }
                                }
                                else tx2_meter_peak5_swr++;
                            }


                            //  Debug.WriteLine(" SWR  " + tx2_meter_peak_swr);


                            //-----------------------------------------------
                            // ALC


                            tx2_meter_new_data_alc = num = -60;
                            tx2_meter_new_data_alcG = -60;



                            if (tx2_meter_peak_alc == Display.CLEAR_FLAG) tx2_meter_peak_alc = num;


                            if (tx2_meter_peak_alc < num) // new value larger than before
                            {
                                tx2_meter_peak_alc = num; // new peak value
                                tx2_meter_peak5_alc = 0;
                            }
                            else // new value smaller than before
                            {
                                if (tx2_meter_peak5_alc == 20)
                                {
                                    if (tx2_meter_peak_alc > num)
                                    {
                                        tx2_meter_peak_alc = tx2_meter_peak_alc - 1; // reduce peak slowly
                                    }
                                    else
                                    {
                                        tx2_meter_peak5_alc = 0; // once the peak moves back down to the current value, reset the counter
                                    }
                                }
                                else tx2_meter_peak5_alc++;
                            }



                            //-----------------------------------------------
                            // MIC

                            if ((setupForm.chkRX2AutoMuteRX2OnVFOATX.Checked == false) || (TXMeter2 == false) || RX2Enabled == true) // ke9ns allow TX 2nd meter if option selected and not in duplex mode
                            {



                                tx2_meter_new_data_mic = num = -60;

                                if (tx2_meter_peak_mic == Display.CLEAR_FLAG) tx2_meter_peak_mic = num;

                                if (tx2_meter_peak_mic < num) // new value larger than before
                                {
                                    tx2_meter_peak_mic = num; // new peak value
                                    tx2_meter_peak5_mic = 0;
                                }
                                else // new value smaller than before
                                {
                                    if (tx2_meter_peak5_mic == 20)
                                    {
                                        if (tx2_meter_peak_mic > num)
                                        {
                                            tx2_meter_peak_mic = tx2_meter_peak_mic - 1; // reduce peak slowly
                                        }
                                        else
                                        {
                                            tx2_meter_peak5_mic = 0; // once the peak moves back down to the current value, reset the counter
                                        }
                                    }
                                    else tx2_meter_peak5_mic++;
                                }



                            }
                            //combo meter


                        } // meterCombo


                        MeterRXMode mode = CurrentMeterRXMode;

                        float peak3 = 0f; // ke9ns ADD for RX1 peak meter routine


                        if (CONT_RUN == true) // if in continuum mode, get the S meter reading in dbm
                        {
                            num = DttSP.CalculateRXMeter(0, 0, DttSP.MeterType.SIGNAL_STRENGTH);

                            if (fwc_init || hid_init)
                            {
                                switch (current_model)
                                {
                                    case Model.SDRX:
                                        num = num +
                                            rx1_meter_cal_offset +
                                            meter_offset +
                                            rx1_filter_size_cal_offset +
                                            rx1_xvtr_gain_offset;
                                        break;
                                    case Model.FLEX5000:
                                    case Model.FLEX3000:
                                        /*Debug.WriteLine("RX1: num: " + num.ToString("f1") + "  meter: " + rx1_meter_cal_offset.ToString("f1") +
                                           "  preamp: " + rx1_preamp_offset[(int)rx1_preamp_mode].ToString("f1") + "  filter: " + rx1_filter_size_cal_offset.ToString("f1") +
                                           "  path: " + rx1_path_offset.ToString("f1") + "  xvtr: " + rx1_xvtr_gain_offset.ToString("f1") +
                                           "  loop: " + rx1_loop_offset.ToString("f1"));*/
                                        num = num +
                                            rx1_meter_cal_offset +
                                            rx1_preamp_offset[(int)rx1_preamp_mode] +
                                            rx1_filter_size_cal_offset +
                                            rx1_path_offset +
                                            rx1_xvtr_gain_offset +
                                            rx1_loop_offset;
                                        break;
                                    case Model.FLEX1500:
                                        num = num +
                                            rx1_meter_cal_offset +
                                            rx1_preamp_offset[(int)rx1_preamp_mode] +
                                            rx1_filter_size_cal_offset +
                                            rx1_xvtr_gain_offset;
                                        break;
                                }
                            }
                            else
                            {
                                num = num +
                                    rx1_meter_cal_offset +
                                    rx1_preamp_offset[(int)rx1_preamp_mode] +
                                    rx1_filter_size_cal_offset +
                                    rx1_xvtr_gain_offset;
                            }
                            //output = num.ToString("f1")+" dBm";
                            CONT_BANDPASS = num;

                        }

                        switch (mode)
                        {
                            case MeterRXMode.SIGNAL_STRENGTH:

                                num = DttSP.CalculateRXMeter(0, 0, DttSP.MeterType.SIGNAL_STRENGTH);

                                if (fwc_init || hid_init)
                                {
                                    switch (current_model)
                                    {
                                        case Model.SDRX:
                                            num = num +
                                                rx1_meter_cal_offset +
                                                meter_offset +
                                                rx1_filter_size_cal_offset +
                                                rx1_xvtr_gain_offset;
                                            break;
                                        case Model.FLEX5000:
                                        case Model.FLEX3000:
                                            /*Debug.WriteLine("RX1: num: " + num.ToString("f1") + "  meter: " + rx1_meter_cal_offset.ToString("f1") +
                                               "  preamp: " + rx1_preamp_offset[(int)rx1_preamp_mode].ToString("f1") + "  filter: " + rx1_filter_size_cal_offset.ToString("f1") +
                                               "  path: " + rx1_path_offset.ToString("f1") + "  xvtr: " + rx1_xvtr_gain_offset.ToString("f1") +
                                               "  loop: " + rx1_loop_offset.ToString("f1"));*/
                                            num = num +
                                                rx1_meter_cal_offset +
                                                rx1_preamp_offset[(int)rx1_preamp_mode] +
                                                rx1_filter_size_cal_offset +
                                                rx1_path_offset +
                                                rx1_xvtr_gain_offset +
                                                rx1_loop_offset;
                                            break;
                                        case Model.FLEX1500:
                                            num = num +
                                                rx1_meter_cal_offset +
                                                rx1_preamp_offset[(int)rx1_preamp_mode] +
                                                rx1_filter_size_cal_offset +
                                                rx1_xvtr_gain_offset;
                                            break;
                                    }
                                }
                                else
                                {
                                    num = num +
                                        rx1_meter_cal_offset +
                                        rx1_preamp_offset[(int)rx1_preamp_mode] +
                                        rx1_filter_size_cal_offset +
                                        rx1_xvtr_gain_offset;
                                }
                                //output = num.ToString("f1")+" dBm";
                                new_meter_data = num;

                                //  Debug.WriteLine("strength meter " + num);

                                break; // signal


                            case MeterRXMode.SIGNAL_AVERAGE:
                                num = DttSP.CalculateRXMeter(0, 0, DttSP.MeterType.SIGNAL_STRENGTH);

                                if (multimeter_avg == Display.CLEAR_FLAG) multimeter_avg = num;

                                num = multimeter_avg_mult_old * multimeter_avg + multimeter_avg_mult_new * num;

                                multimeter_avg = num;

                                if (fwc_init || hid_init)
                                {
                                    switch (current_model)
                                    {
                                        case Model.SDRX:
                                            num = num +
                                                rx1_meter_cal_offset +
                                                meter_offset +
                                                rx1_filter_size_cal_offset +
                                                rx1_xvtr_gain_offset;
                                            break;
                                        case Model.FLEX5000:
                                        case Model.FLEX3000:
                                            num = num +
                                                rx1_meter_cal_offset +
                                                rx1_preamp_offset[(int)rx1_preamp_mode] +
                                                rx1_filter_size_cal_offset +
                                                rx1_path_offset +
                                                rx1_xvtr_gain_offset +
                                                rx1_loop_offset;
                                            break;
                                        case Model.FLEX1500:
                                            num = num +
                                                rx1_meter_cal_offset +
                                                rx1_preamp_offset[(int)rx1_preamp_mode] +
                                                rx1_filter_size_cal_offset +
                                                rx1_xvtr_gain_offset;
                                            break;
                                    }
                                }
                                else
                                {
                                    num = num +
                                        rx1_meter_cal_offset +
                                        rx1_preamp_offset[(int)rx1_preamp_mode] +
                                        rx1_filter_size_cal_offset +
                                        rx1_xvtr_gain_offset;
                                }


                                //output = num.ToString("f1")+" dBm";
                                new_meter_data = num;
                                break;  // average


                            //=======================================================================    
                            case MeterRXMode.SIGNAL_PEAK:       // ke9ns ADD RX1 peak

                                peak3 = num = DttSP.CalculateRXMeter(0, 0, DttSP.MeterType.SIGNAL_STRENGTH); // normal readings -130 to 0 db, but here its -40 to -30

                                if (multimeter_peak == Display.CLEAR_FLAG) multimeter_peak = num;

                                if (multimeter_peak < num)   // check for new peak value
                                {
                                    multimeter_peak = num; // new peak value
                                    peak4 = 0;
                                }
                                else
                                {
                                    if (peak4 == 20)
                                    {
                                        if (multimeter_peak > num) multimeter_peak = multimeter_peak - 1;
                                        else peak4 = 0;
                                    }
                                    else peak4++;
                                }

                                //======================================
                                num = peak3; // this is the standard signal needle only (below is the peak)

                                if (fwc_init || hid_init)
                                {
                                    switch (current_model)
                                    {
                                        case Model.SDRX:
                                            num = num +
                                                rx1_meter_cal_offset +
                                                meter_offset +
                                                rx1_filter_size_cal_offset +
                                                rx1_xvtr_gain_offset;
                                            break;
                                        case Model.FLEX5000:
                                        case Model.FLEX3000:
                                            num = num +
                                          rx1_meter_cal_offset +
                                          rx1_preamp_offset[(int)rx1_preamp_mode] +
                                          rx1_filter_size_cal_offset +
                                          rx1_path_offset +
                                          rx1_xvtr_gain_offset +
                                          rx1_loop_offset;
                                            break;
                                        case Model.FLEX1500:
                                            num = num +
                                                rx1_meter_cal_offset +
                                                rx1_preamp_offset[(int)rx1_preamp_mode] +
                                                rx1_filter_size_cal_offset +
                                                rx1_xvtr_gain_offset;
                                            break;
                                    }
                                }
                                else
                                {
                                    num = num +
                                        rx1_meter_cal_offset +
                                        rx1_preamp_offset[(int)rx1_preamp_mode] +
                                        rx1_filter_size_cal_offset +
                                        rx1_xvtr_gain_offset;
                                }



                                new_meter_data = num;  // send to meter movement

                                //========================================
                                // this is for peak reading only needle and numbers
                                //========================================

                                num = multimeter_peak; // now use current peak value

                                if (fwc_init || hid_init)
                                {
                                    switch (current_model)
                                    {
                                        case Model.SDRX:
                                            num = num +
                                                rx1_meter_cal_offset +
                                                meter_offset +
                                                rx1_filter_size_cal_offset +
                                                rx1_xvtr_gain_offset;
                                            break;
                                        case Model.FLEX5000:
                                        case Model.FLEX3000:
                                            num = num +
                                          rx1_meter_cal_offset +
                                          rx1_preamp_offset[(int)rx1_preamp_mode] +
                                          rx1_filter_size_cal_offset +
                                          rx1_path_offset +
                                          rx1_xvtr_gain_offset +
                                          rx1_loop_offset;
                                            break;
                                        case Model.FLEX1500:
                                            num = num +
                                                rx1_meter_cal_offset +
                                                rx1_preamp_offset[(int)rx1_preamp_mode] +
                                                rx1_filter_size_cal_offset +
                                                rx1_xvtr_gain_offset;
                                            break;
                                    }
                                }
                                else
                                {
                                    num = num +
                                        rx1_meter_cal_offset +
                                        rx1_preamp_offset[(int)rx1_preamp_mode] +
                                        rx1_filter_size_cal_offset +
                                        rx1_xvtr_gain_offset;
                                }



                                meter_peak_value = num; // RX1 used only for peak needle and numbers


                                break; // peak RX1 ke9ns


                            case MeterRXMode.ADC_L:
                                num = DttSP.CalculateRXMeter(0, 0, DttSP.MeterType.ADC_REAL);
                                //output = num.ToString("f1")+" dBFS ";
                                new_meter_data = num;
                                break;
                            case MeterRXMode.ADC_R:
                                num = DttSP.CalculateRXMeter(0, 0, DttSP.MeterType.ADC_IMAG);
                                //output = num.ToString("f1")+" dBFS ";
                                new_meter_data = num;
                                break;
                            case MeterRXMode.ADC2_L:
                                num = DttSP.CalculateRXMeter(2, 0, DttSP.MeterType.ADC_REAL);
                                //output = num.ToString("f1")+" dBFS ";
                                new_meter_data = num;
                                break;
                            case MeterRXMode.ADC2_R:
                                num = DttSP.CalculateRXMeter(2, 0, DttSP.MeterType.ADC_IMAG);
                                //output = num.ToString("f1")+" dBFS ";
                                new_meter_data = num;
                                break;
                            case MeterRXMode.OFF:
                                //output = "";
                                new_meter_data = -200.0f;
                                break;
                        } //mode


                        //-------------------------------------------------------------------------
                        // ke9ns add when in RX, but using 2nd TX meter, return meter back
                        if ((setupForm.chkRX2AutoMuteRX2OnVFOATX.Checked == true) && (TXMeter2 == true) && RX2Enabled == false) // ke9ns allow TX 2nd meter if option selected and not in duplex mode
                        {
                            if (new_meter_data2 != -200.0)
                            {
                                rx2_meter_new_data = -200.0f;

                            }

                            if ((current_meter_tx1_mode == MeterTXMode.MIC) || (current_meter_tx1_mode == MeterTXMode.Combo))
                            {

                                //  Debug.WriteLine("PEAK1 Level" + Audio.Peak1 + " MIC");
                                tx2_meter_new_data_mic = tx2_meter_new_data = (double)20 * Math.Log10(Audio.Peak1); // ke9ns get dBm value from MIC audio stream


                                if (tx2_meter_peak_mic == Display.CLEAR_FLAG) tx2_meter_peak_mic = tx2_meter_new_data;

                                if (tx2_meter_peak_mic < tx2_meter_new_data) // new value larger than before
                                {
                                    tx2_meter_peak_mic = tx2_meter_new_data; // new peak value
                                    tx2_meter_peak5_mic = 0;
                                }
                                else // new value smaller than before
                                {
                                    if (tx2_meter_peak5_mic == 20)
                                    {
                                        if (tx2_meter_peak_mic > tx2_meter_new_data)
                                        {
                                            tx2_meter_peak_mic = tx2_meter_peak_mic - 1; // reduce peak slowly
                                        }
                                        else
                                        {
                                            tx2_meter_peak5_mic = 0; // once the peak moves back down to the current value, reset the counter
                                        }
                                    }
                                    else tx2_meter_peak5_mic++;
                                }
                            } // MIC or COMBO
                            else if (CurrentMeterTX1Mode == MeterTXMode.SWR)
                            {

                                //  double swr = 0.0;

                                switch (current_model)
                                {
                                    case Model.FLEX5000:
                                    case Model.FLEX3000:
                                        if (lastswr > 1) // ke9ns add .191  so the needle moves down slowly
                                        {
                                            lastswr = lastswr - .2;
                                        }
                                        else lastswr = 1;

                                        rx2_meter_new_data = (float)lastswr; // picRX2meter_paint  


                                        break;

                                }

                            }  // ke9ns add: check TX2 meter mode to slow down the needle retreat
                            else if (CurrentMeterTX1Mode == MeterTXMode.FORWARD_POWER) // .191
                            {

                                switch (current_model)
                                {
                                    case Model.FLEX5000:
                                    case Model.FLEX3000:
                                        if (lastfwdpower > 0) // ke9ns add .191  so the needle moves down slowly
                                        {
                                            lastfwdpower = lastfwdpower - 3;
                                        }
                                        else lastfwdpower = 0;

                                        rx2_meter_new_data = (float)lastfwdpower; // picRX2meter_paint  


                                        break;

                                }

                            }  // ke9ns add: check TX2 meter mode to slow down the needle retreat
                            else if (CurrentMeterTX1Mode == MeterTXMode.REVERSE_POWER) // .191
                            {

                                switch (current_model)
                                {
                                    case Model.FLEX5000:
                                    case Model.FLEX3000:
                                        if (lastrevpower > 0) // ke9ns add .191  so the needle moves down slowly
                                        {
                                            lastrevpower = lastrevpower - 3;
                                        }
                                        else lastrevpower = 0;

                                        rx2_meter_new_data = (float)lastrevpower; // picRX2meter_paint  

                                        break;

                                }

                            } // ke9ns add: check TX2 meter mode to slow down the needle retreat
                            else if (CurrentMeterTX1Mode == MeterTXMode.ALC) // .191
                            {


                                if (lastalc > -30) // ke9ns add .191  so the needle moves down slowly
                                {
                                    lastalc = lastalc - 0.5;
                                }
                                else lastalc = -30;

                                rx2_meter_new_data = (float)lastalc; // picRX2meter_paint  


                            }  // ke9ns add: check TX2 meter mode to slow down the needle retreat
                            else if (CurrentMeterTX1Mode == MeterTXMode.MIC) // .191
                            {


                                if (lastmic > -30) // ke9ns add .191  so the needle moves down slowly
                                {
                                    lastmic = lastmic - 0.5;
                                }
                                else lastmic = -30;

                                rx2_meter_new_data = (float)lastmic; // picRX2meter_paint  


                            } // ke9ns add: check TX2 meter mode to slow down the needle retreat
                            else if (CurrentMeterTX1Mode == MeterTXMode.EQ) // .191
                            {


                                if (lasteq > -30) // ke9ns add .191  so the needle moves down slowly
                                {
                                    lasteq = lasteq - 0.5;
                                }
                                else lasteq = -30;

                                rx2_meter_new_data = (float)lasteq; // picRX2meter_paint  


                            } // ke9ns add: check TX2 meter mode to slow down the needle retreat



                            rx2_meter_data_ready = true;

                            if (meterCombo == true) picRX3Meter.Invalidate(); // ke9ns12 add
                            else picRX2Meter.Invalidate(); // ke9ns12 add

                        }




                    } // !MOX
                    else //MOX  (TX) 
                    {

                        if (picRX3Meter.Visible == false) // ke9ns add
                        {
                            if (CurrentMeterTX1Mode == MeterTXMode.Combo)
                            {
                                if (picRX3Meter.Visible == false)
                                {
                                    picRX3Meter.Visible = true; // turn on combo if in combo and TX
                                    picRX3Meter.Enabled = true;

                                    meterCombo = true;


                                }

                            }

                        }

                        MeterTXMode mode = CurrentMeterTXMode;  // ke9ns  RX1 meter first
                        float num = 0f;
                        double power = 0.0;

                        switch (mode)
                        {

                            case MeterTXMode.MIC:
                                if (peak_tx_meter) num = (float)Math.Max(-30.0f, -DttSP.CalculateTXMeter(1, DttSP.MeterType.MIC_PK));
                                else num = (float)Math.Max(-30.0f, -DttSP.CalculateTXMeter(1, DttSP.MeterType.MIC) + 3.0f);
                                //output = num.ToString("f1")+" dB ";
                                lastmic = new_meter_data = num;
                                break;
                            case MeterTXMode.EQ:
                                if (peak_tx_meter) num = (float)Math.Max(-30.0f, -DttSP.CalculateTXMeter(1, DttSP.MeterType.EQ_PK));
                                else num = (float)Math.Max(-30.0f, -DttSP.CalculateTXMeter(1, DttSP.MeterType.EQ) + 3.0f);
                                //output = num.ToString("f1")+" dB ";
                                lasteq = new_meter_data = num;
                                break;
                            case MeterTXMode.LEVELER:
                                if (peak_tx_meter) num = (float)Math.Max(-30.0f, -DttSP.CalculateTXMeter(1, DttSP.MeterType.LEVELER_PK));
                                else num = (float)Math.Max(-30.0f, -DttSP.CalculateTXMeter(1, DttSP.MeterType.LEVELER) + 3.0f);
                                //output = num.ToString("f1")+" dB ";
                                new_meter_data = num;
                                break;
                            case MeterTXMode.LVL_G:
                                num = (float)Math.Max(0, DttSP.CalculateTXMeter(1, DttSP.MeterType.LVL_G));
                                //output = num.ToString("f1")+" dB ";
                                new_meter_data = num;
                                break;
                            case MeterTXMode.CPDR:
                                if (peak_tx_meter) num = (float)Math.Max(-30.0f, -DttSP.CalculateTXMeter(1, DttSP.MeterType.CPDR_PK));
                                else num = (float)Math.Max(-30.0f, -DttSP.CalculateTXMeter(1, DttSP.MeterType.CPDR) + 3.0f);
                                //output = num.ToString("f1")+" dB ";
                                new_meter_data = num;
                                break;
                            case MeterTXMode.ALC:
                                if (peak_tx_meter) num = (float)Math.Max(-30.0f, -DttSP.CalculateTXMeter(1, DttSP.MeterType.ALC_PK));
                                else num = (float)Math.Max(-30.0f, -DttSP.CalculateTXMeter(1, DttSP.MeterType.ALC) + 3.0f);
                                //output = num.ToString("f1")+" dB ";
                                lastalc = new_meter_data = num;
                                break;
                            case MeterTXMode.ALC_G:
                                num = (float)Math.Max(0, -DttSP.CalculateTXMeter(1, DttSP.MeterType.ALC_G));
                                //output = num.ToString("f1")+" dB ";
                                new_meter_data = num;
                                break;
                            case MeterTXMode.FORWARD_POWER:
                                switch (current_model)
                                {
                                    case Model.SDR1000:
                                        if (pa_present && VFOAFreq < 30.0)
                                        {
                                            power = PAPower(pa_fwd_power);
                                            //output = power.ToString("f0")+" W";
                                            new_meter_data = (float)power;
                                        }
                                        else
                                        {
                                            num = (float)Math.Max(0.0, DttSP.CalculateTXMeter(1, DttSP.MeterType.PWR));
                                            num *= (float)((double)ptbPWR.Value * 0.01);
                                            //output = (num*1000).ToString("f0")+" mW";
                                            new_meter_data = num;
                                        }
                                        break;
                                    case Model.FLEX5000:
                                    case Model.FLEX3000:
                                        //output = ((double)pa_fwd_power/4096*2.5).ToString("f3")+" V";
                                        lastfwdpower = power = FWCPAPower(pa_fwd_power);
                                        //power = (double)pm.Watts;
                                        //output = power.ToString("f0")+" W";
                                        //  Debug.WriteLine("power " + power); // ke9ns test

                                        new_meter_data = (float)power;
                                        break;
                                    case Model.FLEX1500:
                                        num = (float)Math.Max(0.0, DttSP.CalculateTXMeter(1, DttSP.MeterType.PWR));
                                        num *= (float)(ptbPWR.Value);
                                        new_meter_data = num;
                                        break;
                                }
                                break;
                            case MeterTXMode.REVERSE_POWER:
                                switch (current_model)
                                {
                                    case Model.FLEX5000:
                                    case Model.FLEX3000:
                                        //output = ((double)pa_rev_power/4096*2.5).ToString("f3")+" V";
                                        lastrevpower = power = FWCPAPower(pa_rev_power) * swr_table[(int)tx_band];
                                        //output = power.ToString("f0")+" W";
                                        new_meter_data = (float)power;
                                        break;
                                    case Model.SDR1000:
                                        if (pa_present && VFOAFreq < 30.0)
                                            power = PAPower(pa_rev_power);
                                        else power = 0.0;
                                        //output = power.ToString("f0")+" W";
                                        new_meter_data = (float)power;
                                        break;
                                    default:
                                        power = 0.0;
                                        //output = power.ToString("f0")+" W";
                                        new_meter_data = (float)power;
                                        break;
                                }
                                break;
                            case MeterTXMode.SWR: // Meter 1 comes here only during TX
                                double swr = 0.0;
                                //	if(chkTUN.Checked)  //ke9ns remove to allow swr anytime AM or FM modes mostly
                                //	{
                                switch (current_model)
                                {
                                    case Model.FLEX5000:
                                    case Model.FLEX3000:
                                        swr = FWCSWR(pa_fwd_power, pa_rev_power);


                                        if (lastswr >= 19) // try 1 more time before displaying SWR
                                        {
                                            for (int q = 0; q < 5; q++) // ke9ns copy from .184 to .191
                                            {
                                                Thread.Sleep(10);
                                                swr = FWCSWR(pa_fwd_power, pa_rev_power);
                                                if (swr < 19) break;
                                            } // for loop

                                        } // if SWR >=19



                                        //output = swr.ToString("f1")+" : 1 ";	
                                        break;
                                    case Model.SDR1000:
                                        if (pa_present && VFOAFreq < 30.0)
                                            swr = SWR(pa_fwd_power, pa_rev_power);
                                        else swr = 1.0;
                                        //output = swr.ToString("f1")+" : 1 ";
                                        break;
                                }
                                //	}
                                //	else
                                //	{
                                //		//output = "in TUN only ";
                                //	}
                                new_meter_data = (float)swr;
                                break;


                            case MeterTXMode.OFF:
                                //output = "";
                                new_meter_data = -200.0f;
                                break;

                        } // mode

                        //-----------------------------------------------------------------------------------------------------------------------
                        // ke9ns add:  only do a TX meter 2nd function if RX2 or RX2 ON, but not when transmitting  and the setup TX meter2nd function is checked

                        MeterTXMode mode1 = CurrentMeterTX1Mode;
                        num = 0f;
                        power = 0.0;

                        // ke9ns: only here on TX

                        if ((setupForm.chkRX2AutoMuteRX2OnVFOATX.Checked == true) && (TXMeter2 == true)) // ke9ns allow TX 2nd meter if option selected and not in duplex mode
                        {
                            switch (mode1)
                            {
                                case MeterTXMode.MIC:
                                    if (peak_tx1_meter) num = (float)Math.Max(-30.0f, -DttSP.CalculateTXMeter(1, DttSP.MeterType.MIC_PK));
                                    else num = (float)Math.Max(-30.0f, -DttSP.CalculateTXMeter(1, DttSP.MeterType.MIC) + 3.0f);
                                    //output = num.ToString("f1")+" dB ";
                                    rx2_meter_new_data = num;
                                    break;
                                case MeterTXMode.EQ:
                                    if (peak_tx1_meter) num = (float)Math.Max(-30.0f, -DttSP.CalculateTXMeter(1, DttSP.MeterType.EQ_PK));
                                    else num = (float)Math.Max(-30.0f, -DttSP.CalculateTXMeter(1, DttSP.MeterType.EQ) + 3.0f);
                                    //output = num.ToString("f1")+" dB ";
                                    rx2_meter_new_data = num;
                                    break;
                                case MeterTXMode.LEVELER:
                                    if (peak_tx1_meter) num = (float)Math.Max(-30.0f, -DttSP.CalculateTXMeter(1, DttSP.MeterType.LEVELER_PK));
                                    else num = (float)Math.Max(-30.0f, -DttSP.CalculateTXMeter(1, DttSP.MeterType.LEVELER) + 3.0f);
                                    //output = num.ToString("f1")+" dB ";
                                    rx2_meter_new_data = num;
                                    break;
                                case MeterTXMode.LVL_G:
                                    num = (float)Math.Max(0, DttSP.CalculateTXMeter(1, DttSP.MeterType.LVL_G));
                                    //output = num.ToString("f1")+" dB ";
                                    rx2_meter_new_data = num;
                                    break;
                                case MeterTXMode.CPDR:
                                    if (peak_tx1_meter) num = (float)Math.Max(-30.0f, -DttSP.CalculateTXMeter(1, DttSP.MeterType.CPDR_PK));
                                    else num = (float)Math.Max(-30.0f, -DttSP.CalculateTXMeter(1, DttSP.MeterType.CPDR) + 3.0f);
                                    //output = num.ToString("f1")+" dB ";
                                    rx2_meter_new_data = num;
                                    break;
                                case MeterTXMode.ALC:
                                    if (peak_tx1_meter) num = (float)Math.Max(-30.0f, -DttSP.CalculateTXMeter(1, DttSP.MeterType.ALC_PK));
                                    else num = (float)Math.Max(-30.0f, -DttSP.CalculateTXMeter(1, DttSP.MeterType.ALC) + 3.0f);
                                    //output = num.ToString("f1")+" dB ";
                                    rx2_meter_new_data = num;
                                    break;
                                case MeterTXMode.ALC_G:
                                    num = (float)Math.Max(0, -DttSP.CalculateTXMeter(1, DttSP.MeterType.ALC_G));
                                    //output = num.ToString("f1")+" dB ";
                                    rx2_meter_new_data = num;
                                    break;
                                case MeterTXMode.FORWARD_POWER:
                                    switch (current_model)
                                    {
                                        case Model.SDR1000:
                                            if (pa_present && VFOAFreq < 30.0)
                                            {
                                                power = PAPower(pa_fwd_power);
                                                //output = power.ToString("f0")+" W";
                                                rx2_meter_new_data = (float)power;
                                            }
                                            else
                                            {
                                                num = (float)Math.Max(0.0, DttSP.CalculateTXMeter(1, DttSP.MeterType.PWR));
                                                num *= (float)((double)ptbPWR.Value * 0.01);
                                                //output = (num*1000).ToString("f0")+" mW";
                                                rx2_meter_new_data = num;
                                            }
                                            break;

                                        case Model.FLEX5000:
                                        case Model.FLEX3000:
                                            //output = ((double)pa_fwd_power/4096*2.5).ToString("f3")+" V";
                                            power = FWCPAPower(pa_fwd_power);
                                            //power = (double)pm.Watts;
                                            //output = power.ToString("f0")+" W";
                                            //  Debug.WriteLine("power " + power); // ke9ns test

                                            rx2_meter_new_data = (float)power;
                                            break;
                                        case Model.FLEX1500:
                                            num = (float)Math.Max(0.0, DttSP.CalculateTXMeter(1, DttSP.MeterType.PWR));
                                            num *= (float)(ptbPWR.Value);
                                            rx2_meter_new_data = num;
                                            break;
                                    }
                                    break;
                                case MeterTXMode.REVERSE_POWER:
                                    switch (current_model)
                                    {
                                        case Model.FLEX5000:
                                        case Model.FLEX3000:
                                            //output = ((double)pa_rev_power/4096*2.5).ToString("f3")+" V";
                                            power = FWCPAPower(pa_rev_power) * swr_table[(int)tx_band];
                                            //output = power.ToString("f0")+" W";
                                            rx2_meter_new_data = (float)power;
                                            break;
                                        case Model.SDR1000:
                                            if (pa_present && VFOAFreq < 30.0)
                                                power = PAPower(pa_rev_power);
                                            else power = 0.0;
                                            //output = power.ToString("f0")+" W";
                                            rx2_meter_new_data = (float)power;
                                            break;
                                        default:
                                            power = 0.0;
                                            //output = power.ToString("f0")+" W";
                                            rx2_meter_new_data = (float)power;
                                            break;
                                    }
                                    break;
                                case MeterTXMode.SWR: // ke9ns: swr for 2nd TX meter if not using RX2
                                    double swr = 0.0;
                                    //  if (chkTUN.Checked) // ke9ns removed to allow SWR during AM or FM modes as well as tune
                                    // {
                                    switch (current_model)
                                    {
                                        case Model.FLEX5000:
                                        case Model.FLEX3000:
                                            swr = FWCSWR(pa_fwd_power, pa_rev_power);


                                            if (lastswr >= 19) // try 1 more time before displaying SWR
                                            {
                                                for (int q = 0; q < 5; q++) // ke9ns copy from .184 to .191
                                                {
                                                    Thread.Sleep(10);
                                                    swr = FWCSWR(pa_fwd_power, pa_rev_power);
                                                    if (swr < 19) break;
                                                } // for loop

                                            } // if SWR >=19




                                            //output = swr.ToString("f1")+" : 1 ";	
                                            break;
                                        case Model.SDR1000:
                                            if (pa_present && VFOAFreq < 30.0)
                                                swr = SWR(pa_fwd_power, pa_rev_power);
                                            else swr = 1.0;
                                            //output = swr.ToString("f1")+" : 1 ";
                                            break;
                                    }
                                    //  }
                                    // else
                                    //  {
                                    //output = "in TUN only ";
                                    //  }
                                    rx2_meter_new_data = (float)swr;
                                    break;

                                case MeterTXMode.Combo: // ke9ns 2nd tx meter 
                                    //combo meter
                                    // fwd power, swr, alc, mic

                                    //-----------------------------------------------
                                    // PWR
                                    switch (current_model)
                                    {

                                        case Model.FLEX5000:
                                        case Model.FLEX3000:

                                            power = FWCPAPower(pa_fwd_power);

                                            tx2_meter_new_data_pwr = num = (float)power;
                                            break;
                                        case Model.FLEX1500:
                                            num = (float)Math.Max(0.0, DttSP.CalculateTXMeter(1, DttSP.MeterType.PWR));
                                            num *= (float)(ptbPWR.Value);
                                            tx2_meter_new_data_pwr = num;
                                            break;
                                    }


                                    if (tx2_meter_peak_pwr == Display.CLEAR_FLAG) tx2_meter_peak_pwr = num;


                                    if (tx2_meter_peak_pwr < num) // new value larger than before
                                    {
                                        tx2_meter_peak_pwr = num; // new peak value
                                        tx2_meter_peak5_pwr = 0;
                                    }
                                    else // new value smaller than before
                                    {
                                        if (tx2_meter_peak5_pwr == 20)
                                        {
                                            // Debug.WriteLine("Peak5 " + tx2_meter_peak_pwr);
                                            if (tx2_meter_peak_pwr > num)
                                            {
                                                tx2_meter_peak_pwr = tx2_meter_peak_pwr - 1; // reduce peak slowly
                                            }
                                            else
                                            {
                                                tx2_meter_peak5_pwr = 0; // once the peak moves back down to the current value, reset the counter
                                            }
                                        }
                                        else tx2_meter_peak5_pwr++;
                                        // Debug.WriteLine("peak5 " + tx2_meter_peak5_pwr);


                                    }



                                    // ke9nsswr  combo meter UpdateMultimeter()
                                    //-----------------------------------------------
                                    // SWR // this is in TX mode
                                    swr = 0.0;

                                    switch (current_model)
                                    {
                                        case Model.FLEX5000:
                                        case Model.FLEX3000:
                                            swr = FWCSWR(pa_fwd_power, pa_rev_power);
                                            if (swr >= 19) // try 1 more time before displaying SWR
                                            {
                                                for (int q = 0; q < 5; q++) // ke9ns copy from .184 to .191
                                                {
                                                    Thread.Sleep(10);
                                                    swr = FWCSWR(pa_fwd_power, pa_rev_power);
                                                    if (swr < 19) break;
                                                } // for loop

                                            } // if SWR >=19
                                            break;

                                    }
                                    if (swr < 1.0 && swr > -1.0) swr = 1; // to prevent -swr numbers 


                                    tx2_meter_new_data_swr = num = (float)swr; // // .0001 dead key with no power

                                    if (tx2_meter_peak_swr == Display.CLEAR_FLAG) tx2_meter_peak_swr = num;

                                    if (tx2_meter_peak_swr < num) // new value larger than before
                                    {
                                        tx2_meter_peak_swr = num; // new peak value
                                        tx2_meter_peak5_swr = 0;
                                    }
                                    else // new value smaller than before
                                    {
                                        if (tx2_meter_peak5_swr == 20)
                                        {

                                            if (tx2_meter_peak_swr > num) tx2_meter_peak_swr = tx2_meter_peak_swr - 0.1f;
                                            else tx2_meter_peak5_swr = 0;
                                        }
                                        else tx2_meter_peak5_swr++;


                                    }

                                    //  Debug.WriteLine("SWR COMBO " + swr + " , " + tx2_meter_peak_swr); 

                                    //-----------------------------------------------
                                    // ALC

                                    if (peak_tx1_meter) num = (float)Math.Max(-30.0f, -DttSP.CalculateTXMeter(1, DttSP.MeterType.ALC_PK));
                                    else num = (float)Math.Max(-30.0f, -DttSP.CalculateTXMeter(1, DttSP.MeterType.ALC) + 3.0f);
                                    tx2_meter_new_data_alc = num;

                                    // this is if you want ALC Gain instead
                                    // num = (float)Math.Max(0, -DttSP.CalculateTXMeter(1, DttSP.MeterType.ALC_G));
                                    //  tx2_meter_new_data_alcG = num;


                                    if (tx2_meter_peak_alc == Display.CLEAR_FLAG) tx2_meter_peak_alc = num;

                                    if (tx2_meter_peak_alc < num) // new value larger than before
                                    {
                                        tx2_meter_peak_alc = num; // new peak value
                                        tx2_meter_peak5_alc = 0;
                                    }
                                    else // new value smaller than before
                                    {
                                        if (tx2_meter_peak5_alc == 20)
                                        {

                                            if (tx2_meter_peak_alc > num) tx2_meter_peak_alc = tx2_meter_peak_alc - 1;
                                            else tx2_meter_peak5_alc = 0;
                                        }
                                        else tx2_meter_peak5_alc++;


                                    }



                                    //-----------------------------------------------
                                    // MIC
                                    if (peak_tx1_meter) num = (float)Math.Max(-30.0f, -DttSP.CalculateTXMeter(1, DttSP.MeterType.MIC_PK));
                                    else num = (float)Math.Max(-30.0f, -DttSP.CalculateTXMeter(1, DttSP.MeterType.MIC) + 3.0f);

                                    tx2_meter_new_data_mic = num;

                                    if (tx2_meter_peak_mic == Display.CLEAR_FLAG) tx2_meter_peak_mic = num;

                                    if (tx2_meter_peak_mic < num) // new value larger than before
                                    {
                                        tx2_meter_peak_mic = num; // new peak value
                                        tx2_meter_peak5_mic = 0;
                                    }
                                    else // new value smaller than before
                                    {
                                        if (tx2_meter_peak5_mic == 20)
                                        {

                                            if (tx2_meter_peak_mic > num) tx2_meter_peak_mic = tx2_meter_peak_mic - 1;
                                            else tx2_meter_peak5_mic = 0;
                                        }
                                        else tx2_meter_peak5_mic++;

                                    }

                                    break;   // MeterTXMode.Combo (above)

                                case MeterTXMode.OFF:
                                    //output = "";
                                    rx2_meter_new_data = -200.0f;
                                    break;

                            } // mode1

                            rx2_meter_data_ready = true;

                            if (meterCombo == true) picRX3Meter.Invalidate(); // ke9ns12 add
                            else picRX2Meter.Invalidate(); // ke9ns12 add

                            //  picRX2Meter.Invalidate(); // ke9ns12 add

                        } // TXMeter2


                    } // TX MOX


                    meter_data_ready = true;
                    picMultiMeterDigital.Invalidate();




                } // meterdataready			

                //end:
                if (chkPower.Checked) Thread.Sleep(Math.Min(meter_delay, meter_dig_delay));
            } //

        } //updateMultimeter


        //===============================================================================
        //===============================================================================
        // ke9ns   RX2 this is where you update the meter signal that will be given to the draw routine up above
        //         added the peak meter signal below
        //===============================================================================
        //===============================================================================


        private HiPerfTimer rx2_meter_timer = new HiPerfTimer();
        private float rx2_meter_avg = Display.CLEAR_FLAG;
        private float rx2_meter_peak = Display.CLEAR_FLAG; // ke9ns ADD
        private int peak4 = 0; // ke9ns ADD RX1 peak hold routine
        private int peak5 = 0; // ke9ns ADD RX2 peak hold routine


        private void UpdateRX2MeterData()
        {
            rx2_meter_timer.Start();

            while (chkPower.Checked && fwc_init && (current_model == Model.FLEX5000 && rx2_enabled))
            {


                if ((setupForm.chkRX2AutoMuteRX2OnVFOATX.Checked == false) || (TXMeter2 == false) || ((TXMeter2 == true) && (!MOX))) // ke9ns do RX2 if in duplex mode and not in special 2nd TX meter mode
                {

                    if (!rx2_meter_data_ready)
                    {
                        /*if(Audio.CurrentAudioState1 != Audio.AudioState.DTTSP)
                            goto end;*/

                        MeterRXMode mode = RX2MeterMode;
                        float num = 0f;
                        float peak3 = 0f; // ke9ns ADD RX2 temp storage for peak routine

                        switch (mode)
                        {
                            case MeterRXMode.SIGNAL_STRENGTH:
                                num = DttSP.CalculateRXMeter(2, 0, DttSP.MeterType.SIGNAL_STRENGTH);

                                //   Debug.WriteLine("RX2: num: " + num.ToString("f1") + "  meter: " + rx2_meter_cal_offset.ToString("f1") +
                                //                      "  preamp: " + rx2_preamp_offset[(int)rx2_preamp_mode].ToString("f1") + "  filter: " + rx2_filter_size_cal_offset.ToString("f1") +
                                //                     "  path: " + rx2_path_offset.ToString("f1") + "  xvtr: " + rx2_xvtr_gain_offset.ToString("f1") +
                                //                    "  loop: " + rx2_loop_offset.ToString("f1"));			

                                num = num +
                                    rx2_meter_cal_offset +
                                    rx2_preamp_offset[(int)rx2_preamp_mode] +
                                    rx2_filter_size_cal_offset +
                                    rx2_path_offset +
                                    rx2_xvtr_gain_offset +
                                    rx2_loop_offset;
                                //output = num.ToString("f1")+" dBm";
                                rx2_meter_new_data = num;
                                break; // signal

                            case MeterRXMode.SIGNAL_AVERAGE:

                                num = DttSP.CalculateRXMeter(2, 0, DttSP.MeterType.SIGNAL_STRENGTH);
                                if (rx2_meter_avg == Display.CLEAR_FLAG) rx2_meter_avg = num;

                                num = multimeter_avg_mult_old * rx2_meter_avg + multimeter_avg_mult_new * num;  // new = (.9 * last) + (.1 * new)

                                rx2_meter_avg = num;

                                num = num +
                                    rx2_meter_cal_offset +
                                    rx2_preamp_offset[(int)rx2_preamp_mode] +
                                    rx2_filter_size_cal_offset +
                                    rx2_path_offset +
                                    rx2_xvtr_gain_offset +
                                    rx2_loop_offset;

                                //output = num.ToString("f1")+" dBm";
                                rx2_meter_new_data = num;
                                break; // average


                            case MeterRXMode.SIGNAL_PEAK:       // ke9ns ADD RX2 peak

                                peak3 = num = DttSP.CalculateRXMeter(2, 0, DttSP.MeterType.SIGNAL_STRENGTH);

                                if (rx2_meter_peak == Display.CLEAR_FLAG) rx2_meter_peak = num;


                                if (rx2_meter_peak < num) // new value larger than before
                                {
                                    rx2_meter_peak = num; // new peak value
                                    peak5 = 0;
                                }
                                else // new value smaller than before
                                {
                                    if (peak5 == 20)
                                    {
                                        //  Debug.WriteLine("peak5 " + rx2_meter_peak);
                                        if (rx2_meter_peak > num) rx2_meter_peak = rx2_meter_peak - 1;
                                        else peak5 = 0;
                                    }
                                    else peak5++;
                                    //   Debug.WriteLine("peak5 " +peak5);


                                }

                                //=======================
                                num = peak3; // this is standard needle (below is peak)

                                num = num +
                                     rx2_meter_cal_offset +
                                     rx2_preamp_offset[(int)rx2_preamp_mode] +
                                     rx2_filter_size_cal_offset +
                                     rx2_path_offset +
                                     rx2_xvtr_gain_offset +
                                     rx2_loop_offset;

                                rx2_meter_new_data = num;


                                //=======================
                                num = rx2_meter_peak;           // peak needle and numbers
                                num = num +
                                       rx2_meter_cal_offset +
                                       rx2_preamp_offset[(int)rx2_preamp_mode] +
                                       rx2_filter_size_cal_offset +
                                       rx2_path_offset +
                                       rx2_xvtr_gain_offset +
                                       rx2_loop_offset;

                                rx2_meter_peak_value = num;

                                break; // peak


                            case MeterRXMode.ADC_L:
                                num = DttSP.CalculateRXMeter(0, 0, DttSP.MeterType.ADC_REAL);
                                //output = num.ToString("f1")+" dBFS ";
                                rx2_meter_new_data = num;
                                break;
                            case MeterRXMode.ADC_R:
                                num = DttSP.CalculateRXMeter(0, 0, DttSP.MeterType.ADC_IMAG);
                                //output = num.ToString("f1")+" dBFS ";
                                rx2_meter_new_data = num;
                                break;
                            case MeterRXMode.ADC2_L:
                                num = DttSP.CalculateRXMeter(2, 0, DttSP.MeterType.ADC_REAL);
                                //output = num.ToString("f1")+" dBFS ";
                                rx2_meter_new_data = num;
                                break;
                            case MeterRXMode.ADC2_R:
                                num = DttSP.CalculateRXMeter(2, 0, DttSP.MeterType.ADC_IMAG);
                                //output = num.ToString("f1")+" dBFS ";
                                rx2_meter_new_data = num;
                                break;
                            case MeterRXMode.OFF:
                                //output = "";
                                rx2_meter_new_data = -200.0f;
                                break;
                        }
                        rx2_meter_data_ready = true;

                        //    Debug.Write(" 333 ");

                        if (meterCombo == true) picRX3Meter.Invalidate(); // ke9ns12 add
                        else picRX2Meter.Invalidate(); // ke9ns12 add

                        //  picRX2Meter.Invalidate(); // ke9ns12 add

                    } // !rx2meterdataready			
                } // !mox
                  //end:
                if (chkPower.Checked) Thread.Sleep(Math.Min(meter_delay, meter_dig_delay));


            } //while rx2 UPDATE



        } //updaterx2meter

        //==========================================================================================

        private float sql_data = -200.0f;
        private void UpdateSQL()
        {
            while (chkPower.Checked)
            {
                if (!mox)
                {

                    float num = DttSP.CalculateRXMeter(0, 0, DttSP.MeterType.SIGNAL_STRENGTH);
                    if (fwc_init && (current_model == Model.FLEX5000 || current_model == Model.FLEX3000))
                    {
                        num = num +
                            rx1_meter_cal_offset +
                            rx1_preamp_offset[(int)rx1_preamp_mode] +
                            rx1_filter_size_cal_offset +
                            rx1_path_offset +           // ke9ns mod: was the end
                             rx1_xvtr_gain_offset +   // added this
                              rx1_loop_offset;        // added this so its the same as the meters
                    }
                    else if (hid_init && current_model == Model.FLEX1500)
                    {
                        num = num +
                            rx1_meter_cal_offset +
                            rx1_preamp_offset[(int)rx1_preamp_mode] +
                            rx1_filter_size_cal_offset +  // ke9ns mod was the end
                        rx1_xvtr_gain_offset; // added this 
                    }
                    else
                    {
                        num = num +
                            rx1_meter_cal_offset +
                            rx1_preamp_offset[(int)rx1_preamp_mode] +
                            rx1_filter_size_cal_offset;
                    }

                    sql_data = num;
                    picSquelch.Invalidate();

                    // ke9ns add: to allow squelch break for scanner
                    //dsp.GetDSPRX(0, 0).FMSquelchThreshold = (float)Math.Pow(10.0, -2 * ptbSquelch.Value / 100.0);
                    // FM squelch is different from normal squelch
                    if (RX1DSPMode == DSPMode.FM)
                    {

                        int sql_x = (int)(((float)ptbSquelch.Value + 160.0) * (picSquelch.Width - 1) / 160.0);

                        ScanControl.SQL = (int)ptbSquelch.Value; // SQL slider value
                        ScanControl.SIG = (int)sql_data;  // -96


                        bool Squelch; // true = squelch, false = break

                        DttSP.GetFMSquelchBreak(0, 0, &Squelch);  // ke9ns add: see update.c (detects the real FM sql break)

                        if (Squelch == false)
                        {
                            ScanControl.ScanStop = 1; // ke9ns add for scanner function in FM mode 1=STOP
                                                      //  Debug.WriteLine("BREAK");

                        }

                        //   Debug.WriteLine("SQLFM MODE (squelch data, squelch setpoint) " + sql_data + " , " + sql_x);

                    }

                } // !mox

                if (chkPower.Checked) Thread.Sleep(100);
            }
        } // UpdateSQL()

        private float rx2_sql_data = -200.0f;
        private void UpdateRX2SQL()
        {
            while (chkPower.Checked && rx2_enabled)
            {
                float num = DttSP.CalculateRXMeter(2, 0, DttSP.MeterType.SIGNAL_STRENGTH); //was 2,0

                //  Debug.WriteLine("SQL Read: "+num.ToString("f1"));

                num = num + rx2_meter_cal_offset + rx2_preamp_offset[(int)rx2_preamp_mode] + rx2_filter_size_cal_offset + rx2_path_offset;

                rx2_sql_data = num;
                picRX2Squelch.Invalidate();

                // ke9ns add: to allow squelch break for scanner
                //dsp.GetDSPRX(0, 0).FMSquelchThreshold = (float)Math.Pow(10.0, -2 * ptbSquelch.Value / 100.0);
                // FM squelch is different from normal squelch
                if (RX2DSPMode == DSPMode.FM) //.244 for scanner routine
                {

                    int sql_x = (int)(((float)ptbRX2Squelch.Value + 160.0) * (picRX2Squelch.Width - 1) / 160.0);

                    ScanControl.SQL2 = (int)ptbRX2Squelch.Value; // SQL slider value
                    ScanControl.SIG2 = (int)rx2_sql_data;  // -96


                    bool Squelch; // true = squelch, false = break

                    DttSP.GetFMSquelchBreak(2, 0, &Squelch);  // ke9ns add: see update.c (detects the real FM sql break)

                    if (Squelch == false)
                    {
                        ScanControl.ScanStop2 = 1; // ke9ns add for scanner function in FM mode 1=STOP
                                                   //   Debug.WriteLine("BREAK2");

                    }

                    //  Debug.WriteLine("SQLFM2 MODE (squelch data, squelch setpoint) " + rx2_sql_data + " , " + sql_x +  " , " + Squelch);

                } //if (RX2DSPMode == DSPMode.FM)


                if (chkPower.Checked && rx2_enabled) Thread.Sleep(100);
            }


        } // UpdateRX2SQL()

        private float noise_gate_data = -200.0f;
        private void UpdateNoiseGate()
        {
            while (chkPower.Checked)
            {
                if (mox)
                {
                    float num = -DttSP.CalculateTXMeter(1, DttSP.MeterType.MIC);

                    noise_gate_data = num + 3.0f;
                    picNoiseGate.Invalidate();
                }

                if (chkPower.Checked) Thread.Sleep(100);
            }
        }

        private void UpdateVOX()
        {
            while (chkPower.Checked)
            {
                switch (rx1_dsp_mode)
                {
                    case DSPMode.LSB:
                    case DSPMode.USB:
                    case DSPMode.DSB:
                    case DSPMode.AM:
                    case DSPMode.SAM:
                    case DSPMode.FM:
                        picVOX.Invalidate();
                        break;

                    // ke9ns add to update VOX level on screen
                    case DSPMode.DIGU:
                    case DSPMode.DIGL:
                        pictureBoxVOX.Invalidate();
                        break;
                }

                if (chkPower.Checked) Thread.Sleep(100);
            }
        }

        //=======================================================================================
        // ke9ns RX ONLY thread (to allow PTT to STOP powerSDR while in RX only mode
        private void PollRXOnly()
        {
            bool doOnce = false;

            while ((rx_only)) // ke9ns do only below if not in manual mox mode, and PTT is not disabled, and not just in RX mode
            {

                if (fwc_init && (current_model == Model.FLEX5000 || current_model == Model.FLEX3000))
                {
                    if ((fwc_rca_ptt == true)) // || (fwc_mic_ptt == true))
                    {
                        if (chkPower.Checked == true) doOnce = true; // if PSDR was in START,then set flag
                        chkPower.Checked = false; // STOP PSDR

                    }
                    else // Release PTT
                    {
                        if (doOnce == true) // if PSDR was running, but now stopped due to a PTT event, then ...
                        {
                            chkPower.Checked = true; // restart PSDR
                            doOnce = false; // reset flag
                        }
                    }

                }
                else if (hid_init && current_model == Model.FLEX1500)
                {
                    if ((hid_ptt_in == true) || (hid_mic_ptt == true)) // ke9ns 1500 only hase the Mic_PTT
                    {
                        if (chkPower.Checked == true) doOnce = true; // if PSDR was in START,then set flag
                        chkPower.Checked = false; // STOP PSDR
                    }
                    else // Release PTT
                    {
                        if (doOnce == true) // if PSDR was running, but now stopped due to a PTT event, then ...
                        {
                            chkPower.Checked = true; // restart PSDR
                            doOnce = false; // reset flag
                        }
                    }
                }

                Thread.Sleep(5);

            } // if ((rx_only))

        } // PollRXONLY()

        //=======================================================================================
        // ke9ns PTT thread

        DSPMode AMSSBmodeAM = DSPMode.FIRST; // ke9ns add  this is the mode you were in before AMSSBmodemodeON = true
        DSPMode AMSSBmodeSSB = DSPMode.FIRST; // ke9ns add
        bool AMSSBmodeON = false; // ke9ns add false = not in alternate mode, true = you moved the low or high RX filter so you are in an alternate SSB mode from AM
        bool AMSSBmodeFILT = false; // ke9ns add  false at start of setRX1Mode, true = end of setRX1 filter

        private bool mon_recall = false;
        private byte mon2_recall = 0; // ke9ns to hold mon_pre for going into out of CW mode

        private static HiPerfTimer vox_timer = new HiPerfTimer();
        private static HiPerfTimer pttht_timer = new HiPerfTimer(); // ke9ns add for PTT hang time (for PTT, MIC, CAT)

        private void PollPTT()
        {
            //HiPerfTimer cwpolltimer = new HiPerfTimer();
            //cwpolltimer.Start();

            /*HiPerfTimer polltimer = new HiPerfTimer();
            polltimer.Start();
            double msecs = 0.0;
            int pollcount = 0;*/

            while (chkPower.Checked)
            {

                if (chkVFOSplit.Checked == true)
                {
                    if ((SplitModeRX != SplitModeTX)) // only change DSP modes if you set them up differently by changing modes while in TX mode
                    {
                        if (!MOX) // RX
                        {
                            if (rx1_dsp_mode != SplitModeRX)
                            {
                                //  Debug.WriteLine("PTT RX HERE");
                                if (SplitModeRX == DSPMode.LSB) radModeLSB.Checked = true;
                                else if (SplitModeRX == DSPMode.USB) radModeUSB.Checked = true;

                                else if (SplitModeRX == DSPMode.DIGU) radModeDIGU.Checked = true;
                                else if (SplitModeRX == DSPMode.DIGL) radModeDIGL.Checked = true;


                                //  Debug.WriteLine("PTT RX HERE DONE");
                                // SetRX1Mode(SplitModeRX);

                            }

                        }
                        else // TX
                        {
                            if (rx1_dsp_mode != SplitModeTX)
                            {
                                //  Debug.WriteLine("PTT TX HERE");
                                if (SplitModeTX == DSPMode.LSB) radModeLSB.Checked = true;
                                else if (SplitModeTX == DSPMode.USB) radModeUSB.Checked = true;

                                else if (SplitModeTX == DSPMode.DIGU) radModeDIGU.Checked = true;
                                else if (SplitModeTX == DSPMode.DIGL) radModeDIGL.Checked = true;

                                //  Debug.WriteLine("PTT TX HERE DONE");
                                // SetRX1Mode(SplitModeTX);

                            }
                        }

                    }

                }

                //---------------------------------------------------------------------------------
                // ke9ns add  allows you to use SSB for RX, while AM for TX
                if (!MOX) // if in RX mode
                {
                    if ((AMSSBmodeON == false) && (AMSSBmodeFILT == true) && ((rx1_dsp_mode == DSPMode.AM) || (rx1_dsp_mode == DSPMode.SAM))) // and in AM mode
                    {

                        if ((udFilterLow.Value >= 20) && (udFilterHigh.Value >= 500)) // and the filter is shifted into USB  mode
                        {
                            if (AMSSBmodeON == false)  // do only 1 time
                            {
                                AMSSBmodeON = true;
                                AMSSBmodeAM = rx1_dsp_mode; // save original mode (to go back to during TX)
                                Debug.WriteLine("TO uuu MODE");
                                SetRX1Mode(DSPMode.USB);
                                AMSSBmodeSSB = DSPMode.USB;
                                Debug.WriteLine("TO UUU MODE");

                            }
                        } //shifted to Right side
                        else if ((udFilterLow.Value <= -500) && (udFilterHigh.Value <= 20)) // and the filter is shifted into LSB mode
                        {
                            if (AMSSBmodeON == false)  // do only 1 time
                            {
                                AMSSBmodeON = true;
                                AMSSBmodeAM = rx1_dsp_mode; // save original mode (to go back to during TX)
                                SetRX1Mode(DSPMode.LSB);
                                AMSSBmodeSSB = DSPMode.LSB;

                                Debug.WriteLine("TO LLL MODE");

                            }
                        } //shifted to Left side


                    } // AM or SAM mode only above
                    else if ((AMSSBmodeON == true) && (AMSSBmodeFILT == true) && ((rx1_dsp_mode == DSPMode.USB) || (rx1_dsp_mode == DSPMode.LSB))) // if now in SSB mode (but you were in AM)
                    {

                        if (((udFilterLow.Value <= -10) && (udFilterHigh.Value >= 10))) // back in AM mode
                        {
                            if (AMSSBmodeON == true)
                            {
                                SetRX1Mode(AMSSBmodeAM);
                                AMSSBmodeON = false;
                                Debug.WriteLine("TO AAA MODE");

                            }
                        }

                    } // AMSSBmodeAM = true

                } // !MOX




                //----------------------------------------------------------------------------
                // ke9ns allows you to use SSB for RX while TX = AM mode
                if (AMSSBmodeON == true)
                {
                    if ((!MOX)) // RX mode
                    {
                        if (rx1_dsp_mode == AMSSBmodeAM)
                        {
                            SetRX1Mode(AMSSBmodeSSB); //SSB
                            Debug.WriteLine("TO SSB MODE");
                        }
                    }
                    else if ((MOX)) // TX mode
                    {
                        if (rx1_dsp_mode == AMSSBmodeSSB)
                        {
                            SetRX1Mode(AMSSBmodeAM);               //put back original AM mode while transmitting
                            Debug.WriteLine("TO AM MODE");
                        }
                    }
                }
                //----------------------------------------------------------------------------


                DSPMode tx_mode = rx1_dsp_mode;

                if (chkVFOBTX.Checked && chkRX2.Checked) tx_mode = rx2_dsp_mode;

                /*// reset the CW ring buffers every 5000ms when not in use
                if(current_ptt_mode != PTTMode.NONE)
                {
                    switch(tx_mode)
                    {
                        case DSPMode.CWL:
                        case DSPMode.CWU:
                            cwpolltimer.Start(); // start over since key is in use
                            break;
                    }
                }
                else
                {
                    switch(tx_mode)
                    {
                        case DSPMode.CWL:
                        case DSPMode.CWU: mic_ptt = fwc_mic_ptt;
                            cwpolltimer.Stop(); // check how long since last reset
                            if(cwpolltimer.DurationMsec > 5000 + break_in_delay && !mox)
                            {
                                // if more than 5 sec + break in delay, reset timer and ring buffer
                                cwpolltimer.Start();
                                DttSP.CWRingRestart();
                            }
                            break;
                    }
                }*/



                if ((!manual_mox) && (!disable_ptt) && (!rx_only)) // ke9ns do only below if not in manual mox mode, and PTT is not disabled, and not just in RX mode
                {
                    bool mic_ptt = false, x2_ptt = false, cat_ptt_local = false, vox_ptt = false; // ke9ns various forms of external PTT operation: MIC, back of Flex, CAT, or VOX

                    if (fwc_init && (current_model == Model.FLEX5000 || current_model == Model.FLEX3000))
                    {
                        mic_ptt = fwc_mic_ptt;
                        x2_ptt = fwc_rca_ptt;
                        vox_ptt = Audio.VOXActive;
                        cat_ptt_local = (ptt_bit_bang_enabled && serialPTT != null && serialPTT.isPTT()) | cat_ptt;


                    }
                    else if (hid_init && current_model == Model.FLEX1500)
                    {
                        mic_ptt = hid_mic_ptt;
                        x2_ptt = hid_ptt_in;
                        vox_ptt = Audio.VOXActive;
                        cat_ptt_local = (ptt_bit_bang_enabled && serialPTT != null && serialPTT.isPTT()) | cat_ptt;
                    }
                    else
                    {
                        byte b = 0;
                        //   if(current_model == Model.SDR1000)  b = Hdw.StatusPort();


                        mic_ptt = (b & (byte)StatusPin.Dot) != 0;
                        x2_ptt = (b & (byte)StatusPin.PIN_11) != 0;

                        if (usb_present) x2_ptt = !x2_ptt;

                        vox_ptt = Audio.VOXActive;

                        cat_ptt_local = (ptt_bit_bang_enabled && serialPTT != null && serialPTT.isPTT()) | cat_ptt;

                        if (auto_mute)
                        {
                            bool mute = !((b & (byte)StatusPin.PIN_12) != 0);
                            if (chkMUT.Checked != mute) chkMUT.Checked = mute;
                        }
                    }

                    /*Debug.WriteLine(cw_ptt.ToString().PadRight(6, ' ')+
                        mic_ptt.ToString().PadRight(6, ' ')+
                        x2_ptt.ToString().PadRight(6, ' ')+
                        vox_ptt.ToString().PadRight(6, ' ')+
                        cat_ptt_local.ToString().PadRight(6, ' ')+
                        current_ptt_mode.ToString());*/

                    if (mic_ptt || x2_ptt || cat_ptt_local || vox_ptt) // ke9ns add: repeat timer for CQCQ ANY PTT will kill playback
                    {

                        if (CQCQReplayON == true)
                        {
                            //  if (CQCQReplayPTT == false) Debug.WriteLine("======= PTT HERE");
                            CQCQReplayPTT = true;

                        }
                    }
                    else
                    {
                        qndr_release = true;

                        if (CQCQReplayPTT == true) // when you finally release PTT 
                        {
                            CQCQReplayON = false;
                            CQCQReplayPTT = false;
                            //   Debug.WriteLine("======= UNKEY HERE");
                            chkMOX.Checked = false;
                        }
                    }



                    if (!mox) // if in RX
                    {

                        //--------------------------------------RCA ptt
                        if (x2_ptt)
                        {
                            current_ptt_mode = PTTMode.X2;
                            switch (tx_mode)
                            {
                                case DSPMode.LSB:
                                case DSPMode.USB:
                                case DSPMode.DSB:
                                case DSPMode.AM:
                                case DSPMode.SAM:
                                case DSPMode.FM:
                                case DSPMode.DIGL:
                                case DSPMode.DIGU:
                                    if (chkVAC1.Checked && allow_vac_bypass) Audio.VACBypass = true; // ke9ns a PTT sets vac_bypass = true
                                    break;
                            }

                            chkMOX.Checked = true;
                            pttht_timer.Start(); // ke9ns add

                            if (!mox) // if in RX
                            {
                                chkPower.Checked = false;
                                return;
                            }
                        } // if(x2_ptt)


                        //--------------------------------------cat_ptt
                        if (cat_ptt_local)
                        {
                            current_ptt_mode = PTTMode.CAT;

                            chkMOX.Checked = true;
                            if (!mox)
                            {
                                chkPower.Checked = false;
                                return;
                            }
                        } //  if (cat_ptt_local)					


                        //----------------------------------------mic_ptt
                        if ((tx_mode == DSPMode.LSB ||
                            tx_mode == DSPMode.USB ||
                            tx_mode == DSPMode.DSB ||
                            tx_mode == DSPMode.AM ||
                            tx_mode == DSPMode.SAM ||
                            tx_mode == DSPMode.DIGU ||
                            tx_mode == DSPMode.DIGL ||
                            tx_mode == DSPMode.FM ||
                            all_mode_mic_ptt) &&
                            mic_ptt)
                        {
                            current_ptt_mode = PTTMode.MIC;

                            pttht_timer.Start(); // ke9ns add

                            if (chkVAC1.Checked && allow_vac_bypass)
                            {
                                Audio.VACBypass = true;
                            }

                            chkMOX.Checked = true;
                            if (!mox)
                            {
                                chkPower.Checked = false;
                                return;
                            }
                        }

                        //--------------------------------------vox_ptt
                        if ((tx_mode == DSPMode.LSB ||
                            tx_mode == DSPMode.USB ||
                            tx_mode == DSPMode.DSB ||
                            tx_mode == DSPMode.AM ||
                            tx_mode == DSPMode.SAM ||
                            tx_mode == DSPMode.DIGU ||
                            tx_mode == DSPMode.DIGL ||
                            tx_mode == DSPMode.FM) &&
                            vox_ptt)
                        {
                            current_ptt_mode = PTTMode.VOX;
                            vox_timer.Start();

                            chkMOX.Checked = true;
                            /*if(!mox)
                            {
                                chkPower.Checked = false;
                                return;=== unkey
                            }*/
                        }

                    } // if (!MOX)
                    else // else if(mox) in TX mode below
                    {
                        switch (current_ptt_mode)
                        {
                            case PTTMode.X2:
                                if (!x2_ptt)
                                {
                                    // ke9ns mod 
                                    pttht_timer.Stop(); // ke9ns: hang timer

                                    //  When Checked:  The PTT delays release for set period of Time(in milliseconds) for the MIC, Rear PTT, or CAT commands.
                                    //      MOX and VOX are unaffected.

                                    if (pttht_timer.DurationMsec > PTTHT)
                                    {

                                        Debug.WriteLine("======= UNKEY HERE " + qndr_mox + " , " + qndr_end + " , " + QuindarEnd + " , " + qndr_mox1 + " , " + qndr_vac1);


                                        if (quindar_end == false)
                                        {
                                            chkMOX.Checked = false; // normal operation: unkey radio when endtone is off

                                        }
                                        else
                                        {
                                            if (qndr_end == false) // && QuindarEnd == false && qndr_vac1 == true )
                                            {
                                                chkMOX.Checked = false; // ke9ns mod: .190 switch to RX (comes here when end tone is done)
                                                Debug.WriteLine("Quindar UNKEY QNDR");
                                                qndr_vac1 = false;
                                            }
                                            else
                                            {
                                                Debug.WriteLine("Quindar DONT UNKEY QNDR"); // dont unkey if doing a END quindar tone
                                            }

                                        }



                                        switch (tx_mode)
                                        {
                                            case DSPMode.LSB:
                                            case DSPMode.USB:
                                            case DSPMode.DSB:
                                            case DSPMode.AM:
                                            case DSPMode.SAM:
                                            case DSPMode.FM:
                                            case DSPMode.DIGL:
                                            case DSPMode.DIGU:
                                                if (chkVAC1.Checked && Audio.VACBypass)
                                                {
                                                    Audio.VACBypass = false;

                                                }
                                                break;
                                        }

                                    }
                                }
                                else pttht_timer.Start(); // // ke9ns mod 
                                break;
                            case PTTMode.CAT:
                                if (!cat_ptt_local)
                                {

                                    // ke9ns mod 
                                    pttht_timer.Stop();
                                    if (pttht_timer.DurationMsec > PTTHT)
                                    {
                                        if (qndr_end == false) chkMOX.Checked = false; // ke9ns mod: .190 dont unkey if doing a END quindar tone


                                    }

                                    //  chkMOX.Checked = false;  // ke9ns original code

                                    /*if((tx_mode == DSPMode.CWL ||
                                        tx_mode == DSPMode.CWU) &&
                                        !cw_disable_monitor)
                                        chkMON.Checked = mon_recall;*/


                                }
                                else pttht_timer.Start(); //  ke9ns mod 

                                break;
                            case PTTMode.MIC:
                                if (!mic_ptt)
                                {
                                    //  chkMOX.Checked = false;  // ke9ns original code
                                    //  if (chkVAC1.Checked && Audio.VACBypass)  Audio.VACBypass = false;

                                    // ke9ns mod 
                                    pttht_timer.Stop();
                                    if (pttht_timer.DurationMsec > PTTHT)
                                    {
                                        if (qndr_end == false) chkMOX.Checked = false; // ke9ns mod: .190 dont unkey if doing a END quindar tone

                                        if (chkVAC1.Checked && Audio.VACBypass) Audio.VACBypass = false;
                                    }

                                }
                                else pttht_timer.Start();  // ke9ns mod 

                                break;
                            case PTTMode.VOX:
                                if (!vox_ptt)
                                {
                                    vox_timer.Stop();
                                    if (vox_timer.DurationMsec > vox_hang_time)
                                    {
                                        if (qndr_end == false) chkMOX.Checked = false; // ke9ns mod: .190 dont unkey if doing a END quindar tone

                                    }
                                }
                                else vox_timer.Start();
                                break;
                        } // switch

                    } // we are in MOX (above)

                } // do above if PTT is allowed to TX radio


                Thread.Sleep(2);

                /*if (++pollcount == 1000) 
                {
                    polltimer.Stop();
                    msecs = polltimer.DurationMsec;
                    polltimer.Start();
                    msecs *= 0.001;
                    Debug.WriteLine("timer average = " +msecs.ToString());	
                    pollcount = 0;
                }*/


            } // while(chkPower.Checked)


            //			poll_ptt_running = false;



        } // pollPTT() thread



        private void PollFWCPAPWR()
        {


            if (!fwc_init || (current_model != Model.FLEX5000 && current_model != Model.FLEX3000) || !FWCEEPROM.PAOK) return;
            //int count = 0;
            int high_swr_count = 0;
            int fwd = 0, rev = 0/*, temp, volts*/;
            //float old_temp = 0.0f, old_supply = 0.0f;
            while (chkPower.Checked)
            {
                if (mox)
                {
                    if (!atu_tuning)
                    {
                        switch (current_model)
                        {
                            case Model.FLEX5000:
                                FWC.ReadPAADC(7, out fwd); // FLEX-5000
                                FWC.ReadPAADC(6, out rev); // FLEX-5000
                                break;
                            case Model.FLEX3000:
                                FWC.ReadPAADC(5, out fwd); // FLEX-3000
                                FWC.ReadPAADC(4, out rev); // FLEX-3000
                                break;
                        }
                    }

                    pa_fwd_power = fwd;
                    pa_rev_power = rev;

                    double swr_scale = SWRScale(FWCPAPower(rev) * swr_table[(int)tx_band]);

                    if (swr_scale < Audio.HighSWRScale)
                    {
                        high_swr_count++;
                        if (high_swr_count >= 3)
                        {
                            high_swr_count = 0;
                            HighSWR = true; // ke9ns: high swr warning on Display, but Flex-5000 itself will foldback due to firmware
                            Audio.HighSWRScale = swr_scale;
                            UpdateDisplay();
                        }
                    }
                    else
                    {
                        high_swr_count = 0;
                        Audio.HighSWRScale = Math.Min(1.0, Audio.HighSWRScale + 0.01);

                        if (Audio.HighSWRScale == 1.0 && HighSWR) HighSWR = false;
                    }


                }

                Thread.Sleep(100);
            }

            pa_fwd_power = 0;
            pa_rev_power = 0;
            HighSWR = false;
        }


        private void PollPAPWR()
        {
            int first_time_count = 0;
            int high_swr_count = 0;

            while (chkPower.Checked && pa_present)
            {
                if (mox)
                {
                    if (!atu_tuning)
                    {
                        first_time_count++;
                        if ((!x2_enabled && first_time_count >= 2) || first_time_count >= x2_delay / 130)
                        {
                            int temp = (int)Hdw.PA_GetADC(0);
                            if (temp >= 0) pa_fwd_power = temp;
                            if (mox)	// in case state changes already
                            {
                                temp = (int)Hdw.PA_GetADC(1);
                                if (temp >= 0) pa_rev_power = temp;
                            }

                            double fwd_power = PAPower(pa_fwd_power);
                            double rev_power = PAPower(pa_rev_power);

                            /*if(rev_power >= 11)
                            {
                                high_swr_count++;
                                if((high_swr_count >= 3 && !chkTUN.Checked) ||
                                    (high_swr_count >= 75 && chkTUN.Checked))
                                {
                                    HighSWR = true;
                                    UpdateDisplay();
                                }
                            }
                            else
                                high_swr_count = 0;							

                            if(high_swr && !disable_swr_protection)
                            {
                                if(Audio.HighSWRScale != 0.1)
                                    Audio.HighSWRScale = 0.1;
                            }*/

                            double swr_scale = SWRScale(rev_power);
                            if (swr_scale < Audio.HighSWRScale)
                            {
                                high_swr_count++;
                                if (high_swr_count >= 3)
                                {
                                    high_swr_count = 0;
                                    HighSWR = true;
                                    Audio.HighSWRScale = swr_scale;
                                    UpdateDisplay();
                                }
                            }
                            else
                            {
                                if (HighSWR)
                                {
                                    high_swr_count = 0;
                                    Audio.HighSWRScale = Math.Min(1.0, Audio.HighSWRScale + 0.01);
                                    if (Audio.HighSWRScale == 1.0)
                                        HighSWR = false;
                                }
                            }

                            //Debug.WriteLine("SWRScale: "+Audio.HighSWRScale.ToString("f3"));
                        }
                    }
                }

                Thread.Sleep(100);
                // roughly 132ms loop
            }

            pa_fwd_power = 0;
            pa_rev_power = 0;
            HighSWR = false;
        }

        private double SWRScale(double ref_pow)
        {
            if (ref_pow < 19) return 1.0;
            else return Math.Max((ref_pow * -0.01774) + 1.137097, 0.25); // mx+b found using 80% at 19, 25% at 50
        }



        //===============================================================================
        //===============================================================================
        // ke9ns mod this is where the CPU% is updated, I added the PA volt and temp
        //===============================================================================
        //===============================================================================
        private static byte PAON = 0; // ke9ns add  1=C, 2=F, 0=off
        private static byte PAONT = 0; // 1=thread running, 0=thread not running yet

        private int last_sec1;		// ke9ns add for time of day clock

        private Color CDTP = Color.WhiteSmoke;  // ke9ns color added to text of currentdatetimepanel
        private int voltcounterL = 0; // ke9ns add .209
        private int voltcounterH = 0;

        private void timer_cpu_meter_Tick(object sender, System.EventArgs e)
        {
            //   Stopwatch stopWatch = new Stopwatch();
            //   stopWatch.Start();



            labelTS3.ForeColor = Color.WhiteSmoke;
            labelTS4.ForeColor = Color.WhiteSmoke;
            int cpu = (int)CpuUsage;

            //  lblCPUMeter.Text = " CPU %     " + CpuUsage.ToString("f1"); // stop time = .005 worst case
            lblCPUMeter.Text = " CPU %     " + cpu.ToString(); // stop time = .005 worst case ke9ns mod

            lblCPUMeter.Select(0, 10);
            lblCPUMeter.SelectionColor = CDTP;

            lblCPUMeter.Select(10, lblCPUMeter.TextLength - 10);

            //  Debug.WriteLine("cpu " + cpu);

            if (cpu > 90) lblCPUMeter.SelectionColor = Color.Red;
            else if (cpu > 79) lblCPUMeter.SelectionColor = Color.Orange;
            else if (cpu > 69) lblCPUMeter.SelectionColor = Color.Yellow;
            else lblCPUMeter.SelectionColor = Color.LightGreen;


            if (URLPresent == true) URLPRESENT = false; // reset the http active setting

            // adding PA temp and volt increases total time to .05 seconds from .005



            int chan = 4;
            switch (current_model)
            {
                case Model.FLEX5000:
                    chan = 4;
                    break;
                case Model.FLEX3000:
                    chan = 3;
                    break;
                default:
                    chan = 0;
                    break;
            }


            if (chan > 0)
            {
                float temperature = 0;
                double temperature1 = 0;

                float volts = 0;
                float volts1 = 0;

                // ke9ns add

                if (PAON == 1) // if you click on temp C or volt it toggle on/off
                {
                    if (PAONT == 0)
                    {
                        PAONT = 1;

                        Thread t5 = new Thread(new ThreadStart(TempVolts));
                        t5.IsBackground = true;
                        t5.Priority = ThreadPriority.Lowest;
                        t5.Name = "Temp and VOlts reading Thread";
                        t5.Start();
                    }

                    temperature = (float)Temp_Value / 4096 * 2.5f;
                    temperature1 = 301 - temperature * 1000 / 2.2;
                    labelTS3.Text = " Temp C°   " + temperature1.ToString("f0"); // ke9ns ADD

                    volts = (float)Volts_Value / 4096 * 2.5f;
                    volts1 = volts * 11;

                    if (volts1 < 60)
                    {
                        if (volts1 < 11.0f)
                        {
                            voltcounterL++;
                        }
                        else if (volts1 > 15.0f)
                        {
                            voltcounterH++;
                        }
                        else
                        {
                            voltcounterL = 0;
                            voltcounterH = 0;
                        }

                        if (voltcounterL > 14)
                        {
                            MessageBox.Show(new Form { TopMost = true }, "!!!WARNING!!! LOW VOLTAGE below 11v, Check your power supply");
                            voltcounterL = 0;
                        }
                        else if (voltcounterH > 14)
                        {
                            MessageBox.Show(new Form { TopMost = true }, "!!!WARNING!!! HIGH VOLTAGE above 15v, Check your power supply");
                            voltcounterH = 0;
                        }

                    }

                    labelTS4.Text = " Volts        " + volts1.ToString("f1");    // ke9ns ADD

                }

                else if (PAON == 2) // toggle temp to F
                {
                    if (PAONT == 0)
                    {
                        PAONT = 1;

                        Thread t5 = new Thread(new ThreadStart(TempVolts));
                        t5.IsBackground = true;
                        t5.Priority = ThreadPriority.Lowest;
                        t5.Name = "Temp and VOlts reading Thread";
                        t5.Start();
                    }

                    temperature = (float)Temp_Value / 4096 * 2.5f;
                    temperature1 = (((301 - temperature * 1000 / 2.2) * 9) / 5) + 32; // convert c to f
                    labelTS3.Text = " Temp F°   " + temperature1.ToString("f0"); // ke9ns ADD


                    volts = (float)Volts_Value / 4096 * 2.5f;
                    volts1 = volts * 11;
                    labelTS4.Text = " Volts        " + volts1.ToString("f1");    // ke9ns ADD
                }

                else
                {
                    temperature = 0f;

                    labelTS3.Text = " Temp C°   click";
                    labelTS4.Text = " Volts        click ";
                }



                if (temperature != 0f)
                {
                    labelTS3.Select(0, 10);
                    labelTS3.SelectionColor = CDTP; // ke9ns: white

                    labelTS3.Select(10, labelTS3.TextLength - 10);

                    //  Debug.WriteLine("TEMPERTURE " + temperature.ToString("f6" ));
                    //  Debug.WriteLine("volts " + volts.ToString("f6" ));


                    if (temperature <= 0.4642F) labelTS3.SelectionColor = Color.Red;  // if temp >= 194F
                    else if (temperature <= 0.4862F) labelTS3.SelectionColor = Color.Orange;  //if temp >= 176F
                    else if (temperature <= 0.509422F) labelTS3.SelectionColor = Color.Yellow;  //if temp >= 157F
                    else if (temperature <= 0.615756F) labelTS3.SelectionColor = Color.LightGreen;  //if temp >= 70F
                    else labelTS3.SelectionColor = Color.LightBlue; // < 70F

                    labelTS4.Select(0, 7);
                    labelTS4.SelectionColor = CDTP;

                    labelTS4.Select(10, labelTS4.TextLength - 10);

                    //   float volts = (float)val / 4096 * 2.5f * 11;
                    //   if (volts >= 15.0) txtVolts.BackColor = Color.Red;

                    if (volts > 1.36) labelTS4.SelectionColor = Color.Red;   // 15v now 

                    // if (volts > 1.27) labelTS4.SelectionColor = Color.Red;   // 14v  was
                    else if (volts < 1.09) labelTS4.SelectionColor = Color.LightBlue;  // 12v
                    else labelTS4.SelectionColor = Color.GreenYellow;

                }

                labelTS3.Select(0, 0);
                labelTS4.Select(0, 0);
            }
            else
            {
                labelTS3.Visible = false;
                labelTS4.Visible = false;
            }


            //--------------------------------------------------------------------
            // ke9ns add space weather update to main console window

            int sec1 = DateTime.Now.Second;
            if (sec1 != last_sec1)
            {
                last_sec1 = sec1;


                if (chkBoxTimer1 == 0)
                {
                    txtTimer.ForeColor = Color.AntiqueWhite;

                    if (chkBoxTimer2 == true)
                    {
                        txtTimer.Text = "wfID Timer: OFF";
                    }
                    else if (chkBoxTimer3 == true)
                    {
                        txtTimer.Text = "voID Timer: OFF";
                    }
                    else if (chkBoxTimer4 == true)
                    {
                        txtTimer.Text = "cwID Timer: OFF";
                    }
                    else
                    {
                        txtTimer.Text = "  ID Timer: OFF"; // signals a static popup box 
                    }
                    txtTimer.Select(12, 3);
                    txtTimer.SelectionColor = Color.Red;
                    txtTimer.Select(0, 0);
                }

                if (noaaON >= 1)
                {
                    //  Debug.WriteLine("time = "+ DateTime.UtcNow.Minute);

                    if (noaaON == 3) LOCALWEATHER = true; // update local weather on screen
                    else LOCALWEATHER = false;

                    if ((DateTime.UtcNow.Second == 0) && ((DateTime.UtcNow.Minute == 30) || (DateTime.UtcNow.Minute == 0)) || (suncounter == 2))  // =2 only at startup
                    {
                        if ((suncounter == 0) || (suncounter == 2)) // 0=already have weather data from before or 2=startup
                        {
                            Debug.WriteLine("update noaa ");


                            Thread t4 = new Thread(new ThreadStart(NOAA)); // get space and local weather data here
                            t4.IsBackground = true;
                            t4.Priority = ThreadPriority.Lowest;
                            t4.Name = "NOAA Space Weather Thread";
                            t4.Start();

                        }
                    }
                    else
                    {
                        if (suncounter == 1) suncounter = 0; // 1=have weather data already, so set to 0
                    }


                    // ke9ns add
                    // A    K
                    // 0    0  Quiet
                    // 2    1 
                    // 3    1
                    // 4    1  Unsettled
                    // 7    2 
                    // 15   3  Active
                    // 27   4
                    // 48   5  Minor Storm
                    // 80   6
                    // 132  7  Severe Storm
                    // 208  8  Major Storm
                    // 400  9

                    /*

                    Radio Blackout Levels:                   Geomagnetic Storm Levels:                       Solar Radiation Levels
                    (effects sunlit side- XRays)            (K-index based effects)                              (Radiation Storm flux levels) 
                    R1=Minor(Weak degradation)      G1=Minor(Weak effects)                            S1=Minor(polar regions)
                    R2=Moderate(limited blackout)   G2=Moderate(HF towards poles faded)  S2=Moderate(polar regions)
                    R3=Strong(Wide blackout)            G3=Strong(HF intermittent)                      S3=Strong(degraded polar regions)
                    R4=Severe(Blackout)                      G4=Severe(HF prop sporadic)                   S4=Severe(blackout polar regions)
                    R5=Extreme(Complete Blackout) G5=Extreme(HF impossible)                     S5=Extreme(Complete blackout polar)

                    NOAA.com>> WWV Solar Flux Index, A and K index values
                    sidc.oma.be>>  Estimated SunSpot#: Official Sun Spot # updated hourly.
                    NWRA.com>> Effective SunSpot#  based on ionospheric measurements, updated hourly.
                    Effective SSN# is a more accurate SSN# since it takes time for actual SunSpots to effect the ionoshere.

                    ALSO certain times of year the following are very important:
                    Tropospheric Ducting Propagation (see http://www.dxinfocentre.com/tropo.html  )
                    and/or Sporadic E propagation (see http://www.dxmaps.com/spots/mapg.php?Lan=E&Frec=MUF&ML=M&HF=N  )

                    */

                    txtNOAA.ForeColor = CDTP;
                    txtNOAA2.ForeColor = CDTP;

                    txtNOAA.Text = "SF: " + SFI + " A: " + Aindex + " K: " + Kindex;

                    if (RadioBlackout.Length < 4) //.252
                    {
                        txtNOAA2.Text = "ss:" + EISN + " ef:" + SSNE + " SpW:" + RadioBlackout; //   txtNOAA2.Text = "SS: " + EISN + " SpWX: " + RadioBlackout;
                    }
                    else
                    {
                        txtNOAA2.Text = "ss:" + EISN + " ef:" + SSNE + " sW:" + RadioBlackout; //   txtNOAA2.Text = "SS: " + EISN + " SpWX: " + RadioBlackout;
                    } 


                    int lenSFI = SFI.ToString().Length;
                    int lenA = Aindex.ToString().Length;
                    int lenK = Kindex.ToString().Length;
                    int lenEISN = EISN.ToString().Length;
                    int lenSSNE = SSNE.ToString().Length;
                    int lenRadio = RadioBlackout.Length;

                    int startSFI = 4;
                    int startA = 4 + lenSFI + 4;
                    int startK = startA + lenA + 4;

                    int startEISN = 3; // was 4
                    int startSSNE = 3 + lenEISN + 4; // was 4 4

                    int startRadio = startSSNE + lenSSNE + 5; //  int startRadio = startEISN + lenEISN + 7;


                    if ((Kindex >= 4) || (RadioBlackout != " "))
                    {
                        txtNOAA.Select(startSFI, lenSFI);
                        txtNOAA.SelectionColor = Color.Red;

                        txtNOAA.Select(startA, lenA);
                        txtNOAA.SelectionColor = Color.Red;

                        txtNOAA.Select(startK, lenK);
                        txtNOAA.SelectionColor = Color.Red;

                        txtNOAA2.Select(startEISN, lenEISN);
                        txtNOAA2.SelectionColor = Color.Red;

                        txtNOAA2.Select(startSSNE, lenSSNE);
                        txtNOAA2.SelectionColor = Color.Red;

                        if (RadioBlackout.Length < 4)
                        {
                            txtNOAA2.Select(startRadio, lenRadio);
                        }
                        else
                        {
                            txtNOAA2.Select(startRadio-1, lenRadio);
                        }

                        txtNOAA2.SelectionColor = Color.Red;


                    }
                    else if ((Kindex > 2))
                    {
                        txtNOAA.Select(startSFI, lenSFI);
                        txtNOAA.SelectionColor = Color.Yellow;

                        txtNOAA.Select(startA, lenA);
                        txtNOAA.SelectionColor = Color.Yellow;

                        txtNOAA.Select(startK, lenK);
                        txtNOAA.SelectionColor = Color.Yellow;

                        txtNOAA2.Select(startEISN, lenEISN);
                        txtNOAA2.SelectionColor = Color.Yellow;

                        txtNOAA2.Select(startSSNE, lenSSNE);
                        txtNOAA2.SelectionColor = Color.Yellow;

                        if (RadioBlackout.Length < 4)
                        {
                            txtNOAA2.Select(startRadio, lenRadio);
                        }
                        else
                        {
                            txtNOAA2.Select(startRadio-1, lenRadio);
                        }
                        txtNOAA2.SelectionColor = Color.Yellow;


                    }
                    else
                    {
                        txtNOAA.Select(startSFI, lenSFI);
                        txtNOAA.SelectionColor = Color.GreenYellow;

                        txtNOAA.Select(startA, lenA);
                        txtNOAA.SelectionColor = Color.GreenYellow;

                        txtNOAA.Select(startK, lenK);
                        txtNOAA.SelectionColor = Color.GreenYellow;

                        txtNOAA2.Select(startEISN, lenEISN);
                        txtNOAA2.SelectionColor = Color.GreenYellow;

                        txtNOAA2.Select(startSSNE, lenSSNE);
                        txtNOAA2.SelectionColor = Color.GreenYellow;

                        if (RadioBlackout.Length < 4)
                        {
                            txtNOAA2.Select(startRadio, lenRadio);
                        }
                        else
                        {
                            txtNOAA2.Select(startRadio-1, lenRadio);
                        }
                        txtNOAA2.SelectionColor = Color.GreenYellow;


                    }


                }
                else
                {
                    txtNOAA.ForeColor = Color.AliceBlue;
                    txtNOAA2.ForeColor = Color.AliceBlue;

                    txtNOAA.Text = "Space WX: OFF";
                    txtNOAA2.Text = "Click On";
                }




                txtNOAA.SelectAll();
                txtNOAA.SelectionAlignment = HorizontalAlignment.Center;

                txtNOAA2.SelectAll();
                txtNOAA2.SelectionAlignment = HorizontalAlignment.Center;

                txtNOAA.Select(0, 0);
                txtNOAA2.Select(0, 0);

            } // if sec1 != lastsec

            //    stopWatch.Stop();        
            //   TimeSpan ts = stopWatch.Elapsed;
            //    Debug.WriteLine("RunTime1 " + ts);


        } // timer_cpu_meter_Tick

        int Volts_Value = 0;
        int Temp_Value = 0;

        //============================================================================================
        // ke9ns add thread for temp,volts
        private void TempVolts()
        {
            while (PAON > 0)
            {
                int chan = 4;
                switch (current_model)
                {
                    case Model.FLEX5000:
                        chan = 4;
                        break;
                    case Model.FLEX3000:
                        chan = 3;
                        break;
                    default:
                        chan = 0;
                        break;
                }



                FWC.ReadPAADC(chan, out Temp_Value);  // read temperature
                FWC.ReadPAADC(2, out Volts_Value); // read voltage

                Thread.Sleep(1000); // ke9ns 1 sec update
            }

            PAONT = 0;

        } // TempVolts() thread





        private void timer_peak_text_Tick(object sender, System.EventArgs e)
        {
            switch (Display.CurrentDisplayMode)
            {
                case DisplayMode.HISTOGRAM:
                case DisplayMode.PANADAPTER:
                case DisplayMode.SPECTRUM:
                case DisplayMode.WATERFALL:
                case DisplayMode.PANAFALL:
                case DisplayMode.PANASCOPE:
                    UpdatePeakText();
                    break;
                default:
                    txtDisplayPeakOffset.Text = "";
                    txtDisplayPeakPower.Text = "";
                    txtDisplayPeakFreq.Text = "";
                    break;
            }
        }

        private int lastHour = 25; //ke9ns add: for .166 cycle vac oFF/on every hour to prevent rx/tx from getting out of sync with real time.
        private bool lastVOX = false; // ke9ns add

        private int last_sec;       // for time of day clock
        private DateTime last_date; // for date
        private void timer_clock_Tick(object sender, System.EventArgs e)
        {


            if ((panelMoveTime.ElapsedMilliseconds > 250) && (MouseMoveSize == false)) // ke9ns add .158 for moving console around without title bar
            {
                if (MousePosition.Y <= (Screen.PrimaryScreen.WorkingArea.Height))
                {
                    int W = this.Size.Width;
                    int H = this.Size.Height;

                    this.Size = new Size(W - (FirstX - MousePosition.X), H - (FirstY - MousePosition.Y));

                    FirstX = MousePosition.X; // ke9ns: the new position
                    FirstY = MousePosition.Y;

                    panelMoveTime.Reset();

                }


            } //  if (panelMoveTime.ElapsedMilliseconds > 250)

            else if ((panelMoveTime.ElapsedMilliseconds > 250) && (MouseMoveSize == true)) // ke9ns add: .158 for moving console around without title bar
            {

                if (MousePosition.Y <= (Screen.PrimaryScreen.WorkingArea.Height))
                {

                    int X = this.Location.X;
                    int Y = this.Location.Y;

                    this.Location = new Point(X - (FirstX - MousePosition.X), Y - (FirstY - MousePosition.Y));

                    FirstX = MousePosition.X; // ke9ns: the new position
                    FirstY = MousePosition.Y;

                    panelMoveTime.Reset();
                }

            } //  if (panelMoveTime.ElapsedMilliseconds > 250)



            if ((!MOX) && (lastHour != DateTime.Now.Hour)) // ke9ns add .166 to prevent VAC gettin out of sync
            {
                lastHour = DateTime.Now.Hour;

                if (setupForm != null)
                    if (setupForm.chkVACReset.Checked == true)
                    {
                        if (chkVOX.Checked == true) lastVOX = true; // ke9ns: vox will turn off when we cycle power

                        if ((chkVAC1.Checked == true))
                        {
                            chkVAC1.Checked = false;
                            Thread.Sleep(50);
                            chkVAC1.Checked = true;
                        }

                        if ((chkVAC2.Checked == true))
                        {
                            chkVAC2.Checked = false;
                            Thread.Sleep(50);
                            chkVAC2.Checked = true;
                        }

                        if (lastVOX == true)
                        {

                            chkVOX.Checked = true; // ke9ns: turn vox back on if it was ON before.
                            lastVOX = false;
                        }
                    } // if (setupForm.chkVACReset.Checked == true)

            } //  if ((!MOX) && (lastHour != DateTime.Now.Hour))


            switch (current_datetime_mode)
            {
                case DateTimeMode.LOCAL:
                    DateTime date = DateTime.Now.Date;
                    if (date != last_date || txtDate.Text == "")
                    {
                        last_date = date;
                        txtDate.Text = DateTime.Now.ToShortDateString();
                    }

                    int sec = DateTime.Now.Second;
                    if (sec != last_sec)
                    {
                        last_sec = sec;
                        txtTime.Text = "LOC  " + DateTime.Now.ToString("HH:mm:ss");
                    }
                    break;
                case DateTimeMode.UTC:
                    date = DateTime.UtcNow.Date;
                    if (date != last_date || txtDate.Text == "")
                    {
                        last_date = date;
                        txtDate.Text = DateTime.UtcNow.ToShortDateString();
                    }

                    sec = DateTime.UtcNow.Second;
                    if (sec != last_sec)
                    {
                        last_sec = sec;
                        txtTime.Text = "UTC  " + DateTime.UtcNow.ToString("HH:mm:ss");
                    }
                    break;
                case DateTimeMode.OFF:
                    txtDate.Text = "Date";
                    txtTime.Text = "Time";
                    break;
            } // switch




            txtDate.ForeColor = Color.LightGray;
            txtTime.ForeColor = Color.WhiteSmoke;

            txtDate.SelectAll();
            txtDate.SelectionAlignment = HorizontalAlignment.Center;

            txtTime.SelectAll();
            txtTime.SelectionAlignment = HorizontalAlignment.Center;

            txtTime.Select(0, 4);
            txtTime.SelectionColor = CDTP;

            txtTime.Select(4, txtTime.TextLength - 4);
            txtTime.SelectionColor = Color.LightGray;


            txtTime.Select(0, 0);
            txtDate.Select(0, 0);


        } //timer_clock_tick

        private void Tune()
        {
            switch ((ATUTuneMode)comboTuneMode.SelectedIndex)
            {
                case ATUTuneMode.MEMORY:
                    PWR = 15;
                    atu_tuning = true;
                    if (!Hdw.PA_ATUTune(ATUTuneMode.MEMORY))
                        goto atu_error;
                    atu_tuning = false;
                    tuned_band = tx_band;
                    break;
                case ATUTuneMode.FULL:
                    PWR = 15;
                    atu_tuning = true;
                    if (!Hdw.PA_ATUTune(ATUTuneMode.FULL))
                        goto atu_error;
                    atu_tuning = false;
                    tuned_band = tx_band;
                    break;
            }

            chkTUN.Checked = false;
            chkTUN.Enabled = true;
            comboTuneMode.Enabled = true;
            chkTUN.BackColor = button_selected_color;
            return;

        atu_error:
            chkTUN.Checked = false;
            chkTUN.Enabled = true;
            comboTuneMode.Enabled = true;
            MessageBox.Show(new Form { TopMost = true }, "Error communicating with the ATU",
                "ATU Error",
                MessageBoxButtons.OK,
                MessageBoxIcon.Error);
        }

        private void DelayedDisplayReset()
        {
            Thread.Sleep((int)((double)block_size1 / (double)sample_rate1 * 1000.0));
            Display.ResetRX1DisplayAverage();
            Display.ResetRX1DisplayPeak();
        }

        private bool tx_cal = false;
        public bool TXCal
        {
            get { return tx_cal; }
            set { tx_cal = value; }
        }

        private int last_3k_fan_on = 0;
        private int last_3k_fan_off = 25;
        private void F3KReadTemp()
        {
            while (chkPower.Checked)
            {
                //if(!mox)
                {
                    int val;
                    FWC.ReadPAADC(3, out val);
                    float volts = (float)val / 4096 * 2.5f;
                    double temp_c = 301 - volts * 1000 / 2.2;

                    if (temp_c < 150.0 && temp_c > -30.0) // filter unreasonable temps
                    {
                        int MAX = 15;
                        int fan_on = MAX;
                        int fan_off = MAX;
                        double speed;

                        if (mox || tx_cal)
                        {
                            speed = (temp_c - 40.0) / (70.0 - 40.0);
                            if (speed > 1.0) speed = 1.0;
                            if (speed < 0.0) speed = 0.0;

                            if (speed < 0.5)
                            {
                                fan_on = (int)(MAX * speed * 2);
                                fan_off = MAX;
                            }
                            else
                            {
                                fan_on = MAX;
                                fan_off = (int)(MAX * (1.0 - speed) * 2);
                            }
                        }
                        else
                        {
                            speed = ((float)temp_c - f3k_temp_thresh) / (100.0 - f3k_temp_thresh);
                            if (speed > 1.0) speed = 1.0;
                            if (speed < 0.0) speed = 0.0;
                            if (speed < 0.5)
                            {
                                fan_on = (int)(MAX * speed * 2);
                                fan_off = MAX;
                            }
                            else
                            {
                                fan_on = MAX;
                                fan_off = (int)(MAX * (1.0 - speed) * 2);
                            }
                        }

                        if (fan_on != last_3k_fan_on || fan_off != last_3k_fan_off)
                        {
                            FWC.SetFanPWM(fan_on, fan_off);
                            Debug.WriteLine("Fan Speed: " + speed.ToString("ff2") + "  on: " + fan_on + "  off: " + fan_off);
                            last_3k_fan_on = fan_on;
                            last_3k_fan_off = fan_off;
                        }
                    }

                    /*if(temp_c >= f3k_temp_thresh && !f3k_fan)
                        F3KFan = true;
                    else if(temp_c < f3k_temp_thresh && f3k_fan)
                        F3KFan = false;*/

                }
                Thread.Sleep(2500);
            }
        }

        private void F3KMicFunctions()
        {
            double running_thresh_ms = 600;
            while (chkPower.Checked)
            {
                mic_down_timer.Stop();
                mic_up_timer.Stop();
                mic_fast_timer.Stop();

                if (mic_up)
                {
                    if (!mic_up_running)
                    {
                        if (mic_up_timer.DurationMsec > running_thresh_ms)
                        {
                            mic_down_running = false;
                            mic_up_running = true;
                        }
                    }
                }
                else if (mic_down)
                {
                    if (!mic_down_running)
                    {
                        if (mic_down_timer.DurationMsec > running_thresh_ms)
                        {
                            mic_up_running = false;
                            mic_down_running = true;
                        }
                    }
                }

                if (mic_up_running)
                {
                    double increment = 0.000100;
                    if (mic_fast) increment = 0.000500;
                    VFOAFreq += increment;
                }
                else if (mic_down_running)
                {
                    double decrement = 0.000100;
                    if (mic_fast) decrement = 0.000500;
                    VFOAFreq -= decrement;
                }

                Thread.Sleep(50);
            }
        }

        private enum WBIR_State
        {
            FastAdapt,
            SlowAdapt,
            NoAdapt,
        }

        /*private bool wbir_tuned = true;
        private bool wbir_tx_band_changed = false;
        private void WBIR()
        {
            WBIR_State state = WBIR_State.FastAdapt;
            int fast_count = 0;
            int countdown = 10000;

            while (chkPower.Checked)
            {
                switch (state)
                {
                    case WBIR_State.FastAdapt:
                        if (mox || wbir_tx_band_changed)
                        {
                            DttSP.SetCorrectIQMu(0, 0, 0.0);
                            DttSP.SetCorrectIQMu(0, 1, 0.0);
                            state = WBIR_State.NoAdapt;
                        }
                        else
                        {
                            if (wbir_tuned)
                            {
                                wbir_tuned = false;
                                fast_count = 0;
                            }
                            DttSP.SetCorrectIQMu(0, 0, 0.05 - (fast_count * 0.005));
                            DttSP.SetCorrectIQMu(0, 1, 0.05 - (fast_count * 0.005));
                            //Debug.WriteLine(" WBIR Fast, Mu: " + (0.05 - (fast_count * 0.005)).ToString("f6" ));
                            fast_count++;
                            if (fast_count == 10)
                            {
                                fast_count = 0;
                                countdown = 10000;
                                state = WBIR_State.SlowAdapt;
                            }
                        }
                        break;
                    case WBIR_State.SlowAdapt:
                        if (mox || wbir_tx_band_changed)
                        {
                            DttSP.SetCorrectIQMu(0, 0, 0.0);
                            DttSP.SetCorrectIQMu(0, 1, 0.0);
                            state = WBIR_State.NoAdapt;
                        }
                        else
                        {
                            countdown -= 100;
                            //Debug.WriteLine("WBIR Slow, countdown: "+countdown);
                            if (!calibrating && (countdown <= 0 || wbir_tuned))
                            {
                                wbir_tuned = false;
                                state = WBIR_State.FastAdapt;
                            }
                        }
                        break;
                    case WBIR_State.NoAdapt:
                        //Debug.WriteLine("WBIR Off");
                        if (!mox && !wbir_tx_band_changed)
                        {
                            DttSP.SetCorrectIQMu(0, 0, 0.005);
                            DttSP.SetCorrectIQMu(0, 1, 0.005);
                            countdown = 10000;
                            state = WBIR_State.SlowAdapt;
                        }
                        break;
                }

                Thread.Sleep(100);
            }
        }

        private bool wbir_rx2_tuned = true;
        private void WBIR_RX2()
        {
            WBIR_State state = WBIR_State.FastAdapt;
            int fast_count = 0;
            int countdown = 10000;

            while (chkPower.Checked)
            {
                switch (state)
                {
                    case WBIR_State.FastAdapt:
                        if (mox || wbir_tx_band_changed)
                        {
                            DttSP.SetCorrectIQMu(2, 0, 0.0);
                            state = WBIR_State.NoAdapt;
                        }
                        else
                        {
                            if (wbir_rx2_tuned)
                            {
                                wbir_rx2_tuned = false;
                                fast_count = 0;
                            }
                            DttSP.SetCorrectIQMu(2, 0, 0.05 - (fast_count * 0.005));
                            //Debug.WriteLine("WBIR2 Fast, Mu: " + (0.05 - (fast_count * 0.005)).ToString("f6" ));
                            fast_count++;
                            if (fast_count == 10)
                            {
                                fast_count = 0;
                                state = WBIR_State.SlowAdapt;
                            }
                        }
                        break;
                    case WBIR_State.SlowAdapt:
                        if (mox || wbir_tx_band_changed)
                        {
                            DttSP.SetCorrectIQMu(2, 0, 0.0);
                            state = WBIR_State.NoAdapt;
                        }
                        else
                        {
                            countdown -= 100;
                            //Debug.WriteLine("WBIR2 Slow, wbcountdown2: "+countdown);
                            if (!calibrating && (countdown <= 0 || wbir_rx2_tuned))
                            {
                                wbir_rx2_tuned = false;
                                countdown = 10000;
                                state = WBIR_State.FastAdapt;
                            }
                        }
                        break;
                    case WBIR_State.NoAdapt:
                        //Debug.WriteLine("WBIR2 Off");
                        if (!mox && !wbir_tx_band_changed)
                        {
                            DttSP.SetCorrectIQMu(2, 0, 0.005);
                            countdown = 10000;
                            state = WBIR_State.SlowAdapt;
                        }
                        break;
                }

                Thread.Sleep(100);

                if(!calibrating && (wbir_rx2_tuned || (wbcountdown2 <= 0)))
                {
                    wbir_rx2_tuned = false;
                    //Debug.WriteLine("WBIR RX2 Fast");
                    double setit=0.1;
                    for(int i=0;i<9 && !wbir_rx2_tuned;i++)
                    {
                        DttSP.SetCorrectIQMu(2, 0, setit);
                        setit -= 0.01;
                        Thread.Sleep(100);
                        //Debug.WriteLine("WBIR RX2 Slower");
                    }
                    //Debug.WriteLine("WBIR RX2 Slow");
                    wbcountdown2 = 10000;
                } 
                else 				
                {
                    Thread.Sleep(100);
                    wbcountdown2 -= 100;
                }
            }
        }*/

        private void AudioWatchdog()
        {
            int limit = sample_rate1 / Audio.BlockSize;
            int count = 0;
            HiPerfTimer t = new HiPerfTimer();
            t.Start();

            while (chkPower.Checked)
            {
                if (Audio.EmptyBuffers > limit) // 1 second dropout
                {
                    count++;

                    Audio.StopAudio();
                    Debug.WriteLine("NOT GOOD2============");

                    if (vac_enabled)
                    {
                        Debug.WriteLine("NOT GOOD============");

                        Audio.StopAudioVAC();
                    }

                    Thread.Sleep(500);
                    this.Invoke(new MethodInvoker(AudioStart));
                }
                Thread.Sleep(3000);
            }
        } // audiowatchdog

        private void AudioStart()
        {
            Audio.Start();   // ke9ns starts the proper callback routine (callback1500 for the Flex1500, or Callback2 for the 3000 and 5000)
        }

        private void MicPTT1500(bool b)
        {
            hid_mic_ptt = b;
        }

        private void PTTIn1500(bool b)
        {
            hid_ptt_in = b;
        }

        #endregion

        #region Event Handlers
        // ======================================================
        // Event Handlers
        // ======================================================

        // Console Events

        private void Console_KeyPress(object sender, System.Windows.Forms.KeyPressEventArgs e)
        {
            /*
                        if (e.KeyChar == (char)Keys.D1)
                        {
                            SpotForm.D1--;
                            return;
                        }
                        if (e.KeyChar == (char)Keys.D2)
                        {
                            SpotForm.D1++;
                            return;
                        }
                        if (e.KeyChar == (char)Keys.D3)
                        {
                            SpotForm.D2--;
                            return;
                        }
                        if (e.KeyChar == (char)Keys.D4)
                        {
                            SpotForm.D2++;
                            return;
                        }
                        if (e.KeyChar == (char)Keys.D5)
                        {
                            SpotForm.D3 = SpotForm.D3 - 1;
                            return;
                        }
                        if (e.KeyChar == (char)Keys.D6)
                        {
                            SpotForm.D3 = SpotForm.D3 + 1;

                            return;
                        }
                        if (e.KeyChar == (char)Keys.D7)
                        {
                            SpotForm.D4 = SpotForm.D4 - 1;

                            return;
                        }
                        if (e.KeyChar == (char)Keys.D8)
                        {
                            SpotForm.D4 = SpotForm.D4 + 1;

                            return;
                        }     
            */
            //   Debug.WriteLine("console_keypress");

            if (setupForm != null && setupForm.chkBoxPTT.Checked == true) // ke9ns add: for spacebar PTT function
            {
                if (e.KeyChar == (char)Keys.Space || e.KeyChar == (char)Keys.Enter) // ke9ns add: if spacebar held down
                {
                    return;
                }
            }

            if (setupForm != null && setupForm.chkBoxPTTLatch.Checked == true) // ke9ns add: for spacebar PTT function
            {
                if (e.KeyChar == (char)Keys.Space || e.KeyChar == (char)Keys.Enter) // ke9ns add: if spacebar held down
                {
                    return;
                }
            }

            if (callsignfocus == 1) return; // ke9ns add to focus on waterfall ID text

            if (e.KeyChar == (char)Keys.Enter)
            {
                btnHidden.Focus();
            }


        } // Console_KeyPress


        //===============================================================================================================
        //===============================================================================================================
        private void Console_KeyUp(object sender, System.Windows.Forms.KeyEventArgs e)
        {

            if (ZoomOn)
            {
                //   Debug.WriteLine("Zoom key up");
                ZoomOn = false; //.242
                if (SpotForm != null) SpotForm.Darken();
            }

            if (setupForm != null && setupForm.chkBoxPTT.Checked == true) // ke9ns add: for Spacebar PTT function
            {

                if (e.KeyCode == Keys.Space) // ke9ns add: if
                {
                    if (chkPower.Checked == true)
                    {
                        if (spacebarPTT == true)
                        {
                            chkMOX.Checked = false;
                            spacebarPTT = false;
                            e.SuppressKeyPress = true; // dont allow spacebar to do its normal windows function of clicking on the last focused item

                            Debug.WriteLine("SPACEBAR RELEASE " + chkPower.Checked);

                        }

                    }

                    return;

                } // spacebar
            } // setupform


            // ke9ns: LATCH PTT 
            if (setupForm != null && setupForm.chkBoxPTTLatch.Checked == true) // ke9ns add: for Spacebar PTT function
            {

                if (e.KeyCode == Keys.Space) // ke9ns add: if
                {
                    if (chkPower.Checked == true)
                    {

                        e.SuppressKeyPress = true; // dont allow spacebar to do its normal windows function of clicking on the last focused item

                        if (chkMOX.Checked == false)
                        {
                            chkMOX.Checked = true;
                        }
                        else
                        {
                            chkMOX.Checked = false;
                        }

                    }

                    return;

                } // spacebar
            } // setupform

            regBand = 0;  // ke9ns add

            if (callsignfocus == 1) return; // ke9ns add to focus on waterfall ID text

            if (e.Shift == false && shift_down)
            {
                shift_down = false;
            }


            if (setupForm != null) // ke9ns add: for DTMF buttons
            {
                Audio.TXInputSignal = Audio.SignalSource.RADIO;
                Audio.SineFreq1 = (double)setupForm.udDSPCWPitch.Value;
                Audio.two_tone = false;
            }




        } // console_keyup

        private static byte regBand = 0; // ke9ns add (used for an extra right click + CTRL function: add bandstacking and hyperlinking) 1=CTRL key pressed
        public static bool ALTM = false; // ke9ns add ALT + M key used to add memory
        public static bool HELPMAP = false; // ke9ns add true = mouse over map menuitem button trackmenuitem1
        public static bool HELPSWR = false; // ke9ns add true = mouse over SWR Scanner button for help
        public bool INIT1 = false; // ke9ns for chrome

        public byte zcode = 0;

        public bool spacebarPTT = false; // ke9ns add: setup checkboxPTT spacebar PTT function


        //   protected override void OnProcessKeyboardAccelerators(ProcessKeyboardAcceleratorEventArgs args)
        //   {

        //     if (args.Key == VirtualKey.Space)
        //   {
        //  args.Handled = true;
        //   }
        //   base.OnProcessKeyboardAccelerators(args);
        //  }




        //===============================================================================================================
        //===============================================================================================================
        //===============================================================================================================
        public bool MapNOAA = false; // .243 true = get an NOAA map update now

        private void Console_KeyDown(object sender, System.Windows.Forms.KeyEventArgs e)
        {
            //   Debug.WriteLine("KEY CODE: " + e.KeyCode);

            if (setupForm != null && setupForm.chkBoxPTT.Checked == true) // ke9ns add: for spacebar PTT function
            {
                if (e.KeyCode == Keys.Space) // ke9ns add: if spacebar held down
                {
                    if (chkPower.Checked == true) // 
                    {
                        if (chkMOX.Checked == false)
                        {
                            spacebarPTT = true; // set flag so we know who issued the MOX
                            chkMOX.Checked = true; // TX radio
                            e.SuppressKeyPress = true;


                            Debug.WriteLine("SPACEBAR PUSH " + chkPower.Checked);

                        }
                    }
                    return;
                } // spacebar
            }
            if (e.KeyCode == Keys.F1) // ke9ns add for help messages (F1 help screen) f1 key
            {

                if (MouseIsOverControl(txtTimer) == true)
                {
                    if (helpboxForm == null || helpboxForm.IsDisposed) helpboxForm = new helpbox(this);

                    helpboxForm.Show();
                    helpboxForm.Focus();
                    helpboxForm.WindowState = FormWindowState.Normal; // ke9ns add
                    helpboxForm.helpbox_message.Text = helpboxForm.txttimer_message.Text;            // ID TIMER HELP


                }
                else if ((MouseIsOverControl(txtNOAA) == true) || (MouseIsOverControl(txtNOAA2) == true))
                {
                    if (helpboxForm == null || helpboxForm.IsDisposed) helpboxForm = new helpbox(this);

                    helpboxForm.Show();
                    helpboxForm.Focus();
                    helpboxForm.WindowState = FormWindowState.Normal; // ke9ns add
                    helpboxForm.helpbox_message.Text = helpboxForm.solar_message.Text;         // SOLOR WEATHER HELP

                }

                else if (HELPMAP == true) // .245 console maps button help
                {
                    if (helpboxForm == null || helpboxForm.IsDisposed) helpboxForm = new helpbox(this);

                    helpboxForm.Show();
                    helpboxForm.Focus();
                    helpboxForm.WindowState = FormWindowState.Normal; // ke9ns add
                                                                      // helpboxForm.helpbox_message.Text = helpboxForm.TRACKMap.Text;             // WORLD MAP WITH Propagation, DX Spotting, Grayline, SUN tracking
                    helpboxForm.helpbox_message.Text = helpboxForm.maps_message.Text;         // 
                }
                else if (HELPSWR == true)
                {
                    if (helpboxForm == null || helpboxForm.IsDisposed) helpboxForm = new helpbox(this);

                    helpboxForm.Show();
                    helpboxForm.Focus();
                    helpboxForm.WindowState = FormWindowState.Normal; // ke9ns add
                    helpboxForm.helpbox_message.Text = helpboxForm.SWRScanner.Text;             // SWR Scanner Help

                }


            } // if (e.KeyCode == Keys.F1)
            else if (e.KeyCode == Keys.F2) // ke9ns add: for help messages (F2 video help screen) f2 key
            {


                if (MouseIsOverControl(txtTimer) == true) // https://youtu.be/cROuuj1UfTE  (ID TIMER VIDEO HELP)
                {
                    if (helpboxForm == null || helpboxForm.IsDisposed) helpboxForm = new helpbox(this);

                    helpboxForm.Show();
                    helpboxForm.Focus();
                    helpboxForm.WindowState = FormWindowState.Normal; // ke9ns add
                    helpboxForm.helpbox_message.Text = helpboxForm.helpbox_message.Text;            // ID TIMER HELP

                    string VideoID = "cROuuj1UfTE";

                    helpboxForm.webBrowser1.Visible = true;
                    helpboxForm.webBrowser1.BringToFront();

                    helpboxForm.webBrowser1.DocumentText = String.Format("<html><head>" +
                             "<meta http-equiv=\"X-UA-Compatible\" content=\"IE=Edge\"/>" +
                             "</head><body>" +
                             "<iframe width=\"100%\" height=\"425\"  src=\"https://www.youtube.com/embed/{0}?autoplay=1&enablejsapi=1\"" +
                             "frameborder = \"0\" allow = \"autoplay; encrypted-media\" allowfullscreen></iframe>" +
                             "</body></html>", VideoID);

                } //    if (MouseIsOverControl(txtTimer) == true)
                if (HELPMAP == true) // https://youtu.be/y7J4ktH2He4   (Maps VIDEO HELP)
                {
                    if (helpboxForm == null || helpboxForm.IsDisposed) helpboxForm = new helpbox(this);

                    helpboxForm.Show();
                    helpboxForm.Focus();
                    helpboxForm.WindowState = FormWindowState.Normal; // ke9ns add
                    helpboxForm.helpbox_message.Text = helpboxForm.helpbox_message.Text;            // ID TIMER HELP

                    string VideoID = "y7J4ktH2He4";

                    helpboxForm.webBrowser1.Visible = true;
                    helpboxForm.webBrowser1.BringToFront();

                    helpboxForm.webBrowser1.DocumentText = String.Format("<html><head>" +
                             "<meta http-equiv=\"X-UA-Compatible\" content=\"IE=Edge\"/>" +
                             "</head><body>" +
                             "<iframe width=\"100%\" height=\"425\"  src=\"https://www.youtube.com/embed/{0}?autoplay=1&enablejsapi=1\"" +
                             "frameborder = \"0\" allow = \"autoplay; encrypted-media\" allowfullscreen></iframe>" +
                             "</body></html>", VideoID);

                } //   HELPMAP

                else if (ESCHOVER == true) // https://youtu.be/A0q9iK9RdMw    eSCToolStripMenuItem  (ESC Enhanced Signal Clarity video help)
                {
                    if (helpboxForm == null || helpboxForm.IsDisposed) helpboxForm = new helpbox(this);

                    helpboxForm.Show();
                    helpboxForm.Focus();
                    helpboxForm.WindowState = FormWindowState.Normal; // ke9ns add
                    helpboxForm.helpbox_message.Text = helpboxForm.helpbox_message.Text;            // ESC video

                    string VideoID = "A0q9iK9RdMw";

                    helpboxForm.webBrowser1.Visible = true;
                    helpboxForm.webBrowser1.BringToFront();

                    helpboxForm.webBrowser1.DocumentText = String.Format("<html><head>" +
                             "<meta http-equiv=\"X-UA-Compatible\" content=\"IE=Edge\"/>" +
                             "</head><body>" +
                             "<iframe width=\"100%\" height=\"425\"  src=\"https://www.youtube.com/embed/{0}?autoplay=1&enablejsapi=1\"" +
                             "frameborder = \"0\" allow = \"autoplay; encrypted-media\" allowfullscreen></iframe>" +
                             "</body></html>", VideoID);

                } //   else if ( ESCHOVER == true )

                else if ((MouseIsOverControl(chkTNF) == true) || (MouseIsOverControl(btnTNFAdd) == true))   // https://youtu.be/M8q30G_jKS8   (TNF tracking notch filter VIDEO HELP)
                {
                    if (helpboxForm == null || helpboxForm.IsDisposed) helpboxForm = new helpbox(this);

                    helpboxForm.Show();
                    helpboxForm.Focus();
                    helpboxForm.WindowState = FormWindowState.Normal; // ke9ns add
                    helpboxForm.helpbox_message.Text = helpboxForm.helpbox_message.Text;            // TNF video

                    string VideoID = "M8q30G_jKS8";

                    helpboxForm.webBrowser1.Visible = true;
                    helpboxForm.webBrowser1.BringToFront();

                    helpboxForm.webBrowser1.DocumentText = String.Format("<html><head>" +
                             "<meta http-equiv=\"X-UA-Compatible\" content=\"IE=Edge\"/>" +
                             "</head><body>" +
                             "<iframe width=\"100%\" height=\"425\"  src=\"https://www.youtube.com/embed/{0}?autoplay=1&enablejsapi=1\"" +
                             "frameborder = \"0\" allow = \"autoplay; encrypted-media\" allowfullscreen></iframe>" +
                             "</body></html>", VideoID);

                } //    if (MouseIsOverControl(chkTNF) == true)

            } //  else if (e.KeyCode == Keys.F2)
            else if (e.KeyCode == Keys.F3) // ke9ns add: Voice keyer Reply button
            {

                buttonCall_Click(this, EventArgs.Empty); // ke9ns add: .187 simulate button press

            } // else if (e.KeyCode == Keys.F3) 
            else if (e.KeyCode == Keys.F4) // ke9ns add: Voice keyer CQCQ button
            {

                btnTrack_Click(this, EventArgs.Empty);// ke9ns add: .187 simulate button press

            } // else if (e.KeyCode == Keys.F4) 
            else if (e.KeyCode == Keys.F5)
            {
                buttonVK1_Click(this, EventArgs.Empty); // ke9ns add: .189 simulate button press Voice keyer VK1

            }
            else if (e.KeyCode == Keys.F6)
            {
                buttonVK2_Click(this, EventArgs.Empty); // ke9ns add: .189 simulate button press Voice keyer VK2

            }
            else if (e.KeyCode == Keys.F7) // ke9ns add .188 1750hz repeater button
            {
                if (RX1DSPMode == DSPMode.FM)
                {
                    if (chkFM1750.Checked == false) chkFM1750.Checked = true;
                    else chkFM1750.Checked = false;
                    chkFM1750_Click(this, EventArgs.Empty); // ke9ns add: .188
                }


            }
            else if (e.KeyCode == Keys.F8) // ke9ns add .190  move waterfall down
            {
                if (setupForm.checkQuindarToneON.Checked == true) setupForm.checkQuindarToneON.Checked = false;
                else setupForm.checkQuindarToneON.Checked = true;
            }
            else if (e.KeyCode == Keys.F9) // ke9ns add .193 down
            {
                if (comboDisplayMode.Text == "Panafall8020")
                {

                    if (setupForm.udSS1H.Value < ((decimal)(H10 * 5 / 6) * .1M)) // .197
                    {
                        mouseholdY = mouseholdY + 5;
                        setupForm.udSS1H.Value = mouseholdY;
                    }



                } //panafall8020
                else if (comboDisplayMode.Text == "Panafall")
                {


                    if (setupForm.udSS2H.Value < ((decimal)(H10 / 2) * .8M)) // .197
                    {
                        mouseholdYY = mouseholdYY + 5;
                        setupForm.udSS2H.Value = mouseholdYY;
                    }


                } // panafall

            }
            else if (e.KeyCode == Keys.F10) // move waterfall up
            {
                if (comboDisplayMode.Text == "Panafall8020")
                {
                    if (setupForm.udSS1H.Value > -((decimal)(H10 * 5 / 6) * .2M)) // .197
                    {
                        mouseholdY = mouseholdY - 5;
                        setupForm.udSS1H.Value = mouseholdY;
                    }

                }
                else if (comboDisplayMode.Text == "Panafall")
                {


                    if (setupForm.udSS2H.Value > -((decimal)(H10 / 2) * .7M)) // .197
                    {
                        mouseholdYY = mouseholdYY - 5;
                        setupForm.udSS2H.Value = mouseholdYY;
                    }

                }

            }
            else if (e.KeyCode == Keys.F11)
            {

            }
            else if (e.KeyCode == Keys.F12)
            {

            }

            if ((e.Shift == true) && (callsignfocus == 0))// ke9ns add (check for CTRL key but not while callsign text box is in focus)
            {
                if (DXR == 0) DXR = 1; // show Spotters on panadapter (and now also display the world map with lat/long coords)
                else DXR = 0; // clear
            }
            else
            {
                //    DXR = 0; // show DX on panadapter
            }

            //  Debug.WriteLine("keypressedCODE " + e.KeyCode);


            if (e.Alt == true) // ke9ns add
            {

                switch (e.KeyCode)
                {



                    case Keys.Z:

                        FWC.FlexWire_WriteValue(0x4C, zcode); // ke9ns: UCB XVTR (single byte transmission instead of 2 byte)

                        break;

                    case Keys.M: // ke9ns add  add to memory list

                        // Debug.WriteLine("ALT + M key ");

                        ALTM = true;
                        if (memoryForm == null || memoryForm.IsDisposed) memoryForm = new MemoryForm(this);
                        //  memoryForm.Show();
                        //  memoryForm.Focus();

                        memoryForm.MemoryRecordAdd_Click(memoryForm.MemoryRecordAdd, EventArgs.Empty); // 

                        break;

                    case Keys.D1: // ke9ns add  for DTMF tones  D1=numbers key 1 


                        DTMx++;
                        if (setupForm != null)
                        {
                            //  setupForm.checkBoxDTMF1_MouseDown(this.setupForm, System.Windows.Forms.MouseEventArgs.Empty);

                            if (MOX == true)
                            {
                                if (e.Shift == false)
                                {
                                    Audio.MOX = true;

                                    Audio.SineFreq1 = 697.0;
                                    Audio.SineFreq2 = 1209.0;
                                    Audio.two_tone = true;
                                    Audio.TXInputSignal = Audio.SignalSource.SINE_TWO_TONE;
                                    Audio.SourceScale = 1.0;
                                }
                            }
                        }

                        break;

                    case Keys.D2: // ke9ns add  for DTMF tones

                        DTMx--;

                        if (setupForm != null)
                        {

                            if (MOX == true)
                            {
                                if (e.Shift == false)
                                {
                                    Audio.MOX = true;

                                    Audio.SineFreq1 = 697.0;
                                    Audio.SineFreq2 = 1336.0;
                                    Audio.two_tone = true;
                                    Audio.TXInputSignal = Audio.SignalSource.SINE_TWO_TONE;
                                    Audio.SourceScale = 1.0;
                                }
                            }
                        }

                        break;

                    case Keys.D3: // ke9ns add  for DTMF tones

                        DTMy++;

                        if (setupForm != null)
                        {

                            if (MOX == true)
                            {
                                Audio.MOX = true;

                                if (e.Shift == true) // * key
                                {
                                    Audio.SineFreq1 = 941.0;
                                    Audio.SineFreq2 = 1477.0;
                                }
                                else
                                {
                                    Audio.SineFreq1 = 697.0;
                                    Audio.SineFreq2 = 1477.0;
                                }
                                Audio.two_tone = true;
                                Audio.TXInputSignal = Audio.SignalSource.SINE_TWO_TONE;
                                Audio.SourceScale = 1.0;
                            }
                        }

                        break;


                    case Keys.D4: // ke9ns add  for DTMF tones

                        DTMy--;

                        if (setupForm != null)
                        {
                            if (MOX == true)
                            {
                                if (e.Shift == false)
                                {
                                    Audio.MOX = true;

                                    Audio.SineFreq1 = 770.0;
                                    Audio.SineFreq2 = 1209.0;
                                    Audio.two_tone = true;
                                    Audio.TXInputSignal = Audio.SignalSource.SINE_TWO_TONE;
                                    Audio.SourceScale = 1.0;
                                }
                            }
                        }

                        break;


                    case Keys.D5: // ke9ns add  for DTMF tones

                        DTM++;
                        DTMx = -(DTM / 2);

                        if (setupForm != null)
                        {
                            if (MOX == true)
                            {
                                if (e.Shift == false)
                                {
                                    Audio.MOX = true;

                                    Audio.SineFreq1 = 770.0;
                                    Audio.SineFreq2 = 1336.0;
                                    Audio.two_tone = true;
                                    Audio.TXInputSignal = Audio.SignalSource.SINE_TWO_TONE;
                                    Audio.SourceScale = 1.0;
                                }
                            }
                        }

                        break;



                    case Keys.D6: // ke9ns add  for DTMF tones


                        DTM--;
                        DTMx = -(DTM / 2);

                        if (setupForm != null)
                        {
                            if (MOX == true)
                            {
                                if (e.Shift == false)
                                {
                                    Audio.MOX = true;

                                    Audio.SineFreq1 = 770.0;
                                    Audio.SineFreq2 = 1477.0;
                                    Audio.two_tone = true;
                                    Audio.TXInputSignal = Audio.SignalSource.SINE_TWO_TONE;
                                    Audio.SourceScale = 1.0;
                                }
                            }
                        }

                        break;

                    case Keys.D7: // ke9ns add  for DTMF tones

                        DTMa++;

                        if (setupForm != null)
                        {
                            if (MOX == true)
                            {
                                if (e.Shift == false)
                                {
                                    Audio.MOX = true;

                                    Audio.SineFreq1 = 852.0;
                                    Audio.SineFreq2 = 1209.0;
                                    Audio.two_tone = true;
                                    Audio.TXInputSignal = Audio.SignalSource.SINE_TWO_TONE;
                                    Audio.SourceScale = 1.0;
                                }
                            }
                        }

                        break;

                    case Keys.D8: // ke9ns add  for DTMF tones

                        DTMa--;

                        if (setupForm != null)
                        {
                            if (MOX == true)
                            {
                                Audio.MOX = true;

                                if (e.Shift == true) // * key
                                {
                                    Audio.SineFreq1 = 941.0;
                                    Audio.SineFreq2 = 1209.0;
                                }
                                else
                                {
                                    Audio.SineFreq1 = 852.0;
                                    Audio.SineFreq2 = 1336.0;
                                }

                                Audio.two_tone = true;
                                Audio.TXInputSignal = Audio.SignalSource.SINE_TWO_TONE;
                                Audio.SourceScale = 1.0;
                            }
                        }

                        break;


                    case Keys.D9: // ke9ns add  for DTMF tones

                        DTMs++;

                        if (setupForm != null)
                        {
                            if (MOX == true)
                            {
                                if (e.Shift == false)
                                {
                                    Audio.MOX = true;

                                    Audio.SineFreq1 = 852.0;
                                    Audio.SineFreq2 = 1477.0;
                                    Audio.two_tone = true;
                                    Audio.TXInputSignal = Audio.SignalSource.SINE_TWO_TONE;
                                    Audio.SourceScale = 1.0;
                                }
                            }
                        }

                        break;

                    case Keys.D0: // ke9ns add  for DTMF tones

                        DTMs--;

                        if (setupForm != null)
                        {
                            if (MOX == true)
                            {
                                if (e.Shift == false)
                                {
                                    Audio.MOX = true;

                                    Audio.SineFreq1 = 941.0;
                                    Audio.SineFreq2 = 1336.0;
                                    Audio.two_tone = true;
                                    Audio.TXInputSignal = Audio.SignalSource.SINE_TWO_TONE;
                                    Audio.SourceScale = 1.0;
                                }
                            }
                        }

                        break;





                } // switch



            } // alt key + M

            ALTM = false;

            Debug.WriteLine("DTM width=" + DTM + " , X=" + DTMx + " , Y=" + DTMy + " , Start Ang=" + DTMa + " , ang Sweep=" + DTMs);



            // CTRL key press DOWN
            if (e.Control == true) // ke9ns add (check for CTRL key press to do a QRZ lookup OR Focus on Red DOT on world MAP) 
            {

                regBand = 1; // ke9ns add (used for an extra right click + CTRL function: add bandstacking and hyperlinking)


                int x = DX_X; // get cursor position at time of CTRL key hit
                int y = DX_Y;

                //---------------------------------------------------------------
                // ke9ns: since the picDisplay area can be scaled, but not resized, you must rescale your values to find things within the picDisplay area

                int xx = picDisplay.Width;  // size of picdisplay as user scales it to their screen
                int yy = picDisplay.Height;

                int xxx = 1000; // actual unscaled size of map in picdisplay
                int yyy = 507;

                Debug.WriteLine(" width " + xx);
                Debug.WriteLine(" Height " + yy);

                Point p = picDisplay.PointToClient(Cursor.Position); // mouse cursor when you hit the ctrl key

                int XX = 0;
                int YY = 0;

                float scalex = ((float)xxx / (float)xx);
                XX = (int)((float)p.X * scalex);

                float scaley = ((float)yyy / (float)yy);
                YY = (int)((float)p.Y * scaley);

                Debug.WriteLine(" unscalledX " + XX);
                Debug.WriteLine(" unscalledY " + YY);

                Debug.WriteLine(" cursor " + p);

                //   ZoomX = XX; //.241
                //   ZoomY = YY; // .241
                //   ZoomP = p;

                //----------------------------------------------------------------------------------------
                // ke9ns add Beam heading for the MOON
                if ((SpotControl.SP5_Active == 1) && (SpotForm.chkMoon.Checked == true))
                {
                    Debug.WriteLine("MOON X " + x + " , " + SpotControl.Moon_X);
                    Debug.WriteLine("MOON Y " + y + " , " + SpotControl.Moon_Y);

                    if ((XX >= SpotControl.Moon_X - 20) && (XX <= SpotControl.Moon_X + 43) && (YY >= SpotControl.Moon_Y - 13) && (YY <= SpotControl.Moon_Y + 27)) // check for rotor Beam heading 
                    {
                        Debug.WriteLine("BEAM HEADING TRANSMIT FROM Display for the MOON " + SpotControl.Moon_AZ.ToString().PadLeft(3, '0'));

                        spotDDUtil_Rotor = "AP1" + SpotControl.Moon_AZ.ToString().PadLeft(3, '0') + ";"; // transmit Az
                        spotDDUtil_Rotor = "AM1;";
                    }
                } // MOON Rotor move
                //----------------------------------------------------------------------------------------
                // ke9ns add Beam heading for the ISS
                if ((SpotControl.SP5_Active == 1) && (SpotForm.chkISS.Checked == true))
                {
                    Debug.WriteLine("ISS X " + x + " , " + SpotControl.ISS_X);
                    Debug.WriteLine("ISS Y " + y + " , " + SpotControl.ISS_Y);

                    if ((XX >= SpotControl.ISS_X - 20) && (XX <= SpotControl.ISS_X + 53) && (YY >= SpotControl.ISS_Y - 13) && (YY <= SpotControl.ISS_Y + 27)) // check for rotor Beam heading 
                    {
                        Debug.WriteLine("BEAM HEADING TRANSMIT FROM Display for the ISS " + SpotControl.ISS_AZ.ToString().PadLeft(3, '0'));

                        spotDDUtil_Rotor = "AP1" + SpotControl.ISS_AZ.ToString().PadLeft(3, '0') + ";"; // transmit Az
                        spotDDUtil_Rotor = "AM1;";
                    }
                } // ISS Rotor move

                if ((SpotControl.SP4_Active == 0) && (SpotControl.SP_Active > 2) && (SpotControl.DX_Index > 0))  // Do below if not in the middle of processing a DX spot, but DX spotting is Active
                {

                    //  int x = DX_X; // cursor position
                    //  int y = DX_Y;

                    //======================================================================================================    



                    int iii = 500;

                    for (int ii = 0; ii < SpotControl.DX_Index; ii++) // check all red dots on Panadapter
                    {

                        if ((SpotControl.DX_X[ii] > 5) && (SpotControl.DX_Y[ii] > 5) && (XX <= (SpotControl.DX_X[ii] + 5)) && (XX >= (SpotControl.DX_X[ii] - 5))
                            && (YY <= (SpotControl.DX_Y[ii] + 5)) && (YY >= (SpotControl.DX_Y[ii] - 5)))
                        {
                            Debug.WriteLine("Good trace ii " + ii);

                            SpotForm.DX_SELECTED = ii;    // ke9ns add to keep the dx spotter window always highlighted
                            SpotForm.DX_TEXT = SpotForm.textBox1.Text.Substring((SpotForm.DX_SELECTED * SpotForm.LineLength) + 16, 40);  // ke9ns add
                            SpotControl.Map_Last = 2;
                            SpotForm.processTCPMessage();
                            iii = ii;
                            break;
                        }
                        else
                        {
                            Debug.WriteLine("trace X " + SpotControl.DX_X[ii] + " Y " + SpotControl.DX_Y[ii]);
                        }

                    }

                    if (iii != 500) // only go to the DX spot freq if you found it directly up above in the for loop
                    {

                        int freq1 = SpotControl.DX_Freq[iii];

                        Debug.WriteLine("freq ii " + freq1);

                        if ((freq1 < 5000000) || ((freq1 > 6000000) && (freq1 < 8000000))) // check for bands using LSB
                        {
                            if (SpotForm.chkDXMode.Checked == true)
                            {
                                if (SpotControl.DX_Mode[iii] == 0) RX1DSPMode = DSPMode.LSB;
                                else if (SpotControl.DX_Mode[iii] == 1) RX1DSPMode = DSPMode.CWU; // ke9ns mod was CWL
                                else if (SpotControl.DX_Mode[iii] == 2) RX1DSPMode = DSPMode.DIGL;
                                else if (SpotControl.DX_Mode[iii] == 3) RX1DSPMode = DSPMode.DIGL;
                                else if (SpotControl.DX_Mode[iii] == 4) RX1DSPMode = DSPMode.DIGL;
                                else if (SpotControl.DX_Mode[iii] == 5) RX1DSPMode = DSPMode.DIGL;
                                else if (SpotControl.DX_Mode[iii] == 6) RX1DSPMode = DSPMode.DIGL;
                                else if (SpotControl.DX_Mode[iii] == 7) RX1DSPMode = DSPMode.DIGL;
                                else if (SpotControl.DX_Mode[iii] == 8) RX1DSPMode = DSPMode.DIGL;
                                else if (SpotControl.DX_Mode[iii] == 9) RX1DSPMode = DSPMode.DIGL;
                                else if (SpotControl.DX_Mode[iii] == 10) RX1DSPMode = DSPMode.DIGL;
                                else if (SpotControl.DX_Mode[iii] == 11) RX1DSPMode = DSPMode.FM;
                                else if (SpotControl.DX_Mode[iii] == 12) RX1DSPMode = DSPMode.LSB;
                                else if (SpotControl.DX_Mode[iii] == 13) RX1DSPMode = DSPMode.DIGL;
                                else if (SpotControl.DX_Mode[iii] == 14) RX1DSPMode = DSPMode.SAM;
                                else if (SpotControl.DX_Mode[iii] == 15) RX1DSPMode = DSPMode.DIGU; // FT8
                                else if (SpotControl.DX_Mode[iii] == 16) RX1DSPMode = DSPMode.DIGL;
                                else if (SpotControl.DX_Mode[iii] == 17) RX1DSPMode = DSPMode.DIGL;
                                else RX1DSPMode = DSPMode.LSB;

                            }
                            else
                            {
                                RX1DSPMode = DSPMode.LSB;
                            }

                        } // LSB
                        else
                        {
                            if (SpotForm.chkDXMode.Checked == true)
                            {

                                if (SpotControl.DX_Mode[iii] == 0) RX1DSPMode = DSPMode.USB;
                                else if (SpotControl.DX_Mode[iii] == 1) RX1DSPMode = DSPMode.CWU;
                                else if (SpotControl.DX_Mode[iii] == 2) RX1DSPMode = DSPMode.DIGU;
                                else if (SpotControl.DX_Mode[iii] == 3) RX1DSPMode = DSPMode.DIGU;
                                else if (SpotControl.DX_Mode[iii] == 4) RX1DSPMode = DSPMode.DIGU;
                                else if (SpotControl.DX_Mode[iii] == 5) RX1DSPMode = DSPMode.DIGU;
                                else if (SpotControl.DX_Mode[iii] == 6) RX1DSPMode = DSPMode.DIGU;
                                else if (SpotControl.DX_Mode[iii] == 7) RX1DSPMode = DSPMode.DIGU;
                                else if (SpotControl.DX_Mode[iii] == 8) RX1DSPMode = DSPMode.DIGU;
                                else if (SpotControl.DX_Mode[iii] == 9) RX1DSPMode = DSPMode.DIGU;
                                else if (SpotControl.DX_Mode[iii] == 10) RX1DSPMode = DSPMode.DIGU;
                                else if (SpotControl.DX_Mode[iii] == 11) RX1DSPMode = DSPMode.FM;
                                else if (SpotControl.DX_Mode[iii] == 12) RX1DSPMode = DSPMode.USB;
                                else if (SpotControl.DX_Mode[iii] == 13) RX1DSPMode = DSPMode.DIGU;
                                else if (SpotControl.DX_Mode[iii] == 14) RX1DSPMode = DSPMode.SAM;
                                else if (SpotControl.DX_Mode[iii] == 15) RX1DSPMode = DSPMode.DIGU; // FT8
                                else if (SpotControl.DX_Mode[iii] == 16) RX1DSPMode = DSPMode.DIGU;
                                else if (SpotControl.DX_Mode[iii] == 17) RX1DSPMode = DSPMode.DIGU;
                                else RX1DSPMode = DSPMode.USB;

                            }
                            else
                            {
                                RX1DSPMode = DSPMode.USB;
                            }

                        } // USB
                        VFOAFreq = (double)freq1 / 1000000; // convert to MHZ

                        //   Debug.WriteLine("freq " + VFOAFreq);

                        if (SpotForm.chkDXMode.Checked == true)
                        {

                            if (SpotControl.DX_Mode2[iii] != 0)
                            {

                                VFOBFreq = (double)(freq1 + SpotControl.DX_Mode2[iii]) / 1000000; // convert to MHZ
                                chkVFOSplit.Checked = true; // turn on  split

                                Debug.WriteLine("split here" + (freq1 + SpotControl.DX_Mode2[iii]));

                            }
                            else
                            {
                                chkVFOSplit.Checked = false; // turn off split

                            }


                        } // chkdxmode checked

                        /*   decided not to do it here, since you dont always want to be moving your antenna on everything you click on.
                                                if (setupForm.ROTOREnabled == true)   // ke9ns add send hygain rotor command to DDUtil via the CAT port setup in PowerSDR
                                                {
                                                    Debug.WriteLine("Red DOT BEAM HEADING TRANSMIT");

                                                    spotDDUtil_Rotor = "AP1" + SpotControl.DX_Beam[iii].ToString().PadLeft(3, '0') + ";";
                                                   // spotDDUtil_Rotor = ";";
                                                    spotDDUtil_Rotor = "AM1;";

                                                } //  
                        */

                        SpotControl.Map_Last = 2; // UPDATE SPOTS ON MAP


                        return;

                    } // if you found a red dot matching your dx spot list



                    //======================================================================================================
                    // this is a CTRL key press
                    for (byte ii = 0; ii < DXK; ii++) // check all spot on Panadapter (not red dots)
                    {

                        if ((x >= DXX[ii]) && (x <= (DXX[ii] + (DXW[ii]) * 3 / 4)) && (y >= DXY[ii]) && (y <= (DXY[ii] + DXH[ii])))
                        {

                            var DXtemp = new StringBuilder("https://www.qrz.com/db/");
                            DXtemp.Append(DXS[ii]);

                            try
                            {
                                SpotForm.DX_RX2 = false;
                                //   System.Diagnostics.Process.Start(DXtemp.ToString()); // change so now only a Right click on the panadapter callsign will open QRZ page

                                //  Debug.WriteLine("DX SELECTED " + ii + " , " + Display.holder[ii] + " , " + DXS[ii]);

                                // a simple Right click on a DX SPot will do a QRZ lookup (mousedown routine)

                                SpotForm.DX_SELECTED = Display.holder[ii]; //ke9ns add
                                SpotForm.textBox1.SelectionStart = SpotForm.DX_SELECTED * SpotForm.LineLength;      // start of each dx spot line
                                SpotForm.textBox1.SelectionLength = SpotForm.LineLength;                    // length of each dx spot  line
                                SpotForm.textBox1_MouseUp(this, new MouseEventArgs(MouseButtons.Left, 0, 0, 0, 0)); // process as though you clicked on the dx spot in the spotter window

                            }
                            catch
                            {
                                Debug.WriteLine("bad station");
                            }

                            return;

                        } // index
                        else if ((x >= DXX[ii] + (DXW[ii] * 3 / 4)) && (x <= (DXX[ii] + DXW[ii])) && (y >= DXY[ii]) && (y <= (DXY[ii] + DXH[ii]))) // check for rotor Beam heading 
                        {
                            SpotForm.DX_RX2 = false;
                            Debug.WriteLine("BEAM HEADING TRANSMIT FROM Display");

                            spotDDUtil_Rotor = "AP1" + SpotControl.DX_Beam[ii].ToString().PadLeft(3, '0') + ";";
                            spotDDUtil_Rotor = "AM1;";

                            //  Debug.WriteLine(">>>>>>> DX SELECTED " + ii);

                            SpotForm.DX_SELECTED = Display.holder[ii]; //ke9ns add
                            SpotForm.textBox1.SelectionStart = SpotForm.DX_SELECTED * SpotForm.LineLength;      // start of each dx spot line
                            SpotForm.textBox1.SelectionLength = SpotForm.LineLength;                    // length of each dx spot  line
                            SpotForm.textBox1_MouseUp(this, new MouseEventArgs(MouseButtons.Left, 0, 0, 0, 0));


                        } // check if you clicked on the last half of the call sign



                    } // for loop

                    if (chkRX2.Checked == true)  // check RX2 click
                    {
                        for (byte ii = 0; ii < DXK2; ii++)
                        {

                            if ((x >= DXX[ii + 50]) && (x <= (DXX[ii + 50] + DXW[ii + 50] * 3 / 4)) && (y >= DXY[ii + 50]) && (y <= (DXY[ii + 50] + DXH[ii + 50])))
                            {
                                var DXtemp = new StringBuilder("https://www.qrz.com/db/");
                                DXtemp.Append(DXS[ii + 50]);

                                try
                                {
                                    SpotForm.DX_RX2 = true;
                                    //      System.Diagnostics.Process.Start(DXtemp.ToString());

                                    SpotForm.DX_SELECTED = Display.holder[ii]; //ke9ns add
                                    SpotForm.textBox1.SelectionStart = SpotForm.DX_SELECTED * SpotForm.LineLength;      // start of each dx spot line
                                    SpotForm.textBox1.SelectionLength = SpotForm.LineLength;                    // length of each dx spot  line
                                    SpotForm.textBox1_MouseUp(this, new MouseEventArgs(MouseButtons.Left, 0, 0, 0, 0));


                                }
                                catch
                                {
                                    Debug.WriteLine("bad station");
                                }

                                break;

                            } // index
                            else if ((x <= (DXX[ii + 50] + DXW[ii + 50] * 3 / 4)) && (y >= DXY[ii + 50]) && (y <= (DXY[ii + 50] + DXH[ii + 50])))
                            {
                                SpotForm.DX_RX2 = true;
                                Debug.WriteLine("BEAM HEADING TRANSMIT FROM Display RX2");

                                spotDDUtil_Rotor = "AP1" + SpotControl.DX_Beam[ii].ToString().PadLeft(3, '0') + ";";
                                spotDDUtil_Rotor = ";";
                                spotDDUtil_Rotor = "AM1;";

                                SpotForm.DX_SELECTED = Display.holder[ii]; //ke9ns add
                                SpotForm.textBox1.SelectionStart = SpotForm.DX_SELECTED * SpotForm.LineLength;      // start of each dx spot line
                                SpotForm.textBox1.SelectionLength = SpotForm.LineLength;                    // length of each dx spot  line
                                SpotForm.textBox1_MouseUp(this, new MouseEventArgs(MouseButtons.Left, 0, 0, 0, 0));


                            } // check if you clicked on the last half of the call sign


                        } // for loop

                    } // rx2 checked on 


                } //   if ((SpotControl.SP4_Active == 0) && (SpotControl.SP_Active > 2))



                //---------------------------------------------------------------------------------
                //---------------------------------------------------------------------------------
                //---------------------------------------------------------------------------------
                //---------------------------------------------------------------------------------
                //ke9ns memory in Pan  you are here from a CTRL key press
                if ((SpotControl.SP6_Active == 1))
                {
                    // int x = DX_X;
                    //  int y = DX_Y;


                    for (int ii = 0; ii < MMK3; ii++) // check all spot on Panadapter
                    {

                        if ((x >= MMX[ii]) && (x <= (MMX[ii] + MMW[ii])) && (y >= MMY[ii]) && (y <= (MMY[ii] + MMH[ii])))
                        {
                            //  Debug.WriteLine("NAME === " + MMS[ii] + " index "+MMM[ii]);

                            try
                            {
                                SpotForm.DX_RX2 = false;
                                changeComboFMMemory(MMM[ii]);

                            }
                            catch
                            {
                                Debug.WriteLine("bad station");
                            }

                            return;

                        } // index

                    } // for loop

                    //-------------------------------------------------------


                    if (chkRX2.Checked == true)  // check RX2 click
                    {
                        for (int ii = 0; ii < MMK4; ii++)
                        {

                            if ((x >= MMX[ii + 50]) && (x <= (MMX[ii + 50] + DXW[ii + 50])) && (y >= MMY[ii + 50]) && (y <= (MMY[ii + 50] + MMH[ii + 50])))
                            {
                                try
                                {
                                    SpotForm.DX_RX2 = true;
                                    //  System.Diagnostics.Process.Start(DXtemp.ToString());
                                    changeComboFMMemory(MMM[ii]);

                                }
                                catch
                                {
                                    Debug.WriteLine("bad station");
                                }

                                break;

                            } // index


                        } // for loop

                    } // rx2 checked on 


                } // memory ON pAN ACTIVE

                //---------------------------------------------------------------------------------
                //---------------------------------------------------------------------------------
                //---------------------------------------------------------------------------------
                //---------------------------------------------------------------------------------
                //ke9ns: With Console in Focus and mouse over the SWL listing on the screen, and hit the CTRL key, then pull up Freq and mode of SWL listing

                if ((SpotControl.SP1_Active == 1))
                {
                    Debug.WriteLine("SWL test====");

                    //  int x = DX_X;
                    //  int y = DX_Y;

                    for (byte ii = 0; ii < SXK; ii++)
                    {

                        if ((x >= SXX[ii]) && (x <= (SXX[ii] + SXW[ii])) && (y >= SXY[ii]) && (y <= (SXY[ii] + SXH[ii])))
                        {
                            try
                            {
                                SpotForm.DX_RX2 = false;
                                Debug.WriteLine("freq " + SXF[ii]);
                                Debug.WriteLine("Mode " + SXM[ii]);

                                VFOAFreq = ((double)SXF[ii]) / 1000000.0; // convert to MHZ

                                //   Display.VFOA = ((long)SpotControl.SWL_Freq[swl_index[xxx]]) ; // keep as hz

                                if (SXM[ii] == "AM") RX1DSPMode = DSPMode.SAM;
                                else if (SXM[ii] == "SAM") RX1DSPMode = DSPMode.SAM;
                                else if (SXM[ii] == "USB") RX1DSPMode = DSPMode.USB;
                                else if (SXM[ii] == "DIGU") RX1DSPMode = DSPMode.DIGU;


                            }
                            catch
                            {
                                Debug.WriteLine("Bad location");
                            }

                            return;

                        } // index

                    } // for loop

                    if (chkRX2.Checked == true)  // check RX2 click
                    {
                        for (byte ii = 0; ii < SXK2; ii++)
                        {

                            if ((x >= SXX[ii + 100]) && (x <= (SXX[ii + 100] + SXW[ii + 100])) && (y >= SXY[ii + 100]) && (y <= (SXY[ii + 100] + SXH[ii + 100])))
                            {
                                try
                                {
                                    SpotForm.DX_RX2 = true;
                                    Debug.WriteLine("freq " + SXF[ii + 100]);
                                    Debug.WriteLine("Mode " + SXM[ii + 100]);

                                    VFOBFreq = ((double)SXF[ii + 100]) / 1000000.0; // convert to MHZ

                                    //   Display.VFOA = ((long)SpotControl.SWL_Freq[swl_index[xxx]]) ; // keep as hz

                                    if (SXM[ii + 100] == "AM") RX2DSPMode = DSPMode.SAM;
                                    else if (SXM[ii + 100] == "SAM") RX2DSPMode = DSPMode.SAM;
                                    else if (SXM[ii + 100] == "USB") RX2DSPMode = DSPMode.USB;
                                    else if (SXM[ii + 100] == "DIGU") RX2DSPMode = DSPMode.DIGU;

                                }
                                catch
                                {
                                    Debug.WriteLine("Bad location");

                                }
                                return;

                            } // index

                        } // for loop


                    } // RX2



                } //  if ((SpotControl.SP3_Active == 1) && (SpotControl.SP1_Active ==1))


            } // e.control key
            else
            {
                regBand = 0;
            }

            SpotControl.Map_Last = 2; // force map update


            if (callsignfocus == 1) return; // ke9ns add to focus on waterfall ID text

            if (e.Shift == true && !shift_down) shift_down = true;


            //==================================================================
            if (e.Control == true && e.Shift == true)  // CTRL and SHIFT together
            {
                switch (e.KeyCode)
                {
                    case Keys.A:
                        if (fwc_init && (current_model == Model.FLEX3000))
                        {
                            if (flex3000ATUForm == null || flex3000ATUForm.IsDisposed)
                                flex3000ATUForm = new FLEX3000ATUForm(this);
                            flex3000ATUForm.Show();
                            flex3000ATUForm.Focus();
                            flex3000ATUForm.WindowState = FormWindowState.Normal; // ke9ns add
                        }
                        break;
                    case Keys.C:
                        if ((fwc_init && (current_model == Model.FLEX5000 || current_model == Model.FLEX3000)) ||
                            (hid_init && current_model == Model.FLEX1500))
                        {
                            fwcCalForm = new FWCCalForm(this);
                            fwcCalForm.Show();
                            fwcCalForm.Focus();
                            fwcCalForm.WindowState = FormWindowState.Normal; // ke9ns add
                        }
                        break;
                    case Keys.D:
                        if (fwc_init && (current_model == Model.FLEX5000 || current_model == Model.FLEX3000))
                        {
                            if (flex5000DebugForm == null || flex5000DebugForm.IsDisposed)
                                flex5000DebugForm = new FLEX5000DebugForm(this);
                            flex5000DebugForm.Show();
                            flex5000DebugForm.Focus();
                            flex5000DebugForm.WindowState = FormWindowState.Normal; // ke9ns add
                        }
                        else if (hid_init && current_model == Model.FLEX1500)
                        {
                            if (flex1500DebugForm == null || flex1500DebugForm.IsDisposed)
                                flex1500DebugForm = new FLEX1500DebugForm(this); // this was not there before
                            flex1500DebugForm.Show();
                            flex1500DebugForm.Focus();
                            flex1500DebugForm.WindowState = FormWindowState.Normal; // ke9ns add
                        }
                        break;
                    case Keys.F:
                        if (fwc_init && (current_model == Model.FLEX5000 || current_model == Model.FLEX3000))
                        {
                            flex5000FinalTestForm = new FLEX5000FinalTestForm(this);
                            flex5000FinalTestForm.Show();
                            flex5000FinalTestForm.Focus();
                            flex5000FinalTestForm.WindowState = FormWindowState.Normal; // ke9ns add
                        }
                        break;
                    case Keys.I:
                        if (fwc_init && (current_model == Model.FLEX5000 || current_model == Model.FLEX3000))
                        {
                            if (fwcTestForm == null || fwcTestForm.IsDisposed)
                                fwcTestForm = new FWCTestForm(this);
                            fwcTestForm.Show();
                            fwcTestForm.Focus();
                            fwcTestForm.WindowState = FormWindowState.Normal; // ke9ns add
                        }
                        break;
                    case Keys.O:
                        relaysToolStripMenuItem.Visible = true;
                        break;
                    case Keys.P:
                        switch (current_model)
                        {
                            case Model.FLEX5000:
                            case Model.FLEX3000:
                                if (fwc_init)
                                {
                                    flex5000ProdTestForm = new FLEX5000ProdTestForm(this);
                                    flex5000ProdTestForm.Show();
                                    flex5000ProdTestForm.Focus();
                                    flex5000ProdTestForm.WindowState = FormWindowState.Normal; // ke9ns add
                                }
                                break;
                            case Model.FLEX1500:
                                if (hid_init)
                                {
                                    flex5000ProdTestForm = new FLEX5000ProdTestForm(this);
                                    flex5000ProdTestForm.Show();
                                    flex5000ProdTestForm.Focus();
                                    flex5000ProdTestForm.WindowState = FormWindowState.Normal; // ke9ns add
                                }
                                break;
                            case Model.SDR1000:
                                if (ProdTestForm == null || ProdTestForm.IsDisposed)
                                    ProdTestForm = new ProductionTest(this);
                                ProdTestForm.Show();
                                ProdTestForm.Focus();
                                ProdTestForm.WindowState = FormWindowState.Normal; // ke9ns add
                                break;
                        }
                        break;
                    case Keys.R:
                        if (fwc_init && current_model == Model.FLEX5000 && FWCEEPROM.RX2OK)
                        {
                            if (flex5000RX2CalForm == null || flex5000RX2CalForm.IsDisposed)
                                flex5000RX2CalForm = new FLEX5000RX2CalForm(this);
                            flex5000RX2CalForm.Show();
                            flex5000RX2CalForm.Focus();
                            flex5000RX2CalForm.WindowState = FormWindowState.Normal; // ke9ns add
                        }
                        break;
                    case Keys.S: // HEROS form
                        if ((fwc_init && (current_model == Model.FLEX5000 || current_model == Model.FLEX3000)) ||
                            (hid_init && current_model == Model.FLEX1500))
                        {
                            if (preSelForm == null || preSelForm.IsDisposed)
                                preSelForm = new PreSelForm(this);
                            preSelForm.Show();
                            preSelForm.Focus();
                            preSelForm.WindowState = FormWindowState.Normal; // ke9ns add
                        }
                        break;
                    case Keys.T:
                        if (pa_present && current_model == Model.SDR1000)
                        {
                            if (PAQualForm == null || PAQualForm.IsDisposed)
                                PAQualForm = new PAQualify(this);
                            PAQualForm.Show();
                            PAQualForm.Focus();
                            PAQualForm.WindowState = FormWindowState.Normal; // ke9ns add
                        }
                        break;
                    case Keys.V:
                        if (fwc_init && current_model == Model.FLEX5000 && FWCEEPROM.VUOK)
                        {
                            if (flex5000VUCalForm == null || flex5000VUCalForm.IsDisposed)
                                flex5000VUCalForm = new FLEX5000VUCalForm(this);
                            flex5000VUCalForm.Show();
                            flex5000VUCalForm.Focus();
                            flex5000VUCalForm.WindowState = FormWindowState.Normal; // ke9ns add
                        }
                        break;
                }
                shift_down = false;

            } // if (e.Control == true && e.Shift == true)  // CTRL and SHIFT together

            else if (e.Control == true && e.Alt == true)     // ALT + CTRL keys are pressed
            {
                switch (e.KeyCode)
                {
                    case Keys.D4: // the 4 key
                        if (fwc_init && current_model == Model.FLEX5000)
                        {
                            if (flex5000LPFForm == null || flex5000LPFForm.IsDisposed)
                                flex5000LPFForm = new FLEX5000LPFForm();
                            flex5000LPFForm.Show();
                            flex5000LPFForm.Focus();
                            flex5000LPFForm.WindowState = FormWindowState.Normal; // ke9ns add
                        }
                        break;
                    case Keys.D:
                        if (dspTestForm == null || dspTestForm.IsDisposed)
                            dspTestForm = new DSPTestForm(this);
                        dspTestForm.Show();
                        dspTestForm.Focus();
                        dspTestForm.WindowState = FormWindowState.Normal; // ke9ns add
                        break;
                    case Keys.G:
                        if (hid_init && current_model == Model.FLEX1500)
                            CallCal1500TXImageComb();
                        break;
                    case Keys.R:
                        if (FWCEEPROM.RX2OK)
                        {
                            // DiversityForm diversityForm = new DiversityForm(this);  BT/2/24/11
                            if (diversityForm == null || diversityForm.IsDisposed)
                                diversityForm = new DiversityForm(this);
                            diversityForm.Focus();
                            diversityForm.Show();
                            diversityForm.WindowState = FormWindowState.Normal; // ke9ns add
                        }
                        break;
                    case Keys.U:
                        mnuUCB_Click(this, EventArgs.Empty);
                        break;
                    case Keys.F:
                        if (!chkFullDuplex.Visible) chkFullDuplex.Visible = true;
                        else chkFullDuplex.Visible = false;
                        break;
                    case Keys.A:
                        if (aboutForm == null || aboutForm.IsDisposed)
                            aboutForm = new AboutForm();
                        aboutForm.ShowDialog();
                        aboutForm.Focus();
                        break;
                }
            } //if(e.Control == true && e.Alt == true)     // ALT + CTRL keys are pressed

            else if (!enable_kb_shortcuts)
            {
                return; // dont go any further if shortcuts are not enabled in setup general
            }
            else if (e.Control && !e.Alt)       // CTRL key is pressed, ALT key NOT PRESSED
            {

                switch (e.KeyCode)
                {
                    case Keys.Add:
                        if (ptbRF.Value != ptbRF.Maximum)
                        {
                            ptbRF.Value++;
                            ptbRF_Scroll(this, EventArgs.Empty);
                        }
                        break;
                    case Keys.Subtract:
                        if (ptbRF.Value != ptbRF.Minimum)
                        {
                            ptbRF.Value--;
                            ptbRF_Scroll(this, EventArgs.Empty);
                        }
                        break;
                    case Keys.Left:
                        ChangeTuneStepUp();
                        e.Handled = true;
                        break;
                    case Keys.Right:
                        ChangeTuneStepDown();
                        e.Handled = true;
                        break;
                    case Keys.Up:

                        if (setupForm != null)
                        {
                            if (setupForm.chkBoxWheelRev.Checked == true) Console_MouseWheel(this, new MouseEventArgs(MouseButtons.None, 0, 0, 0, -120)); // reverse it here because I will reverse it again in the mousewheel routine
                            else Console_MouseWheel(this, new MouseEventArgs(MouseButtons.None, 0, 0, 0, 120));
                        }

                        //  Console_MouseWheel(this, new MouseEventArgs(MouseButtons.None, 0, 0, 0, 120));

                        e.Handled = true;
                        break;
                    case Keys.Down:

                        if (setupForm != null)
                        {
                            if (setupForm.chkBoxWheelRev.Checked == true) Console_MouseWheel(this, new MouseEventArgs(MouseButtons.None, 0, 0, 0, 120));
                            else Console_MouseWheel(this, new MouseEventArgs(MouseButtons.None, 0, 0, 0, -120));
                        }

                        //  Console_MouseWheel(this, new MouseEventArgs(MouseButtons.None, 0, 0, 0, -120));
                        e.Handled = true;
                        break;
                    case Keys.A:
                        if (RX1AGCMode == AGCMode.FAST)
                            RX1AGCMode = AGCMode.FIXD;
                        else RX1AGCMode++;
                        break;
                    case Keys.B:
                        chkNR.Checked = !chkNR.Checked;
                        break;
                    case Keys.C:
                        btnMemoryQuickSave_Click(this, EventArgs.Empty);
                        break;
                    case Keys.D:
                        switch (Display.CurrentDisplayMode)
                        {
                            case DisplayMode.PANADAPTER:
                                comboDisplayMode.Text = "Spectrum";
                                break;
                            case DisplayMode.SPECTRUM:
                                comboDisplayMode.Text = "Panadapter";
                                break;
                            default:
                                comboDisplayMode.Text = "Panadapter";
                                break;
                        }
                        break;
                    case Keys.E:                                     // and CTRL key is pressed
                        if (ptbRF.Value != ptbRF.Minimum)
                        {
                            ptbRF.Value--;
                            ptbRF_Scroll(this, EventArgs.Empty);
                        }
                        break;
                    case Keys.F:
                        int low = (int)udFilterLow.Value;
                        int high = (int)udFilterHigh.Value;
                        if (high - low > 10)
                        {
                            switch (rx1_dsp_mode)
                            {
                                case DSPMode.AM:
                                case DSPMode.SAM:
                                case DSPMode.DSB:
                                case DSPMode.FM:
                                case DSPMode.CWU:
                                case DSPMode.CWL:
                                    UpdateRX1Filters(low + 5, high - 5);
                                    break;
                                case DSPMode.USB:
                                case DSPMode.DIGU:
                                    UpdateRX1Filters(low, high - 10);
                                    break;
                                case DSPMode.LSB:
                                case DSPMode.DIGL:
                                    UpdateRX1Filters(low + 10, high);
                                    break;
                            }
                        }
                        break;
                    case Keys.L:
                        if (chkVFOLock.Enabled)
                            chkVFOLock.Checked = !chkVFOLock.Checked;
                        break;
                    case Keys.M:
                        if (chkMOX.Enabled) chkMOX.Checked = !mox;
                        break;
                    case Keys.N:
                        chkANF.Checked = !chkANF.Checked;
                        break;
                    case Keys.P:
                        RX1PreampMode = (PreampMode)(((int)rx1_preamp_mode + 1) % (int)PreampMode.LAST);
                        break;
                    case Keys.R:
                        if (ptbRF.Value != ptbRF.Maximum)
                        {
                            ptbRF.Value++;
                            ptbRF_Scroll(this, EventArgs.Empty);
                        }
                        break;
                    case Keys.S:
                        if (chkVFOSplit.Enabled)
                            chkVFOSplit.Checked = !chkVFOSplit.Checked;
                        break;
                    case Keys.V:
                        btnMemoryQuickRestore_Click(this, EventArgs.Empty);
                        break;
                    case Keys.W:
                        if (ptbCWSpeed.Value != ptbCWSpeed.Minimum)
                        {
                            ptbCWSpeed.Value--;
                            ptbCWSpeed_Scroll(this, EventArgs.Empty);
                        }
                        break;
                    case Keys.Z:  //.241 now zoom feature

                        // oldke9ns add show world map in window CTRL Z
                        //   if (helpbox1Form == null || helpbox1Form.IsDisposed) helpbox1Form = new helpbox1(this);
                        //   helpbox1Form.Show();
                        //   helpbox1Form.Focus();
                        //   helpbox1Form.WindowState = FormWindowState.Normal; // ke9ns add

                        //.241 e.control section creates ZoomX = XX and Y as well 
                        // .241 here is where we activate it

                        if (ZoomOn == false)
                        {
                            ZoomOn = true; //.241 toggle ON/OFF

                            MapNOAA = true; //.243

                            // if (initializing == false) NOAA(); //.242 update maps   NOAA(); //.242 update maps


                            int xx = picDisplay.Width;  // size of picdisplay as user scales it to their screen
                            int yy = picDisplay.Height;

                            //   Debug.WriteLine("Zoom displayarea width " + xx);
                            //   Debug.WriteLine("Zoom displayarea Height " + yy);

                            Point p = picDisplay.PointToClient(Cursor.Position); // mouse cursor 


                            float scalex = ((float)ZoomRealX / (float)xx); // get the cursor position as if the image was 1000x507 and not the current window size
                            ZoomX = (int)((float)p.X * scalex);

                            float scaley = ((float)ZoomRealY / (float)yy);
                            ZoomY = (int)((float)p.Y * scaley);


                            //  Debug.WriteLine("Zoom cursor " + p.X + " , " + p.Y);
                            //   Debug.WriteLine("Zoom scaled to 1000,507 X " + ZoomX); //.241
                            //  Debug.WriteLine("Zoom scaled to 1000,50 Y " + ZoomY);
                            //  Debug.WriteLine("Zoom On/OFF " + ZoomOn);

                            if (SpotForm != null) SpotForm.Darken();
                        }

                        break;
                }
            } // if(e.Control && !e.Alt)		// CTRL key is pressed

            else if (e.Alt && !e.Control)   //  ALT key is pressed, CTRL NOT PRESSED
            {
                switch (e.KeyCode)
                {
                    case Keys.Up:
                        if (ptbMic.Value != ptbMic.Maximum)
                        {
                            ptbMic.Value++;
                            ptbMic_Scroll(this, EventArgs.Empty);
                        }
                        break;
                    case Keys.Down:
                        if (ptbMic.Value != ptbMic.Minimum)
                        {
                            ptbMic.Value--;
                            ptbMic_Scroll(this, EventArgs.Empty);
                        }
                        break;
                    case Keys.Right:
                        if (ptbVOX.Value != ptbVOX.Maximum)
                        {
                            ptbVOX.Value++;
                            ptbVOX_Scroll(this, EventArgs.Empty);
                        }
                        break;
                    case Keys.Left:
                        if (ptbVOX.Value != ptbVOX.Minimum)
                        {
                            ptbVOX.Value--;
                            ptbVOX_Scroll(this, EventArgs.Empty);
                        }
                        break;
                    case Keys.Add:
                        if (ptbPWR.Value != ptbPWR.Maximum)
                        {
                            ptbPWR.Value++;
                            ptbPWR_Scroll(this, EventArgs.Empty);
                        }
                        break;
                    case Keys.Subtract:
                        if (ptbPWR.Value != ptbPWR.Minimum)
                        {
                            ptbPWR.Value--;
                            ptbPWR_Scroll(this, EventArgs.Empty);
                        }
                        break;
                    case Keys.B:
                        chkNB.Checked = !chkNB.Checked;
                        break;
                    case Keys.D:
                        chkEnableMultiRX.Checked = !chkEnableMultiRX.Checked;
                        break;
                    case Keys.F:
                        int low = (int)udFilterLow.Value;
                        int high = (int)udFilterHigh.Value;
                        switch (rx1_dsp_mode)
                        {
                            case DSPMode.AM:
                            case DSPMode.SAM:
                            case DSPMode.DSB:
                            case DSPMode.FM:
                            case DSPMode.CWU:
                            case DSPMode.CWL:
                                UpdateRX1Filters(low - 5, high + 5);
                                break;
                            case DSPMode.USB:
                            case DSPMode.DIGU:
                                UpdateRX1Filters(low, high + 10);
                                break;
                            case DSPMode.LSB:
                            case DSPMode.DIGL:
                                UpdateRX1Filters(low - 10, high);
                                break;
                        }
                        break;
                    case Keys.G:
                        btnVFOAtoB_Click(this, EventArgs.Empty);
                        break;
                    case Keys.H:
                        btnVFOBtoA_Click(this, EventArgs.Empty);
                        break;
                    case Keys.I:
                        btnFilterShiftReset_Click(this, EventArgs.Empty);
                        break;
                    case Keys.N:
                        chkDSPNB2.Checked = !chkDSPNB2.Checked;
                        break;
                    case Keys.Q:
                        if (ptbCWSpeed.Value != ptbCWSpeed.Maximum)
                        {
                            ptbCWSpeed.Value++;
                            ptbCWSpeed_Scroll(this, EventArgs.Empty);
                        }
                        break;
                    case Keys.R:
                        btnRITReset_Click(this, EventArgs.Empty);
                        break;
                    case Keys.T:
                        chkTUN.Checked = !chkTUN.Checked;
                        break;
                    case Keys.V:
                        btnVFOSwap_Click(this, EventArgs.Empty);
                        break;
                    case Keys.Y:
                        btnXITReset_Click(this, EventArgs.Empty);
                        break;
                    case Keys.Z:
                        if (btnZeroBeat.Enabled)
                            btnZeroBeat_Click(this, EventArgs.Empty);
                        break;
                }
            } // if(!e.Control && e.Alt)		//  ALT key is pressed, CTRL NOT PRESSED
            else if (!e.Alt && !e.Control) // ALT and CTRL NOT PRESSED
            {


                if (this.ActiveControl is TextBoxTS) return;
                if (this.ActiveControl is NumericUpDownTS) return;

                //   Debug.WriteLine("1keypressedCODE " + e.KeyCode);

                switch (e.KeyCode)
                {
                    case Keys.Multiply:
                        chkMUT.Checked = !chkMUT.Checked;
                        break;
                    case Keys.Add:
                        if (ptbAF.Value != ptbAF.Maximum)
                        {
                            ptbAF.Value++;
                            ptbAF_Scroll(this, EventArgs.Empty);
                        }
                        break;
                    case Keys.Subtract:
                        if (ptbAF.Value != ptbAF.Minimum)
                        {
                            ptbAF.Value--;
                            ptbAF_Scroll(this, EventArgs.Empty);
                        }
                        break;
                    case Keys.K:
                        int low = (int)udFilterLow.Value;
                        int high = (int)udFilterHigh.Value;
                        int increment = 0;

                        switch (rx1_dsp_mode)
                        {
                            case DSPMode.CWL:
                            case DSPMode.CWU:
                            case DSPMode.DIGL:
                            case DSPMode.DIGU:
                                increment = 10;
                                break;
                            default:
                                increment = 50;
                                break;
                        }
                        UpdateRX1Filters(low - increment, high - increment);
                        /*if(tbFilterShift.Value != tbFilterShift.Minimum)
								tbFilterShift.Value--;
							tbFilterShift_Scroll(this, EventArgs.Empty);*/
                        break;
                    case Keys.L:
                        low = (int)udFilterLow.Value;
                        high = (int)udFilterHigh.Value;
                        increment = 0;
                        switch (rx1_dsp_mode)
                        {
                            case DSPMode.CWL:
                            case DSPMode.CWU:
                            case DSPMode.DIGL:
                            case DSPMode.DIGU:
                                increment = 10;
                                break;
                            default:
                                increment = 50;
                                break;
                        }
                        UpdateRX1Filters(low + increment, high + increment);
                        /*if(tbFilterShift.Value != tbFilterShift.Maximum)
								tbFilterShift.Value++;
							tbFilterShift_Scroll(this, EventArgs.Empty);*/
                        break;


                } // e.keycode

                if (e.KeyCode == key_tune_up_1)
                {
                    double freq = Double.Parse(txtVFOAFreq.Text);
                    freq += 1.0;
                    VFOAFreq = freq;
                }
                else if (e.KeyCode == key_tune_down_1)
                {
                    double freq = Double.Parse(txtVFOAFreq.Text);
                    freq -= 1.0;
                    VFOAFreq = freq;
                }
                else if (e.KeyCode == key_tune_up_2)
                {
                    double freq = Double.Parse(txtVFOAFreq.Text);
                    freq += 0.1;
                    VFOAFreq = freq;
                }
                else if (e.KeyCode == key_tune_down_2)
                {

                    double freq = Double.Parse(txtVFOAFreq.Text);
                    freq -= 0.1;
                    VFOAFreq = freq;
                }
                else if (e.KeyCode == key_tune_up_3)
                {
                    double freq = Double.Parse(txtVFOAFreq.Text);
                    freq += 0.01;
                    VFOAFreq = freq;
                }
                else if (e.KeyCode == key_tune_down_3)
                {
                    double freq = Double.Parse(txtVFOAFreq.Text);
                    freq -= 0.01;
                    VFOAFreq = freq;
                }
                else if (e.KeyCode == key_tune_up_4)
                {
                    double freq = Double.Parse(txtVFOAFreq.Text);
                    freq += 0.001;
                    VFOAFreq = freq;
                }
                else if (e.KeyCode == key_tune_down_4)
                {
                    double freq = Double.Parse(txtVFOAFreq.Text);
                    freq -= 0.001;
                    VFOAFreq = freq;
                }
                else if (e.KeyCode == key_tune_up_5)
                {
                    double freq = Double.Parse(txtVFOAFreq.Text);
                    freq += 0.0001;
                    VFOAFreq = freq;
                }
                else if (e.KeyCode == key_tune_down_5)
                {
                    double freq = Double.Parse(txtVFOAFreq.Text);
                    freq -= 0.0001;
                    VFOAFreq = freq;
                }
                else if (e.KeyCode == key_tune_up_6)
                {
                    double freq = Double.Parse(txtVFOAFreq.Text);
                    freq += 0.00001;
                    VFOAFreq = freq;
                }
                else if (e.KeyCode == key_tune_down_6)
                {
                    double freq = Double.Parse(txtVFOAFreq.Text);
                    freq -= 0.00001;
                    VFOAFreq = freq;
                }
                else if (e.KeyCode == key_tune_up_7)
                {
                    double freq = Double.Parse(txtVFOAFreq.Text);
                    freq += 0.000001;
                    VFOAFreq = freq;
                }
                else if (e.KeyCode == key_tune_down_7)
                {
                    double freq = Double.Parse(txtVFOAFreq.Text);
                    freq -= 0.000001;
                    VFOAFreq = freq;
                }
                else if (e.KeyCode == key_rit_up)
                {
                    udRIT.Value += udRIT.Increment;
                }
                else if (e.KeyCode == key_rit_down)
                {
                    udRIT.Value -= udRIT.Increment;
                }
                else if (e.KeyCode == key_xit_up)
                {
                    udXIT.Value += udXIT.Increment;
                }
                else if (e.KeyCode == key_xit_down)
                {
                    udXIT.Value -= udXIT.Increment;
                }
                else if (e.KeyCode == key_filter_up)
                {
                    if (rx1_filter == Filter.NONE)
                        return;
                    if (rx1_filter == Filter.VAR2)
                        RX1Filter = Filter.F1;
                    else
                        RX1Filter++;
                }
                else if (e.KeyCode == key_filter_down)
                {
                    if (rx1_filter == Filter.NONE)
                        return;
                    if (rx1_filter == Filter.F1)
                        RX1Filter = Filter.VAR2;
                    else
                        RX1Filter--;
                }
                else if (e.KeyCode == key_mode_up)
                {
                    switch (rx1_dsp_mode)
                    {
                        case DSPMode.LSB:
                            RX1DSPMode = DSPMode.USB;
                            break;
                        case DSPMode.USB:
                            RX1DSPMode = DSPMode.DSB;
                            break;
                        case DSPMode.DSB:
                            RX1DSPMode = DSPMode.CWL;
                            break;
                        case DSPMode.CWL:
                            RX1DSPMode = DSPMode.CWU;
                            break;
                        case DSPMode.CWU:
                            RX1DSPMode = DSPMode.FM;
                            break;
                        case DSPMode.FM:
                            RX1DSPMode = DSPMode.AM;
                            break;
                        case DSPMode.AM:
                            RX1DSPMode = DSPMode.SAM;
                            break;
                        case DSPMode.SAM:
                            RX1DSPMode = DSPMode.DIGL;
                            break;
                        case DSPMode.DIGL:
                            RX1DSPMode = DSPMode.DIGU;
                            break;
                        case DSPMode.DIGU:
                            RX1DSPMode = DSPMode.SPEC;
                            break;
                        case DSPMode.SPEC:
                            RX1DSPMode = DSPMode.DRM;
                            break;
                        case DSPMode.DRM:
                            RX1DSPMode = DSPMode.LSB;
                            break;
                    }
                } // if (e.keycode == keymode up

                else if (e.KeyCode == key_mode_down)
                {
                    switch (rx1_dsp_mode)
                    {
                        case DSPMode.LSB:
                            RX1DSPMode = DSPMode.DRM;
                            break;
                        case DSPMode.USB:
                            RX1DSPMode = DSPMode.LSB;
                            break;
                        case DSPMode.DSB:
                            RX1DSPMode = DSPMode.USB;
                            break;
                        case DSPMode.CWL:
                            RX1DSPMode = DSPMode.DSB;
                            break;
                        case DSPMode.CWU:
                            RX1DSPMode = DSPMode.CWL;
                            break;
                        case DSPMode.FM:
                            RX1DSPMode = DSPMode.CWU;
                            break;
                        case DSPMode.AM:
                            RX1DSPMode = DSPMode.FM;
                            break;
                        case DSPMode.SAM:
                            RX1DSPMode = DSPMode.AM;
                            break;
                        case DSPMode.DIGL:
                            RX1DSPMode = DSPMode.SAM;
                            break;
                        case DSPMode.DIGU:
                            RX1DSPMode = DSPMode.DIGL;
                            break;
                        case DSPMode.SPEC:
                            RX1DSPMode = DSPMode.DIGU;
                            break;
                        case DSPMode.DRM:
                            RX1DSPMode = DSPMode.SPEC;
                            break;
                    }
                } //  if(e.KeyCode == keymode down

                else if (e.KeyCode == key_band_up && !vfo_lock) // M key
                {
                    switch (rx1_band)
                    {
                        case Band.B160M:
                            if (band_160m_index == (band_160m_register - 1)) // was 2
                            {
                                band_80m_index = 0;
                                radBand80_Click(this, EventArgs.Empty);
                            }
                            else
                            {
                                radBand160_Click(this, EventArgs.Empty);
                            }
                            break;
                        case Band.B80M:
                            if (band_80m_index == band_80m_register - 1) // was 2
                            {
                                band_60m_index = 0;
                                radBand60_Click(this, EventArgs.Empty);
                            }
                            else
                            {
                                radBand80_Click(this, EventArgs.Empty);
                            }
                            break;
                        case Band.B60M:
                            switch (current_region)
                            {
                                case FRSRegion.US:
                                    if (band_60m_index == 4) 	// 5 60m channels
                                    {
                                        band_40m_index = 0;
                                        radBand40_Click(this, EventArgs.Empty);
                                    }
                                    else
                                    {
                                        radBand60_Click(this, EventArgs.Empty);
                                    }
                                    break;

                                case FRSRegion.UK_Plus:
                                    if (band_60m_index == 10) // 11 60m channels
                                    {
                                        band_40m_index = 0;
                                        radBand40_Click(this, EventArgs.Empty);
                                    }
                                    else
                                    {
                                        radBand60_Click(this, EventArgs.Empty);
                                    }
                                    break;

                                // w4tme FRSRegions that do not use a channelized 60m band will all have 5 band stack registers for 60m to align with IARU Regions 1 & 2
                                case FRSRegion.UK:
                                case FRSRegion.Europe:
                                case FRSRegion.Italy:
                                case FRSRegion.Norway:
                                case FRSRegion.Denmark:
                                case FRSRegion.Latvia:
                                case FRSRegion.Slovakia:
                                case FRSRegion.Bulgaria:
                                case FRSRegion.Greece:
                                case FRSRegion.Hungary:
                                case FRSRegion.Belgium:
                                case FRSRegion.France:
                                case FRSRegion.Russia:
                                case FRSRegion.Sweden:
                                case FRSRegion.IARU3:
                                case FRSRegion.Japan:
                                case FRSRegion.Italy_Plus:
                                case FRSRegion.ES_CH_FIN:
                                case FRSRegion.Netherlands:
                                case FRSRegion.EU_Travel:
                                case FRSRegion.Luxembourg:
                                case FRSRegion.IARU2:
                                case FRSRegion.Australia:
                                case FRSRegion.China:

                                    if (band_60m_index == 4)  // 5 60m channels for all entities
                                    {
                                        band_40m_index = 0;
                                        radBand40_Click(this, EventArgs.Empty);
                                    }
                                    else
                                    {
                                        radBand60_Click(this, EventArgs.Empty);
                                    }
                                    break;

                                default:
                                    if (band_60m_index == band_60m_register - 1) // was 2
                                    {
                                        band_40m_index = 0;
                                        radBand40_Click(this, EventArgs.Empty);
                                    }
                                    else
                                    {
                                        radBand60_Click(this, EventArgs.Empty);
                                    }
                                    break;
                            }
                            break;
                        case Band.B40M:
                            if (band_40m_index == band_40m_register - 1) // was 2
                            {
                                band_30m_index = 0;
                                radBand30_Click(this, EventArgs.Empty);
                            }
                            else
                            {
                                radBand40_Click(this, EventArgs.Empty);
                            }
                            break;
                        case Band.B30M:
                            if (band_30m_index == band_30m_register - 1)  // was 2
                            {
                                band_20m_index = 0;
                                radBand20_Click(this, EventArgs.Empty);
                            }
                            else
                            {
                                radBand30_Click(this, EventArgs.Empty);
                            }
                            break;
                        case Band.B20M:
                            if (band_20m_index == band_20m_register - 1) // was 2
                            {
                                band_17m_index = 0;
                                radBand17_Click(this, EventArgs.Empty);
                            }
                            else
                            {
                                radBand20_Click(this, EventArgs.Empty);
                            }
                            break;
                        case Band.B17M:
                            if (band_17m_index == band_17m_register - 1)
                            {
                                band_15m_index = 0;
                                radBand15_Click(this, EventArgs.Empty);
                            }
                            else
                            {
                                radBand17_Click(this, EventArgs.Empty);
                            }
                            break;
                        case Band.B15M:
                            if (band_15m_index == band_15m_register - 1)
                            {
                                band_12m_index = 0;
                                radBand12_Click(this, EventArgs.Empty);
                            }
                            else
                            {
                                radBand15_Click(this, EventArgs.Empty);
                            }
                            break;
                        case Band.B12M:
                            if (band_12m_index == band_12m_register - 1)
                            {
                                band_10m_index = 0;
                                radBand10_Click(this, EventArgs.Empty);
                            }
                            else
                            {
                                radBand12_Click(this, EventArgs.Empty);
                            }
                            break;
                        case Band.B10M:
                            if (band_10m_index == band_10m_register - 1)
                            {
                                band_6m_index = 0;
                                radBand6_Click(this, EventArgs.Empty);
                            }
                            else
                            {
                                radBand10_Click(this, EventArgs.Empty);
                            }
                            break;
                        case Band.B6M:
                            if (band_6m_index == band_6m_register - 1)
                            {
                                band_LMF_index = 0;  // ke9ns add
                                radBandGEN0_Click(this, EventArgs.Empty);  // ke9ns add

                                //	if(XVTRPresent)
                                //	{
                                //		band_2m_index = 0;
                                //       radBand2_Click(this, EventArgs.Empty);
                                //	}
                                //	else
                                //	{
                                //		band_wwv_index = 0;
                                //       radBandWWV_Click(this, EventArgs.Empty);
                                //	}
                            }
                            else
                            {
                                radBand6_Click(this, EventArgs.Empty);
                            }
                            break;
                        //-------------------------------------------------------
                        // ke9ns add
                        case Band.BLMF:
                            if (band_LMF_index == band_LMF_register - 1)
                            {
                                band_120m_index = 0;
                                radBandGEN1_Click(this, EventArgs.Empty);
                            }
                            else
                            {
                                radBandGEN0_Click(this, EventArgs.Empty);
                            }
                            break;
                        case Band.B120M:
                            if (band_120m_index == band_120m_register - 1)
                            {
                                band_90m_index = 0;
                                radBandGEN2_Click(this, EventArgs.Empty);
                            }
                            else
                            {
                                radBandGEN1_Click(this, EventArgs.Empty);
                            }
                            break;
                        case Band.B90M:
                            if (band_90m_index == band_90m_register - 1)
                            {
                                band_61m_index = 0;
                                radBandGEN3_Click(this, EventArgs.Empty);
                            }
                            else
                            {
                                radBandGEN2_Click(this, EventArgs.Empty);
                            }
                            break;
                        case Band.B61M:
                            if (band_61m_index == band_61m_register - 1)
                            {
                                band_49m_index = 0;
                                radBandGEN4_Click(this, EventArgs.Empty);
                            }
                            else
                            {
                                radBandGEN3_Click(this, EventArgs.Empty);
                            }
                            break;

                        case Band.B49M:
                            if (band_49m_index == band_49m_register - 1)
                            {
                                band_41m_index = 0;
                                radBandGEN5_Click(this, EventArgs.Empty);
                            }
                            else
                            {
                                radBandGEN4_Click(this, EventArgs.Empty);
                            }
                            break;
                        case Band.B41M:
                            if (band_41m_index == band_41m_register - 1)
                            {
                                band_31m_index = 0;
                                radBandGEN6_Click(this, EventArgs.Empty);
                            }
                            else
                            {
                                radBandGEN5_Click(this, EventArgs.Empty);
                            }
                            break;
                        case Band.B31M:
                            if (band_31m_index == band_31m_register - 1)
                            {
                                band_25m_index = 0;
                                radBandGEN7_CheckedChanged(this, EventArgs.Empty);
                            }
                            else
                            {
                                radBandGEN6_Click(this, EventArgs.Empty);
                            }
                            break;

                        case Band.B25M:
                            if (band_25m_index == band_25m_register - 1)
                            {
                                band_22m_index = 0;
                                radBandGEN8_Click(this, EventArgs.Empty);
                            }
                            else
                            {
                                radBandGEN7_CheckedChanged(this, EventArgs.Empty);
                            }
                            break;
                        case Band.B22M:
                            if (band_22m_index == band_22m_register - 1)
                            {
                                band_19m_index = 0;
                                radBandGEN9_Click(this, EventArgs.Empty);
                            }
                            else
                            {
                                radBandGEN8_Click(this, EventArgs.Empty);
                            }
                            break;
                        case Band.B19M:
                            if (band_19m_index == band_19m_register - 1)
                            {
                                band_16m_index = 0;
                                radBandGEN10_Click(this, EventArgs.Empty);
                            }
                            else
                            {
                                radBandGEN9_Click(this, EventArgs.Empty);
                            }
                            break;
                        case Band.B16M:
                            if (band_16m_index == band_16m_register - 1)
                            {
                                band_14m_index = 0;
                                radBandGEN11_Click(this, EventArgs.Empty);
                            }
                            else
                            {
                                radBandGEN10_Click(this, EventArgs.Empty);
                            }
                            break;
                        case Band.B14M:
                            if (band_14m_index == band_14m_register - 1)
                            {
                                band_13m_index = 0;
                                radBandGEN12_Click(this, EventArgs.Empty);
                            }
                            else
                            {
                                radBandGEN11_Click(this, EventArgs.Empty);
                            }
                            break;
                        case Band.B13M:
                            if (band_13m_index == band_13m_register - 1)
                            {
                                band_11m_index = 0;
                                radBandGEN13_Click(this, EventArgs.Empty);
                            }
                            else
                            {
                                radBandGEN12_Click(this, EventArgs.Empty);
                            }
                            break;
                        case Band.B11M:
                            if (band_11m_index == band_11m_register - 1)
                            {
                                if (XVTRPresent)
                                {
                                    band_2m_index = 0;
                                    radBand2_Click(this, EventArgs.Empty); // ke9ns: this is now the 630m band button
                                }
                                else
                                {
                                    band_wwv_index = 0;
                                    radBandWWV_Click(this, EventArgs.Empty);
                                }
                            }
                            else
                            {
                                radBandGEN12_Click(this, EventArgs.Empty);
                            }
                            break;

                        //-----------------------------------------------------
                        case Band.B2M:
                            if (band_2m_index == band_2m_register - 1)
                            {
                                band_wwv_index = 0;
                                radBandWWV_Click(this, EventArgs.Empty);
                            }
                            else
                            {
                                radBand2_Click(this, EventArgs.Empty);
                            }
                            break;
                        case Band.WWV:
                            if (band_wwv_index == band_wwv_register - 1) // ke9ns mod  was 7
                            {
                                band_gen_index = 0;
                                radBandGEN_Click(this, EventArgs.Empty);
                            }
                            else
                            {
                                radBandWWV_Click(this, EventArgs.Empty);
                            }
                            break;
                            /*	case Band.GEN:                            // ke9ns not going to mess with original function of GEN from keyboard or cat
                                    if(band_gen_index == 4)
                                    {
                                        band_160m_index = 0;
                                        radBand160_Click(this, EventArgs.Empty);
                                    }
                                    else
                                    {
                                        radBandGEN_Click(this, EventArgs.Empty);
                                    }
                                    break;
                                    */
                    }
                } //  if(e.KeyCode == key_band_up && !vfo_lock) // keys.M key

                else if (e.KeyCode == key_band_down && !vfo_lock) // keys.N key
                {
                    switch (rx1_band)
                    {
                        case Band.B160M:
                            if (band_160m_index == 0)
                            {
                                band_gen_index = 4;
                                radBandGEN_Click(this, EventArgs.Empty);
                            }
                            else
                            {
                                last_band = "160M";
                                band_160m_index = (band_160m_index + 1) % band_160m_register;
                                radBand160_Click(this, EventArgs.Empty);
                            }
                            break;
                        case Band.B80M:
                            if (band_80m_index == 0)
                            {
                                band_160m_index = 2;
                                radBand160_Click(this, EventArgs.Empty);
                            }
                            else
                            {
                                last_band = "80M";
                                band_80m_index = (band_80m_index + 1) % band_80m_register;
                                radBand80_Click(this, EventArgs.Empty);
                            }
                            break;
                        case Band.B60M:
                            if (band_60m_index == 0)
                            {
                                band_80m_index = 2;
                                radBand80_Click(this, EventArgs.Empty);
                            }
                            else
                            {
                                last_band = "60M";
                                band_60m_index = (band_60m_index + 3) % band_60m_register;
                                radBand60_Click(this, EventArgs.Empty);
                            }
                            break;
                        case Band.B40M:
                            if (band_40m_index == 0)
                            {
                                band_60m_index = 4;
                                radBand60_Click(this, EventArgs.Empty);
                            }
                            else
                            {
                                last_band = "40M";
                                band_40m_index = (band_40m_index + 1) % band_40m_register;
                                radBand40_Click(this, EventArgs.Empty);
                            }
                            break;
                        case Band.B30M:
                            if (band_30m_index == 0)
                            {
                                band_40m_index = 2;
                                radBand40_Click(this, EventArgs.Empty);
                            }
                            else
                            {
                                last_band = "30M";
                                band_30m_index = (band_30m_index + 1) % band_30m_register;
                                radBand30_Click(this, EventArgs.Empty);
                            }
                            break;
                        case Band.B20M:
                            if (band_20m_index == 0)
                            {
                                band_30m_index = 2;
                                radBand30_Click(this, EventArgs.Empty);
                            }
                            else
                            {
                                last_band = "20M";
                                band_20m_index = (band_20m_index + 1) % band_20m_register;
                                radBand20_Click(this, EventArgs.Empty);
                            }
                            break;
                        case Band.B17M:
                            if (band_17m_index == 0)
                            {
                                band_20m_index = 2;
                                radBand20_Click(this, EventArgs.Empty);
                            }
                            else
                            {
                                last_band = "17M";
                                band_17m_index = (band_17m_index + 1) % band_17m_register;
                                radBand17_Click(this, EventArgs.Empty);
                            }
                            break;
                        case Band.B15M:
                            if (band_15m_index == 0)
                            {
                                band_17m_index = 2;
                                radBand17_Click(this, EventArgs.Empty);
                            }
                            else
                            {
                                last_band = "15M";
                                band_15m_index = (band_15m_index + 1) % band_15m_register;
                                radBand15_Click(this, EventArgs.Empty);
                            }
                            break;
                        case Band.B12M:
                            if (band_12m_index == 0)
                            {
                                band_15m_index = 2;
                                radBand15_Click(this, EventArgs.Empty);
                            }
                            else
                            {
                                last_band = "12M";
                                band_12m_index = (band_12m_index + 1) % band_12m_register;
                                radBand12_Click(this, EventArgs.Empty);
                            }
                            break;
                        case Band.B10M:
                            if (band_10m_index == 0)
                            {
                                band_12m_index = 2;
                                radBand12_Click(this, EventArgs.Empty);
                            }
                            else
                            {
                                last_band = "10M";
                                band_10m_index = (band_10m_index + 1) % band_10m_register;
                                radBand10_Click(this, EventArgs.Empty);
                            }
                            break;
                        case Band.B6M:
                            if (band_6m_index == 0)
                            {
                                band_10m_index = 2;
                                radBand10_Click(this, EventArgs.Empty);
                            }
                            else
                            {
                                last_band = "6M";
                                band_6m_index = (band_6m_index + 1) % band_6m_register;
                                radBand6_Click(this, EventArgs.Empty);
                            }
                            break;

                        //-------------------------------------------------------
                        // ke9ns add
                        case Band.BLMF:
                            if (band_LMF_index == 2)
                            {
                                band_6m_index = 0;
                                radBand6_Click(this, EventArgs.Empty);
                            }
                            else
                            {
                                last_band = "LMF";
                                band_LMF_index = (band_LMF_index + 1) % band_LMF_register;
                                radBandGEN0_Click(this, EventArgs.Empty);
                            }
                            break;
                        case Band.B120M:
                            if (band_120m_index == 2)
                            {
                                band_LMF_index = 0;
                                radBandGEN0_Click(this, EventArgs.Empty);
                            }
                            else
                            {
                                last_band = "120M";
                                band_120m_index = (band_120m_index + 1) % band_120m_register;
                                radBandGEN1_Click(this, EventArgs.Empty);
                            }
                            break;
                        case Band.B90M:
                            if (band_90m_index == 2)
                            {
                                band_120m_index = 0;
                                radBandGEN1_Click(this, EventArgs.Empty);
                            }
                            else
                            {
                                last_band = "90M";
                                band_90m_index = (band_90m_index + 1) % band_90m_register;
                                radBandGEN2_Click(this, EventArgs.Empty);
                            }
                            break;
                        case Band.B61M:
                            if (band_61m_index == 2)
                            {
                                band_90m_index = 0;
                                radBandGEN2_Click(this, EventArgs.Empty);
                            }
                            else
                            {
                                last_band = "61M";
                                band_61m_index = (band_61m_index + 1) % band_61m_register;
                                radBandGEN3_Click(this, EventArgs.Empty);
                            }
                            break;

                        case Band.B49M:
                            if (band_49m_index == 2)
                            {
                                band_61m_index = 0;
                                radBandGEN3_Click(this, EventArgs.Empty);
                            }
                            else
                            {
                                last_band = "49M";
                                band_49m_index = (band_49m_index + 1) % band_49m_register;
                                radBandGEN4_Click(this, EventArgs.Empty);
                            }
                            break;
                        case Band.B41M:
                            if (band_41m_index == 2)
                            {
                                band_49m_index = 0;
                                radBandGEN4_Click(this, EventArgs.Empty);
                            }
                            else
                            {
                                last_band = "41M";
                                band_41m_index = (band_41m_index + 1) % band_41m_register;
                                radBandGEN5_Click(this, EventArgs.Empty);
                            }
                            break;
                        case Band.B31M:
                            if (band_31m_index == 2)
                            {
                                band_41m_index = 0;
                                radBandGEN5_Click(this, EventArgs.Empty);
                            }
                            else
                            {
                                last_band = "31M";
                                band_31m_index = (band_31m_index + 1) % band_31m_register;
                                radBandGEN6_Click(this, EventArgs.Empty);
                            }
                            break;

                        case Band.B25M:
                            if (band_25m_index == 2)
                            {
                                band_31m_index = 0;
                                radBandGEN6_Click(this, EventArgs.Empty);
                            }
                            else
                            {
                                last_band = "25M";
                                band_25m_index = (band_25m_index + 1) % band_25m_register;
                                radBandGEN7_CheckedChanged(this, EventArgs.Empty);
                            }
                            break;
                        case Band.B22M:
                            if (band_22m_index == 2)
                            {
                                band_25m_index = 0;
                                radBandGEN7_CheckedChanged(this, EventArgs.Empty);
                            }
                            else
                            {
                                last_band = "22M";
                                band_22m_index = (band_22m_index + 1) % band_22m_register;
                                radBandGEN8_Click(this, EventArgs.Empty);
                            }
                            break;
                        case Band.B19M:
                            if (band_19m_index == 2)
                            {
                                band_22m_index = 0;
                                radBandGEN8_Click(this, EventArgs.Empty);
                            }
                            else
                            {
                                last_band = "19M";
                                band_19m_index = (band_19m_index + 1) % band_19m_register;
                                radBandGEN9_Click(this, EventArgs.Empty);
                            }
                            break;
                        case Band.B16M:
                            if (band_16m_index == 2)
                            {
                                band_19m_index = 0;
                                radBandGEN9_Click(this, EventArgs.Empty);
                            }
                            else
                            {
                                last_band = "16M";
                                band_16m_index = (band_16m_index + 1) % band_16m_register;
                                radBandGEN10_Click(this, EventArgs.Empty);
                            }
                            break;
                        case Band.B14M:
                            if (band_14m_index == 2)
                            {
                                band_16m_index = 0;
                                radBandGEN10_Click(this, EventArgs.Empty);
                            }
                            else
                            {
                                last_band = "14M";
                                band_14m_index = (band_14m_index + 1) % band_14m_register;
                                radBandGEN11_Click(this, EventArgs.Empty);
                            }
                            break;
                        case Band.B13M:
                            if (band_13m_index == 2)
                            {
                                band_14m_index = 0;
                                radBandGEN11_Click(this, EventArgs.Empty);
                            }
                            else
                            {
                                last_band = "13M";
                                band_13m_index = (band_13m_index + 1) % band_13m_register;
                                radBandGEN12_Click(this, EventArgs.Empty);
                            }
                            break;
                        case Band.B11M:
                            if (band_11m_index == 2)
                            {
                                band_13m_index = 0;
                                radBandGEN11_Click(this, EventArgs.Empty);
                            }
                            else
                            {
                                last_band = "11M";
                                band_11m_index = (band_11m_index + 1) % band_11m_register;
                                radBandGEN12_Click(this, EventArgs.Empty);
                            }
                            break;

                        //-----------------------------------------------------

                        case Band.B2M:
                            if (band_2m_index == 0)
                            {
                                //band_6m_index = 2;
                                //  radBand6_Click(this, EventArgs.Empty);
                                band_11m_index = 0;
                                radBandGEN12_Click(this, EventArgs.Empty);

                            }
                            else
                            {
                                last_band = "2M";
                                band_2m_index = (band_2m_index + 1) % band_2m_register;
                                radBand6_Click(this, EventArgs.Empty);
                            }
                            break;
                        case Band.WWV:
                            if (band_wwv_index == 0)
                            {
                                if (xvtr_present)
                                {
                                    band_2m_index = 2;
                                    radBand2_Click(this, EventArgs.Empty);
                                }
                                else
                                {
                                    band_6m_index = 2;
                                    radBand6_Click(this, EventArgs.Empty);
                                }
                            }
                            else
                            {
                                last_band = "WWV";
                                band_wwv_index = (band_wwv_index + 7) % band_wwv_register; //ke9ns mod was 6
                                radBandWWV_Click(this, EventArgs.Empty);
                            }
                            break;
                            /*	case Band.GEN:
                                    if(band_gen_index == 0)
                                    {
                                        band_wwv_index = 7;
                                        radBandWWV_Click(this, EventArgs.Empty);
                                    }
                                    else
                                    {
                                        last_band = "GEN";
                                        band_gen_index = (band_gen_index+3)%5;
                                        radBandGEN_Click(this, EventArgs.Empty);
                                    }
                                    break;
        */
                            // ke9ns could add GEN SWL Bands here later


                    } // switch rx1 band

                } // if(e.KeyCode == key_band_down && !vfo_lock)

                else if (e.KeyCode == key_cw_dot) // .
                {

                }
                else if (e.KeyCode == key_cw_dash) // ?
                {

                }
                else if (vfo_lock || !quick_qsy)
                {
                    return;
                }
                else if ((int)e.KeyCode >= 48 && (int)e.KeyCode <= 57) // check for numbers 0 to 9
                {
                    if (small_lsd)
                    {
                        txtVFOAMSD.Visible = false;
                        txtVFOALSD.Visible = false;
                    }
                    txtVFOAFreq.Focus();
                    txtVFOAFreq.Text = ((int)(e.KeyCode - 48)).ToString();
                    txtVFOAFreq.Select(1, 0);
                }
                else if ((int)e.KeyCode >= 96 && (int)e.KeyCode <= 105) // codes ' thru i 
                {
                    if (small_lsd)
                    {
                        txtVFOAMSD.Visible = false;
                        txtVFOALSD.Visible = false;
                    }
                    txtVFOAFreq.Focus();
                    txtVFOAFreq.Text = ((int)e.KeyCode - 96).ToString();
                    txtVFOAFreq.Select(1, 0);
                }
                else if (e.KeyCode.Equals(Keys.Decimal) ||
                    (separator == "." && e.KeyCode.Equals(Keys.OemPeriod)) ||
                    (separator == "," && e.KeyCode.Equals(Keys.Oemcomma)))
                {
                    if (small_lsd)
                    {
                        txtVFOAMSD.Visible = false;
                        txtVFOALSD.Visible = false;
                    }
                    txtVFOAFreq.Focus();
                    txtVFOAFreq.Text = separator;
                    txtVFOAFreq.Select(1, 0);
                }


                //   Debug.WriteLine("5KEYPRESS================= " + e.KeyCode);


            } // NO ALT and NO CTRL key pressed

        } // CONSOLE_KEYDOWN()


        //=======================================================================================================
        // chkPower
        private bool one_time = true;
        private void chkPower_CheckedChanged(object sender, System.EventArgs e)
        {

            if (chkPower.Checked)
            {
                //  if (N1MM_RESIZE)
                // {
                //    N1MM = true;
                //   N1MM_RESIZE = false;
                //  }

                ptbDisplayPan_Scroll(chkPower, EventArgs.Empty); //.225
                ptbDisplayPan2_Scroll(chkPower, EventArgs.Empty); //.225


                IIC_AMPCONTROL(AMPBAND, AMPBAND1); // ke9ns add to update band data at Turn ON

                //  Display.Power = 1;

                //chkPower.Text = "Stop";
                chkPower.BackColor = button_selected_color;
                txtVFOAFreq.ForeColor = vfo_text_light_color;
                txtVFOAMSD.ForeColor = vfo_text_light_color;
                txtVFOALSD.ForeColor = small_vfo_color;
                if (chkVOX.Checked) chkVOX.Checked = false;

                UpdateVFOASub();

                if (rx2_enabled && PowerRX2Pause == false) chkRX2_CheckedChanged(this, EventArgs.Empty); //.233 mod add PowerRX2Pause
                if (chkEnableMultiRX.Checked) chEnableMultiRX_CheckedChanged(this, EventArgs.Empty);
                if (chkVFOSplit.Checked) chkVFOSplit_CheckedChanged(this, EventArgs.Empty);

                switch (current_model)
                {
                    case Model.SDR1000:
                        Hdw.PowerOn();
                        Hdw.DDSTuningWord = 0;
                        break;

                    case Model.FLEX5000:
                        if (fwc_init) FWC.SetStandby(false);
                        fwc_dds_freq = 0.0f;
                        last_tw = 0;
                        rx2_dds_freq = 0.0f;
                        rx2_last_tw = 0;
                        RX1Ant = rx1_ant;
                        break;

                    case Model.FLEX3000:
                        if (fwc_init) FWC.SetStandby(false);
                        fwc_dds_freq = 0.0f;
                        last_tw = 0;
                        break;

                    case Model.FLEX1500:
                        fwc_dds_freq = 0.0f;
                        last_tw = 0;
                        break;
                }

                if (fwc_init && (current_model == Model.FLEX3000 || current_model == Model.FLEX5000))
                {
                    try
                    {
                        Pal.SetBufferSize((uint)block_size1);
                    }
                    catch (Exception)
                    {
                        // ignore exceptions in case version of PAL dll doesn't support this function
                    }
                }

                txtVFOAFreq_LostFocus(this, EventArgs.Empty);
                txtVFOBFreq_LostFocus(this, EventArgs.Empty);


                // wjt added 
                if (PTTBitBangEnabled && serialPTT == null) // we are enabled but don't have port object 
                {
                    //Debug.WriteLine("Forcing property set on PTTBitBangEnabled"); 
                    PTTBitBangEnabled = true; // force creation of serial ptt 
                }
                // wjt added ends 
                setupForm.AudioReceiveMux1 = setupForm.AudioReceiveMux1;        // set receive mux


                Audio.callback_return = 0;

                if (vac_enabled)
                {
                    Audio.VACRBReset = true;
                    Audio.VACEnabled = true;
                }

                if (vac2_enabled)
                {
                    Audio.VAC2RBReset = true;
                    Audio.VAC2Enabled = true;
                }

                Thread.Sleep(100); // wait for hardware to settle before starting audio (possible sample rate change)

                switch (current_model)
                {
                    case Model.FLEX5000:
                    case Model.FLEX3000:
                    case Model.SDR1000:
                    case Model.DEMO:
                        //  case Model.SOFTROCK40:
                        if (!Audio.Start())
                        {
                            chkPower.Checked = false;
                            return;
                        }
                        break;
                    case Model.FLEX1500:
                        if (!Audio.Start()) // to start VAC
                        {
                            chkPower.Checked = false;
                            return;
                        }
                        Flex1500.StartAudio();
                        break;
                }

                if (draw_display_thread == null || !draw_display_thread.IsAlive)
                {
                    draw_display_thread = new Thread(new ThreadStart(RunDisplay));
                    draw_display_thread.Name = "Draw Display Thread";
                    draw_display_thread.Priority = ThreadPriority.BelowNormal;
                    draw_display_thread.IsBackground = true;
                    draw_display_thread.Start();
                }

                if (multimeter_thread == null || !multimeter_thread.IsAlive)
                {
                    multimeter_thread = new Thread(new ThreadStart(UpdateMultimeter));
                    multimeter_thread.Name = "Multimeter Thread";
                    multimeter_thread.Priority = ThreadPriority.Lowest;
                    multimeter_thread.IsBackground = true;
                    multimeter_thread.Start();
                }

                if (fwc_init && current_model == Model.FLEX5000 && rx2_enabled)
                {


                    if (rx2_meter_thread == null || !rx2_meter_thread.IsAlive)
                    {

                        rx2_meter_thread = new Thread(new ThreadStart(UpdateRX2MeterData));
                        rx2_meter_thread.Name = "RX2 Meter Thread";
                        rx2_meter_thread.Priority = ThreadPriority.Lowest;
                        rx2_meter_thread.IsBackground = true;
                        rx2_meter_thread.Start();
                    }

                    if (rx2_sql_update_thread == null || !rx2_sql_update_thread.IsAlive)
                    {
                        rx2_sql_update_thread = new Thread(new ThreadStart(UpdateRX2SQL));
                        rx2_sql_update_thread.Name = "Update RX2 SQL";
                        rx2_sql_update_thread.Priority = ThreadPriority.Normal;
                        rx2_sql_update_thread.IsBackground = true;
                        rx2_sql_update_thread.Start();
                    }
                }

                if (sql_update_thread == null || !sql_update_thread.IsAlive)
                {
                    sql_update_thread = new Thread(new ThreadStart(UpdateSQL));
                    sql_update_thread.Name = "Update SQL";
                    sql_update_thread.Priority = ThreadPriority.Normal;
                    sql_update_thread.IsBackground = true;
                    sql_update_thread.Start();
                }

                if (noise_gate_update_thread == null || !noise_gate_update_thread.IsAlive)
                {
                    noise_gate_update_thread = new Thread(new ThreadStart(UpdateNoiseGate));
                    noise_gate_update_thread.Name = "Update NoiseGate";
                    noise_gate_update_thread.Priority = ThreadPriority.Normal;
                    noise_gate_update_thread.IsBackground = true;
                    noise_gate_update_thread.Start();
                }

                if (vox_update_thread == null || !vox_update_thread.IsAlive)
                {
                    vox_update_thread = new Thread(new ThreadStart(UpdateVOX));
                    vox_update_thread.Name = "Update VOX";
                    vox_update_thread.Priority = ThreadPriority.Normal;
                    vox_update_thread.IsBackground = true;
                    vox_update_thread.Start();
                }

                if (poll_ptt_thread == null || !poll_ptt_thread.IsAlive)
                {
                    poll_ptt_thread = new Thread(new ThreadStart(PollPTT));
                    poll_ptt_thread.Name = "Poll PTT Thread";
                    poll_ptt_thread.Priority = ThreadPriority.Normal;
                    poll_ptt_thread.IsBackground = true;
                    poll_ptt_thread.Start();


                }

                if (fwc_init && current_model == Model.FLEX3000)
                {
                    if (FWCEEPROM.PAOK)
                    {
                        if (f3k_temp_thread == null || !f3k_temp_thread.IsAlive)
                        {
                            f3k_temp_thread = new Thread(new ThreadStart(F3KReadTemp));
                            f3k_temp_thread.Name = "F3K Temp Thread";
                            f3k_temp_thread.Priority = ThreadPriority.Lowest;
                            f3k_temp_thread.IsBackground = true;
                            f3k_temp_thread.Start();
                        }
                    }

                    if (f3k_mic_function_thread == null || !f3k_mic_function_thread.IsAlive)
                    {
                        f3k_mic_function_thread = new Thread(new ThreadStart(F3KMicFunctions));
                        f3k_mic_function_thread.Name = "F3K Mic Feature Thread";
                        f3k_mic_function_thread.Priority = ThreadPriority.Normal;
                        f3k_mic_function_thread.IsBackground = true;
                        f3k_mic_function_thread.Start();
                    }
                }

                switch (current_model)
                {
                    case Model.FLEX5000:
                    case Model.FLEX3000:
                        if (poll_pa_pwr_thread == null || !poll_pa_pwr_thread.IsAlive)
                        {
                            poll_pa_pwr_thread = new Thread(new ThreadStart(PollFWCPAPWR));
                            poll_pa_pwr_thread.Name = "Poll FWC PA PWR Thread";
                            poll_pa_pwr_thread.Priority = ThreadPriority.BelowNormal;
                            poll_pa_pwr_thread.IsBackground = true;
                            poll_pa_pwr_thread.Start();
                        }
                        break;
                    case Model.FLEX1500:
                        // do nothing ... no bridge to read
                        break;
                    default:
                        if (pa_present)
                        {
                            if (poll_pa_pwr_thread == null || !poll_pa_pwr_thread.IsAlive)
                            {
                                poll_pa_pwr_thread = new Thread(new ThreadStart(PollPAPWR));
                                poll_pa_pwr_thread.Name = "Poll PA PWR Thread";
                                poll_pa_pwr_thread.Priority = ThreadPriority.BelowNormal;
                                poll_pa_pwr_thread.IsBackground = true;
                                poll_pa_pwr_thread.Start();
                            }
                        }
                        break;
                } // current model

                /*wbir_thread = new Thread(new ThreadStart(WBIR));
                wbir_thread.Name = "WBIR Thread";
                wbir_thread.Priority = ThreadPriority.Normal;
                wbir_thread.IsBackground = true;
                wbir_thread.Start();

                if (current_model == Model.FLEX5000 && FWCEEPROM.RX2OK)
                {
                    wbir_rx2_thread = new Thread(new ThreadStart(WBIR_RX2));
                    wbir_rx2_thread.Name = "WBIR RX2 Thread";
                    wbir_rx2_thread.Priority = ThreadPriority.Normal;
                    wbir_rx2_thread.IsBackground = true;
                    wbir_rx2_thread.Start();
                }*/

                update_rx1_dds_thread = new Thread(new ThreadStart(UpdateRX1DDSFreq));
                update_rx1_dds_thread.Name = "RX1 DDS Thread";
                update_rx1_dds_thread.Priority = ThreadPriority.Normal;
                update_rx1_dds_thread.IsBackground = true;
                update_rx1_dds_thread.Start();

                update_tx_dds_thread = new Thread(new ThreadStart(UpdateTXDDSFreq));
                update_tx_dds_thread.Name = "TX DDS Thread";
                update_tx_dds_thread.Priority = ThreadPriority.Normal;
                update_tx_dds_thread.IsBackground = true;
                update_tx_dds_thread.Start();

                if (current_model == Model.FLEX5000 && FWCEEPROM.RX2OK)
                {
                    update_rx2_dds_thread = new Thread(new ThreadStart(UpdateRX2DDSFreq));
                    update_rx2_dds_thread.Name = "RX2 DDS Thread";
                    update_rx2_dds_thread.Priority = ThreadPriority.Normal;
                    update_rx2_dds_thread.IsBackground = true;
                    update_rx2_dds_thread.Start();
                }

                if (fwc_init && (current_model == Model.FLEX5000 || current_model == Model.FLEX3000))
                {
                    audio_watchdog_thread = new Thread(new ThreadStart(AudioWatchdog));
                    audio_watchdog_thread.Name = "Audio Watchdog Thread";
                    audio_watchdog_thread.Priority = ThreadPriority.Lowest;
                    audio_watchdog_thread.IsBackground = true;
                    audio_watchdog_thread.Start();
                }

                if (!rx_only)
                {
                    chkMOX.Enabled = true;
                    chkTUN.Enabled = true;
                }
                chkVFOLock.Enabled = true;

                timer_peak_text.Enabled = true;

                /*  if (current_model == Model.SDR1000 && atu_present)
                  {
                      int counter = 0;
                      while (((Hdw.StatusPort() & (byte)StatusPin.PA_DATA)) == 0)
                      {
                          Thread.Sleep(50);
                          if (counter++ > 100)		// 5 second time out
                          {
                              MessageBox.Show(new Form { TopMost = true }, "ATU Initialization Timeout.\n" +
                                  "Please check power to radio",
                                  "ATU Init Error",
                                  MessageBoxButtons.OK,
                                  MessageBoxIcon.Hand);
                              chkPower.Checked = false;
                              return;
                          }
                      }
                      Hdw.PA_ATUTune(ATUTuneMode.BYPASS);
                  }
  */
                CWKeyer.Reset();
                CWPTT.Start();

                // check rx image version and force recal if necessary for 5K / 3K
                if (one_time && (current_model == Model.FLEX5000 || current_model == Model.FLEX3000) && !production)
                {
                    one_time = false;
                    Application.DoEvents();
                    if (FWCEEPROM.RX1ImageVer < 5) // check version
                    {
                        // force calibration
                        if (flex5000ProdTestForm == null || flex5000ProdTestForm.IsDisposed)
                            flex5000ProdTestForm = new FLEX5000ProdTestForm(this);
                        flex5000ProdTestForm.Show();
                        flex5000ProdTestForm.Hide();

                        Thread.Sleep(100);
                        Application.DoEvents();

                        MessageBox.Show(new Form { TopMost = true }, "For optimal performance, PowerSDR needs to update your Receiver Image calibration.  This may take several minutes.",
                            "Update RX Image Calibration",
                            MessageBoxButtons.OK,
                            MessageBoxIcon.Information);

                        Thread t = flex5000ProdTestForm.CallCalFWCRXImage();
                        while (t.IsAlive)
                        {
                            Thread.Sleep(50);
                            Application.DoEvents();
                        }

                        if (current_model == Model.FLEX5000 && FWCEEPROM.RX2OK)
                        {
                            if (FWCEEPROM.RX2ImageVer < 5)
                            {
                                if (flex5000RX2CalForm == null || flex5000RX2CalForm.IsDisposed)
                                    flex5000RX2CalForm = new FLEX5000RX2CalForm(this);
                                flex5000RX2CalForm.Show();
                                flex5000RX2CalForm.Hide();
                                Thread.Sleep(100);
                                Application.DoEvents();

                                Thread t2 = flex5000RX2CalForm.CallCalRX2Image();
                                while (t2.IsAlive)
                                {
                                    Thread.Sleep(50);
                                    Application.DoEvents();
                                }
                            }
                        }

                        MessageBox.Show(new Form { TopMost = true }, "Calibration complete.",
                            "Calibration Complete",
                            MessageBoxButtons.OK,
                            MessageBoxIcon.Information);
                    }
                }

                /*
                if (eqForm != null)
                {
                    Debug.WriteLine("TXEQ SCROLL ON START");

                    eqForm.tbTXEQ28Preamp.Value = Math.Max(eqForm.tbTXEQ28Preamp.Minimum, Math.Min(eqForm.tbTXEQ28Preamp.Maximum, eqForm.tbTXEQ28Preamp.Value - 1)); //.223 add
                    eqForm.tbTXEQ28Preamp.Value = Math.Max(eqForm.tbTXEQ28Preamp.Minimum, Math.Min(eqForm.tbTXEQ28Preamp.Maximum, eqForm.tbTXEQ28Preamp.Value + 1));

                    eqForm.tbTXEQPreamp.Value = Math.Max(eqForm.tbTXEQPreamp.Minimum, Math.Min(eqForm.tbTXEQPreamp.Maximum, eqForm.tbTXEQPreamp.Value - 1)); //.223 add
                    eqForm.tbTXEQPreamp.Value = Math.Max(eqForm.tbTXEQPreamp.Minimum, Math.Min(eqForm.tbTXEQPreamp.Maximum, eqForm.tbTXEQPreamp.Value + 1));
                
                    eqForm.tbTXEQ9Preamp.Value = Math.Max(eqForm.tbTXEQ9Preamp.Minimum, Math.Min(eqForm.tbTXEQ9Preamp.Maximum, eqForm.tbTXEQ9Preamp.Value - 1)); //.223 add
                    eqForm.tbTXEQ9Preamp.Value = Math.Max(eqForm.tbTXEQ9Preamp.Minimum, Math.Min(eqForm.tbTXEQ9Preamp.Maximum, eqForm.tbTXEQ9Preamp.Value + 1));

                    //  eqForm.tbPEQ1_Scroll(this, EventArgs.Empty);  //.223 add
                    // eqForm.tbTX28EQ15_Scroll(this, EventArgs.Empty); // 
                    //  eqForm.tbTXEQ_Scroll(this, EventArgs.Empty); //
                }
*/

            } // checked power
            else // power off
            {
                Display.lastvaluecount = 0;

                if (setupForm != null && setupForm.checkBoxN1MM.Checked)
                {
                    //    N1MM = false;
                    //    N1MM_RESIZE = true;
                }

                //chkPower.Text = "Start";
                //prevent previous CAT command from triggering PTT immediately upon restarting
                cat_ptt = false;

                //  Display.Power = 0;

                chkVOX.Checked = false; // prevent unintentional TX if VOX was left on when power turned off
                chkMOX.Checked = false;
                chkMOX.Enabled = false;

                if (tuning && (current_model == Model.FLEX3000))
                {
                    flex3000ATUForm.AbortTune();
                }

                chkTUN.Checked = false;
                chkTUN.Enabled = false;

                // wjt added 
                if (serialPTT != null)  // let go of serial port
                {
                    serialPTT.Destroy();
                    serialPTT = null;
                }
                // wjt added ends 

                chkVFOLock.Enabled = false;

                if (!(fwc_init && (current_model == Model.FLEX5000 || current_model == Model.FLEX3000)))
                {
                    //  if(current_model == Model.SDR1000)     Hdw.StandBy();
                }
                else
                {
                    FWC.SetStandby(true);
                }
                chkPower.BackColor = SystemColors.Control;
                txtVFOAFreq.ForeColor = vfo_text_dark_color;
                txtVFOAMSD.ForeColor = vfo_text_dark_color;
                txtVFOALSD.ForeColor = vfo_text_dark_color;
                UpdateVFOASub();

                txtVFOBFreq.ForeColor = vfo_text_dark_color;
                txtVFOBMSD.ForeColor = vfo_text_dark_color;
                txtVFOBLSD.ForeColor = vfo_text_dark_color;
                txtVFOBBand.ForeColor = band_text_dark_color;

                timer_peak_text.Enabled = false;

                Display.ResetRX1DisplayAverage();
                Display.ResetRX1DisplayPeak();
                Display.ResetRX2DisplayAverage();
                Display.ResetRX2DisplayPeak();

                CWPTT.Stop();

                switch (current_model)
                {
                    case Model.SDR1000:
                    case Model.FLEX5000:
                    case Model.FLEX3000:
                    //  case Model.SOFTROCK40:
                    case Model.DEMO:
                        Audio.callback_return = 2;
                        Audio.StopAudio();
                        break;
                    case Model.FLEX1500:
                        //Audio.StopAudio(); // take this out when using new driver
                        Flex1500.StopAudio();
                        break;
                }

                if (vac_enabled)
                {
                    Debug.WriteLine("test8===============");

                    Audio.StopAudioVAC();
                }

                if (vac2_enabled)
                {
                    Audio.StopAudioVAC2();
                }

                if (draw_display_thread != null)
                {
                    if (!draw_display_thread.Join(500))
                        draw_display_thread.Abort();
                }
                if (multimeter_thread != null)
                {
                    if (!multimeter_thread.Join(500))
                        multimeter_thread.Abort();
                }
                if (sql_update_thread != null)
                {
                    if (!sql_update_thread.Join(500))
                        sql_update_thread.Abort();
                }
                if (noise_gate_update_thread != null)
                {
                    if (!noise_gate_update_thread.Join(500))
                        noise_gate_update_thread.Abort();
                }
                if (vox_update_thread != null)
                {
                    if (!vox_update_thread.Join(500))
                        vox_update_thread.Abort();
                }

                if ((poll_ptt_thread != null)) // ke9ns mod
                {
                    if (!poll_ptt_thread.Join(500))
                        poll_ptt_thread.Abort();
                }
            }

            if (fwc_init && current_model == Model.FLEX5000)
            {
                bool tx1, tx2, tx3;
                if (flex5000RelayForm != null)
                    flex5000RelayForm.UpdateRelayState(out tx1, out tx2, out tx3);
            }

            panelVFOAHover.Invalidate();
            panelVFOBHover.Invalidate();

            setupForm.AudioStreamRunning = chkPower.Checked;

            AutoWaterPan(); // ke9ns add

        } //chkPower_Checkchanged


        //===============================================================================
        //===============================================================================
        // ke9ns   This is where you select the RX1 display. Panafall can now stay on with RX2
        //===============================================================================
        //===============================================================================
        public void comboDisplayMode_SelectedIndexChanged(object sender, System.EventArgs e)
        {
            DisplayMode old_mode = Display.CurrentDisplayMode;

            CONT_Curr = 0; // clear continuum counter
            CONT_dbm.Clear();

            switch (comboDisplayMode.Text)  // ke9ns  list of display modes is populated for a list at the top of the code Displaymodes
            {
                case "Spectrum":
                    CONT_RUN = false;

                    Display.CurrentDisplayMode = DisplayMode.SPECTRUM;
                    UpdateRXDisplayVars((int)udFilterLow.Value, (int)udFilterHigh.Value);
                    CTUN1 = false;

                    break;
                case "Panadapter":
                    CONT_RUN = false;
                    Display.CurrentDisplayMode = DisplayMode.PANADAPTER;
                    CalcDisplayFreq();
                    break;
                case "Scope":
                    CONT_RUN = false;
                    Display.CurrentDisplayMode = DisplayMode.SCOPE;
                    CTUN1 = false;
                    break;
                case "Phase":
                    CONT_RUN = false;
                    Display.CurrentDisplayMode = DisplayMode.PHASE;
                    CTUN1 = false;
                    break;
                case "Phase2":
                    CONT_RUN = false;
                    Display.CurrentDisplayMode = DisplayMode.PHASE2;
                    CTUN1 = false;
                    break;
                case "Waterfall":
                    CONT_RUN = false;
                    Display.CurrentDisplayMode = DisplayMode.WATERFALL;
                    CalcDisplayFreq();
                    break;
                case "Histogram":
                    CONT_RUN = false;
                    Display.CurrentDisplayMode = DisplayMode.HISTOGRAM;
                    CTUN1 = false;
                    break;
                case "Panafall":
                    CONT_RUN = false;
                    Display.map = 0;
                    Display.CurrentDisplayMode = DisplayMode.PANAFALL;
                    CalcDisplayFreq();
                    break;
                case "Panafall8020":                                    // ke9ns add special panfall size 80%pan 20% water
                    CONT_RUN = false;
                    Display.map = 1;
                    Display.CurrentDisplayMode = DisplayMode.PANAFALL;
                    CalcDisplayFreq();
                    break;
                case "Panascope":
                    CONT_RUN = false;
                    Display.CurrentDisplayMode = DisplayMode.PANASCOPE;
                    CalcDisplayFreq();
                    break;
                case "Continuum":
                    Display.CurrentDisplayMode = DisplayMode.CONTINUUM;
                    CTUN1 = false;
                    CalcDisplayFreq();
                    break;
                case "Off":
                    CONT_RUN = false;
                    Display.CurrentDisplayMode = DisplayMode.OFF;
                    CTUN1 = false;
                    break;
            }

#if (!NO_TNF)
            switch (Display.CurrentDisplayMode)
            {
                case DisplayMode.PANADAPTER:
                case DisplayMode.WATERFALL:
                case DisplayMode.PANAFALL:
                case DisplayMode.PANASCOPE:
                    btnTNFAdd.Enabled = true; break;
                default:
                    btnTNFAdd.Enabled = false; break;
            }

#endif

            if (old_mode == DisplayMode.OFF && (draw_display_thread == null || !draw_display_thread.IsAlive))
            {
                draw_display_thread = new Thread(new ThreadStart(RunDisplay));
                draw_display_thread.Name = "Draw Display Thread";
                draw_display_thread.Priority = ThreadPriority.BelowNormal;
                draw_display_thread.IsBackground = true;
                draw_display_thread.Start();
            }

            switch (old_mode)
            {
                case DisplayMode.PANADAPTER:
                case DisplayMode.WATERFALL:
                case DisplayMode.PANAFALL:
                case DisplayMode.PANASCOPE:
                    switch (Display.CurrentDisplayMode)
                    {
                        case DisplayMode.PANADAPTER:
                        case DisplayMode.WATERFALL:
                        case DisplayMode.PANAFALL:
                        case DisplayMode.PANASCOPE:
                            break;
                        default:
                            RX1Filter = rx1_filter; // reset filter display limits
                            TXFilterLow = TXFilterLow;
                            break;
                    }
                    break;
            }

            switch (Display.CurrentDisplayMode)
            {
                case DisplayMode.PHASE:
                case DisplayMode.PHASE2:
                case DisplayMode.SCOPE:
                case DisplayMode.OFF:
                    chkDisplayAVG.Text = "Avg"; // ke9ns 
                    chkDisplayAVG.Enabled = false;
                    if (chkDisplayAVG.Checked)
                        chkDisplayAVG.BackColor = SystemColors.Control;
                    //chkDisplayAVG.Checked = false;
                    chkDisplayPeak.Enabled = false;
                    if (chkDisplayPeak.Checked)
                        chkDisplayPeak.BackColor = SystemColors.Control;
                    //chkDisplayPeak.Checked = false;
                    break;
                case DisplayMode.WATERFALL:
                    chkDisplayAVG.Text = "Avg"; // ke9ns 
                    chkDisplayAVG.Enabled = true;
                    if (setupForm.WeakSignalWaterfallEnabled == true)
                        chkDisplayAVG.Checked = true;
                    if (chkDisplayAVG.Checked)
                        chkDisplayAVG.BackColor = button_selected_color;
                    chkDisplayPeak.Enabled = true;
                    if (chkDisplayPeak.Checked)
                        chkDisplayPeak.BackColor = button_selected_color;
                    btnZeroBeat.Enabled = true;
                    dsp.GetDSPRX(0, 0).SpectrumPreFilter = true;
                    dsp.GetDSPRX(1, 0).SpectrumPreFilter = true;
                    break;
                case DisplayMode.PANADAPTER:
                    chkDisplayAVG.Text = "Avg"; // ke9ns 
                    chkDisplayAVG.Enabled = true;
                    if (chkDisplayAVG.Checked)
                        chkDisplayAVG.BackColor = button_selected_color;
                    chkDisplayPeak.Enabled = true;
                    if (chkDisplayPeak.Checked)
                        chkDisplayPeak.BackColor = button_selected_color;
                    btnZeroBeat.Enabled = chkDisplayAVG.Checked;
                    dsp.GetDSPRX(0, 0).SpectrumPreFilter = true;
                    dsp.GetDSPRX(1, 0).SpectrumPreFilter = true;
                    break;
                case DisplayMode.HISTOGRAM:
                    chkDisplayAVG.Text = "Avg"; // ke9ns 
                    chkDisplayAVG.Enabled = true;
                    if (chkDisplayAVG.Checked)
                        chkDisplayAVG.BackColor = button_selected_color;
                    chkDisplayPeak.Enabled = true;
                    if (chkDisplayPeak.Checked)
                        chkDisplayPeak.BackColor = button_selected_color;
                    btnZeroBeat.Enabled = chkDisplayAVG.Checked;
                    if (rx1_dsp_mode != DSPMode.SPEC)
                    {
                        dsp.GetDSPRX(0, 0).SpectrumPreFilter = false;
                        dsp.GetDSPRX(1, 0).SpectrumPreFilter = false;
                    }
                    else
                    {
                        dsp.GetDSPRX(0, 0).SpectrumPreFilter = true;
                        dsp.GetDSPRX(1, 0).SpectrumPreFilter = true;
                    }
                    RX1Filter = rx1_filter;
                    break;

                case DisplayMode.PANAFALL:                // ke9ns pan
                    chkDisplayAVG.Enabled = true;

                    if ((Display.PW_AVG == 0))
                    {
                        if (chkDisplayAVG.Checked == true) chkDisplayAVG.Text = "AvgB"; // ke9ns add 
                        else chkDisplayAVG.Text = "Avg"; // ke9ns add 
                    }

                    chkDisplayAVG.BackColor = button_selected_color;


                    chkDisplayPeak.Enabled = true;
                    if (chkDisplayPeak.Checked)
                        chkDisplayPeak.BackColor = button_selected_color;
                    btnZeroBeat.Enabled = chkDisplayAVG.Checked;

                    dsp.GetDSPRX(0, 0).SpectrumPreFilter = true;
                    dsp.GetDSPRX(1, 0).SpectrumPreFilter = true;

                    break;
                case DisplayMode.PANASCOPE:
                    chkDisplayAVG.Text = "Avg"; // ke9ns 
                    chkDisplayAVG.Enabled = true;
                    if (chkDisplayAVG.Checked)
                        chkDisplayAVG.BackColor = button_selected_color;
                    chkDisplayPeak.Enabled = true;
                    if (chkDisplayPeak.Checked)
                        chkDisplayPeak.BackColor = button_selected_color;
                    btnZeroBeat.Enabled = chkDisplayAVG.Checked;
                    dsp.GetDSPRX(0, 0).SpectrumPreFilter = true;
                    dsp.GetDSPRX(1, 0).SpectrumPreFilter = true;
                    break;
                default:
                    chkDisplayAVG.Enabled = true;
                    if (chkDisplayAVG.Checked)
                        chkDisplayAVG.BackColor = button_selected_color;
                    chkDisplayPeak.Enabled = true;
                    if (chkDisplayPeak.Checked)
                        chkDisplayPeak.BackColor = button_selected_color;
                    btnZeroBeat.Enabled = chkDisplayAVG.Checked;
                    if (rx1_dsp_mode != DSPMode.SPEC)
                    {
                        dsp.GetDSPRX(0, 0).SpectrumPreFilter = false;
                        dsp.GetDSPRX(1, 0).SpectrumPreFilter = false;
                    }
                    else
                    {
                        dsp.GetDSPRX(0, 0).SpectrumPreFilter = true;
                        dsp.GetDSPRX(1, 0).SpectrumPreFilter = true;
                    }
                    break;
            }

            if (chkDisplayAVG.Checked)
            {
                switch (Display.CurrentDisplayMode)
                {
                    case DisplayMode.PANADAPTER:
                    case DisplayMode.HISTOGRAM:
                    case DisplayMode.SPECTRUM:
                    case DisplayMode.WATERFALL:
                    case DisplayMode.PANAFALL:
                    case DisplayMode.PANASCOPE:
                        btnZeroBeat.Enabled = true;
                        break;
                    default:
                        btnZeroBeat.Enabled = false;
                        break;
                }

                switch (Display.CurrentDisplayMode)
                {
                    case DisplayMode.PANADAPTER:
                    case DisplayMode.HISTOGRAM:
                    case DisplayMode.SPECTRUM:
                    case DisplayMode.WATERFALL:
                    case DisplayMode.PANASCOPE:
                        chkDisplayAVG.Text = "Avg"; // ke9ns 
                        break;

                }

            }

            was_panadapter = false;
            was_waterfall = false;

            if (comboDisplayMode.Focused)
                btnHidden.Focus();

        } // comboDisplaymode index changed



        private void chkBIN_CheckedChanged(object sender, System.EventArgs e)
        {
            if (chkBIN.Checked) chkBIN.BackColor = button_selected_color;
            else chkBIN.BackColor = SystemColors.Control;
            dsp.GetDSPRX(0, 0).BinOn = chkBIN.Checked;
            dsp.GetDSPRX(0, 1).BinOn = chkBIN.Checked;
        }

        private void comboAGC_SelectedIndexChanged(object sender, System.EventArgs e)
        {
            if (comboAGC.SelectedIndex < 0) return;

            dsp.GetDSPRX(0, 0).RXAGCMode = (AGCMode)comboAGC.SelectedIndex;
            dsp.GetDSPRX(0, 1).RXAGCMode = (AGCMode)comboAGC.SelectedIndex;

            // set whether custom controls are active
            switch ((AGCMode)comboAGC.SelectedIndex)
            {
                case AGCMode.LONG:
                    setupForm.CustomRXAGCEnabled = false;
                    /*SetupForm.RXAGCAttack = 2;
					SetupForm.RXAGCHang = 750;
					SetupForm.RXAGCDecay = 2000;*/
                    //comboAGC.BackColor = SystemColors.Window;
                    toolTip1.SetToolTip(comboAGC, "Automatic Gain Control Mode Setting:\n" +
                        "Long (Attack 2ms, Hang 750ms, Decay 200ms)");
                    break;
                case AGCMode.SLOW:
                    setupForm.CustomRXAGCEnabled = false;
                    /*SetupForm.RXAGCAttack = 2;
					SetupForm.RXAGCHang = 500;
					SetupForm.RXAGCDecay = 500;*/
                    toolTip1.SetToolTip(comboAGC, "Automatic Gain Control Mode Setting:\n" +
                        "Slow (Attack 2ms, Hang 500ms, Decay 500ms)");
                    //comboAGC.BackColor = SystemColors.Window;
                    break;
                case AGCMode.MED:
                    setupForm.CustomRXAGCEnabled = false;
                    /*SetupForm.RXAGCAttack = 2;
					SetupForm.RXAGCHang = 250;
					SetupForm.RXAGCDecay = 250;*/
                    toolTip1.SetToolTip(comboAGC, "Automatic Gain Control Mode Setting:\n" +
                        "Medium (Attack 2ms, Hang 250ms, Decay 250ms)");
                    //comboAGC.BackColor = SystemColors.Window;
                    break;
                case AGCMode.FAST:
                    setupForm.CustomRXAGCEnabled = false;
                    /*SetupForm.RXAGCAttack = 2;
					SetupForm.RXAGCHang = 100;
					SetupForm.RXAGCDecay = 100;*/
                    toolTip1.SetToolTip(comboAGC, "Automatic Gain Control Mode Setting:\n" +
                        "Fast (Attack 2ms, Hang 100ms, Decay 100ms)");
                    //comboAGC.BackColor = SystemColors.Window;
                    break;
                case AGCMode.CUSTOM:
                    setupForm.CustomRXAGCEnabled = true;
                    toolTip1.SetToolTip(comboAGC, "Automatic Gain Control Mode Setting:\n" +
                        "Custom - Set specifics in Setup Form -> DSP -> AGC/ALC");
                    //comboAGC.BackColor = SystemColors.Window;
                    break;
                case AGCMode.FIXD:
                    setupForm.CustomRXAGCEnabled = false;
                    toolTip1.SetToolTip(comboAGC, "Automatic Gain Control Mode Setting:\n" +
                        "Fixed - Set gain with AGC-T control above");
                    //comboAGC.BackColor = Color.Orange;
                    break;
            }

            // set RF control to Max or Fixed gain depending on mode
            switch ((AGCMode)comboAGC.SelectedIndex)
            {
                case AGCMode.FIXD:
                    RF = setupForm.AGCFixedGain;
                    ptbRF_Scroll(this, EventArgs.Empty);
                    break;
                default:
                    RF = setupForm.AGCMaxGain;
                    ptbRF_Scroll(this, EventArgs.Empty);
                    break;
            }

            if (comboAGC.Focused)
                btnHidden.Focus();

        } // comboAGC settings



        //==========================================================================================================
        // ke9ns triggers FIRST
        public void Console_Closing1(object sender, System.ComponentModel.CancelEventArgs e)
        {
            Debug.WriteLine("CONSOLE_CLOSING_Cancel");



            // ke9ns: save any unsaved tunestep values here during closing
            if (setupForm != null)
            {
                if (RX1DSPMode == DSPMode.CWL || RX1DSPMode == DSPMode.CWL) // if in CW mode when you power down
                {
                    setupForm.txtWheelTune4.Text = txtWheelTune.Text; //CW mode only
                    setupForm.txtWheelTune5.Text = setupForm.txtWheelTune2.Text; //CW mode only
                    setupForm.txtWheelTune6.Text = setupForm.txtWheelTune3.Text; //CW mode only
                }
                else
                {
                    setupForm.txtWheelTune9.Text = txtWheelTune.Text; //SSB mode only
                    setupForm.txtWheelTune7.Text = setupForm.txtWheelTune2.Text; //SSB mode only
                    setupForm.txtWheelTune8.Text = setupForm.txtWheelTune3.Text; //SSB mode only
                }

                Debug.WriteLine("TUNESTEP SAVE:" + txtWheelTune.Text + " , 2:" + setupForm.txtWheelTune2.Text + " ,3:" + setupForm.txtWheelTune3.Text + " ,4:" + setupForm.txtWheelTune4.Text + " ,5:" + setupForm.txtWheelTune5.Text
                     + " ,6:" + setupForm.txtWheelTune6.Text + " ,7:" + setupForm.txtWheelTune7.Text + " ,8:" + setupForm.txtWheelTune8.Text + " ,9:" + setupForm.txtWheelTune9.Text);

            }

        } // Console_Closing1


        public bool VOAOFF = false; // ke9ns .197  true = ran tracksun() 1 time with VOACAP OFF

        //==============================================================================================
        // ke9ns: actually runs Console_Closing1 just before this below
        public void Console_Closing(object sender, FormClosingEventArgs e)
        {

            if (chkPower.Checked) //.254
            {
                chkPower.Checked = false;
                Thread.Sleep(800);
                    
            }

            if (SpotForm != null) // ke9ns add .198
            {
                Debug.WriteLine("SPOT TURNED OFF " + SpotForm.checkBoxMUF.Checked + " , " + SpotForm.VOARUN + " , " + SpotForm.VOARUN + " , " + SpotControl.SP5_Active + " , " + SpotForm.mapon);

                SpotForm.checkBoxMUF.CheckedChanged -= SpotForm.checkBoxMUF_CheckedChanged;
                SpotForm.checkBoxMUF.Checked = false;
                SpotControl.Map_Last = SpotControl.Map_Last | 2;    // force update of world map

                SpotControl.SP5_Active = 0;                     // turn off tracking

                Debug.WriteLine("SPOT TURNED OFF- " + SpotForm.checkBoxMUF.Checked + " , " + SpotForm.VOARUN + " , " + SpotForm.VOARUN + " , " + SpotControl.SP5_Active + " , " + SpotForm.mapon);

            } //  if (SpotForm != null) 


            e.Cancel = false; // ke9ns add
            Debug.WriteLine("CONSOLE_CLOSING POWER OFF NOW");



            chkPower.Checked = false;
            Thread.Sleep(300);

            //------------------------------------------------------------------------
            // ke9ns  add

            StreamWriter writer = new StreamWriter(app_data_path + "shutdown1.log"); //   // look for %userprofile%\AppData\Roaming\FlexRadio Systems\PowerSDR v2.8.0\

            writer.WriteLine("This is a PowerSDR powering downlog: 1-8");

            writer.WriteLine("1) Disable Audio, CAT, Rotor, VFODIAL, N1MM, QuicRec, Powermate, CWX Polling, timers, VOARUN, MUF");

            Debug.WriteLine("CONSOLE_CLOSING");

            tot_onoff = false; // ke9ns shut down any tot timer

            IIC_AMPCONTROL(128, 128); // ke9ns shut down

            Audio.callback_return = 2;
            CATEnabled = false;
            ROTOREnabled = false; // ke9ns add

            vfodial = false; // ke9ns add to terminal the dial routine
            N1MM_ON = false; // ke9ns add to shut off N1MM

            ckQuickRec.Checked = false; // make sure recording is stopped

            if (KBON == 1) powerMate.Shutdown(); // ke9ns add 

            if (cwxForm != null) cwxForm.stopPoll = false; // ke9ns add

            if (timerID != 0) timeKillEvent(timerID);     // kill the mmtimer

            if (timerID1 != 0) timeKillEvent(timerID1);



            writer.WriteLine("1) Done");
            writer.WriteLine("2) Hide all forms ");

            Thread.Sleep(100);

            //--------------------------------------------------------------
            // hide all open forms
            if (setupForm != null) setupForm.Hide();
            if (cwxForm != null) cwxForm.Hide();
            if (eqForm != null) eqForm.Hide();
            if (ucbForm != null) ucbForm.Hide();
            if (xvtrForm != null) xvtrForm.Hide();
            if (ProdTestForm != null) ProdTestForm.Hide();
            if (fwcMixForm != null) fwcMixForm.Hide();
            if (flex3000MixerForm != null) flex3000MixerForm.Hide();
            if (flex1500MixerForm != null) flex1500MixerForm.Hide();
            if (flex5000LLHWForm != null) flex5000LLHWForm.Hide();
            if (flex5000DebugForm != null) flex5000DebugForm.Hide();
            if (fwcAntForm != null) fwcAntForm.Hide();
            if (hidAntForm != null) hidAntForm.Hide();
            if (fwcAtuForm != null) fwcAtuForm.Hide();
            if (flexControlBasicForm != null) flexControlBasicForm.Hide();
            if (flexControlAdvancedForm != null) flexControlAdvancedForm.Hide();
            if (memoryForm != null) memoryForm.Hide();
            if (preSelForm != null) preSelForm.Hide();

            if (SpotForm != null) SpotForm.Hide(); // ke9ns add
            if (ScanForm != null) ScanForm.Hide(); // ke9ns add scanner form
            if (WaveForm != null) WaveForm.Hide(); // ke9ns add wave screen
            if (IDBOXForm != null) IDBOXForm.Hide(); // ke9ns add ID timer box
            if (helpboxForm != null) helpboxForm.Hide(); // ke9ns add help screen
            if (StackForm != null) StackForm.Hide(); // ke9ns add bandstack
            if (TOTBOXForm != null) TOTBOXForm.Hide(); // ke9ns add time out timer


            if (fwcAtuForm != null)
            {
                fwcAtuForm.Hide();
                fwcAtuForm.DoBypass();
            }
            //--------------------------------------------------------------

            writer.WriteLine("2) Done");
            writer.WriteLine("3) Save MemoryList and DXMemList");

            MemoryList.Save();
            DXMemList.Save1(); // ke9ns add
            writer.WriteLine("3) Done");

            Thread.Sleep(100);

            Debug.WriteLine("CONSOLE_CLOSING----- SAVE MEMORY DONE");

            writer.WriteLine("4) Save SWL_logger, ke9ns8.dat, and Database STATE variables, and Power.csv file");

            SaveState();                // put current settings back into database     DB.SaveVars("State", ref a);		    // save the values to the DB

            writer.WriteLine("4) Done");


            writer.WriteLine("5) turn off PABias and MIDI");

            Thread.Sleep(100);


            //--------------------------------------------------------------
            try
            {
                switch (current_model)
                {
                    case Model.FLEX5000:
                        if (fwc_init)
                        {
                            FWC.SetPABias(false);
                            if (FWCMidi.Init) FWCMidi.Close();
                        }
                        break;
                    case Model.FLEX3000:
                        if (fwc_init)
                        {
                            FWC.SetPABias(false);
                            FWC.SetFanSpeed(0.0f);
                            if (FWCMidi.Init) FWCMidi.Close();
                        }
                        break;
                    case Model.FLEX1500:
                        if (hid_init)
                        {
                            USBHID.SetMOX(false);
                            HIDPAFilter = 0;
                        }
                        break;
                }
            }
            catch (Exception)
            {

            }

            writer.WriteLine("5) DONE");
            //-------------------------------------------------------------
            Debug.WriteLine("CONSOLE_CLOSING----- SAVING STATE TO DATABASE. DONE");

            writer.WriteLine("6) Save SetupForm OPTIONS variables for Database");

            if (setupForm != null) setupForm.SaveOptions();
            writer.WriteLine("6) DONE");
            Thread.Sleep(100);

            writer.WriteLine("7) CLOSE all forms");

            if (cwxForm != null && !cwxForm.IsDisposed) cwxForm.Close();

            if (eqForm != null && !eqForm.IsDisposed) eqForm.Close();
            if (ucbForm != null && !ucbForm.IsDisposed) ucbForm.Close();
            if (xvtrForm != null && !xvtrForm.IsDisposed) xvtrForm.Close();
            if (ProdTestForm != null && !ProdTestForm.IsDisposed) ProdTestForm.Close();
            if (fwcMixForm != null && !fwcMixForm.IsDisposed) fwcMixForm.Close();
            if (flex3000MixerForm != null && !flex3000MixerForm.IsDisposed) flex3000MixerForm.Close();
            if (flex1500MixerForm != null && !flex1500MixerForm.IsDisposed) flex1500MixerForm.Close();
            if (flex5000LLHWForm != null && !flex5000LLHWForm.IsDisposed) flex5000LLHWForm.Close();
            if (flex5000DebugForm != null && !flex5000DebugForm.IsDisposed) flex5000DebugForm.Close();
            if (fwcAntForm != null && !fwcAntForm.IsDisposed) fwcAntForm.Close();
            if (hidAntForm != null && !hidAntForm.IsDisposed) hidAntForm.Close();
            if (fwcAtuForm != null && !fwcAtuForm.IsDisposed) fwcAtuForm.Close();
            if (flexControlBasicForm != null && !flexControlBasicForm.IsDisposed) flexControlBasicForm.Close();
            if (flexControlAdvancedForm != null && !flexControlAdvancedForm.IsDisposed) flexControlAdvancedForm.Close();
            if (memoryForm != null && !memoryForm.IsDisposed) memoryForm.Close();
            if (preSelForm != null && !preSelForm.IsDisposed) preSelForm.Close();

            if (SpotForm != null && !SpotForm.IsDisposed) SpotForm.Close(); // ke9ns add

            if (ScanForm != null && !ScanForm.IsDisposed) ScanForm.Close(); // ke9ns add scanner form
                                                                            //   Thread.Sleep(100);
            if (WaveForm != null && !WaveForm.IsDisposed) WaveForm.Close(); // ke9ns add wave screen
                                                                            //   Thread.Sleep(100);
            if (IDBOXForm != null && !IDBOXForm.IsDisposed) IDBOXForm.Close(); // ke9ns add ID timer box
                                                                               //   Thread.Sleep(100);
            if (helpboxForm != null && !helpboxForm.IsDisposed) helpboxForm.Close(); // ke9ns add help screen
                                                                                     //  Thread.Sleep(100);
            if (StackForm != null && !StackForm.IsDisposed) StackForm.Close(); // ke9ns add bandstack
                                                                               //  Thread.Sleep(100);
            if (TOTBOXForm != null && !TOTBOXForm.IsDisposed) TOTBOXForm.Close(); // ke9ns add time out timer

            Thread.Sleep(100);

            writer.WriteLine("7) DONE");

            Debug.WriteLine("CONSOLE_CLOSING------ ALL FORMS CLOSED DONE");

            this.Hide(); // hide the console.

            writer.WriteLine("8) done with Console_closing, on to PowerDown_2of3  Dispose");
            // ke9ns console_closing(), then Dispose(), then ExitConsole(), then back to Displose() to finish

            writer.Close();

            e.Cancel = false;

        } // console_closing



        // ke9ns:  use chkRX1Preamp_CheckedChanged for Flex-5000 
        private void comboPreamp_SelectedIndexChanged(object sender, System.EventArgs e)
        {
            //if (initializing) return;
            PreampMode mode = PreampMode.FIRST;
            bool exit = false;
            switch (current_model)
            {
                case Model.SDR1000:
                    switch (comboPreamp.Text)
                    {
                        case "Off":
                            mode = PreampMode.OFF;
                            break;
                        case "Low":
                            mode = PreampMode.LOW;
                            break;
                        case "Med":
                            mode = PreampMode.MED;
                            break;
                        case "High":
                        case "On":
                            mode = PreampMode.HIGH;
                            break;
                        default:
                            exit = true;
                            break;
                    }
                    break;
                case Model.FLEX1500:
                    switch (comboPreamp.Text)
                    {
                        case "-10":
                            mode = (PreampMode)FLEX1500PreampMode.MINUS_10;
                            break;
                        case "  0":
                            mode = (PreampMode)FLEX1500PreampMode.ZERO;
                            break;
                        case "+10":
                            mode = (PreampMode)FLEX1500PreampMode.PLUS_10;
                            break;
                        case "+20":
                            mode = (PreampMode)FLEX1500PreampMode.PLUS_20;
                            break;
                        case "+30":
                            mode = (PreampMode)FLEX1500PreampMode.PLUS_30;
                            break;
                        default:
                            mode = (PreampMode)FLEX1500PreampMode.ZERO;
                            break;
                    }
                    break;
                case Model.FLEX3000:
                    //  case Model.FLEX5000:
                    switch (comboPreamp.Text)
                    {
                        case "Attn":
                            mode = PreampMode.OFF;
                            break;
                        case "Off":
                            mode = PreampMode.LOW;
                            break;
                        case "Pre1":
                            mode = PreampMode.MED;
                            break;
                        case "Pre2":
                            mode = PreampMode.HIGH;
                            break;
                        default:
                            exit = true;
                            break;
                    }
                    break;
                case Model.FLEX5000:
                    exit = true; // ke9ns   on/off only
                    break;
                default:
                    exit = true;
                    break;
            }

            if (comboPreamp.Focused)
                btnHidden.Focus();

            if (exit) return;

            RX1PreampMode = mode;


        } // comboPreamp_SelectedIndexChanged



        //=========================================================================================
        // ke9ns   MUTE button (original 2.7.2 not muting VAC on 1500 and 3000, but works on 5000)
        //=========================================================================================
        private void chkMUT_CheckedChanged(object sender, System.EventArgs e)
        {


            if (chkBoxMuteSpk.Checked == true) //  ke9ns add s indicates muting just spk and not headphones
            {
                chkMUT.Text = "MUTs";
            }
            else
            {
                chkMUT.Text = "MUT";
            }


            if (chkMUT.Checked)
            {
                chkMUT.BackColor = button_selected_color;
            }
            else
            {
                chkMUT.BackColor = SystemColors.Control;
            }

            //	if(num_channels == 2)
            //		{
            //if(current_model == Model.SDR1000)  Hdw.MuteRelay = chkMUT.Checked;
            //	}



            if (fwc_init || hid_init)  //  ke9ns add
            {
                switch (current_model)
                {
                    case Model.FLEX5000:
                        if (fwcMixForm == null || fwcMixForm.IsDisposed) fwcMixForm = new FWCMixForm(this);


                        if ((chkMUT.Checked))
                        {
                            if (chkBoxMuteSpk.Checked == false) // standard MUTE
                            {
                                Audio.MonitorVolume = 0.0;
                            }
                            else
                            {

                                //  Debug.WriteLine("MUTE S======");

                                fwcMixForm.chkExtSpkrSel.Checked = false;
                                fwcMixForm.chkLineOutRCASel.Checked = false;



                            }

                        } // if (chkMUT.Checked)
                        else
                        {
                            if (chkBoxMuteSpk.Checked == false) // standard MUTE
                            {

                                ptbAF_Scroll(this, EventArgs.Empty);
                                // Debug.WriteLine("NO MUTE S======");

                            }
                            else
                            {
                                fwcMixForm.chkExtSpkrSel.Checked = true;
                                fwcMixForm.chkLineOutRCASel.Checked = true;

                            }

                        } // chkMUT.Checked == false

                        break;
                    case Model.FLEX3000:
                        if (flex3000MixerForm == null || flex3000MixerForm.IsDisposed) flex3000MixerForm = new FLEX3000MixerForm(this);

                        if (chkMUT.Checked)
                        {
                            if (chkBoxMuteSpk.Checked == false) // standard MUTE
                            {
                                Audio.MonitorVolume = 0.0;
                            }
                            else
                            {
                                flex3000MixerForm.chkExtSpkrSel.Checked = false;
                                //  flex3000MixerForm.chkLineOutDB9Sel.Checked = false;

                            }

                        }
                        else
                        {
                            if (chkBoxMuteSpk.Checked == false) // standard MUTE
                            {
                                ptbAF_Scroll(this, EventArgs.Empty);
                            }
                            else
                            {
                                flex3000MixerForm.chkExtSpkrSel.Checked = true;
                                // flex3000MixerForm.chkLineOutDB9Sel.Checked = true;
                            }

                        }

                        break;
                    case Model.FLEX1500:
                        if (flex1500MixerForm == null || flex1500MixerForm.IsDisposed) flex1500MixerForm = new FLEX1500MixerForm(this);

                        if (chkMUT.Checked)
                        {
                            if (chkBoxMuteSpk.Checked == false) // standard MUTE
                            {
                                Audio.MonitorVolume = 0.0;
                            }
                            else
                            {
                                flex1500MixerForm.chkFlexWireOutSel.Checked = false;

                            }

                        }
                        else
                        {
                            if (chkBoxMuteSpk.Checked == false) // standard MUTE
                            {
                                ptbAF_Scroll(this, EventArgs.Empty);
                            }
                            else
                            {
                                flex1500MixerForm.chkFlexWireOutSel.Checked = true;

                            }

                        }


                        break;
                }
            }

            if (chkMUT.Checked) // ke9ns add
            {
                chkMUT.BackColor = button_selected_color;
            }
            else
            {
                chkMUT.BackColor = SystemColors.Control;
            }


        } //chkMUT_CheckedChanged

        //===============================================================
        // ke9ns add to allow a right click on the MUT button to toggle between full MUTE and mute just spker
        private void chkMUT_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                if (setupForm == null || setupForm.IsDisposed) setupForm = new Setup(this);

                //  setupForm.Show();
                // setupForm.Focus();
                //  setupForm.WindowState = FormWindowState.Normal; // ke9ns add

                //  setupForm.tcSetup.SelectedIndex = 1; // select audio tab;
                //  setupForm.tcAudio.SelectedIndex = 1; // select vac1 tab
                //  setupForm.chkAudioIQtoVAC.Focus();

                if (chkMUT.Checked == false)   // only toggle the special mute if MUT is OFF
                {
                    if (chkBoxMuteSpk.Checked == false) chkBoxMuteSpk.Checked = true;
                    else chkBoxMuteSpk.Checked = false;
                }

            } // right click
            else if (me.Button == System.Windows.Forms.MouseButtons.Middle) // toggle mute between PC and Flex radio speaker
            {
                SendMessageW(this.Handle, WM_APPCOMMAND, this.Handle, (IntPtr)APPCOMMAND_VOLUME_MUTE);

                if (chkMUT.Checked) chkMUT.Checked = false;
                else chkMUT.Checked = true;

            }

            if (chkBoxMuteSpk.Checked == true) //  ke9ns add s indicates muting just spk and not headphones
            {
                chkMUT.Text = "MUTs";
            }
            else
            {
                chkMUT.Text = "MUT";
            }

            if (chkMUT.Checked) // ke9ns add
            {
                chkMUT.BackColor = button_selected_color;
            }
            else
            {
                chkMUT.BackColor = SystemColors.Control;
            }

        } // chkMUT_MouseDown


        //===============================================================
        // ke9ns add to allow a right click on the MUT button to toggle between full MUTE and mute just spker
        private void chkBoxMuteSpk_CheckedChanged(object sender, EventArgs e)
        {
            if (chkBoxMuteSpk.Checked == true) //  ke9ns add s indicates muting just spk and not headphones
            {
                chkMUT.Text = "MUTs";
            }
            else
            {
                chkMUT.Text = "MUT";
            }

            if (chkMUT.Checked)
            {
                chkMUT.BackColor = button_selected_color;
            }
            else
            {
                chkMUT.BackColor = SystemColors.Control;
            }

        } // chkBoxMuteSpk_CheckedChanged


        private bool chkBoxMON = false; // ke9ns add true = select MON slider instead of AF

        //=======================================================================================================
        // ke9ns add left click will cause the slider to change to AF
        private void lblAF_MouseUp(object sender, MouseEventArgs e)
        {

            MouseEventArgs me = (MouseEventArgs)e;

            lblMON.Text = "MON: " + ptbMON.Value.ToString(); // ke9ns add
            lblAF.Text = "AF: " + ptbAF.Value.ToString();

            if ((me.Button == System.Windows.Forms.MouseButtons.Left))
            {
                chkBoxMON = false;


                lblMON.ForeColor = Color.White;
                lblAF.ForeColor = Color.Yellow; // AF is now selected

                lblAF.Font = new Font(SystemFonts.DefaultFont, FontStyle.Bold | FontStyle.Italic);            // new Font(defaultFont.FontFamily, defaultFont.Size, FontStyle.Bold);
                lblMON.Font = new Font(SystemFonts.DefaultFont, FontStyle.Italic);

                ptbMON.Visible = false;
                ptbAF.Visible = true;


            } // LEFT

        } // lblAF_MouseUp

        //=======================================================================================================
        // ke9ns add left click will cause the slider to change to MN or MON value
        private void lblMON_MouseUp(object sender, MouseEventArgs e)
        {

            MouseEventArgs me = (MouseEventArgs)e;

            lblMON.Text = "MON: " + ptbMON.Value.ToString(); // ke9ns add
            lblAF.Text = "AF: " + ptbAF.Value.ToString();

            if ((me.Button == System.Windows.Forms.MouseButtons.Left))
            {
                chkBoxMON = true;

                lblAF.ForeColor = Color.White;
                lblMON.ForeColor = Color.Yellow; // Tune is now selected

                lblMON.Font = new Font(SystemFonts.DefaultFont, FontStyle.Bold | FontStyle.Italic);            // new Font(defaultFont.FontFamily, defaultFont.Size, FontStyle.Bold);
                lblAF.Font = new Font(SystemFonts.DefaultFont, FontStyle.Italic);

                ptbAF.Visible = false;
                ptbMON.Visible = true;


            } // LEFT


        } // lblMON_MouseUp

        //============================================================================
        // ke9ns add left  click on the TUNE: power level will cause the slider to change over to TUNE power level slider
        private void lblTUNE_MouseUp(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            lblPWR.Text = "Drive: " + ptbPWR.Value.ToString();
            lblTUNE.Text = "Tune: " + ptbTune.Value.ToString();

            if ((me.Button == System.Windows.Forms.MouseButtons.Left))
            {

                chkBoxTune = true;                 // ke9ns add show TUNE slider


                lblPWR.ForeColor = Color.White;
                lblTUNE.ForeColor = Color.Yellow; // Tune is now selected

                lblTUNE.Font = new Font(SystemFonts.DefaultFont, FontStyle.Bold | FontStyle.Italic);            // new Font(defaultFont.FontFamily, defaultFont.Size, FontStyle.Bold);
                lblPWR.Font = new Font(SystemFonts.DefaultFont, FontStyle.Italic);

                ptbPWR.Visible = false;
                ptbTune.Visible = true;




            } // left
            else if ((me.Button == System.Windows.Forms.MouseButtons.Right)) // LOCK DRIVE and TUNE levels
            {

                if (chkBoxDrive.Checked == false)
                {
                    chkBoxDrive.Checked = true;     // ke9ns show DRIVE slider and LOCK it
                }
                else
                {
                    chkBoxDrive.Checked = false;    // ke9ns show DRIVE slider
                }


            } //RIGHT


        } //  lblTUNE_MouseUp

        public bool chkBoxTune = false; // ke9ns add true = slide shows tune power ptbTune.value

        //============================================================================
        // ke9ns add
        private void lblPWR_MouseDown(object sender, MouseEventArgs e)
        {

            MouseEventArgs me = (MouseEventArgs)e;
            if (setupForm != null)
            {
                if (setupForm.udTXDriveMax.Value < ptbPWR.Value)
                {
                    ptbPWR.Value = (int)setupForm.udTXDriveMax.Value;
                }

                if (setupForm.udTXDriveMax.Value < ptbTune.Value)
                {
                    ptbTune.Value = (int)setupForm.udTXDriveMax.Value;
                }
            }

            lblPWR.Text = "Drive: " + ptbPWR.Value.ToString();
            lblTUNE.Text = "Tune: " + ptbTune.Value.ToString();


            if ((me.Button == System.Windows.Forms.MouseButtons.Left)) // ke9ns select DRIVE slider
            {

                chkBoxTune = false;                 // ke9ns add show DRIVER slider

                lblPWR.ForeColor = Color.Yellow;
                lblTUNE.ForeColor = Color.White; // Tune is now selected


                lblPWR.Font = new Font(SystemFonts.DefaultFont, FontStyle.Bold | FontStyle.Italic);            // new Font(defaultFont.FontFamily, defaultFont.Size, FontStyle.Bold);
                lblTUNE.Font = new Font(SystemFonts.DefaultFont, FontStyle.Italic);

                ptbPWR.Visible = true;
                ptbTune.Visible = false;


            }
            else if ((me.Button == System.Windows.Forms.MouseButtons.Right))
            {


                if (chkBoxDrive.Checked == false)
                {
                    chkBoxDrive.Checked = true;     // ke9ns show DRIVE slider and LOCK it
                }
                else
                {
                    chkBoxDrive.Checked = false;    // ke9ns show DRIVE slider
                }



            } // right click

        } // lblPWR_MouseDown



        //=========================================================================
        // ke9ns add
        private void chkBoxDrive_CheckedChanged(object sender, EventArgs e)
        {

            if (setupForm != null)
            {
                if (setupForm.udTXDriveMax.Value < ptbPWR.Value)
                {
                    ptbPWR.Value = (int)setupForm.udTXDriveMax.Value;
                }

                if (setupForm.udTXDriveMax.Value < ptbTune.Value)
                {
                    ptbTune.Value = (int)setupForm.udTXDriveMax.Value;
                }
            }
            lblPWR.Text = "Drive: " + ptbPWR.Value.ToString();
            lblTUNE.Text = "Tune: " + ptbTune.Value.ToString();

            if (chkBoxTune == false)
            {
                lblPWR.ForeColor = Color.Yellow; // DRIVE is now selected
                lblTUNE.ForeColor = Color.White;

                lblPWR.Font = new Font(SystemFonts.DefaultFont, FontStyle.Bold | FontStyle.Italic);            // new Font(defaultFont.FontFamily, defaultFont.Size, FontStyle.Bold);
                lblTUNE.Font = new Font(SystemFonts.DefaultFont, FontStyle.Italic);

            }
            else
            {
                lblPWR.ForeColor = Color.White;
                lblTUNE.ForeColor = Color.Yellow;  //  Tune is now selected

                lblTUNE.Font = new Font(SystemFonts.DefaultFont, FontStyle.Bold | FontStyle.Italic);            // new Font(defaultFont.FontFamily, defaultFont.Size, FontStyle.Bold);
                lblPWR.Font = new Font(SystemFonts.DefaultFont, FontStyle.Italic);

            }


            if (chkBoxDrive.Checked == true)
            {

                ptbPWR.Enabled = false;
                ptbTune.Enabled = false;

                if (setupForm != null)
                {
                    setupForm.udTXTunePower.Enabled = false; // disable the TUNE value selector in setup 
                    setupForm.lblTransmitTunePower.ForeColor = Color.Red;
                }

            }
            else
            {

                ptbPWR.Enabled = true;
                ptbTune.Enabled = true;

                if (setupForm != null)
                {
                    setupForm.udTXTunePower.Enabled = true; // dont disable the TUNE value selector in setup 
                    setupForm.lblTransmitTunePower.ForeColor = SystemColors.ControlText;
                }

            }




        } // chkBoxDrive_CheckedChanged



        //===================================================================
        // ke9ns add to show TUNE slider value on console
        private void ptbTune_Scroll(object sender, EventArgs e)
        {


            if (setupForm != null)
            {
                if (setupForm.udTXDriveMax.Value < ptbPWR.Value)
                {
                    ptbPWR.Value = (int)setupForm.udTXDriveMax.Value;
                }

                if (setupForm.udTXDriveMax.Value < ptbTune.Value)
                {
                    ptbTune.Value = (int)setupForm.udTXDriveMax.Value;
                }
            }




            TunePower = ptbTune.Value; // ke9ns this is the TUNE power value and NOT the Driver ptbPWR value


            lblTUNE.Text = "Tune: " + ptbTune.Value.ToString(); // ke9ns add


            if (chkBoxTune == false)
            {
                lblPWR.ForeColor = Color.Yellow; // DRIVE is now selected
                lblTUNE.ForeColor = Color.White;

                lblPWR.Font = new Font(SystemFonts.DefaultFont, FontStyle.Bold | FontStyle.Italic);            // new Font(defaultFont.FontFamily, defaultFont.Size, FontStyle.Bold);
                lblTUNE.Font = new Font(SystemFonts.DefaultFont, FontStyle.Italic);

            }
            else
            {
                lblPWR.ForeColor = Color.White;
                lblTUNE.ForeColor = Color.Yellow;  //  Tune is now selected

                lblTUNE.Font = new Font(SystemFonts.DefaultFont, FontStyle.Bold | FontStyle.Italic);            // new Font(defaultFont.FontFamily, defaultFont.Size, FontStyle.Bold);
                lblPWR.Font = new Font(SystemFonts.DefaultFont, FontStyle.Italic);

            }

        } // ptbTune_Scroll

        //===================================================================

        //  static Font T1;

        const float MAX_VU_POWER = 60.0f;
        static float[] vhf_power_map = { 0, 0.2f, 2.9f, 10.8f, 22.8f, 36.6f, 48.2f, 52.5f, 58.3f, 60.8f, 62.4f, 64.2f };
        //static float[] uhf_power_map = { 0, 1.3f, 31.2f, 42.2f, 49.7f, 53.7f, 55.8f, 57.6f, 59.3f, 60.3f, 61.6f, 62.4f };
        static float[] uhf_power_map = { 0, 1.5f, 5.5f, 18.1f, 33.5f, 44.3f, 51.2f, 55.7f, 59.0f, 61.6f, 63.5f, 65.0f };

        private void ptbPWR_Scroll(object sender, System.EventArgs e)
        {

            if (setupForm != null)
            {
                if (setupForm.udTXDriveMax.Value > 100) setupForm.udTXDriveMax.Value = 100;
                if (setupForm.udTXDriveMax.Value < 0) setupForm.udTXDriveMax.Value = 0;

                if (ptbPWR.Value < 0) ptbPWR.Value = 0;
                if (ptbPWR.Value > 100) ptbPWR.Value = 100;

                if (ptbTune.Value < 0) ptbTune.Value = 0;
                if (ptbTune.Value > 100) ptbTune.Value = 100;

                if (setupForm.udTXDriveMax.Value < ptbPWR.Value)
                {
                    ptbPWR.Value = (int)setupForm.udTXDriveMax.Value;
                }

                if (setupForm.udTXDriveMax.Value < ptbTune.Value)
                {
                    ptbTune.Value = (int)setupForm.udTXDriveMax.Value;
                }
            }


            lblPWR.Text = "Drive: " + ptbPWR.Value.ToString();

            if (chkBoxTune == false)
            {
                lblPWR.ForeColor = Color.Yellow; // DRIVE is now selected
                lblTUNE.ForeColor = Color.White;

                lblPWR.Font = new Font(SystemFonts.DefaultFont, FontStyle.Bold | FontStyle.Italic);            // new Font(defaultFont.FontFamily, defaultFont.Size, FontStyle.Bold);
                lblTUNE.Font = new Font(SystemFonts.DefaultFont, FontStyle.Italic);

            }
            else
            {
                lblPWR.ForeColor = Color.White;
                lblTUNE.ForeColor = Color.Yellow;  //  Tune is now selected

                lblTUNE.Font = new Font(SystemFonts.DefaultFont, FontStyle.Bold | FontStyle.Italic);            // new Font(defaultFont.FontFamily, defaultFont.Size, FontStyle.Bold);
                lblPWR.Font = new Font(SystemFonts.DefaultFont, FontStyle.Italic);


            }

            if (chkTUN.Checked == true)
            {
                ptbTune.Value = ptbPWR.Value;
                lblTUNE.Text = "Tune: " + ptbTune.Value.ToString();
            }

            if (setupForm == null)
                return;

            if (ptbPWR.Value == 0)
            {
                Audio.RadioVolume = 0.0;
                return;
            }

            float val = (float)ptbPWR.Value;
            double new_volume = 0;

            Band b = tx_band;

            int new_pwr = ptbPWR.Value;

            power_by_band[(int)tx_band] = new_pwr; // original

            try
            {
                if ((int)newMode == 12) newMode = rx1_dsp_mode;

                if ((int)newMode >= 0 && (int)newMode < 12)
                {
                    power_by_mode_by_band[(int)tx_band, (int)newMode] = new_pwr; // ke9ns add
                }
            }
            catch
            {

            }

            if ((!tuning || xvtr_tune_power) && (tx_xvtr_index >= 0))
            {
                int power = ptbPWR.Value;

                if (ptbPWR.Focused) xvtrForm.SetPower(tx_xvtr_index, power);

                b = BandByFreq(xvtrForm.TranslateFreq(TXFreq), tx_xvtr_index, true, current_region);

            }

            if (fwc_init && current_model == Model.FLEX5000 && FWCEEPROM.VUOK && (tx_xvtr_index == 0 || tx_xvtr_index == 1))
            {

                double tx_freq = TXFreq;

                // ******************************************
                // ** Remap VU for more linear slider action
                // ******************************************
                float desired_power = val * MAX_VU_POWER / 100.0f;
                float new_pwr_val = 0;

                if (tx_xvtr_index == 0 && tx_freq >= 144.00)
                {

                    // loop through linear table looking for proper slope point on VHF
                    for (int i = 1; i < 10; i++)
                    {
                        if (desired_power < vhf_power_map[i])
                        {
                            float slope = vhf_power_map[i] - vhf_power_map[i - 1];
                            float percent = (desired_power - vhf_power_map[i - 1]) / slope;
                            new_pwr_val = (i - 2 + percent) * 10;
                            break;
                        }
                    }
                }
                else if (tx_xvtr_index == 1)
                {
                    // loop through linear table looking for proper slope point on UHF
                    for (int i = 1; i < 10; i++)
                    {
                        if (desired_power < uhf_power_map[i])
                        {
                            float slope = uhf_power_map[i] - uhf_power_map[i - 1];
                            float percent = (desired_power - uhf_power_map[i - 1]) / slope;
                            new_pwr_val = (i - 2 + percent) * 10;
                            break;
                        }
                    }
                }

                double interpolatedVolume = 0;

                // ******************************************
                // ** Interpolate VU over freq
                // ******************************************
                if (tx_xvtr_index == 0 && tx_freq >= 144.00)
                {
                    if (xvtrForm.VPA && enable_vu_power_curve)
                    {


                        for (int i = 0; i < freqs_2m.Length; i++)
                        {
                            if (freqs_2m[i] == tx_freq)
                            {
                                interpolatedVolume = vhf_power_table[i];
                                new_volume = (new_pwr_val / 100.0) * interpolatedVolume;
                                break;
                            }
                            else if (freqs_2m[i] > tx_freq)
                            {
                                double percent = (tx_freq - freqs_2m[i - 1]) / (freqs_2m[i] - freqs_2m[i - 1]);
                                interpolatedVolume = vhf_power_table[i - 1] + percent * (vhf_power_table[i] - vhf_power_table[i - 1]);
                                new_volume = (new_pwr_val / 100.0) * interpolatedVolume;
                                break;
                            }
                        }


                    }
                    else //Full scale for low power
                    {

                        for (int i = 0; i < freqs_2m.Length; i++)
                        {
                            if (freqs_2m[i] == tx_freq)
                            {
                                interpolatedVolume = vhf_power_table[i];
                                new_volume = Math.Sqrt(val / 100.0) * interpolatedVolume;
                                break;
                            }
                            else if (freqs_2m[i] > tx_freq)
                            {
                                double percent = (tx_freq - freqs_2m[i - 1]) / (freqs_2m[i] - freqs_2m[i - 1]);
                                interpolatedVolume = vhf_power_table[i - 1] + percent * (vhf_power_table[i] - vhf_power_table[i - 1]);
                                new_volume = Math.Sqrt(val / 100.0) * interpolatedVolume;
                                break;
                            }
                        }

                    }
                }
                else if (tx_xvtr_index == 1)
                {
                    if (xvtrForm.UPA && enable_vu_power_curve)
                    {
                        for (int i = 0; i < freqs_70cm.Length; i++)
                        {
                            if (freqs_70cm[i] == tx_freq)
                            {
                                interpolatedVolume = uhf_power_table[i];
                                new_volume = (new_pwr_val / 100.0) * interpolatedVolume;
                                break;
                            }

                            else if (freqs_70cm[i] > tx_freq)
                            {
                                double percent = (tx_freq - freqs_70cm[i - 1]) / (freqs_70cm[i] - freqs_70cm[i - 1]);
                                interpolatedVolume = uhf_power_table[i - 1] + percent * (uhf_power_table[i] - uhf_power_table[i - 1]);
                                new_volume = (new_pwr_val / 100.0) * interpolatedVolume;
                                break;
                            }
                        }
                    }
                    else  //Full scale for low power
                    {
                        for (int i = 0; i < freqs_70cm.Length; i++)
                        {
                            if (freqs_70cm[i] == tx_freq)
                            {
                                interpolatedVolume = uhf_power_table[i];
                                new_volume = Math.Sqrt(val / 100.0) * interpolatedVolume;
                                break;
                            }

                            else if (freqs_70cm[i] > tx_freq)
                            {
                                double percent = (tx_freq - freqs_70cm[i - 1]) / (freqs_70cm[i] - freqs_70cm[i - 1]);
                                interpolatedVolume = uhf_power_table[i - 1] + percent * (uhf_power_table[i] - uhf_power_table[i - 1]);
                                new_volume = Math.Sqrt(val / 100.0) * interpolatedVolume;
                                break;
                            }
                        }
                    }
                }
                Audio.RadioVolume = new_volume;
            }
            else if (pa_present && VFOAFreq < 29.7f || (fwc_init && (current_model == Model.FLEX5000 || current_model == Model.FLEX3000)))
            {
                int[] powers = { 1, 2, 5, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100 };

                if (new_power_cal)
                {
                    //double new_volume;
                    // interpolate between values
                    int pwr = (int)val;
                    int index1 = 12;
                    while (powers[index1] > pwr) index1--;
                    int index2 = 0;
                    while (powers[index2] < pwr) index2++;

                    /*  if (current_model == Model.SDR1000 && pwr < 10)
                      {
                          new_volume = Math.Sqrt(pwr / 10.0 * Math.Pow(power_table[(int)b][3], 2.0)) / audio_volts1;
                      }
                    */

                    Debug.WriteLine("FORWARD POWER: " + b + " , " + pwr + " , " + index1 + " , " + index2 + " , " + power_table[(int)b][index1] + " , " + power_table[(int)b][index2]);

                    if (index1 == index2)
                    {
                        new_volume = power_table[(int)b][index1] / audio_volts1;
                    }
                    else
                    {
                        double percent = ((double)pwr - powers[index1]) / ((double)powers[index2] - powers[index1]);
                        double val1;
                        if (index1 < 0) val1 = 0;
                        else val1 = Math.Pow(power_table[(int)b][index1], 2.0);
                        double val2 = Math.Pow(power_table[(int)b][index2], 2.0);
                        new_volume = Math.Sqrt(val1 + percent * (val2 - val1)) / audio_volts1;
                    }

                    if (!tuning && (rx1_dsp_mode == DSPMode.AM || rx1_dsp_mode == DSPMode.SAM))
                        new_volume = Math.Sqrt(Math.Pow((new_volume * audio_volts1), 2.0) * 2.0) / audio_volts1;
                    Audio.RadioVolume = new_volume;
                }
                else
                {
                    double target_dbm = 10 * (double)Math.Log10((double)val * 1000);
                    target_dbm -= GainByBand(TXBand);

                    double target_volts = Math.Sqrt(Math.Pow(10, target_dbm * 0.1) * 0.05);		// E = Sqrt(P * R) 
                    Audio.RadioVolume = target_volts / audio_volts1;
                }
            }
            else if (hid_init && current_model == Model.FLEX1500)
            {
                if (tx_ant_1500 == HIDAnt.PA)
                {
                    Band band = b;
                    if (tx_xvtr_index >= 0) // get the HF band
                        band = BandByFreq(xvtrForm.TranslateFreq(TXFreq), -1, true, current_region);

                    float cal = power_table[(int)band][0];
                    Audio.RadioVolume = cal * val / 100.0;
                }
                else Audio.RadioVolume = Math.Sqrt((double)ptbPWR.Value / 100.0);
                //Debug.WriteLine("RadioVolume: " + Audio.RadioVolume.ToString("f4"));
            }
            else
            {
                const double TARGET = 0.8;		// audio in volts needed to hit 1W 
                Audio.RadioVolume = (double)Math.Sqrt((double)ptbPWR.Value / 100.0) / audio_volts1 * TARGET;
            }


            if (ptbPWR.Focused) btnHidden.Focus();

        } // ptbPWR_Scroll


        //===========================================================================================
        // ke9ns add
        private void ptbMON_Scroll(object sender, EventArgs e)
        {

            TXAF = ptbMON.Value;  // ke9ns update MON volume


            if ((mox) && ((chkMON.Checked == true) || (ckQuickPlay.Checked == true))) // && ((setupForm.chkRX2AutoMuteRX2OnVFOATX.Checked == true && setupForm.chkRX2AutoMuteRX1OnVFOBTX.Checked == true)) )  // ke9ns add    (dont go into MON if in full duplex mode, leave as AF)
            {
                lblMON.Text = "MON: " + ptbMON.Value.ToString(); // ke9ns add
                ptbAF.Value = ptbMON.Value;

                lblAF.Text = "AF: " + ptbAF.Value.ToString();

                ptbAF_Scroll(this, EventArgs.Empty);

            }
            else lblMON.Text = "MON: " + ptbMON.Value.ToString(); // ke9ns add


            if (chkBoxMON == false)
            {
                lblAF.ForeColor = Color.Yellow; // DRIVE is now selected
                lblMON.ForeColor = Color.White;

                lblAF.Font = new Font(SystemFonts.DefaultFont, FontStyle.Bold | FontStyle.Italic);            // new Font(defaultFont.FontFamily, defaultFont.Size, FontStyle.Bold);
                lblMON.Font = new Font(SystemFonts.DefaultFont, FontStyle.Italic);

            }
            else
            {
                lblAF.ForeColor = Color.White;
                lblMON.ForeColor = Color.Yellow;  //  Tune is now selected

                lblMON.Font = new Font(SystemFonts.DefaultFont, FontStyle.Bold | FontStyle.Italic);            // new Font(defaultFont.FontFamily, defaultFont.Size, FontStyle.Bold);
                lblAF.Font = new Font(SystemFonts.DefaultFont, FontStyle.Italic);

            }

        } //ptbMON_Scroll


        //===========================================================================================
        private void ptbAF_Scroll(object sender, System.EventArgs e)
        {
            //udAF.Value = ptbAF.Value;

            //  Debug.WriteLine("SCROLL here "+ mox + " , "+ ckQuickPlay.Checked);
            if ((mox) && ((chkMON.Checked == true) || (ckQuickPlay.Checked == true))) // && ((setupForm.chkRX2AutoMuteRX2OnVFOATX.Checked == true && setupForm.chkRX2AutoMuteRX1OnVFOBTX.Checked == true)) )  // ke9ns add    (dont go into MON if in full duplex mode, leave as AF)
            {
                lblMON.Text = "MON: " + ptbMON.Value.ToString(); // ke9ns add
                lblAF.Text = "AF: " + ptbAF.Value.ToString();
            }
            else
            {
                lblAF.Text = "AF: " + ptbAF.Value.ToString();
            }


            if (chkBoxMON == false)
            {
                lblAF.ForeColor = Color.Yellow; // DRIVE is now selected
                lblMON.ForeColor = Color.White;

                lblAF.Font = new Font(SystemFonts.DefaultFont, FontStyle.Bold | FontStyle.Italic);            // new Font(defaultFont.FontFamily, defaultFont.Size, FontStyle.Bold);
                lblMON.Font = new Font(SystemFonts.DefaultFont, FontStyle.Italic);

            }
            else
            {
                lblAF.ForeColor = Color.White;
                lblMON.ForeColor = Color.Yellow;  //  Tune is now selected

                lblMON.Font = new Font(SystemFonts.DefaultFont, FontStyle.Bold | FontStyle.Italic);            // new Font(defaultFont.FontFamily, defaultFont.Size, FontStyle.Bold);
                lblAF.Font = new Font(SystemFonts.DefaultFont, FontStyle.Italic);

            }


            if ((hid_init) && (current_model == Model.FLEX1500) && (mox) && (chkMON.Checked))
            {
                double percent = (double)(ptbAF.Value - ptbAF.Minimum) / (double)ptbAF.Maximum;

                byte reg_val = (byte)(0xFF - 0x7F * percent);

                USBHID.SetMonGain(reg_val);
            }
            else
            {
                if (chkMUT.Checked) // check if in MUTE mode
                {
                    if (chkBoxMuteSpk.Checked == false) // ke9ns add chkMUT routine now check sor chkBoxMuteSpk option
                    {
                        Audio.MonitorVolume = 0.0;
                    }
                    else
                    {
                        switch (current_model) // ke9ns add (to allow slider to adjust output of headphones
                        {
                            case Model.FLEX1500:
                                Audio.MonitorVolume = ptbAF.Value / 100.0 * 0.8; // cap at 80% of Full Scale to prevent popping
                                break;
                            default:
                                // if ((mox) && (chkVFOBTX.Checked == false || chkRX2.Checked == false))
                                Audio.MonitorVolume = ptbAF.Value / 100.0;
                                break;
                        }

                    }
                }
                else if ((num_channels > 2) && (mox) && (!chkMON.Checked))  // if TX and no MON enabled
                {
                    if (chkBoxMuteSpk.Checked == false) // ke9ns add chkMUT routine now check sor chkBoxMuteSpk option
                    {
                        Audio.MonitorVolume = 0.0;
                    }
                    else
                    {

                    }
                }
                else
                {

                    switch (current_model)
                    {
                        case Model.FLEX1500:
                            Audio.MonitorVolume = ptbAF.Value / 100.0 * 0.8; // cap at 80% of Full Scale to prevent popping
                            break;
                        default:
                            // if ((mox) && (chkVFOBTX.Checked == false || chkRX2.Checked == false))
                            Audio.MonitorVolume = ptbAF.Value / 100.0;
                            break;
                    }
                }

            }

            if ((mox) && ((chkMON.Checked == true) || (ckQuickPlay.Checked == true)))// && ((setupForm.chkRX2AutoMuteRX2OnVFOATX.Checked == true && setupForm.chkRX2AutoMuteRX1OnVFOBTX.Checked == true) ) )  // ke9ns MOD to prevent MON function when in full duplex (RX2 ON the VFOB TX)
            {

                TXAF = ptbAF.Value;   // if transmit
                Debug.WriteLine("TXAF WRITE " + TXAF);

            }
            else
            {
                RXAF = ptbAF.Value; // ke9ns if Receive  was !MOX
                Debug.WriteLine("RXAF: " + RXAF + " , " + TXAF);
            }



            if (ptbAF.Focused) btnHidden.Focus();

        } // ptbAF_Scroll


        //======================================================================================================

        public void ptbRF_Scroll(object sender, System.EventArgs e)
        {
            lblRF.Text = "AGC-T:  " + ptbRF.Value.ToString();

            switch (RX1AGCMode)
            {
                case AGCMode.FIXD:
                    if (setupForm != null) setupForm.AGCFixedGain = ptbRF.Value;
                    break;
                default:
                    if (setupForm != null) setupForm.AGCMaxGain = ptbRF.Value;
                    break;
            }

            rx1_agct_by_band[(int)rx1_band] = ptbRF.Value;

            if (AGCTDIS == true)
            {
                if (Display.AGCT_Y_BELOW == true) // because of the scale settings or auto pan (you may not have much below the noise floor showing up on the pan)
                {

                    if (setupForm != null)
                    {
                        if (setupForm.tbGridOffset.Value < 40) setupForm.tbGridOffset.Value++; // move up
                        setupForm.tbGridOffset_Scroll(this, EventArgs.Empty); //move the noise floor up/down to allow the Green AGCT_Y line to show up on the screen (not drop below view)
                        // ke9ns: this is the slider from setup->Display->auto pan slider
                    }
                }
            }

            if (ptbRF.Focused) btnHidden.Focus();
        }


        //=============================================================================
        private void ptbMic_Scroll(object sender, System.EventArgs e)
        {
            lblMicVal.Text = ptbMic.Value.ToString();

            if (dsp.GetDSPTX(0).CurrentDSPMode != DSPMode.FM)
            {
                double gain_db = (double)ptbMic.Value;
                if (mic_boost) gain_db += 20.0;

                Audio.MicPreamp = Math.Pow(10.0, gain_db / 20.0); // convert to scalar
            }
            if (ptbMic.Focused) btnHidden.Focus();
        }



        public bool CW_STATE = false; // ke9ns add to allow display of CW signals per setupForm.chkCWDisplay (audio.cs sets true or false)

        // ke9ns mod (link up with CWX panel)
        private void ptbCWSpeed_Scroll(object sender, System.EventArgs e)
        {
            //  if (setupForm == null || setupForm.IsDisposed) setupForm = new Setup(this); // ke9ns add
            //  if (cwxForm == null || cwxForm.IsDisposed)     cwxForm = new CWX(this);

            lblCWSpeed.Text = "Speed:  " + ptbCWSpeed.Value.ToString() + " WPM";

            if (cwxForm != null) // if cwx panel open, then use it,otherwise change CWKeyer directly
            {
                //   Debug.WriteLine("CWX1 " + ptbCWSpeed.Value);

                cwxForm.WPM = ptbCWSpeed.Value; // cwxForm.WPM = ptbCWSpeed.Value; // ke9ns add

            }
            else
            {
                //  Debug.WriteLine("CWX0 " + ptbCWSpeed.Value);

                CWKeyer.WPM = ptbCWSpeed.Value;
            }

            if (ptbCWSpeed.Focused) btnHidden.Focus();

        } // ptbCWSpeed_Scroll

        private void chkVOX_CheckedChanged(object sender, System.EventArgs e)
        {
            //  if ((vac_enabled || vac2_enabled) == false) // ke9ns only allows VOX when VAC1 and VAC2 OFF
            //  {
            if (setupForm != null) setupForm.VOXEnable = chkVOX.Checked;

            if (chkVOX.Checked) chkVOX.BackColor = button_selected_color;
            else
            {
                Audio.VOXActive = false;
                chkVOX.BackColor = SystemColors.Control;
            }
            //  }
            //  else chkVOX.Checked = false;
        }

        private void checkVOX_CheckedChanged(object sender, System.EventArgs e)
        {
            //  if ((vac_enabled || vac2_enabled) == false) // ke9ns original code: only allows VOX when VAC1 and VAC2 OFF
            //  {


            if (setupForm != null)
            {
                setupForm.VOXEnable = checkVOX.Checked;
            }

            if (checkVOX.Checked) checkVOX.BackColor = button_selected_color;
            else
            {
                Audio.VOXActive = false;
                checkVOX.BackColor = SystemColors.Control;
            }
            //  }
            //  else chkVOX.Checked = false;
        }

        private void ptbSquelch_Scroll(object sender, System.EventArgs e)
        {
            chkSquelch.Text = "SQL:  " + ptbSquelch.Value.ToString();

            if (rx1_dsp_mode == DSPMode.FM) //FM Squelch
            {
                dsp.GetDSPRX(0, 0).FMSquelchThreshold = (float)Math.Pow(10.0, -2 * ptbSquelch.Value / 100.0);
                dsp.GetDSPRX(0, 1).FMSquelchThreshold = (float)Math.Pow(10.0, -2 * ptbSquelch.Value / 100.0);
            }
            else //non-FM Squelch
            {
                if (fwc_init && (current_model == Model.FLEX5000 || current_model == Model.FLEX3000))
                {
                    dsp.GetDSPRX(0, 0).RXSquelchThreshold = (float)ptbSquelch.Value -
                        rx1_meter_cal_offset -
                        rx1_preamp_offset[(int)rx1_preamp_mode] -
                        rx1_filter_size_cal_offset -
                        rx1_path_offset;

                    dsp.GetDSPRX(0, 1).RXSquelchThreshold = (float)ptbSquelch.Value -
                        rx1_meter_cal_offset -
                        rx1_preamp_offset[(int)rx1_preamp_mode] -
                        rx1_filter_size_cal_offset -
                        rx1_path_offset;
                }
                else
                {
                    dsp.GetDSPRX(0, 0).RXSquelchThreshold = (float)ptbSquelch.Value -
                        rx1_preamp_offset[(int)rx1_preamp_mode] -
                        rx1_meter_cal_offset -
                        rx1_filter_size_cal_offset;

                    dsp.GetDSPRX(0, 1).RXSquelchThreshold = (float)ptbSquelch.Value -
                        rx1_preamp_offset[(int)rx1_preamp_mode] -
                        rx1_meter_cal_offset -
                        rx1_filter_size_cal_offset;
                }
            }

            if (ptbSquelch.Focused) btnHidden.Focus();

        } //ptbSquelch_Scroll

        private void picSquelch_Paint(object sender, System.Windows.Forms.PaintEventArgs e)
        {
            int signal_x = (int)((sql_data + 160.0) * (picSquelch.Width - 1) / 160.0);
            int sql_x = (int)(((float)ptbSquelch.Value + 160.0) * (picSquelch.Width - 1) / 160.0);

            if (mox) signal_x = sql_x = 0;

            e.Graphics.FillRectangle(new SolidBrush(Color.LimeGreen), 0, 0, signal_x, picSquelch.Height);

            if (sql_x < signal_x)
            {
                e.Graphics.FillRectangle(new SolidBrush(Color.Red), sql_x + 1, 0, signal_x - sql_x - 1, picSquelch.Height);
                ScanControl.ScanStop = 1; // ke9ns add

            }

            ScanControl.SQL = (int)ptbSquelch.Value;
            ScanControl.SIG = (int)sql_data;



        } // picSquelch_Paint

        private void chkNoiseGate_CheckedChanged(object sender, System.EventArgs e)
        {
            if (setupForm != null) setupForm.NoiseGateEnabled = chkNoiseGate.Checked;

            if (chkNoiseGate.Checked) chkNoiseGate.BackColor = button_selected_color;
            else chkNoiseGate.BackColor = SystemColors.Control;
        }

        private void ptbVACRXGain_Scroll(object sender, System.EventArgs e)
        {
            lblRXGain.Text = "RX Gain:  " + ptbVACRXGain.Value.ToString();
            if (setupForm != null)
            {
                if (!(chkRX2.Checked && chkVAC2.Checked && chkVFOBTX.Checked))
                {
                    lblVACRXIndicator.Text = "VAC1";
                    lblVACTXIndicator.Text = "VAC1";
                    setupForm.VACRXGain = ptbVACRXGain.Value;
                    vac_rx_gain = ptbVACRXGain.Value;
                }
                else
                {
                    lblVACRXIndicator.Text = "VAC2";
                    lblVACTXIndicator.Text = "VAC2";
                    setupForm.VAC2RXGain = ptbVACRXGain.Value;
                    vac2_rx_gain = ptbVACRXGain.Value;
                }
            }
            if (ptbVACRXGain.Focused) btnHidden.Focus();
        }

        private void ptbVACTXGain_Scroll(object sender, System.EventArgs e)
        {
            lblTXGain.Text = "TX Gain:  " + ptbVACTXGain.Value.ToString();
            if (setupForm != null)
            {
                if (!(chkRX2.Checked && chkVAC2.Checked && chkVFOBTX.Checked))
                {
                    lblVACRXIndicator.Text = "VAC1";
                    lblVACTXIndicator.Text = "VAC1";
                    setupForm.VACTXGain = ptbVACTXGain.Value;
                    vac_tx_gain = ptbVACTXGain.Value;
                }
                else
                {
                    lblVACRXIndicator.Text = "VAC2";
                    lblVACTXIndicator.Text = "VAC2";
                    setupForm.VAC2TXGain = ptbVACTXGain.Value;
                    vac2_tx_gain = ptbVACTXGain.Value;
                }
            }
            if (ptbVACTXGain.Focused) btnHidden.Focus();
        }

        private void ptbVOX_Scroll(object sender, System.EventArgs e)
        {
            lblVOXVal.Text = ptbVOX.Value.ToString();
            if (setupForm != null) setupForm.VOXSens = ptbVOX.Value;
            if (ptbVOX.Focused) btnHidden.Focus();
        }

        private void prettyTrackBarVOX_Scroll(object sender, System.EventArgs e)
        {
            labelVOXVal.Text = prettyTrackBarVOX.Value.ToString();
            if (setupForm != null) setupForm.VOXSens = prettyTrackBarVOX.Value;
            if (prettyTrackBarVOX.Focused) btnHidden.Focus();
        }

        private void picVOX_Paint(object sender, System.Windows.Forms.PaintEventArgs e)
        {
            int peak_x = (int)(Audio.Peak * 20.0f * (float)picVOX.Width); // W4TME  (was 20)
            int vox_x = (int)((float)ptbVOX.Value * ((float)picVOX.Width - 1.0f) / 500.0f);  //W4TME

            if (!chkVOX.Checked || peak_x < 0) peak_x = vox_x = 0;
            e.Graphics.FillRectangle(new SolidBrush(Color.LimeGreen), 0, 0, peak_x, picVOX.Height);
            if (vox_x < peak_x)
                e.Graphics.FillRectangle(new SolidBrush(Color.Red), vox_x + 1, 0, peak_x - vox_x - 1, picVOX.Height);
        }


        // ke9ns add  add vox slider to DIGITAL panel (not just PHONE)
        private void pictureBoxVOX_Paint(object sender, System.Windows.Forms.PaintEventArgs e)
        {
            int peak_x = (int)(Audio.Peak * 20.0f * (float)pictureBoxVOX.Width); // W4TME
            int vox_x = (int)((float)prettyTrackBarVOX.Value * ((float)pictureBoxVOX.Width - 1.0f) / 500.0f);  //W4TME

            if (!checkVOX.Checked || peak_x < 0) peak_x = vox_x = 0;
            e.Graphics.FillRectangle(new SolidBrush(Color.LimeGreen), 0, 0, peak_x, pictureBoxVOX.Height);
            if (vox_x < peak_x)
                e.Graphics.FillRectangle(new SolidBrush(Color.Red), vox_x + 1, 0, peak_x - vox_x - 1, pictureBoxVOX.Height);
        }

        private void ptbNoiseGate_Scroll(object sender, System.EventArgs e)
        {
            lblNoiseGateVal.Text = ptbNoiseGate.Value.ToString();
            if (setupForm != null) setupForm.NoiseGate = ptbNoiseGate.Value;
            if (ptbNoiseGate.Focused) btnHidden.Focus();
        }

        private void picNoiseGate_Paint(object sender, System.Windows.Forms.PaintEventArgs e)
        {
            int signal_x = (int)((noise_gate_data + 160.0) * (picNoiseGate.Width - 1) / 160.0);
            int noise_x = (int)(((float)ptbNoiseGate.Value + 160.0) * (picNoiseGate.Width - 1) / 160.0);

            if (!mox) signal_x = noise_x = 0;
            e.Graphics.FillRectangle(new SolidBrush(Color.LimeGreen), 0, 0, signal_x, picNoiseGate.Height);
            if (noise_x < signal_x)
                e.Graphics.FillRectangle(new SolidBrush(Color.Red), noise_x + 1, 0, signal_x - noise_x - 1, picNoiseGate.Height);
        }

        private void WheelTune_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
        {
            if (e.Button == MouseButtons.Left) ChangeTuneStepUp();
        }


        //============================================================================================
        // ke9ns mod  normally MON works only on post-processed audio, so no AM or FM since AM has an envelope and FM is FM
        //            add ability to switch between Pre and Post-processed audio
        //============================================================================================
        public void chkMON_CheckedChanged(object sender, System.EventArgs e)
        {
            //CWKeyer.SensorQueuePrint();
            //CWKeyer.ToneQueuePrint();


            chkMON.CheckedChanged -= chkMON_CheckedChanged; // ke9ns mod turn eventoff

            if (moninit == 1) // ke9ns mod: comes here first time
            {
                if (chkMON.Checked == true)
                {
                    if (Audio.MON_PRE == 1)
                    {
                        Audio.MON_PRE = 0;
                        chkMON.Checked = false;
                    }
                    else
                    {
                        Audio.MON_PRE = 0;
                        chkMON.Checked = true;
                    }

                }
                else
                {
                    Audio.MON_PRE = 1;// comes here to turn off MON from quickplay
                    chkMON.Checked = false;
                }
                moninit = 0; // only do 1 time

            } //  if (moninit == 1)


            if (Audio.MON_PRE == 0)  // ke9ns mod MON_PRE was 0 
            {
                if (chkMON.Checked == false)
                {
                    Audio.MON_PRE = 1;           // turn on MON_PRE
                    chkMON.Text = "MONpr";
                    chkMON.Checked = true;
                    //  Debug.WriteLine("pre=1 and checked = true  PR");
                }
                else
                {
                    Audio.MON_PRE = 0;            // turn off MON_PRE
                    chkMON.Text = "MONps";
                    chkMON.Checked = true;
                    //  Debug.WriteLine("pre=0 and checked = true  PS");
                }

            }
            else // MON_PRE was 1 so turn off here
            {
                if (chkMON.Checked == false)
                {
                    Audio.MON_PRE = 0;
                    chkMON.Text = "MON";
                    chkMON.Checked = false;
                    //  Debug.WriteLine("pre=0 and checked = false OFF");

                }
                else
                {
                    Audio.MON_PRE = 0;
                    chkMON.Text = "MON";
                    chkMON.Checked = true;
                    // Debug.WriteLine("pre=0 and checked = true BAD");
                }


            }

            chkMON.CheckedChanged += chkMON_CheckedChanged; //ke9ns mod turn eventoff

            Audio.MON = chkMON.Checked; // ke9ns tell audio routine MON is on or OFF


            //--------------------------------------------------------------------------

            if (chkMON.Checked)
            {
                chkMON.BackColor = button_selected_color;
            }
            else
            {
                chkMON.BackColor = SystemColors.Control;
            }

            //  Debug.WriteLine("num_channels " + num_channels);

            if ((num_channels == 4) || (num_channels == 6)) // normally 2 channels
            {
                if (!((chkMON.Checked == false) && (mox)))
                {
                    ptbAF_Scroll(this, EventArgs.Empty);
                    //   Debug.WriteLine("ptbAF_Scroll " + num_channels);


                }
                else
                {
                    Audio.MonitorVolume = 0.0;
                }
            }
            else
            {
                //   if (chkPower.Checked && mox && current_model == Model.SDR1000)
                //  {
                //      Hdw.MuteRelay = !chkMON.Checked;
                //  }
            }



            if ((hid_init) && (current_model == Model.FLEX1500))
            {
                USBHID.SetMon(chkMON.Checked);

                if (chkMON.Checked && mox) ptbAF_Scroll(this, EventArgs.Empty);
            }




        } // chkMON_CheckedChanged



        //============================================================================================
        // ke9ns 
        private void AudioMOXChanged(bool tx)
        {

            if ((tx))
            {
                Audio.MOX = tx;

                if ((chkMON.Checked == true) || (ckQuickPlay.Checked == true)) ptbAF.Value = txaf;  // ke9ns mod     // && (setupForm.chkRX2AutoMuteRX2OnVFOATX.Checked == true && setupForm.chkRX2AutoMuteRX1OnVFOBTX.Checked == true))    // k9ens mod was just if (tx)  no MON if the full duplex
                else ptbAF.Value = rxaf;

            }
            else // rx
            {

                //Audio.MOX = tx; // now taken care of near the ramp logic
                ptbAF.Value = rxaf;
            }

            //udPWR_ValueChanged(this, EventArgs.Empty);
            ptbAF_Scroll(this, EventArgs.Empty);

        } // private void AudioMOXChanged(bool tx)



        private void HdwMOXChanged(bool tx, double freq)
        {
            //	if(current_model == Model.SDR1000)		Hdw.UpdateHardware = false;

            if (tx)
            {
                switch (rx1_dsp_mode)
                {
                    case DSPMode.AM:
                    case DSPMode.SAM:
                    case DSPMode.FM:
                        freq -= 0.011025;
                        break;
                        /*case DSPMode.DRM:
                            freq -= 0.012;
                            break;*/
                }

                spur_reduction = false;
                if_shift = false;

                if (fwc_init && (current_model == Model.FLEX5000 || current_model == Model.FLEX3000))
                {
                    // make sure TX freq has been set
                    if (tx_dds_freq_updated)
                    {
                        FWC.SetTXFreqTW(tx_dds_freq_tw, tx_dds_freq_mhz);
                        tx_dds_freq_updated = false;
                    }

                    FWC.SetMOX(true);
                    fwc_pa_bias = true;
                    if (current_model == Model.FLEX3000)
                    {
                        //f3k_fan = true;
                        mic_down = false;
                        mic_down_running = false;
                        mic_up = false;
                        mic_up_running = false;
                    }

                    if (preSelForm != null)
                        preSelForm.MOX = tx;
                }
                else if (hid_init && current_model == Model.FLEX1500)
                {
                    if (chkVFOSplit.Checked)
                        txtVFOBFreq_LostFocus(this, EventArgs.Empty);
                    else
                        txtVFOAFreq_LostFocus(this, EventArgs.Empty);

                    rx1_dds_freq_updated = false;
                    last_tw = 0; // to reset spur reduction on next transition to RX

                    USBHID.SetFreqTW(rx1_dds_freq_tw);
                    Set1500Filters(TW2Freq(rx1_dds_freq_tw));

                    USBHID.SetMOX(true);

                    Debug.WriteLine("====HDWMOXCHANGED TX");
                }
                else
                {
                    if (num_channels == 2) Hdw.MuteRelay = !chkMON.Checked;

                    if (ext_ctrl_enabled)
                    {
                        Hdw.UpdateHardware = true;
                        UpdateExtCtrl();
                        Hdw.UpdateHardware = false;
                    }

                    if (x2_enabled)
                    {
                        Hdw.UpdateHardware = true;
                        Hdw.X2 = (byte)(Hdw.X2 | 0x40);
                        Hdw.UpdateHardware = false;
                        Thread.Sleep(x2_delay);
                    }

                    Hdw.GainRelay = true;       // 0dB
                    Hdw.Attn = false;

                    if ((xvtr_present) && (freq >= 134.0)) // ke9ns test was 144.0  .217
                    {
                        Hdw.XVTR_RF = true;
                        if (current_xvtr_tr_mode == XVTRTRMode.POSITIVE) Hdw.XVTR_TR = true;
                        else if (current_xvtr_tr_mode == XVTRTRMode.NEGATIVE) Hdw.XVTR_TR = false;
                    }
                    else
                    {
                        if (tx_xvtr_index < 0 || !xvtrForm.GetXVTRRF(tx_xvtr_index))
                        {
                            Hdw.RFE_TR = true;
                            if (pa_present && freq <= 30.0)
                            {
                                Hdw.PA_TR_Relay = true;
                                Hdw.PABias = true;
                            }
                            if (rfe_pa_tr_enable && freq <= 30.0) Hdw.PA_TR_Relay = true;
                        }
                        else
                        {
                            Hdw.XVTR_RF = true;
                        }
                    }

                    Hdw.TransmitRelay = true;
                }
            }
            else // rx
            {
                if (fwc_init && (current_model == Model.FLEX5000 || current_model == Model.FLEX3000))
                {
                    FWC.SetMOX(false);
                    //FWC.SetPABias(false); // now done in firmware
                    fwc_pa_bias = false;

                    if (preSelForm != null)
                        preSelForm.MOX = tx;

                    spur_reduction = setupForm.chkGeneralSpurRed.Checked;

                    if (rx1_dsp_mode != DSPMode.DRM && rx1_dsp_mode != DSPMode.SPEC) if_shift = true;
                }
                else if (hid_init && current_model == Model.FLEX1500)
                {

                    USBHID.SetMOX(false);

                    Debug.WriteLine("====HDWMOXCHANGED RX");
                    spur_reduction = chkSR.Checked;

                    if (rx1_dsp_mode != DSPMode.DRM && rx1_dsp_mode != DSPMode.SPEC) if_shift = true;

                    txtVFOAFreq_LostFocus(this, EventArgs.Empty);
                }
                /* else if(current_model == Model.SDR1000)
                 {
                     if(xvtr_present && Hdw.XVTR_RF)
                     {
                         Hdw.XVTR_RF = false;
                         if(current_xvtr_tr_mode == XVTRTRMode.POSITIVE)
                             Hdw.XVTR_TR = false;
                         else if(current_xvtr_tr_mode == XVTRTRMode.NEGATIVE)
                             Hdw.XVTR_TR = true;
                     }
                     else
                     {	
                         if(tx_xvtr_index < 0 || !xvtrForm.GetXVTRRF(tx_xvtr_index))
                         {
                             Hdw.RFE_TR = false;
                             if(pa_present)
                             {
                                 Hdw.PABias = false;
                                 Hdw.PA_TR_Relay = false;
                             }
                             if(rfe_pa_tr_enable)
                             {
                                 Hdw.PA_TR_Relay = false;
                             }
                         }
                         else
                         {
                             Hdw.XVTR_RF = false;
                         }
                     }
                     Hdw.TransmitRelay = false;

                     if(x2_enabled)
                     {
                         Hdw.UpdateHardware = true;
                         Hdw.X2 = (byte)(Hdw.X2 & 0xBF);
                         Hdw.UpdateHardware = false;
                         Thread.Sleep(x2_delay);
                     }

                     if(!chkMUT.Checked && num_channels == 2)
                         Hdw.MuteRelay = false;

                     RX1PreampMode = rx1_preamp_mode;

                     spur_reduction = setupForm.chkGeneralSpurRed.Checked;

                     if (rx1_dsp_mode != DSPMode.DRM &&
                     rx1_dsp_mode != DSPMode.SPEC)
                         if_shift = true;
                 }
                 */
            }

            if (!fwc_init && !hid_init && current_model != Model.FLEX5000 && current_model != Model.FLEX3000 && current_model != Model.FLEX1500)
            {
                Hdw.UpdateHardware = true;

                if (tx && !tuning)
                {
                    DDSFreq = freq;
                }
                else if (tx && chkVFOSplit.Checked)
                {
                    txtVFOBFreq_LostFocus(this, EventArgs.Empty);
                }
                else
                {
                    txtVFOAFreq_LostFocus(this, EventArgs.Empty);
                }
            }
        } // HdwMOXChanged


        //======================================================================
        // ke9ns add
        DSPMode SplitModeTX = DSPMode.FIRST;
        DSPMode SplitModeRX = DSPMode.USB;

        private void UIMOXChangedTrue()
        {
            Display.MOX = true;
            meter_peak_count = multimeter_peak_hold_samples;        // reset multimeter peak

            switch (Display.CurrentDisplayMode)
            {
                case DisplayMode.PANADAPTER:
                case DisplayMode.SPECTRUM:
                case DisplayMode.HISTOGRAM:
                case DisplayMode.WATERFALL:
                case DisplayMode.PANAFALL:
                case DisplayMode.PANASCOPE:
                    //Display.DrawBackground();
                    break;
            }

            comboMeterRXMode.ForeColor = Color.Gray;
            comboMeterTXMode.ForeColor = Color.White;
            comboMeterTXMode_SelectedIndexChanged(this, EventArgs.Empty);

            comboMeterTX1Mode.ForeColor = Color.White; // ke9ns add
            comboMeterTX1Mode_SelectedIndexChanged(this, EventArgs.Empty); // ke9ns add for lblrx2meter


            if (!disable_ui_mox_changes)
            {
                setupForm.SpurRedEnabled = false;
                DisableAllBands();

                if (chkVFOSplit.Checked != true) DisableAllModes(); // ke9ns mod to allow MODE change while in SPLIT
                else
                {
                    DisableAllModes();
                    //EnableAllModes();

                    if (radModeLSB.Text != "") radModeLSB.Enabled = true;
                    if (radModeLSB.BackColor == vfo_text_dark_color) radModeLSB.BackColor = button_selected_color;
                    if (radModeUSB.Text != "") radModeUSB.Enabled = true;
                    if (radModeUSB.BackColor == vfo_text_dark_color) radModeUSB.BackColor = button_selected_color;

                    if (radModeDIGL.Text != "") radModeDIGL.Enabled = true;
                    if (radModeDIGL.BackColor == vfo_text_dark_color) radModeDIGL.BackColor = button_selected_color;
                    if (radModeDIGU.Text != "") radModeDIGU.Enabled = true;
                    if (radModeDIGU.BackColor == vfo_text_dark_color) radModeDIGU.BackColor = button_selected_color;

                }


                chkVFOSplit.Enabled = false;
                btnVFOAtoB.Enabled = false;
                btnVFOBtoA.Enabled = false;
                btnVFOSwap.Enabled = false;
                chkPower.BackColor = Color.Red;
            }

            //	if(current_model == Model.SDR1000)				comboPreamp.Enabled = !chkMOX.Checked;
            setupForm.MOX = chkMOX.Checked;
            ResetMultiMeterPeak();
            //chkMOX.BackColor = button_selected_color;

            picSquelch.Invalidate();

            /*Thread t = new Thread(new ThreadStart(DelayedDisplayReset));
			t.Name = "Display Reset";
			t.Priority = ThreadPriority.BelowNormal;
			t.IsBackground = true;
			t.Start();*/
        }

        private void UIMOXChangedFalse()
        {
            Display.MOX = false;
            switch (Display.CurrentDisplayMode)
            {
                case DisplayMode.PANADAPTER:
                case DisplayMode.SPECTRUM:
                case DisplayMode.HISTOGRAM:
                case DisplayMode.WATERFALL:
                case DisplayMode.PANAFALL:
                case DisplayMode.PANASCOPE:
                    //Display.DrawBackground();
                    break;
            }

            if (!disable_ui_mox_changes) // ke9ns (if not disabled then do below)
            {
                setupForm.SpurRedEnabled = true;
                EnableAllBands();
                EnableAllModes();
                chkVFOSplit.Enabled = true;
                btnVFOAtoB.Enabled = true;
                btnVFOBtoA.Enabled = true;
                btnVFOSwap.Enabled = true;
            }

            if (chkPower.Checked) chkPower.BackColor = button_selected_color;
            comboMeterTXMode.ForeColor = Color.Gray;
            comboMeterTX1Mode.ForeColor = Color.Gray; // ke9ns add

            comboMeterRXMode.ForeColor = Color.White;
            comboMeterRXMode_SelectedIndexChanged(this, EventArgs.Empty); //

            comboRX2MeterMode_SelectedIndexChanged(this, EventArgs.Empty); // ke9ns add to update lblrx2meter text


            pa_fwd_power = 0;
            pa_rev_power = 0;

            Audio.HighSWRScale = 1.0;
            HighSWR = false;

            for (int i = 0; i < meter_text_history.Length; i++)
                meter_text_history[i] = 0.0f;

            if (!fwc_init) // || current_model == Model.SDR1000)
                comboPreamp.Enabled = !chkMOX.Checked;
            setupForm.MOX = chkMOX.Checked;
            ResetMultiMeterPeak();
            chkMOX.BackColor = SystemColors.Control;

            picNoiseGate.Invalidate();

            /*Thread t = new Thread(new ThreadStart(DelayedDisplayReset));
			t.Name = "Display Reset";
			t.Priority = ThreadPriority.BelowNormal;
			t.IsBackground = true;
			t.Start();*/
        }


        //================================================================================================= KEY TRANSMITTER
        private HiPerfTimer t1 = new HiPerfTimer();
        //private double timer1 = 0.0;

        private bool mox = false;
        private void chkMOX_CheckedChanged2(object sender, System.EventArgs e)
        {
            Debug.WriteLine("chkMOX checkedchanged2");

            //   Display.PON = false; // reset buffer on TX/RX changeover

            if (chkMOX.Checked == false && quindar_end == true) // ke9ns add .192 to allow VAC with quindar tones
            {

                //  Debug.WriteLine("======= chkmox here: " + qndr_mox + " , " + qndr_end + " , " + QuindarEnd + " , " + qndr_mox1 + " , " + qndr_vac1);

                if ((chkVAC1.Checked || chkVAC2.Checked) && qndr_mox == false && QuindarEnd == true)
                {
                    chkMOX.CheckedChanged -= chkMOX_CheckedChanged2;
                    chkMOX.Checked = false;
                    manual_mox = true;
                    chkMOX.CheckedChanged += chkMOX_CheckedChanged2;
                    Debug.WriteLine("Quindar: LEAVE IN MOX - END TONE PLAYING");
                    return;
                }
            }


            if (ckQuickPlay.Checked) // if you let go transmit button, shut off playback
            {
                WaveForm.QuickPlay = false;
                ckQuickPlay.BackColor = SystemColors.Control;
                ckQuickRec.Enabled = !ckQuickPlay.Checked;
            }


            // ke9ns add: this prevents the PTT from overriding the txWaterID just while its transmitting
            if (TXIDMenuItem.Checked == true) // ke9ns add
            {
                chkMOX.Checked = true; // dont allow to unkey while txwater ID is going
                manual_mox = true;
            }
            else
            {
                if (chkMOX.Checked == false)  // ke9ns mod: check for quindar END tone (dont allow to unkey while playing)
                {
                    Debug.WriteLine("Quindar: UNMOX");
                    manual_mox = false;

                }


            }


            panelAntenna.Invalidate(); //ke9ns add (antenna flashes red on Transmit ant2 -> ant3 )
            grpVFOA.Invalidate(); // ke9ns add to check for ring color during MOX
            grpVFOB.Invalidate();


            //   Debug.WriteLine("MOX: "+chkMOX.Checked);	

            t1.Start();  // hiperformance timer start

            if (rx_only && chkMOX.Checked)
            {
                chkMOX.Checked = false;
                return;
            }

            // only allow softrock style xmit  for cw and ssb for now
            //   if (rx1_dsp_mode != DSPMode.CWL && rx1_dsp_mode != DSPMode.CWU &&
            //       rx1_dsp_mode != DSPMode.USB && rx1_dsp_mode != DSPMode.LSB &&
            //      ( /* current_model == Model.SDR1000_DDSLOCKED || */ current_model == Model.SOFTROCK40)
            //      )
            //  {
            //    chkMOX.Checked = false;
            //     return;
            //  }

            bool tx = chkMOX.Checked;

            if (!tx) WBIRRX1Holdoff();  // do this is TX turned OFF

            if (tx) mox = tx;

            double freq = 0.0;

            if (tx)
            {
                /*t1.Stop();
                timer1 += t1.DurationMsec;
                count1++;*/
                //-------------------------------------------------------------
                //FM Offsets
                if (dsp.GetDSPTX(0).CurrentDSPMode == DSPMode.FM && current_fm_tx_mode != FMTXMode.Simplex && !chkVFOSplit.Checked)
                {
                    switch (current_fm_tx_mode)
                    {
                        case FMTXMode.Low:
                            if (!chkFMTXRev.Checked)
                                TXFreq -= fm_tx_offset_mhz; // usual case
                            else
                                TXFreq += fm_tx_offset_mhz;
                            break;
                        case FMTXMode.High:
                            if (!chkFMTXRev.Checked)
                                TXFreq += fm_tx_offset_mhz; // usual case
                            else
                                TXFreq -= fm_tx_offset_mhz;
                            break;
                    }
                } // FM offsets

                //-------------------------------------------------------------

                if (chkVFOBTX.Checked || (!chkRX2.Checked && chkVFOSplit.Checked)) freq = double.Parse(txtVFOBFreq.Text);
                else if (chkRX2.Checked && chkVFOSplit.Checked) freq = double.Parse(txtVFOABand.Text);
                else freq = double.Parse(txtVFOAFreq.Text);
                //-------------------------------------------------------------


                if (tx_xvtr_index >= 0) freq = xvtrForm.TranslateFreq(freq);

                if (chkXIT.Checked) freq = freq + (int)udXIT.Value * 0.000001;

                /*t1.Stop();
                timer2 += t1.DurationMsec;
                count2++;*/

                // DO THIS IF NOT CALIBRATING
                if (!calibrating)
                {
                    if ((tx_band == Band.B60M) && (current_region == FRSRegion.US) && (!extended))
                    {
                        switch (dsp.GetDSPTX(0).CurrentDSPMode)
                        {
                            case DSPMode.USB:
                            case DSPMode.CWL:
                            case DSPMode.CWU:
                            case DSPMode.DIGU:
                                break;
                            default:
                                MessageBox.Show(new Form { TopMost = true }, rx1_dsp_mode.ToString() + " mode is not allowed on 60M band.",
                                    "Transmit Error: Mode/Band",
                                    MessageBoxButtons.OK,
                                    MessageBoxIcon.Error);
                                chkMOX.Checked = false;
                                return;
                                // break;
                        } // switch
                    } // tx band


                    //-------------------------------------------------------------------------------------------
                    // dont check 60m valid PowerSDR will still work, but Flex will not transmit

                    if (!CheckValidTXFreq(current_region, freq, dsp.GetDSPTX(0).CurrentDSPMode))    // out of band
                    {
                        if (tx_band == Band.B60M && (current_region == FRSRegion.US) && CheckValidTXFreq_Private(current_region, freq) && !extended)
                        {
                            if (dsp.GetDSPTX(0).TXFilterHigh - dsp.GetDSPTX(0).TXFilterLow > 2800)
                                MessageBox.Show(new Form { TopMost = true }, "The transmit filter you have selected exceeds the bandwidth\n" +
                                    "constraints (2.8kHz) for the US 60m band.",
                                    "60m Bandwidth",
                                    MessageBoxButtons.OK,
                                    MessageBoxIcon.Error);
                            else
                                MessageBox.Show(new Form { TopMost = true }, "The US 60m region requires transmission center of energy to be around\n" +
                                    "the defined channels.  Click the 60m Band button to jump to the nearest channel.",
                                    "US 60m Off Channel",
                                    MessageBoxButtons.OK,
                                    MessageBoxIcon.Error);
                        } // tx band
                        else
                        {

                            switch (dsp.GetDSPTX(0).CurrentDSPMode)
                            {
                                case DSPMode.CWL:
                                case DSPMode.CWU:
                                    MessageBox.Show(new Form { TopMost = true }, "The frequency " + freq.ToString("f6" ) + "MHz is not within the\n" +
                                        "Band specifications for your country (" + ((int)current_region).ToString() + ").",
                                        "Transmit Error: Out Of Band",
                                        MessageBoxButtons.OK,
                                        MessageBoxIcon.Error);
                                    break;
                                default:
                                    MessageBox.Show(new Form { TopMost = true }, "The frequency " + freq.ToString("f6" ) + "MHz in combination with your TX filter\n" +
                                        "settings [" + Display.TXFilterLow.ToString() + ", " + Display.TXFilterHigh.ToString() + "] are not within the " +
                                        "Band specifications for your country (" + ((int)current_region).ToString() + ").",
                                        "Transmit Error: Out Of Band",
                                        MessageBoxButtons.OK,
                                        MessageBoxIcon.Error);
                                    break;
                            }
                        }

                        chkMOX.Checked = false;
                        return;
                    } // if valid




                } // calibrating


                /*t1.Stop();
                timer3 += t1.DurationMsec;
                count3++;*/

                switch (rx1_dsp_mode)
                {
                    case DSPMode.CWL:
                        freq += (double)cw_pitch * 0.0000010;
                        break;
                    case DSPMode.CWU:
                        freq -= (double)cw_pitch * 0.0000010;
                        break;
                }
            } // TX
            else // RX mode
            {
                current_ptt_mode = PTTMode.NONE;
                /*if(pa_present)
                {
                    if(poll_pa_pwr_thread !=null && poll_pa_pwr_thread.IsAlive)
                        poll_pa_pwr_thread.Abort();
                }*/

                //Undo FM Offsets
                if (dsp.GetDSPTX(0).CurrentDSPMode == DSPMode.FM && current_fm_tx_mode != FMTXMode.Simplex && !chkVFOSplit.Checked)
                {
                    switch (current_fm_tx_mode)
                    {
                        case FMTXMode.Low:
                            if (!chkFMTXRev.Checked)
                                TXFreq += fm_tx_offset_mhz; // usual case
                            else
                                TXFreq -= fm_tx_offset_mhz;
                            break;
                        case FMTXMode.High:
                            if (!chkFMTXRev.Checked)
                                TXFreq -= fm_tx_offset_mhz; // usual case
                            else
                                TXFreq += fm_tx_offset_mhz;
                            break;
                    }
                }
            } // NO TX

            //-----------------------------------------------------------------------

            if (!full_duplex)
            {
                if (tx)
                {
                    DttSP.SetCorrectIQMu(0, 0, 0.000);
                    DttSP.SetCorrectIQMu(0, 1, 0.000);

                    if (current_model == Model.FLEX5000 && FWCEEPROM.RX2OK)
                        DttSP.SetCorrectIQMu(2, 0, 0.000);

                    if (chkVFOATX.Checked || mute_rx1_on_vfob_tx)
                        DttSP.SetThreadProcessingMode(0, 0);

                    if (current_model == Model.FLEX1500)
                    {
#if FLEX1500_BUFFER_MUTE
                        if (hid_init && current_model == Model.FLEX1500)
                        {
                            switch (dsp.GetDSPTX(0).CurrentDSPMode)
                            {
                                case DSPMode.CWL:
                                case DSPMode.CWU:
                                    break;
                                default:
                                    USBHID.WriteI2C2Value(0x30, 0x25, 0x00);
                                    break;
                            }
                        }
#endif

                        AudioMOXChanged(tx);

                        DttSP.FlushAllBufs(0, false);

                        HdwMOXChanged(true, 0.0f);
                        // set interval based on the buffer size and mode
#if FLEX1500_BUFFER_MUTE
                        if (hid_init && current_model == Model.FLEX1500)
                        {
                            switch (dsp.GetDSPTX(0).CurrentDSPMode)
                            {
                                case DSPMode.CWL:
                                case DSPMode.CWU:
                                    break;
                                default:
                                    CWKeyer.MuteEnqueue(new CWMuteItem(tx, CWSensorItem.GetCurrentTime() + phone_blank_time));
                                    break;
                            }
                        }
#endif
                    } // if 1500

                    //else if(current_model == Model.FLEX3000)
                    else DttSP.FlushAllBufs(0, false);

                    DttSP.FlushAllBufs(1, true);
                    DttSP.SetThreadProcessingMode(1, 2);
                } // TX
            } // not full duplex mode

            /*if (tx)
            {
                t1.Stop();
                timer4 += t1.DurationMsec;
                count4++;
            }*/

            if (tx)
            {
                AudioMOXChanged(tx);
                if (current_model != Model.FLEX1500) HdwMOXChanged(tx, freq);
            }
            else
            {
                // temporarily disable audio blanking for FLEX-1500
#if FLEX1500_BUFFER_MUTE
                if (hid_init && current_model == Model.FLEX1500)
                {
                    switch (dsp.GetDSPTX(0).CurrentDSPMode)
                    {
                        case DSPMode.CWL:
                        case DSPMode.CWU:
                            break;
                        default:
                            USBHID.WriteI2C2Value(0x30, 0x25, 0x00);
                            break;
                    }
                }
#endif
                switch (dsp.GetDSPTX(0).CurrentDSPMode)
                {
                    case DSPMode.CWL:
                    case DSPMode.CWU:
                        Audio.MOX = tx; // switch manually since ramping is already done
                        break;
                    default:
                        if (limit_slew)
                        {
                            Audio.Ramp = true;
                            int audio_buffer = (int)(block_size1 / (double)sample_rate1 * 1e3); // in ms
                            int dsp_buffer = (int)(dsp.GetDSPTX(0).BufferSize / (double)sample_rate1 * 1e3); // in ms
                            Thread.Sleep(2 * (audio_buffer + dsp_buffer));
                        }
                        else
                        {
                            Audio.MOX = tx; // switch manually since ramping is already done
                        }
                        break;
                }

                mox = tx;
                HdwMOXChanged(tx, freq);

                AudioMOXChanged(tx);

                DttSP.SetThreadProcessingMode(1, 0);
                DttSP.FlushAllBufs(1, true);
                if (current_model == Model.FLEX5000 && FWCEEPROM.RX2OK) DttSP.FlushAllBufs(2, false);
                DttSP.FlushAllBufs(0, false);
                DttSP.SetThreadProcessingMode(0, 2);

#if FLEX1500_BUFFER_MUTE
                switch (dsp.GetDSPTX(0).CurrentDSPMode)
                {
                    case DSPMode.CWL:
                    case DSPMode.CWU:
                        break;
                    default:
                        CWKeyer.MuteEnqueue(new CWMuteItem(tx, CWSensorItem.GetCurrentTime() + phone_blank_time));
                        break;
                }
#endif
            } // NO TX



            if (!tx) // in RX zero out PA
            {
                pa_fwd_power = 0;
                pa_rev_power = 0;
                HighSWR = false;
            }

            if (tx) UIMOXChangedTrue(); // update User Interface (i.e. meters)
            else UIMOXChangedFalse();

            /*Debug.WriteLine("1:"+(timer1/count1).ToString("f3")+
                " 2:"+(timer2/count2).ToString("f3")+
                " 3:"+(timer3/count3).ToString("f3")+
                " 4:"+(timer4/count4).ToString("f3")+
                " 5:"+(timer5/count5).ToString("f3")+
                " 6:"+(timer6/count6).ToString("f3")+
                " 7:"+(timer7/count7).ToString("f3")+
                " 8:"+(timer8/count8).ToString("f3")+
                " 9:"+(timer9/count9).ToString("f3")+
                " 10:"+(timer10/count10).ToString("f3")+
                " 11:"+(timer11/count11).ToString("f3")+
                " 12:"+(timer12/count12).ToString("f3"));*/

            /*if (!tx)
                Debug.WriteLine("1: " + timer1.ToString("f1").PadLeft(4, '0') +
                    " 2: " + timer2.ToString("f1").PadLeft(4, '0') +
                    " 3: " + timer3.ToString("f1").PadLeft(4, '0') +
                    " 4: " + timer4.ToString("f1").PadLeft(4, '0') +
                    " 5: " + timer5.ToString("f1").PadLeft(4, '0') +
                    " 6: " + timer6.ToString("f1").PadLeft(4, '0') +
                    " 7: " + timer7.ToString("f1").PadLeft(4, '0') +
                    " 8: " + timer8.ToString("f1").PadLeft(4, '0'));*/



        } // chkMOX_CHeckchanged2



        //private Thread mox_update_thread;
        //============================================================================	
        private void chkMOX_Click(object sender, System.EventArgs e)
        {
            Debug.WriteLine("chkMOX CLICK on the button");

            CQCQReplayON = false; // ke9ns add: shut down CQCQ if you click MOX button

            if (chkMOX.Checked)          // because the CheckedChanged event fires first
            {
                manual_mox = true;
            }
            else
            {
                if (cat_ptt) cat_ptt = false;

                manual_mox = false;

                if (chkTUN.Checked) chkTUN.Checked = false;


            }

        } // chkMox Clicked
          //====================================================================
        private void comboMeterRXMode_SelectedIndexChanged(object sender, System.EventArgs e)
        {
            if (comboMeterRXMode.Items.Count == 0 || comboMeterRXMode.SelectedIndex < 0)
            {
                current_meter_rx_mode = MeterRXMode.FIRST;
            }
            else
            {
                MeterRXMode mode = MeterRXMode.FIRST;
                switch (comboMeterRXMode.Text)
                {
                    case "Signal":
                        mode = MeterRXMode.SIGNAL_STRENGTH;
                        break;
                    case "Sig Avg":
                        multimeter_avg = Display.CLEAR_FLAG;
                        mode = MeterRXMode.SIGNAL_AVERAGE;
                        break;
                    case "Sig Pk":      // ke9ns ADD
                        multimeter_peak = Display.CLEAR_FLAG;
                        mode = MeterRXMode.SIGNAL_PEAK;
                        break;
                    case "ADC L":
                        mode = MeterRXMode.ADC_L;
                        break;
                    case "ADC R":
                        mode = MeterRXMode.ADC_R;
                        break;
                    case "ADC2 L":
                        mode = MeterRXMode.ADC2_L;
                        break;
                    case "ADC2 R":
                        mode = MeterRXMode.ADC2_R;
                        break;
                    case "Off":
                        mode = MeterRXMode.OFF;
                        break;
                }
                current_meter_rx_mode = mode;

                if (!mox)
                {
                    switch (mode)
                    {
                        case MeterRXMode.SIGNAL_STRENGTH:
                        case MeterRXMode.SIGNAL_PEAK:  // ke9ns
                        case MeterRXMode.SIGNAL_AVERAGE:
                            lblMultiSMeter.Text = "  1   3   5   7   9  +20 +40 +60";
                            break;

                        case MeterRXMode.ADC_L:
                        case MeterRXMode.ADC_R:
                            lblMultiSMeter.Text = "-100  -80   -60   -40   -20    0";
                            break;
                        case MeterRXMode.OFF:
                            lblMultiSMeter.Text = "";
                            break;
                    }
                    ResetMultiMeterPeak();
                }
            }

            picMultiMeterDigital.Invalidate();

            if (comboMeterRXMode.Focused)
                btnHidden.Focus();
        }


        //======================================================================================================
        private void comboMeterTXMode_SelectedIndexChanged(object sender, System.EventArgs e)
        {
            MeterTXMode mode = MeterTXMode.FIRST;

            if (comboMeterTXMode.Items.Count == 0 || comboMeterTXMode.SelectedIndex < 0)
            {
                //current_meter_tx_mode = MeterTXMode.FIRST;
            }
            else
            {
                switch (comboMeterTXMode.Text)
                {
                    case "Fwd Pwr":
                        mode = MeterTXMode.FORWARD_POWER;// Foward Watts Output
                        break;
                    case "Ref Pwr":
                        mode = MeterTXMode.REVERSE_POWER; // Reflected Watts Output
                        break;
                    case "Mic":
                        mode = MeterTXMode.MIC;   // Microphone input dBm level adjusted from the MIXER screen
                        break;
                    case "EQ":
                        mode = MeterTXMode.EQ;    //
                        break;
                    case "Leveler":
                        mode = MeterTXMode.LEVELER;
                        break;
                    case "Lev Gain":
                        mode = MeterTXMode.LVL_G;
                        break;
                    case "CPDR":
                        mode = MeterTXMode.CPDR;
                        break;
                    case "ALC":
                        mode = MeterTXMode.ALC;
                        break;
                    case "ALC Comp":
                        mode = MeterTXMode.ALC_G;
                        break;
                    case "SWR":
                        mode = MeterTXMode.SWR;
                        break;
                    case "Off":
                        mode = MeterTXMode.OFF;
                        break;
                }

                if (chkTUN.Checked)
                {
                    tune_meter_tx_mode = mode;
                    if (setupForm != null) setupForm.TuneMeterTXMode = mode;
                }
                current_meter_tx_mode = mode;
            }

            if (mox)
            {
                switch (mode)
                {
                    case MeterTXMode.FIRST:
                        lblMultiSMeter.Text = "";
                        break;
                    case MeterTXMode.MIC:
                    case MeterTXMode.EQ:
                    case MeterTXMode.LEVELER:
                    case MeterTXMode.CPDR:
                    case MeterTXMode.ALC:
                        lblMultiSMeter.Text = "-20    -10     -5      0   1   2   3";
                        break;
                    case MeterTXMode.FORWARD_POWER:
                    case MeterTXMode.REVERSE_POWER:
                        if (pa_present ||
                            (fwc_init && (current_model == Model.FLEX5000 || current_model == Model.FLEX3000)) ||
                            (hid_init && current_model == Model.FLEX1500))
                            lblMultiSMeter.Text = "1      5     10    50   100  120+";
                        else
                            lblMultiSMeter.Text = "0      0.1     0.2     0.5        1.0";
                        break;
                    case MeterTXMode.SWR:
                        lblMultiSMeter.Text = "1      1.5   2     3     5    10";
                        lblMultiSMeter.Text = "0             10              20";
                        break;
                    case MeterTXMode.OFF:
                        lblMultiSMeter.Text = "";
                        break;
                    case MeterTXMode.LVL_G:
                    case MeterTXMode.ALC_G:
                        lblMultiSMeter.Text = "0       5       10      15      20";
                        break;
                }
                ResetMultiMeterPeak();
            }

            picMultiMeterDigital.Invalidate();

            if (comboMeterTXMode.Focused)
                btnHidden.Focus();

        } // combometertxmode



        //================================================================================ 
        //================================================================================ 
        // ke9ns mod to allow split of avg, avgB, avgP 
        //================================================================================ 
        //================================================================================ 
        private void chkDisplayAVG_CheckedChanged(object sender, System.EventArgs e)
        {

            if (Display.CurrentDisplayMode == DisplayMode.PANAFALL) // ke9ns pan
            {

                chkDisplayAVG.CheckedChanged -= chkDisplayAVG_CheckedChanged; // turn eventoff

                // PW_AVG 0 = water AVG follows Panadapter AVG ON/OFF
                //        1 = water AVG OFF no matter

                if ((Display.PW_AVG & 1) == 0) // 0=  avg ON waterfall if its ON panadater
                {

                    if (chkDisplayAVG.Checked == false)   // if AVG on both panadapter and waterfall and you click the avg button then do below
                    {
                        // AVG ONLY ON PANADAPTER
                        Display.PW_AVG = 1;             // waterfall avg OFF 
                        chkDisplayAVG.Checked = true;   // Panadapter avg ON (keeping the button ON)
                        chkDisplayAVG.Text = "AvgP"; // ke9ns 

                    }
                    else // true
                    {
                        // AVG ON FULL PANAFALL
                        //  Debug.WriteLine("dhdkd===");
                        Display.PW_AVG = 0;             // waterfall avg ON    
                        chkDisplayAVG.Checked = true;   // Panadapter avg ON  (simply flipping the button ON)
                        chkDisplayAVG.Text = "AvgB"; // ke9ns 
                    }

                }
                else //  1=panafall mode, and waterfall AVG OFF 
                {

                    if (chkDisplayAVG.Checked == false)   // if AVG on both panadapter and waterfall and you click the avg button then do below
                    {
                        // TURN OFF ALL AVG 
                        Display.PW_AVG = 0;             // waterfall avg OFF 
                        chkDisplayAVG.Checked = false;   // Panadapter avg OFF (keeping the button ON)
                        chkDisplayAVG.Text = "Avg"; // ke9ns 

                    }
                    else // true  (pw_avg=1 and panafall mode and button was OFF, now ON) impossibility
                    {

                        Display.PW_AVG = 0;             // waterfall avg ON    
                        chkDisplayAVG.Checked = true;   // Panadapter avg ON  (simply flipping the button ON)
                        chkDisplayAVG.Text = "Avg"; // ke9ns 
                    }

                } //

                chkDisplayAVG.CheckedChanged += chkDisplayAVG_CheckedChanged; // turn event back on


            } // in panafallmode ?


            Display.AverageOn = chkDisplayAVG.Checked; // Tell display avg is turned on or off

            if (chkDisplayAVG.Checked)
            {
                chkDisplayAVG.BackColor = button_selected_color;
            }
            else
            {
                chkDisplayAVG.BackColor = SystemColors.Control;
            }

            if (chkDisplayAVG.Checked)
            {
                switch (Display.CurrentDisplayMode)
                {
                    case DisplayMode.PANADAPTER:
                    case DisplayMode.HISTOGRAM:
                    case DisplayMode.SPECTRUM:
                    case DisplayMode.WATERFALL:
                    case DisplayMode.PANAFALL:
                    case DisplayMode.PANASCOPE:
                        btnZeroBeat.Enabled = true; // only allow zerobeat when avg is on 
                        break;
                    default:
                        btnZeroBeat.Enabled = false;
                        break;
                }
            }
            else btnZeroBeat.Enabled = false;

        } // chkDisplayAVG_CheckedChanged


        //==========================================================================
        private void chkDisplayPeak_CheckedChanged(object sender, System.EventArgs e)
        {
            Display.PeakOn = chkDisplayPeak.Checked;
            if (chkDisplayPeak.Checked)
            {
                chkDisplayPeak.BackColor = button_selected_color;
            }
            else
            {
                chkDisplayPeak.BackColor = SystemColors.Control;
            }
        }

        private void chkSquelch_CheckedChanged(object sender, System.EventArgs e)
        {
            if (rx1_dsp_mode == DSPMode.FM && !chkSquelch.Checked) chkSquelch.Checked = true;

            dsp.GetDSPRX(0, 0).RXSquelchOn = chkSquelch.Checked;
            dsp.GetDSPRX(0, 1).RXSquelchOn = chkSquelch.Checked;
        }


        //======================================================================================================
        // ke9ns mod   tune function too loud in MON (turn down when in tune) BUT 6/12/16 observe MUT button when on

        private MeterTXMode old_tune_meter_tx_mode;
        //   private DSPMode old_Mode;  // ke9ns add

        private void chkTUN_CheckedChanged(object sender, System.EventArgs e)
        {

            if (chkTUN.Checked)
            {
                if (!chkPower.Checked)
                {
                    MessageBox.Show(new Form { TopMost = true }, "Power must be on to turn on the Tune function.",
                        "Power is off",
                        MessageBoxButtons.OK,
                        MessageBoxIcon.Hand);
                    chkTUN.Checked = false;
                    return;
                }

                if (chkNoiseGate.Checked) dsp.GetDSPTX(0).TXSquelchOn = false;


                tuning = true;

                setupForm.chkBoxPulser.Enabled = false;               // ke9ns add: dont allow changing pulser while in tune mode



                chkTUN.BackColor = button_selected_color;

                if (current_meter_tx_mode != tune_meter_tx_mode) // ke9ns switch meters if needed when keyed up
                {
                    old_tune_meter_tx_mode = current_meter_tx_mode;
                    CurrentMeterTXMode = tune_meter_tx_mode;
                    comboMeterTXMode_SelectedIndexChanged(this, EventArgs.Empty);

                    comboMeterTX1Mode_SelectedIndexChanged(this, EventArgs.Empty); // ke9ns add

                }

                switch (Audio.TXDSPMode)
                {
                    case DSPMode.USB:
                    case DSPMode.CWU:
                    case DSPMode.DIGU:
                        Audio.SineFreq1 = cw_pitch;
                        DttSP.SetTXFilter(1, cw_pitch - 100, cw_pitch + 100);
                        Audio.TXInputSignal = Audio.SignalSource.SINE;
                        Audio.SourceScale = 1.0;
                        break;
                    case DSPMode.LSB:
                    case DSPMode.CWL:
                    case DSPMode.DIGL:
                        Audio.SineFreq1 = cw_pitch;
                        DttSP.SetTXFilter(1, -cw_pitch - 100, -cw_pitch + 100);
                        Audio.TXInputSignal = Audio.SignalSource.SINE;
                        Audio.SourceScale = 1.0;
                        break;
                    case DSPMode.DSB:
                        Audio.SineFreq1 = cw_pitch;
                        DttSP.SetTXFilter(1, cw_pitch - 100, cw_pitch + 100);
                        Audio.TXInputSignal = Audio.SignalSource.SINE;
                        Audio.SourceScale = 1.0;
                        break;
                    case DSPMode.AM:
                    case DSPMode.SAM:
                    case DSPMode.FM:
                        Audio.SineFreq1 = cw_pitch;
                        DttSP.SetTXFilter(1, cw_pitch - 100, cw_pitch + 100);
                        Audio.TXInputSignal = Audio.SignalSource.SINE;
                        Audio.SourceScale = 1.0;
                        break;
                }

                DttSP.SetMode(1, 0, DSPMode.DIGU);

                // ensure radio believes we are in CW for tx freq limits
                if (fwc_init && (current_model == Model.FLEX5000 || current_model == Model.FLEX3000))
                {
                    switch (Audio.TXDSPMode)
                    {
                        case DSPMode.CWL:
                        case DSPMode.LSB:
                        case DSPMode.DIGL:
                            FWC.SetTXDSPMode(DSPMode.CWL);

                            break;
                        default:
                            FWC.SetTXDSPMode(DSPMode.CWU);
                            break;
                    }
                }



                PreviousPWR = ptbPWR.Value;


                if (!xvtr_tune_power || tx_xvtr_index < 0) PWR = tune_power;

                if (!chkVFOSplit.Checked && !chkVFOBTX.Checked)
                {
                    txtVFOAFreq_LostFocus(this, EventArgs.Empty);
                }
                else
                {
                    if (chkVFOBTX.Checked) txtVFOBFreq_LostFocus(this, EventArgs.Empty);
                    else // split is on
                    {
                        if (!chkRX2.Checked)
                            txtVFOBFreq_LostFocus(this, EventArgs.Empty);
                        else
                            txtVFOABand_LostFocus(this, EventArgs.Empty);
                    }
                }


                chkMOX.Checked = true;

                if (!mox)
                {
                    chkTUN.Checked = false;
                    return;
                }
                current_ptt_mode = PTTMode.MANUAL;

                switch (Audio.TXDSPMode)
                {
                    case DSPMode.CWL:
                    case DSPMode.CWU:
                        Audio.TXDSPMode = DSPMode.DIGU;
                        break;
                }

                if (setupForm.chkBoxTNTX3.Checked == true) FWC.SetRCATX3(chkTUN.Checked); // ke9ns add use TX3 for external TUN tuner feature



                if ((atu_present) && (tx_band != Band.B2M) && ((ATUTuneMode)comboTuneMode.SelectedIndex != ATUTuneMode.BYPASS))
                {
                    Debug.WriteLine("TUNNING in TUN mode");

                    chkTUN.Enabled = false;
                    comboTuneMode.Enabled = false;

                    Thread t = new Thread(new ThreadStart(Tune));
                    t.IsBackground = true;
                    t.Priority = ThreadPriority.Normal;
                    t.Name = "TUN Thread";
                    t.Start();
                }

                if (chkMUT.Checked == false) // ke9ns add prevent MUT from malfunctioning
                {
                    Audio.MonitorVolume = (ptbAF.Value / 100.0) / 10;  // ke9ns add cut volume during a tune

                }
                else
                {
                    if (chkBoxMuteSpk.Checked == false) // ke9ns add
                    {
                        Audio.MonitorVolume = 0.0; // if muted

                    }
                    else
                    {
                        //  Debug.WriteLine("check...");

                    }
                }

                //---------------------------------
                // ke9ns add pulser code

                if ((setupForm != null) && (setupForm.chkBoxPulser.Checked == true) && (PulseON == false))
                {

                    PulseON = true;   // set 1 time (now calls audio.cs rouine and pulser())

                    Last_PR = 0.0;

                    PR = (1000.0 / (double)setupForm.tbPulseRate1.Value);  // valuse from 25 to 50 mSec
                    DC = ((double)setupForm.tbDutyCycle.Value / 100.0);   // value from .1 to .9
                    DCOFF = (PR * DC); // so if PR = 25msec, then at 20%  DCOFF = 30msec , so on every 25msec and stay on for 5msec more each time




                } // turn pulser ON


                //---------------------------------

                return;

            } // chkTUN = true
            else
            {
                setupForm.chkBoxPulser.Enabled = true; // ke9ns add 

                if (setupForm.chkBoxTNTX3.Checked == true) FWC.SetRCATX3(chkTUN.Checked); // ke9ns add: use TX3 for external TUN tuner feature


                if (timerID != 0)  // ke9ns add
                {

                    timeKillEvent(timerID);     // turn pulser OFF
                }

                if (timerID1 != 0)  // ke9ns add
                {
                    timeKillEvent(timerID1);
                }

                PulseON = false; // ke9ns add

                Audio.TXInputSignal = Audio.SignalSource.RADIO;
                //Audio.RampDown = true;
                Thread.Sleep(50);

                chkMOX.Checked = false;
                chkTUN.BackColor = SystemColors.Control;
                tuning = false;

                if (!chkVFOSplit.Checked && !chkVFOBTX.Checked)
                {
                    txtVFOAFreq_LostFocus(this, EventArgs.Empty);
                }
                else
                {
                    if (chkVFOBTX.Checked)
                        txtVFOBFreq_LostFocus(this, EventArgs.Empty);
                    else // split is on
                    {
                        if (!chkRX2.Checked)
                            txtVFOBFreq_LostFocus(this, EventArgs.Empty);
                        else
                            txtVFOABand_LostFocus(this, EventArgs.Empty);
                    }
                }

                if (!(atu_present && tx_band != Band.B2M && (ATUTuneMode)comboTuneMode.SelectedIndex != ATUTuneMode.BYPASS))
                {
                    if (tx_xvtr_index < 0 || xvtr_tune_power) TunePower = ptbPWR.Value;
                }


                PWR = PreviousPWR;


                DSPMode mode = dsp.GetDSPTX(0).CurrentDSPMode;

                if (fwc_init && (current_model == Model.FLEX5000 || current_model == Model.FLEX3000))
                    FWC.SetTXDSPMode(mode);

                DttSP.SetMode(1, 0, mode);
                switch (mode)
                {
                    case DSPMode.AM:
                    case DSPMode.SAM:
                    case DSPMode.FM:
                        Audio.SineFreq1 = cw_pitch;
                        break;
                    case DSPMode.CWL:
                    case DSPMode.CWU:
                        Audio.TXDSPMode = mode;
                        break;
                }

                DttSP.SetTXFilter(1, dsp.GetDSPTX(0).TXFilterLow, dsp.GetDSPTX(0).TXFilterHigh);

                if (tune_meter_tx_mode != old_tune_meter_tx_mode)
                    CurrentMeterTXMode = old_tune_meter_tx_mode;

                if (chkNoiseGate.Checked)
                    dsp.GetDSPTX(0).TXSquelchOn = true;

                if (chkMUT.Checked == false) // ke9ns add prevent MUT from malfunctioning
                {
                    Audio.MonitorVolume = ptbAF.Value / 100.0; // ke9ns add to bring volume back up when done
                }


            } // chkTUN not


        } // chkTUN_checkchanged



        //==================================================================================================================
        // ke9ns Tone Pulser routine for timing (setup tbDutyCycle 10 to 90% , and tbPulseRate = 20 to 40 pulses/second )
        //

        public bool PulseON = false; // Tone ON = true, Tone OFF = false

        double PR = 0.0;
        double DC = 0.0;
        double DCOFF = 0.0;

        double Last_PR = 0.0;

        private bool setkey_memory = false;
        private bool setptt_memory = false;

        //==========================================================================================
        // ke9ns add  PTT radio on/off
        private void setptt(bool state)
        {
            if (setptt_memory != state)
            {
                //  Debug.WriteLine("CW333");
                CWPTTItem item = new CWPTTItem(state, CWSensorItem.GetCurrentTime());
                CWKeyer.PTTEnqueue(item);

                setptt_memory = state;
            }
            //			if (newptt) Thread.Sleep(200);
        } //  setptt

        //==========================================================================================
        // ke9ns add  key radio on/off
        private void setkey(bool state)                 // ke9ns   This is the CW key signal back to the flex radio itself
        {
            if (setkey_memory != state)                                          // only allow this to happen 1 time if state stays the same (once to turn ON, once to turn OFF)
            {
                // Debug.WriteLine("CW222");
                CWSensorItem item = new CWSensorItem(CWSensorItem.InputType.StraightKey, state);
                CWKeyer.SensorEnqueue(item);

                setkey_memory = state;
            }
        }  // setkey


        //==========================================================================================
        // ke9ns add  precision msec multimedia timers
        // Pulser timer
        private void TimerPeriodicEventCallback(int id, int msg, int user, int param1, int param2)
        {

            setup_timer1((int)DCOFF); // set duty cycle timer now

            Audio.SourceScale = 1.0;  // turn on audio during this portion

            //  setkey(true);


        } // TimerPeriodicEventCallback

        //==========================================================================================
        // ke9ns add precision msec multimedia timers  (ONE SHOT)
        // DUTY timers
        private void TimerPeriodicEventCallback1(int id, int msg, int user, int param1, int param2)
        {
            Audio.SourceScale = 0.0; // turn off audio during this portion

            //   setkey(false);


            // look for changes in the sliders for Pulses/second and duty
            PR = (1000.0 / (double)setupForm.tbPulseRate1.Value);  // value from 25 to 50 mSec
            DC = ((double)setupForm.tbDutyCycle.Value / 100.0);   // value from .1 to .9
            DCOFF = (PR * DC); // so if PR = 25msec, then at 20%  DCOFF = 30msec , so on every 25msec and stay on for 5msec more each time

            if (Last_PR != PR)
            {
                setup_timer((int)PR);
                Last_PR = PR;
            }


        } // TimerPeriodicEventCallback1



        //==================================================================================================================
        private void comboTuneMode_SelectedIndexChanged(object sender, System.EventArgs e)
        {
            if (atu_present)
            {
                if (comboTuneMode.SelectedIndex == (int)ATUTuneMode.BYPASS)
                {
                    //  if(current_model == Model.SDR1000)    					Hdw.PA_ATUTune(ATUTuneMode.BYPASS);	
                    tuned_band = Band.FIRST;
                    if (chkTUN.BackColor == button_selected_color)
                        chkTUN.BackColor = SystemColors.Control;
                }
            }

            if (comboTuneMode.Focused)
                btnHidden.Focus();
        }

        private void HideFocus(object sender, EventArgs e)
        {
            btnHidden.Focus();
        }

        //============================================================================
        // ke9ns add

        private int VFOLOCKAB = 0;

        private void chkVFOLock_CheckedChanged(object sender, System.EventArgs e)
        {
            Font temp1 = new Font(SystemFonts.DefaultFont, FontStyle.Bold);            // new Font(defaultFont.FontFamily, defaultFont.Size, FontStyle.Bold);


            if ((setupForm == null) || (setupForm.chkBoxVFOLockAB.Checked == false))
            {

                VFOLock = chkVFOLock.Checked; // ke9ns VFOA lock only (original code)

                if (chkVFOLock.Checked)
                {
                    chkVFOLock.BackColor = button_selected_color;
                }
                else
                {
                    chkVFOLock.BackColor = SystemColors.Control;
                }

            } // if (setupForm.chkBoxVFOLockAB.Checked == false)
            else
            {
                if (chkVFOLock.Checked == true)
                {
                    if (VFOLOCKAB == 0)
                    {
                        temp1 = chkVFOLock.Font;
                        chkVFOLock.Font = ff5; //  new Font(SystemFonts.DefaultFont, FontStyle.Bold | FontStyle.Italic);            // new Font(defaultFont.FontFamily, defaultFont.Size, FontStyle.Bold);

                        VFOLockB = false;
                        VFOLock = true;   // ke9ns VFOA lock only

                        VFOLOCKAB++; // now 1
                        chkVFOLock.BackColor = button_selected_color;

                        chkVFOLock.Text = "VFOA Lock";

                    }
                    else if (VFOLOCKAB == 1) //
                    {
                        VFOLock = true;   // ke9ns VFOA lock 
                        VFOLockB = true;  // ke9ns VFOB lock 
                        VFOLOCKAB++; // now 2
                        chkVFOLock.BackColor = button_selected_color;



                        chkVFOLock.Text = "VFOA/B Lock";


                    }
                    else if (VFOLOCKAB == 2)
                    {
                        VFOLock = false;
                        VFOLockB = true;   // ke9ns VFOB lock only
                        VFOLOCKAB++; // now 3
                        chkVFOLock.BackColor = button_selected_color;



                        chkVFOLock.Text = "VFOB Lock";

                    }
                    else
                    {
                        VFOLOCKAB = 0;
                    }

                } //  if (chkVFOLock.Checked == true)
                else
                {
                    if (VFOLOCKAB > 0 && VFOLOCKAB < 3)
                    {
                        chkVFOLock.Checked = true;
                    }
                    else
                    {
                        chkVFOLock.Font = temp1;

                        VFOLock = false;   // ke9ns VFOA lock 
                        VFOLockB = false;  // ke9ns VFOB lock 
                        VFOLOCKAB = 0;
                        chkVFOLock.BackColor = SystemColors.Control;
                        chkVFOLock.Text = "VFO Lock";
                    }
                } //  if (chkVFOLock.Checked == true)

            } // if (setupForm.chkBoxVFOLockAB.Checked == false)



        } //  chkVFOLock_CheckedChanged

        public bool meterPause = false; // ke9ns add true=pause image pointer rotate when updating image of buttons

        private void btnBandVHF_Click(object sender, System.EventArgs e)  // ke9ns hf screen click on VHF button
        {
            meterPause = true;

            panelBandVHF.Visible = true;

            panelBandHF.Visible = false;
            panelBandGN.Visible = false; // ke9ns add

            // panelBandGN.Invalidate(); // ke9ns add
            // panelBandHF.Invalidate(); // ke9ns add
            panelBandVHF.Invalidate(); // ke9ns add forces a paint

            meterPause = false;

        }

        private void btnBandVHFRX2_Click(object sender, System.EventArgs e)  // ke9ns hf screen click on VHF button
        {
            meterPause = true;

            if (FWCEEPROM.RX2OK) if (FWCEEPROM.VUOK) panelBandVHFRX2.Visible = true;

            panelBandHFRX2.Visible = false;
            panelBandGNRX2.Visible = false; // ke9ns add

            // panelBandGNRX2.Invalidate(); // ke9ns add
            // panelBandHFRX2.Invalidate(); // ke9ns add
            panelBandVHFRX2.Invalidate(); // ke9ns add forces a paint

            meterPause = false;

        }

        private void btnBandHF_Click(object sender, System.EventArgs e) // ke9ns vhf screen click on HF button  (or GEN screen click on btnBandHF1  HF button)
        {

            meterPause = true; // ke9ns add to pause rotateimage

            panelBandHF.Visible = true;

            panelBandGN.Visible = false; // ke9ns add
            panelBandVHF.Visible = false;

            //  panelBandVHF.Invalidate(); // ke9ns add
            //   panelBandGN.Invalidate(); // ke9ns add
            panelBandHF.Invalidate(); // ke9ns add

            meterPause = false; // ke9ns add to pause rotateimage

        }
        private void btnBandHFRX2_Click(object sender, System.EventArgs e) // ke9ns vhf screen click on HF button  (or GEN screen click on btnBandHF1  HF button)
        {

            meterPause = true; // ke9ns add to pause rotateimage

            if (FWCEEPROM.RX2OK) panelBandHFRX2.Visible = true;

            panelBandGNRX2.Visible = false; // ke9ns add
            panelBandVHFRX2.Visible = false;

            //  panelBandVHFRX2.Invalidate(); // ke9ns add
            //   panelBandGNRX2.Invalidate(); // ke9ns add
            panelBandHFRX2.Invalidate(); // ke9ns add

            meterPause = false; // ke9ns add to pause rotateimage

        }
        private void btnBandGEN_Click(object sender, EventArgs e) // ke9ns add hf screen click on GEN button
        {

            meterPause = true; // ke9ns add to pause rotateimage


            panelBandGN.Visible = true; // ke9ns add
            panelBandVHF.Visible = false;
            panelBandHF.Visible = false;

            //  panelBandVHF.Invalidate(); // ke9ns add
            //  panelBandHF.Invalidate(); // ke9ns add
            panelBandGN.Invalidate(); // ke9ns add

            meterPause = false; // ke9ns add to pause rotateimage

        }
        // .203
        private void btnBandGENRX2_Click(object sender, EventArgs e) // ke9ns add hf screen click on GEN button
        {

            meterPause = true; // ke9ns add to pause rotateimage


            if (FWCEEPROM.RX2OK) if (FWCEEPROM.RX2OK) panelBandGNRX2.Visible = true; // ke9ns add
            panelBandVHFRX2.Visible = false;
            panelBandHFRX2.Visible = false;

            //  panelBandVHFRX2.Invalidate(); // ke9ns add
            //  panelBandHFRX2.Invalidate(); // ke9ns add
            panelBandGNRX2.Invalidate(); // ke9ns add

            meterPause = false; // ke9ns add to pause rotateimage

        }
        private void udFilterLow_LostFocus(object sender, EventArgs e)
        {
            udFilterLow_ValueChanged(sender, e);
        }

        private void udFilterHigh_LostFocus(object sender, EventArgs e)
        {
            udFilterHigh_ValueChanged(sender, e);
        }

        private void udRIT_LostFocus(object sender, EventArgs e)
        {
            udRIT_ValueChanged(sender, e);
        }

        private void udXIT_LostFocus(object sender, EventArgs e)
        {
            udXIT_ValueChanged(sender, e);
        }

        private void DateTime_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
        {
            if (current_datetime_mode + 1 == DateTimeMode.LAST) CurrentDateTimeMode = DateTimeMode.OFF;
            else CurrentDateTimeMode = current_datetime_mode + 1;

            btnHidden.Focus();
        }

        private void chkSR_CheckedChanged(object sender, System.EventArgs e)
        {
            if (setupForm != null) setupForm.SpurReduction = chkSR.Checked;
            if (chkEnableMultiRX.Checked) txtVFOBFreq_LostFocus(this, EventArgs.Empty);
            if (chkSR.Checked) chkSR.BackColor = button_selected_color;
            else chkSR.BackColor = SystemColors.Control;

            tempVFOAFreq = VFOAFreq; // ke9ns add
            CTUN1_HZ = 0; // ke9ns add: when changing SR, reset CTUN

            CalcDisplayFreq();
        }

        private void btnChangeTuneStepSmaller_Click(object sender, System.EventArgs e)
        {
            ChangeTuneStepDown();
        }

        private void btnChangeTuneStepLarger_Click(object sender, System.EventArgs e)
        {
            ChangeTuneStepUp();
        }

        private void comboTXProfile_SelectedIndexChanged(object sender, System.EventArgs e)
        {
            if (setupForm == null || initializing) return;

            setupForm.TXProfile = comboTXProfile.Text;

            if (comboDigTXProfile.Text != comboTXProfile.Text)
                comboDigTXProfile.Text = comboTXProfile.Text;

            if (comboFMTXProfile.Text != comboTXProfile.Text)
                comboFMTXProfile.Text = comboTXProfile.Text;

            if (comboCWTXProfile.Text != comboTXProfile.Text)
                comboCWTXProfile.Text = comboTXProfile.Text;

            UpdateDisplay();

            if (comboTXProfile.Focused) btnHidden.Focus();
        }

        private void comboDigTXProfile_SelectedIndexChanged(object sender, System.EventArgs e)
        {
            if (setupForm == null || initializing) return;
            setupForm.TXProfile = comboDigTXProfile.Text;

            if (comboTXProfile.Text != comboDigTXProfile.Text)
                comboTXProfile.Text = comboDigTXProfile.Text;

            if (comboFMTXProfile.Text != comboTXProfile.Text)
                comboFMTXProfile.Text = comboTXProfile.Text;

            if (comboCWTXProfile.Text != comboTXProfile.Text)
                comboCWTXProfile.Text = comboTXProfile.Text;
            UpdateDisplay();

            if (comboDigTXProfile.Focused) btnHidden.Focus();
        }

        // ke9ns add
        private void comboCWTXProfile_SelectedIndexChanged(object sender, System.EventArgs e)
        {
            if (setupForm == null || initializing) return;
            setupForm.TXProfile = comboCWTXProfile.Text;

            if (comboTXProfile.Text != comboDigTXProfile.Text)
                comboTXProfile.Text = comboDigTXProfile.Text;

            if (comboFMTXProfile.Text != comboTXProfile.Text)
                comboFMTXProfile.Text = comboTXProfile.Text;

            if (comboCWTXProfile.Text != comboTXProfile.Text)
                comboCWTXProfile.Text = comboTXProfile.Text;

            UpdateDisplay();

            if (comboCWTXProfile.Focused) btnHidden.Focus();
        } // comboCWTXProfile_SelectedIndexChanged


        public void comboFMTXProfile_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (setupForm == null || initializing) return;

            setupForm.TXProfile = comboFMTXProfile.Text;

            if (comboTXProfile.Text != comboDigTXProfile.Text)
                comboTXProfile.Text = comboDigTXProfile.Text;

            if (comboDigTXProfile.Text != comboTXProfile.Text)
                comboDigTXProfile.Text = comboTXProfile.Text;

            if (comboCWTXProfile.Text != comboTXProfile.Text)
                comboCWTXProfile.Text = comboTXProfile.Text;

            UpdateDisplay();

            if (comboFMTXProfile.Focused) btnHidden.Focus();



        } // comboFMTXProfile_SelectedIndexChanged

        private void chkShowTXFilter_CheckedChanged(object sender, System.EventArgs e)
        {
            if (chkShowTXFilter.Checked)
            {
                chkShowDigTXFilter.Checked = true;
            }
            else chkShowDigTXFilter.Checked = false;
            Display.DrawTXFilter = chkShowTXFilter.Checked;
        }

        private void chkShowDigTXFilter_CheckedChanged(object sender, System.EventArgs e)
        {
            if (chkShowDigTXFilter.Checked)
            {
                chkShowTXFilter.Checked = true;
            }
            else chkShowTXFilter.Checked = false;
        }

        private void mnuFilterReset_Click(object sender, System.EventArgs e)
        {
            DialogResult dr = MessageBox.Show(
                "Are you sure you want to reset all RX1 custom filter settings to the default?",
                "Reset Filters?",
                MessageBoxButtons.YesNo,
                MessageBoxIcon.Question);

            if (dr == DialogResult.No) return;

            InitFilterPresets(rx1_filters);

            radFilter1.Text = rx1_filters[(int)rx1_dsp_mode].GetName(Filter.F1);
            radFilter2.Text = rx1_filters[(int)rx1_dsp_mode].GetName(Filter.F2);
            radFilter3.Text = rx1_filters[(int)rx1_dsp_mode].GetName(Filter.F3);
            radFilter4.Text = rx1_filters[(int)rx1_dsp_mode].GetName(Filter.F4);
            radFilter5.Text = rx1_filters[(int)rx1_dsp_mode].GetName(Filter.F5);
            radFilter6.Text = rx1_filters[(int)rx1_dsp_mode].GetName(Filter.F6);
            radFilter7.Text = rx1_filters[(int)rx1_dsp_mode].GetName(Filter.F7);
            radFilter8.Text = rx1_filters[(int)rx1_dsp_mode].GetName(Filter.F8);
            radFilter9.Text = rx1_filters[(int)rx1_dsp_mode].GetName(Filter.F9);
            radFilter10.Text = rx1_filters[(int)rx1_dsp_mode].GetName(Filter.F10);
            radFilterVar1.Text = rx1_filters[(int)rx1_dsp_mode].GetName(Filter.VAR1);
            radFilterVar2.Text = rx1_filters[(int)rx1_dsp_mode].GetName(Filter.VAR2);
            RX1Filter = rx1_filter;

            if (filterRX1Form != null && !filterRX1Form.IsDisposed)
            {
                filterRX1Form.DSPMode = rx1_dsp_mode;
            }
        }

        private void menuItemRX2FilterReset_Click(object sender, System.EventArgs e)
        {
            DialogResult dr = MessageBox.Show(
                "Are you sure you want to reset all RX2 custom filter settings to the default?",
                "Reset Filters?",
                MessageBoxButtons.YesNo,
                MessageBoxIcon.Question);

            if (dr == DialogResult.No) return;

            InitFilterPresets(rx2_filters);

            radRX2Filter1.Text = rx2_filters[(int)rx2_dsp_mode].GetName(Filter.F1);
            radRX2Filter2.Text = rx2_filters[(int)rx2_dsp_mode].GetName(Filter.F2);
            radRX2Filter3.Text = rx2_filters[(int)rx2_dsp_mode].GetName(Filter.F3);
            radRX2Filter4.Text = rx2_filters[(int)rx2_dsp_mode].GetName(Filter.F4);
            radRX2Filter5.Text = rx2_filters[(int)rx2_dsp_mode].GetName(Filter.F5);
            radRX2Filter6.Text = rx2_filters[(int)rx2_dsp_mode].GetName(Filter.F6);
            radRX2Filter7.Text = rx2_filters[(int)rx2_dsp_mode].GetName(Filter.F7);
            radRX2FilterVar1.Text = rx2_filters[(int)rx2_dsp_mode].GetName(Filter.VAR1);
            radRX2FilterVar2.Text = rx2_filters[(int)rx2_dsp_mode].GetName(Filter.VAR2);
            RX2Filter = rx2_filter;

            if (filterRX2Form != null && !filterRX2Form.IsDisposed)
            {
                filterRX2Form.DSPMode = rx2_dsp_mode;
            }
        }

        private void mnuFlexControl_Click(object sender, EventArgs e)
        {
            switch (current_flexcontrol_mode)
            {
                case FlexControlMode.Basic:
                    if (flexControlBasicForm == null || flexControlBasicForm.IsDisposed)
                        flexControlBasicForm = new FlexControlBasicForm(this);
                    flexControlBasicForm.Show();
                    flexControlBasicForm.Focus();
                    //   flexControlBasicForm.WindowState = FormWindowState.Normal; // ke9ns add to allow clicking the menu item name to bring the screen back up from the windows tray
                    break;
                case FlexControlMode.Advanced:
                    if (flexControlAdvancedForm == null || flexControlAdvancedForm.IsDisposed)
                        flexControlAdvancedForm = new FlexControlAdvancedForm(this);
                    flexControlAdvancedForm.Show();
                    flexControlAdvancedForm.Focus();
                    //    flexControlAdvancedForm.WindowState = FormWindowState.Normal; // ke9ns add
                    break;
            }
        }

        private void chkVACStereo_CheckedChanged(object sender, System.EventArgs e)
        {
            if (setupForm != null)
            {
                if (!(chkRX2.Checked && chkVAC2.Checked && chkVFOBTX.Checked))
                {
                    setupForm.VACStereo = chkVACStereo.Checked;
                    vac_stereo = chkVACStereo.Checked;
                }
                else
                {
                    setupForm.VAC2Stereo = chkVACStereo.Checked;
                    vac2_stereo = chkVACStereo.Checked;
                }
            }
        }

        private void chkCWIambic_CheckedChanged(object sender, System.EventArgs e)
        {
            if (setupForm != null) setupForm.CWIambic = chkCWIambic.Checked;
        }

        private void chkCWSidetone_CheckedChanged(object sender, System.EventArgs e)
        {
            if (setupForm != null) setupForm.CWDisableMonitor = chkCWSidetone.Checked;
        }

        //===============================================================
        public void udCWPitch_ValueChanged(object sender, System.EventArgs e)
        {
            if (setupForm != null) setupForm.CWPitch = (int)udCWPitch.Value;
            if (udCWPitch.Focused) btnHidden.Focus();
        }

        private void comboVACSampleRate_SelectedIndexChanged(object sender, System.EventArgs e)
        {
            if (setupForm != null)
            {
                if (!(chkRX2.Checked && chkVAC2.Checked && chkVFOBTX.Checked))
                {
                    setupForm.VACSampleRate = comboVACSampleRate.Text;
                    vac_sample_rate = comboVACSampleRate.Text;
                }
                else
                {
                    setupForm.VAC2SampleRate = comboVACSampleRate.Text;
                    vac2_sample_rate = comboVACSampleRate.Text;
                }

            }
            if (comboVACSampleRate.Focused) btnHidden.Focus();
        }

        private void chkX2TR_CheckedChanged(object sender, System.EventArgs e)
        {
            if (setupForm != null) setupForm.X2TR = chkX2TR.Checked;

            if (chkX2TR.Checked) chkX2TR.BackColor = button_selected_color;
            else chkX2TR.BackColor = SystemColors.Control;
        }

        private void chkShowTXCWFreq_CheckedChanged(object sender, System.EventArgs e)
        {
            Display.DrawTXCWFreq = chkShowTXCWFreq.Checked;
        }

        private void chkCWBreakInEnabled_CheckedChanged(object sender, System.EventArgs e)
        {
            if (setupForm != null) setupForm.BreakInEnabled = chkCWBreakInEnabled.Checked;
            if (fwc_init && (current_model == Model.FLEX5000 || current_model == Model.FLEX3000))
                FWC.SetBreakIn(chkCWBreakInEnabled.Checked);
        }

        private void udCWBreakInDelay_ValueChanged(object sender, System.EventArgs e)
        {
            if (setupForm != null) setupForm.BreakInDelay = (int)udCWBreakInDelay.Value;
            if (udCWBreakInDelay.Focused)
                btnHidden.Focus();
        }

        private void udCWBreakInDelay_LostFocus(object sender, System.EventArgs e)
        {
            udCWBreakInDelay_ValueChanged(sender, e);
        }

        public void DisableDAX()
        {
            // disable VAC on console. dax_audio_enum = false by default
            chkVAC1.Checked = false;
            chkVAC1.Enabled = false;
            chkVAC2.Checked = false;
            chkVAC2.Enabled = false;
        }

        public void EnableDAX()
        {
            // enable VAC on console
            chkVAC1.Enabled = true;
            chkVAC2.Enabled = true;  // was false set to true later if RX2 installed 
            dax_audio_enum = true;
        }

        //=====================================================================================  
        private void chkVAC1_CheckedChanged(object sender, System.EventArgs e)
        {
            PowerRX2Pause = true; //.235

            if (setupForm != null) setupForm.VACEnable = chkVAC1.Checked;

            if (chkVAC1.Checked)
            {
                chkVAC1.BackColor = button_selected_color;

                if (chkVOX.Checked)
                {
                    chkVOX.Checked = false;
                    if (setupForm != null) setupForm.VOXEnable = chkVOX.Checked;
                    Audio.VOXActive = false;
                    chkVOX.BackColor = SystemColors.Control;

                }
            }
            else chkVAC1.BackColor = SystemColors.Control;

            PowerRX2Pause = false; //.235

        } // VAC1 clicked


        //================================================================================================
        //  ke9ns mute works on this but not on vac1 
        //================================================================================================
        private void chkVAC2_CheckedChanged(object sender, EventArgs e)
        {
            PowerRX2Pause = true; //.233


            if (setupForm != null) setupForm.VAC2Enable = chkVAC2.Checked;  // ke9ns if you check vac2 from setup form then update here as well

            //  if (!fwc_init || current_model != Model.FLEX5000 || !FWCEEPROM.RX2OK || !chkRX2.Checked)

            if (!fwc_init || current_model != Model.FLEX5000 || !FWCEEPROM.RX2OK || !chkRX2.Checked)
            {
                if (chkVOX.Checked)
                {
                    chkVOX.Checked = false;
                    if (setupForm != null) setupForm.VOXEnable = chkVOX.Checked;
                    Audio.VOXActive = false;
                    chkVOX.BackColor = SystemColors.Control;
                }

                PowerRX2Pause = false; //.233
                return;
            }


            if (chkVFOBTX.Checked)
            {
                if (chkVAC2.Checked)
                {
                    ptbVACRXGain.Value = vac2_rx_gain;
                    ptbVACRXGain_Scroll(this, EventArgs.Empty);

                    ptbVACTXGain.Value = vac2_tx_gain;
                    ptbVACTXGain_Scroll(this, EventArgs.Empty);

                    comboVACSampleRate.Text = vac2_sample_rate;

                    chkVACStereo.Checked = vac2_stereo;
                }
                else
                {
                    ptbVACRXGain.Value = vac_rx_gain;
                    ptbVACRXGain_Scroll(this, EventArgs.Empty);

                    ptbVACTXGain.Value = vac_tx_gain;
                    ptbVACTXGain_Scroll(this, EventArgs.Empty);

                    comboVACSampleRate.Text = vac_sample_rate;

                    chkVACStereo.Checked = vac_stereo;
                }
            }

            if (chkVAC2.Checked)
            {
                chkVAC2.BackColor = button_selected_color;

                if (chkVOX.Checked)
                {
                    chkVOX.Checked = false;
                    if (setupForm != null) setupForm.VOXEnable = chkVOX.Checked;
                    Audio.VOXActive = false;
                    chkVOX.BackColor = SystemColors.Control;
                }

            }
            else chkVAC2.BackColor = SystemColors.Control;

            PowerRX2Pause = false; //.233

        } // chkVAC2



        private void chkRXEQ_CheckedChanged(object sender, System.EventArgs e)
        {
            if (chkRXEQ.Checked) chkRXEQ.BackColor = button_selected_color;
            else chkRXEQ.BackColor = SystemColors.Control;
            if (eqForm != null) eqForm.RXEQEnabled = chkRXEQ.Checked;
        }

        private void chkTXEQ_CheckedChanged(object sender, System.EventArgs e)
        {
            if (chkTXEQ.Checked) chkTXEQ.BackColor = button_selected_color;
            else chkTXEQ.BackColor = SystemColors.Control;
            if (eqForm != null) eqForm.TXEQEnabled = chkTXEQ.Checked;
        }

        private void chkBCI_CheckedChanged(object sender, System.EventArgs e)
        {
            if (chkBCI.Checked)
                chkBCI.BackColor = button_selected_color;
            else
                chkBCI.BackColor = SystemColors.Control;

            //  if(current_model == Model.SDR1000)                SetHWFilters(dds_freq);
        }

        public bool CheckForTXCW()
        {
            if (!cw_semi_break_in_enabled) return false;
            DSPMode tx_mode = rx1_dsp_mode;
            if (chkVFOBTX.Checked && chkRX2.Checked) tx_mode = rx2_dsp_mode;

            bool ret_val = false;

            switch (tx_mode)
            {
                case DSPMode.CWL:
                case DSPMode.CWU:
                    ret_val = true;
                    break;
                default:
                    ret_val = false;
                    break;
            }

            return ret_val;
        }

        #endregion

        #region VFO Events

        private enum TuneLocation
        {
            VFOA = 0,
            VFOB,
            VFOASub,
            DisplayBottom,
            Other,
        }


        //==================================================================================================
        // ke9ns mod
        private TuneLocation TuneHitTest(int x, int y)
        {
            //---------------------------------------------------------------------------
            //---------------------------------------------------------------------------
            // ke9ns add  to allow proper click to tune operation between Rx1 and rx2

            /*   
                 if ((Display.CurrentDisplayModeBottom != DisplayMode.OFF) && (rx2_enabled))
                 {

                     if ((Display.K9 == 5) && (Display.K10 != 5))  // to help RX2 pan display in 1/3 instead of 1/2
                     {
                          H7 = picDisplay.Height * 2 / 3;
                     }
                     else if ((Display.K9 == 5) && (Display.K10 == 5)) // to help RX2 pan display in 1/4 instead of 1/2
                     {
                          H7 = picDisplay.Height / 2;
                     }
                     else if (Display.K9 == 7) // special panafall mode for grayline tracking
                     {
                         H7 = picDisplay.Height * 5 / 6;
                     }
                     else
                     {
                          H7 = picDisplay.Height / 2; // ke9ns this was standard
                     }

                 }
                 else
                 {
                     H7 = picDisplay.Height / 2; // ke9ns this was standard
                 }
                 //--------------------------------------------------------------------------------
     */

            int left, right, top, bottom;

            left = grpVFOA.Left + txtVFOAFreq.Left;
            right = left + txtVFOAFreq.Width;
            top = grpVFOA.Top + txtVFOAFreq.Top;
            bottom = top + txtVFOAFreq.Height;

            if (x > left && x < right && y > top && y < bottom) return TuneLocation.VFOA;

            left = grpVFOB.Left + txtVFOBFreq.Left;
            right = left + txtVFOBFreq.Width;
            top = grpVFOB.Top + txtVFOBFreq.Top;
            bottom = top + txtVFOBFreq.Height;

            if (x > left && x < right && (y > top) && (y < bottom) && (Display.CurrentDisplayModeBottom != DisplayMode.OFF)) return TuneLocation.VFOB; // ke9ns mod

            left = grpVFOA.Left + txtVFOABand.Left;
            right = left + txtVFOABand.Width;
            top = grpVFOA.Top + txtVFOABand.Top;
            bottom = top + txtVFOABand.Height;
            if (x > left && x < right && y > top && y < bottom) return TuneLocation.VFOASub;

            left = panelDisplay.Left + picDisplay.Left;
            right = left + picDisplay.Width;
            top = panelDisplay.Top + picDisplay.Top + H7; // ke9ns mod
            bottom = top + H7; // ke9ns mod
            if ((x > left) && (x < right) && (y > top) && (y < bottom) && (Display.CurrentDisplayModeBottom != DisplayMode.OFF)) return TuneLocation.DisplayBottom; // ke9ns mod

            return TuneLocation.Other;

        } // TuneLocation TuneHitTest


        //=====================================================================================================
        public void Console_MouseWheel(object sender, System.Windows.Forms.MouseEventArgs e)
        {
            //			if(this.ActiveControl is TextBoxTS && this.ActiveControl != txtVFOAFreq
            //				&& this.ActiveControl != txtVFOBFreq) return;
            //			if(this.ActiveControl is NumericUpDownTS) return;


            if (CTUN == true) // ke9ns add: true = bandpass moves and panadapter stays put.
            {
                if (e.Delta == 0) return;

                int mousewheel = (e.Delta > 0 ? 1 : -1); // 1 per click

                if (setupForm != null)
                {
                    if (setupForm.chkBoxWheelRev.Checked == true) mousewheel = -mousewheel; // ke9ns add: reverse wheel rotation option
                }

                if ((Display.CurrentDisplayMode == DisplayMode.PANADAPTER) || (Display.CurrentDisplayMode == DisplayMode.PANAFALL) || (Display.CurrentDisplayMode == DisplayMode.PANASCOPE) || (Display.CurrentDisplayMode == DisplayMode.WATERFALL))
                {
                    UPDATEOFF = 2; // ke9ns: let system know not to update screen for a little while pan

                }

                if (mousewheel < 0)
                {
                    CTUN1_HZ = CTUN1_HZ - CurrentTuneStepHz;      // ke9ns add: allow bandpass window to scroll across display instead of display freq scroll under bandpass.
                    tempVFOAFreq = VFOAFreq - (double)CurrentTuneStepHz / 1e6; // vfoafreq in mhz
                    CalcDisplayFreq(); // ke9ns keep display from moving
                }
                else // value >= 0
                {
                    CTUN1_HZ = CTUN1_HZ + CurrentTuneStepHz;     // ke9ns add: allow bandpass window to scroll across display instead of display freq scroll under bandpass.
                    tempVFOAFreq = VFOAFreq + (double)CurrentTuneStepHz / 1e6;
                    CalcDisplayFreq(); // ke9ns keep display from moving
                }
                Debug.WriteLine("CTUN=" + CTUN1_HZ);

                return;


            } // ctun mode

            if (this.ActiveControl is TextBoxTS ||
                this.ActiveControl is NumericUpDownTS ||
                this.ActiveControl is TrackBarTS)
            {
                Console_KeyPress(this, new KeyPressEventArgs((char)Keys.Enter));
                return;
            }


            if (e.Delta == 0) return;

            int num_steps = (e.Delta > 0 ? 1 : -1); // 1 per click


            if (ROTAFACTOR == true) // mouse over the VFOA arrow sign
            {

                XX = XX + (float)((float)num_steps * .01f);

                Debug.WriteLine("ROTA  " + XX);
                dialcheckA = true;



                return;
            }

            if (setupForm != null)
            {
                if (setupForm.chkBoxWheelRev.Checked == true) num_steps = -num_steps; // ke9ns add reverse wheel rotation

                // Debug.WriteLine("Mousewheel click: " + num_steps);

            }

            if (vfo_char_width == 0) GetVFOCharWidth();

            if (num_steps == 0) return;

            int step = CurrentTuneStepHz;
            if (shift_down && step >= 10) step /= 10;

            //  Debug.WriteLine("TUNESTEP = " + step);

            switch (TuneHitTest(e.X, e.Y))
            {
                case TuneLocation.VFOA:

                    //  Debug.WriteLine("VFOAAAAAAAAAAAAAAAAAAAAAAAAA");

                    double freq = double.Parse(txtVFOAFreq.Text);
                    double mult = 1000.0;
                    int right = grpVFOA.Left + txtVFOAFreq.Left + txtVFOAFreq.Width;

                    if (vfoa_hover_digit < 0)
                    {
                        int x = right + 2 - (vfo_pixel_offset - 5); //ke9ns: was    right + 2 - (vfo_pixel_offset - 5);

                        Debug.WriteLine("Mousewheel digit: " + vfoa_hover_digit);
                        while (x < e.X && mult > 0.0000011)
                        {
                            mult /= 10.0;
                            x += vfo_char_width;
                            if (mult == 1.0) x += vfo_decimal_space;
                            else x += vfo_char_space;
                        }
                    }
                    else
                    {
                        mult = Math.Pow(10, -vfoa_hover_digit) * 1000.0;
                        Debug.WriteLine("Mousewheel digit1: " + vfoa_hover_digit + " , " + mult); //719
                    }

                    if (mult <= 1.0)
                    {
                        freq += mult * num_steps;
                        //Debug.WriteLine("freq: "+freq.ToString("f6" ));
                        VFOAFreq = freq;
                    }


                    break;

                case TuneLocation.VFOB:

                    //   Debug.WriteLine("VFOBBBBBBBBBBBBBBBBBBBBBBBBBBB");

                    freq = double.Parse(txtVFOBFreq.Text);
                    mult = 1000.0;
                    right = grpVFOB.Left + txtVFOBFreq.Left + txtVFOBFreq.Width;
                    if (vfob_hover_digit < 0)
                    {
                        int x = right + 2 - (vfo_pixel_offset - 5);
                        while (x < e.X && mult > 0.0000011)
                        {
                            mult /= 10;
                            x += vfo_char_width;
                            if (mult == 1.0)
                                x += vfo_decimal_space;
                            else x += vfo_char_space;
                        }
                    }
                    else
                    {
                        mult = Math.Pow(10, -vfob_hover_digit) * 1000.0;
                    }

                    if (mult <= 1.0)
                    {
                        freq += mult * num_steps;
                        VFOBFreq = freq;
                    }

                    break;

                case TuneLocation.VFOASub:
                    if (rx2_enabled && (chkEnableMultiRX.Checked || chkVFOSplit.Checked))
                    {
                        freq = VFOASubFreq;
                        mult = 1000.0;
                        right = grpVFOA.Left + txtVFOABand.Left + txtVFOABand.Width;
                        if (vfoa_sub_hover_digit < 0)
                        {
                            int x = right + 2 - (vfo_sub_pixel_offset - 5);
                            while (x < e.X && mult > 0.0000011)
                            {
                                mult /= 10;
                                x += vfo_sub_char_width;
                                if (mult == 1.0)
                                    x += vfo_sub_decimal_space;
                                else x += vfo_sub_char_space;
                            }
                        }
                        else
                        {
                            mult = Math.Pow(10, -vfoa_sub_hover_digit) * 1000.0;
                        }

                        if (mult <= 1.0)
                        {
                            freq += mult * num_steps;
                            VFOASubFreq = freq;
                        }
                    }
                    else
                    {
                        VFOAFreq = SnapTune(VFOAFreq, step, num_steps);
                    }
                    break;

                case TuneLocation.DisplayBottom:
                    if (rx2_enabled && chkVFOSplit.Checked && current_click_tune_mode == ClickTuneMode.VFOB && wheel_tunes_vfob)
                        VFOASubFreq = SnapTune(VFOASubFreq, step, num_steps);
                    else if (rx2_enabled || (current_click_tune_mode == ClickTuneMode.VFOB && wheel_tunes_vfob))
                        VFOBFreq = SnapTune(VFOBFreq, step, num_steps);
                    else
                        VFOAFreq = SnapTune(VFOAFreq, step, num_steps);
                    break;

                case TuneLocation.Other:
                    if (current_click_tune_mode == ClickTuneMode.VFOB && wheel_tunes_vfob)
                    {
                        if (rx2_enabled && chkVFOSplit.Checked)
                            VFOASubFreq = SnapTune(VFOASubFreq, step, num_steps);
                        else
                            VFOBFreq = SnapTune(VFOBFreq, step, num_steps);
                    }
                    else VFOAFreq = SnapTune(VFOAFreq, step, num_steps);
                    break;

            } //switch(TuneHitTest(e.X, e.Y))

        } // console_mousewheel

        /// <summary>
        /// Calculates a "Snapped" frequency that lies on an integer multiple of the Tune Step.
        /// </summary>
        /// <param name="freq_mhz">The starting frequency in MHz</param>
        /// <param name="step_size_hz">The selected step size in Hz</param>
        /// <param name="num_steps">Indicates both the number and direction of steps.  Negative
        /// numbers indicate steps down while positive numbers indicate steps up.</param>
        /// <returns>The adjusted frequency in MHz</returns>
        /// 
        public bool snapTNew = false; // ke9ns .196 true=new way for larger tunesteps
        public double SnapTune(double freq_mhz, int step_size_hz, int num_steps)
        {
            long freq_hz = (long)Math.Round(freq_mhz * 1e6); // convert frequency to Hz -- use long to support >4GHz

            long temp = freq_hz / step_size_hz; // do integer division to end up on a step size boundary


            if ((snapTNew == true) && ((freq_hz % step_size_hz) != 0)) // ke9ns add .196 (new way of tunestep for larger values
            {
                Debug.WriteLine("MODULO tunestep modulo");

                freq_hz = freq_hz / 1000;
                freq_hz = freq_hz * 1000; // drop everything below 1khz

                double temp8 = (double)freq_hz / (double)step_size_hz; // 466.67
                freq_hz = (long)((temp8 * (double)step_size_hz) + ((double)step_size_hz * (double)num_steps));
                Debug.WriteLine("MODULO tunestep modulo " + temp8 + " , " + freq_hz);

            }
            else
            {
                Debug.WriteLine("tunestep no modulo");
                // handle when starting frequency was already on a step size boundary and tuning down
                if (num_steps < 0 && freq_hz % step_size_hz != 0)
                {
                    num_steps++; // off boundary -- add one as the divide takes care of one step
                }

                temp += num_steps; // increment by the number of steps (positive or negative)

                freq_hz = temp * step_size_hz; // multiply back up to get hz

            }


            return Math.Round(freq_hz * 1e-6, 6); // return freq in MHz

        } //SnapTune


        //================================================================================ 
        //================================================================================ 
        //================================================================================ 
        // ke9ns mod to VFOA allow khz freq(when in HF band) entry as well as standard mhz entry 
        //================================================================================ 
        //================================================================================ 
        //================================================================================   

        private void txtVFOAFreq_LostFocus(object sender, System.EventArgs e)
        {

          //  Debug.WriteLine("START LostFocus " + txtVFOAFreq.Text + " , " + saved_vfoa_freq + " , " + VFOAFreq); // 144,00000, 7,0001, 144


            if (txtVFOAFreq.Text == separator || txtVFOAFreq.Text == "") // "."
            {
                VFOAFreq = saved_vfoa_freq;
                return;
            }

            double freq;

            try  // ke9ns add  the try to prevent a crash
            {
                freq = double.Parse(txtVFOAFreq.Text);  // ke9ns original
                Debug.WriteLine("freq=========" + freq + " , " + txtVFOAFreq.Text);

            }
            catch (Exception)
            {
                  Debug.WriteLine("BAD txtVFOAFreq_LostFocus " + txtVFOAFreq.Text);

                VFOAFreq = saved_vfoa_freq;
                return;
            }


             // freq = double.Parse(txtVFOAFreq.Text.Replace(",",".")); // ke9ns mod

           //  Debug.WriteLine("txtVFOAFreq_LostFocus freq " + freq); // 144     freq in europe 7.00mhz  is 7 here  or 7,00005 if 7.00005mhz

                // ke9ns MOD khz freq entry here
                if ((freq > 99.0) && ((panelBandHF.Visible == true || panelBandGN.Visible == true)) && (txtVFOAFreq.Text.Contains(separator) == false) ) // "." check for khz entry instead of mhz  was 65 now 99 .240
                {
                    if (freq <= 999) // 3 digit must be khz 700 = 700 khz
                    {
                        freq = freq / 1000;     // 721 = .721 mhz

                    } // 3digite
                    else if (freq <= 9999) // 4 digits  7123 = 7.123 mhz
                    {
                        freq = freq / 1000;
                    }
                    else if (freq <= 99999) // 5 digits  12345 = 12.345 mhz
                    {
                        if (freq < 65000) freq = freq / 1000; // 30123 = 30.123 mhz
                        else freq = freq / 10000;  //65123 = 6.5123 mhz

                    }
                    else if (freq <= 999999) // 6 digits  123456  = .123456
                    {
                        freq = freq / 100000; // 123456  = .123456 
                    }
                    else if (freq <= 9999999) // 7 digits
                    {
                        freq = freq / 1000000; // 1212345 = 1.212345
                    }
                    else // 8 digits
                    {
                        freq = freq / 1000000; // 14123456 = 14.123456
                    }



                    txtVFOAFreq.Text = freq.ToString("0.######"); //.253


                } // assume anything over 65 is actually khz not mhz


            //========================================================================


            //txtVFOAFreq.Text = freq.ToString("f6");

           
            UpdateVFOAFreq(freq.ToString("f6"));

           
            FREQA = freq; // ke9ns: used in S9 determining routine (in meters)

           
            Display.VFOA = (long)(freq * 1e6); // ke9ns in hz
           
           

            //===================================================
            //ke9ns add .211 VFOB

            double freq2;

            try  // ke9ns add  the try to prevent a crash
            {
                freq2 = double.Parse(txtVFOBFreq.Text);  // ke9ns original
            }
            catch (Exception)
            {
                //  Debug.WriteLine("BAD txtVFOAFreq_LostFocus " + txtVFOAFreq.Text);

                VFOBFreq = saved_vfoa_freq;
                return;
            }
         

            // ke9ns MOD: khz freq entry here
            if ((freq2 > 99.0) && ((panelBandHFRX2.Visible == true || panelBandGNRX2.Visible == true)) && (txtVFOBFreq.Text.Contains(separator) == false) ) // "." check for khz entry instead of mhz  was 65 now 99 .240
            {
                if (freq2 <= 999) // 3 digit must be khz 700 = 700 khz
                {
                    freq2 = freq2 / 1000;     // 721 = .721 mhz

                } // 3digite
                else if (freq2 <= 9999) // 4 digits  7123 = 7.123 mhz
                {
                    freq2 = freq2 / 1000;
                }
                else if (freq2 <= 99999) // 5 digits  12345 = 12.345 mhz
                {
                    if (freq2 < 65000) freq2 = freq2 / 1000; // 30123 = 30.123 mhz
                    else freq2 = freq2 / 10000;  //65123 = 6.5123 mhz

                }
                else if (freq2 <= 999999) // 6 digits  123456  = .123456
                {
                    freq2 = freq2 / 100000; // 123456  = .123456 
                }
                else if (freq2 <= 9999999) // 7 digits
                {
                    freq2 = freq2 / 1000000; // 1212345 = 1.212345
                }
                else // 8 digits
                {
                    freq2 = freq2 / 1000000; // 14123456 = 14.123456
                }


                txtVFOBFreq.Text = freq2.ToString("0.######"); //txtVFOAFreq.Text = freq.ToString("f6",CultureInfo.CurrentCulture.NumberFormat);


            } // assume anything over 65 is actually khz not mhz

            //========================================================================
          
            //txtVFOBFreq.Text = freq.ToString("f6" );

            UpdateVFOBFreq(freq2.ToString("f6"));

            FREQB = freq2; // ke9ns used in S9 determining routine (in meters)

            Display.VFOB = (long)(freq2 * 1e6); // ke9ns in hz

            //====================================================

          

            //   Debug.WriteLine("MIDDLE LostFocus " + txtVFOAFreq.Text + " , " + saved_vfoa_freq + " , " + VFOAFreq + " , " + Display.VFOA + " , " + freq.ToString("f6" ) + " , " + FREQA);

            if (chkTUN.Checked && chkVFOATX.Checked && !chkVFOSplit.Checked)
            {
                switch (dsp.GetDSPTX(0).CurrentDSPMode)
                {
                    case DSPMode.CWL:
                    case DSPMode.LSB:
                    case DSPMode.DIGL:
                        Display.VFOA += cw_pitch;
                        break;
                    case DSPMode.CWU:
                    case DSPMode.USB:
                    case DSPMode.DIGU:
                    case DSPMode.AM:
                    case DSPMode.SAM:
                    case DSPMode.FM:
                    case DSPMode.DSB:
                        if (RX1IsOn60mChannel())
                            Display.VFOA -= (long)((ModeFreqOffset(rx1_dsp_mode) * 1e6) + cw_pitch);
                        else
                            Display.VFOA -= cw_pitch;
                        break;
                }
            }

            if (xvtrForm != null) // add .253
            {
                rx1_xvtr_index = xvtrForm.XVTRFreq(freq);

               
                if (!chkVFOSplit.Checked && !chkVFOBTX.Checked)
                    tx_xvtr_index = rx1_xvtr_index;


                if (rx1_xvtr_index < 0)  //in HF
                {
                    int old_xvtr_index = xvtrForm.XVTRFreq(saved_vfoa_freq);
                    if (old_xvtr_index >= 0 && freq >= max_freq)
                    {
                        VFOAFreq = saved_vfoa_freq;
                        return;
                    }
                }

                //VU and RX2
                if ((current_model == Model.FLEX5000 && FWCEEPROM.VUOK) &&    //VU
                    (rx1_xvtr_index != last_rx1_xvtr_index ||      //rx1 xvtr band change
                    tx_xvtr_index != last_tx_xvtr_index))           //tx xvtr band change
                {
                    if (rx1_xvtr_index == 0 && rx2_xvtr_index == 0 && rx2_enabled && !swapping)
                    {
                        MessageBox.Show(new Form { TopMost = true }, "Error: Cannot use VHF on both RX1 and RX2",
                                        "VU Error",
                                        MessageBoxButtons.OK,
                                        MessageBoxIcon.Error);
                        rx1_band = Band.VHF0;
                        VFOAFreq = saved_vfoa_freq;
                        //Give an error message, set to the last set frequency
                        return;
                    }
                    else if (rx1_xvtr_index == 1 && rx2_xvtr_index == 1 && rx2_enabled && !swapping)
                    {
                        MessageBox.Show(new Form { TopMost = true }, "Error: Cannot use UHF on both RX1 and RX2",
                                        "VU Error",
                                        MessageBoxButtons.OK,
                                        MessageBoxIcon.Error);
                        //Give an error message, set to the last set frequency
                        rx1_band = Band.VHF1;
                        VFOAFreq = saved_vfoa_freq;
                        return;
                    }
                    else if ((rx1_xvtr_index == 0 || rx1_xvtr_index == 1) &&    //VFOA is V or U
                            tx_xvtr_index >= 2 && !swapping)  //VFOB is XVTR using Split (can't use XVTR with RX2)
                    {
                        MessageBox.Show(new Form { TopMost = true }, "Error: Cannot use Split with XVTR on VFOB.  Try swapping VFOs",
                                        "VU Error",
                                        MessageBoxButtons.OK,
                                        MessageBoxIcon.Error);
                        //Give an error message, set to the last set frequency
                        //chkVFOATX.Focus();
                        //Application.DoEvents();
                        chkVFOBTX.Checked = false;
                        chkVFOATX.Checked = true;
                        //chkVFOSplit.Checked = false;
                        return;
                    }
                    else
                    {
                        if (rx1_xvtr_index == 0 || rx1_xvtr_index == 1 || last_rx1_xvtr_index == 0 || last_rx1_xvtr_index == 1)
                        {
                            switch (rx1_xvtr_index)
                            {
                                case 0:
                                    if (xvtrForm.VIFGain)
                                        RX1XVTRGainOffset = vhf_level_table[1];
                                    else
                                        RX1XVTRGainOffset = vhf_level_table[0];
                                    break;
                                case 1:
                                    if (xvtrForm.UIFGain)
                                        RX1XVTRGainOffset = uhf_level_table[1];
                                    else
                                        RX1XVTRGainOffset = uhf_level_table[0];
                                    break;
                            }
                        }

                        if (rx1_xvtr_index == 0 || rx1_xvtr_index == 1 || last_rx1_xvtr_index == 0 || last_rx1_xvtr_index == 1)
                        {
                            SetVURXPath();
                        }
                    }
                }

                //handle XVTRs
                if (last_rx1_xvtr_index != rx1_xvtr_index)
                {
                    //rx
                    if (rx1_xvtr_index >= 2)
                    {
                        switch (current_model)
                        {
                            case Model.FLEX5000:
                                FWC.SetXVTRRXOn(true);
                                FWC.SetXVTRSplit(xvtrForm.GetXVTRRF(rx1_xvtr_index));
                                break;
                            case Model.SDR1000:
                                if (chkPower.Checked)
                                    Hdw.X2 = (byte)((Hdw.X2 & 0xF0) | xvtrForm.GetXVTRAddr(rx1_xvtr_index));
                                break;
                            default:
                                break;
                        }

                        RX1XVTRGainOffset = xvtrForm.GetRXGain(rx1_xvtr_index);

                        // EW: don't need to handle RX Only on RX Side
                        /*if (last_rx1_xvtr_index == -1)
                            saved_rx_only = rx_only;

                        RXOnly = xvtrForm.GetRXOnly(rx1_xvtr_index);*/
                    }
                    else if (rx1_xvtr_index < 0) //exclude VU case
                    {
                        switch (current_model)
                        {
                            case Model.FLEX5000:
                                FWC.SetXVTRRXOn(false);
                                break;
                            case Model.SDR1000:
                                if (chkPower.Checked)
                                    Hdw.X2 = (byte)((Hdw.X2 & 0xF0) | xvtrForm.GetXVTRAddr(rx1_xvtr_index));
                                break;
                            default:
                                break;
                        }
                        RX1XVTRGainOffset = 0.0f;
                        comboPreamp_SelectedIndexChanged(this, EventArgs.Empty);
                    }
                }
                //tx
                if (last_tx_xvtr_index != tx_xvtr_index)
                {
                    if (tx_xvtr_index >= 2)
                    {
                        switch (current_model)
                        {
                            case Model.FLEX5000:
                                FWC.SetXVTRTXOn(true);
                                break;
                            case Model.SDR1000:
                                break;
                            default:
                                break;
                        }

                        if (last_tx_xvtr_index == -1) saved_rx_only = rx_only;

                        RXOnly = xvtrForm.GetRXOnly(tx_xvtr_index);
                    }
                    else if (tx_xvtr_index < 0)    //exclude VU case
                    {
                        switch (current_model)
                        {
                            case Model.FLEX5000:
                                FWC.SetXVTRTXOn(false);
                                break;
                            case Model.SDR1000:
                                break;
                            default:
                                break;
                        }

                        if (last_tx_xvtr_index >= 0)
                        {

                            RXOnly = saved_rx_only;
                        }
                    }

                }

            } // xvtrform null

           

            if (fwc_init && current_model == Model.FLEX5000 && FWCEEPROM.VUOK &&
                    (tx_xvtr_index == 0 || tx_xvtr_index == 1) && chkVFOATX.Checked)
            {
                ptbPWR_Scroll(this, EventArgs.Empty);
            }

            // update BandText Info
            string bandInfo;
            double db_freq = freq; // ke9ns in mhz  (=7.128)


            if (RX1IsOn60mChannel()) db_freq -= ModeFreqOffset(rx1_dsp_mode);

            bool transmit_allowed = DB.BandText(db_freq, out bandInfo);

            if (!transmit_allowed)
            {
                txtVFOABand.BackColor = out_of_band_color;
                //if(!chkVFOSplit.Checked && mox && !extended)
                //	chkMOX.Checked = false;
            }
            else txtVFOABand.BackColor = band_background_color;

            if (!(rx2_enabled && (chkEnableMultiRX.Checked || chkVFOSplit.Checked)))
            {
                //  Debug.WriteLine("Band text "+ db_freq);

                txtVFOABand.Text = bandInfo; // ke9ns  display bandtext into the vfo text area here
            }

            Debug.WriteLine("VFOALostFocus ");
            Band b = BandByFreq(freq, rx1_xvtr_index, false, current_region);
            Debug.WriteLine("1VFOALostFocus ");

            if (b != rx1_band)
            {
                SetRX1Band(b);
            }

            Debug.WriteLine("1VFOALostFocus ");


            // Set preamp options based on frequency - used to be in SetRX1Band()
            if (fwc_init)
            {
                switch (current_model)
                {
                    case Model.FLEX5000:
                        if (freq < 2.0)
                        {
                            if (chkRX1Preamp.Enabled) chkRX1Preamp.Enabled = false;
                            if (chkRX1Preamp.Checked) chkRX1Preamp.Checked = false;
                        }
                        else if (freq >= 28.0 && rx1_xvtr_index < 0 && !enable_6m_preamp)
                        {
                            if (chkRX1Preamp.Enabled) chkRX1Preamp.Enabled = false;
                            if (!chkRX1Preamp.Checked) chkRX1Preamp.Checked = true;
                        }
                        else if (!chkRX1Preamp.Enabled) chkRX1Preamp.Enabled = true;
                        break;
                    case Model.FLEX3000:
                        if (FWCEEPROM.TRXRev >> 8 < 6) // before rev G
                        {
                            if (freq < 2.0)
                            {
                                if (!comboPreamp.Items.Contains("Attn"))
                                    comboPreamp.Items.Insert(0, "Attn");
                                if (!comboPreamp.Items.Contains("Off"))
                                    comboPreamp.Items.Insert(1, "Off");
                                if (comboPreamp.Items.Contains("Pre1"))
                                    comboPreamp.Items.Remove("Pre1");
                                if (comboPreamp.Items.Contains("Pre2"))
                                    comboPreamp.Items.Remove("Pre2");

                                if (comboPreamp.SelectedIndex < 0 || comboPreamp.SelectedIndex > comboPreamp.Items.Count - 1)
                                    comboPreamp.SelectedIndex = 1; // Off
                            }
                            else
                            {
                                if (!comboPreamp.Items.Contains("Attn"))
                                    comboPreamp.Items.Insert(0, "Attn");
                                if (!comboPreamp.Items.Contains("Off"))
                                    comboPreamp.Items.Insert(1, "Off");
                                if (!comboPreamp.Items.Contains("Pre1"))
                                    comboPreamp.Items.Insert(2, "Pre1");
                                if (!comboPreamp.Items.Contains("Pre2"))
                                    comboPreamp.Items.Insert(3, "Pre2");

                                if (comboPreamp.SelectedIndex < 0 || comboPreamp.SelectedIndex > comboPreamp.Items.Count - 1)
                                    comboPreamp.SelectedIndex = 3; // Pre2
                            }
                        }
                        else // revs G+
                        {
                            if (freq < 7.0)
                            {
                                if (!comboPreamp.Items.Contains("Attn"))
                                    comboPreamp.Items.Insert(0, "Attn");
                                if (!comboPreamp.Items.Contains("Off"))
                                    comboPreamp.Items.Insert(1, "Off");
                                if (comboPreamp.Items.Contains("Pre1"))
                                    comboPreamp.Items.Remove("Pre1");
                                if (comboPreamp.Items.Contains("Pre2"))
                                    comboPreamp.Items.Remove("Pre2");

                                if (comboPreamp.SelectedIndex < 0 || comboPreamp.SelectedIndex > comboPreamp.Items.Count - 1)
                                    comboPreamp.SelectedIndex = 1; // Off
                            }
                            else if (freq < 13.0)
                            {
                                if (!comboPreamp.Items.Contains("Attn"))
                                    comboPreamp.Items.Insert(0, "Attn");
                                if (!comboPreamp.Items.Contains("Off"))
                                    comboPreamp.Items.Insert(1, "Off");
                                if (!comboPreamp.Items.Contains("Pre1"))
                                    comboPreamp.Items.Insert(2, "Pre1");
                                if (comboPreamp.Items.Contains("Pre2"))
                                    comboPreamp.Items.Remove("Pre2");

                                if (comboPreamp.SelectedIndex < 0 || comboPreamp.SelectedIndex > comboPreamp.Items.Count - 1)
                                    comboPreamp.SelectedIndex = 1; // Off
                            }
                            else
                            {
                                if (!comboPreamp.Items.Contains("Attn"))
                                    comboPreamp.Items.Insert(0, "Attn");
                                if (!comboPreamp.Items.Contains("Off"))
                                    comboPreamp.Items.Insert(1, "Off");
                                if (!comboPreamp.Items.Contains("Pre1"))
                                    comboPreamp.Items.Insert(2, "Pre1");
                                if (!comboPreamp.Items.Contains("Pre2"))
                                    comboPreamp.Items.Insert(3, "Pre2");

                                if (comboPreamp.SelectedIndex < 0 || comboPreamp.SelectedIndex > comboPreamp.Items.Count - 1)
                                    comboPreamp.SelectedIndex = 1; // Off
                            }
                        }
                        break;
                }
            }

            Band old_tx_band = tx_band;

            if (!chkVFOSplit.Checked && !chkVFOBTX.Checked)
            {
                Debug.WriteLine("VFOALostFocus2 ");
                b = BandByFreq(freq, tx_xvtr_index, true, current_region);

                Band b1 = b; // ke9ns add

                if ((extended) || (current_region == FRSRegion.Russia)) // ke9ns add: if you have extended capabilities then SWL bands are really ham bands
                {
                    //.248 160m :0-2.099, 80M:2.1-4.099, 60-40M 4.1-7.399, 30-20m 7.4- 14.449, 17-15M 14.450-21.549,12-10m 21.550-29.799, 6m 29.8- ? mhz

                    if (Band.BLMF == b) b1 = Band.B160M; // .47 mhz  (160m LPF ends at 2.1mhz)

                    else if (Band.B120M == b) b1 = Band.B80M; // 2-3 mhz    (80m LPF ends at 4.1mhz)
                    else if (Band.B90M == b) b1 = Band.B80M; // 3-3.5 mhz

                    else if (Band.B61M == b) b1 = Band.B60M; // 4-5.25 mhz  (60m-40m LPF ends at 7.4mhz)
                    else if (Band.B49M == b) b1 = Band.B40M; // 5.45 - 7 mhz

                    else if (Band.B41M == b) b1 = Band.B30M; // 7.3-9 mhz   (30m-20m LPF ends at 14.45mhz)
                    else if (Band.B31M == b) b1 = Band.B30M; // 9-10.1 mhz
                    else if (Band.B25M == b) b1 = Band.B30M; // 10.15-13.75 mhz
                    else if (Band.B22M == b) b1 = Band.B20M; // 13.75-14 mhz

                    else if (Band.B19M == b) b1 = Band.B17M; // 14.35-17 mhz  (17m-15m LPF ends at 21.55mhz)
                    else if (Band.B16M == b) b1 = Band.B17M; // 17-18 mhz
                    else if (Band.B14M == b) b1 = Band.B15M; // 18-21.5 mhz

                    else if (Band.B13M == b) b1 = Band.B12M; // 21-25 mhz   (12-10m LPF ends at 29.8mhz)
                    else if (Band.B11M == b) b1 = Band.B10M; // 25-28 mhz
                }

                if (b1 != tx_band) // ke9ns: HIGH-LOW  since there are now calibrations outside of ham bands and I addes SWL bands, I need to route TX into existing ham bands
                {
                    SetTXBand(b1); // ke9ns mod: b1

                }
            }

            if (chkPower.Checked && ext_ctrl_enabled) UpdateExtCtrl();

            if (tx_band != old_tx_band)
            {
                if (tx_band == Band.B60M && RX1IsOn60mChannel())
                {
                    chkXIT.Enabled = false;
                    chkXIT.Checked = false;
                }
                else
                    chkXIT.Enabled = true;
            }

            saved_vfoa_freq = freq;

            if (rx1_xvtr_index >= 0)
                freq = xvtrForm.TranslateFreq(freq);
            else
            {
                if (freq < min_freq)
                {
                    freq = min_freq;
                    UpdateVFOAFreq(freq.ToString("f6"));
                }
                else if (freq > max_freq)
                {
                    freq = max_freq;
                    UpdateVFOAFreq(freq.ToString("f6"));
                }
            }

            if (fwc_init && (current_model == Model.FLEX5000 || current_model == Model.FLEX3000) ||
                hid_init && current_model == Model.FLEX1500)
            {
                double rx_freq = freq;
                double tx_freq = freq;

                if (chkRIT.Checked)
                    rx_freq += (int)udRIT.Value * 0.000001;

                if (rx_freq < min_freq) rx_freq = min_freq;
                else if (rx_freq > max_freq) rx_freq = max_freq;

                if (chkXIT.Checked)
                    tx_freq += (int)udXIT.Value * 0.000001;

                if (tx_freq < min_freq) tx_freq = min_freq;
                else if (tx_freq > max_freq) tx_freq = max_freq;

                if (mox && !chkVFOSplit.Checked && !full_duplex && !chkVFOBTX.Checked && !calibrating)
                {
                    if (!CheckValidTXFreq(current_region, tx_freq, dsp.GetDSPTX(0).CurrentDSPMode))
                    {
                        switch (dsp.GetDSPTX(0).CurrentDSPMode)
                        {
                            case DSPMode.CWL:
                            case DSPMode.CWU:
                                MessageBox.Show(new Form { TopMost = true }, "The frequency " + tx_freq.ToString("f6") + "MHz is not within the\n" +
                                    "Band specifications for your country (" + ((int)current_region).ToString() + ").",
                                    "Transmit Error: Out Of Band",
                                    MessageBoxButtons.OK,
                                    MessageBoxIcon.Error);
                                break;
                            default:
                                MessageBox.Show(new Form { TopMost = true }, "The frequency " + tx_freq.ToString("f6") + "MHz in combination with your TX filter\n" +
                                    "settings [" + Display.TXFilterLow.ToString() + ", " + Display.TXFilterHigh.ToString() + "] are not within the " +
                                    "Band specifications for your country (" + ((int)current_region).ToString() + ").",
                                    "Transmit Error: Out Of Band",
                                    MessageBoxButtons.OK,
                                    MessageBoxIcon.Error);
                                break;
                        }
                        if (chkTUN.Checked)
                            chkTUN.Checked = false;

                        chkMOX.Checked = false;
                        return;
                    }
                }


                if (rx1_dsp_mode == DSPMode.CWL)
                {
                    rx_freq += (double)cw_pitch * 0.0000010;
                    tx_freq += (double)cw_pitch * 0.0000010;
                }
                else if (rx1_dsp_mode == DSPMode.CWU)
                {
                    rx_freq -= (double)cw_pitch * 0.0000010;
                    tx_freq -= (double)cw_pitch * 0.0000010;
                }



                switch (RX1DSPMode)
                {
                    case DSPMode.AM:
                    case DSPMode.SAM:
                    case DSPMode.FM:
                        tx_freq -= 0.011025;
                        if (chkTUN.Checked) tx_freq -= cw_pitch * 1e-6;
                        break;
                    case DSPMode.USB:
                    case DSPMode.DIGU:
                    case DSPMode.DSB:
                        if (chkTUN.Checked)
                        {
                            if (RX1IsOn60mChannel())
                                tx_freq -= (ModeFreqOffset(rx1_dsp_mode) + cw_pitch * 1e-6);
                            else
                                tx_freq -= cw_pitch * 1e-6;
                        }
                        break;
                    case DSPMode.LSB:
                    case DSPMode.DIGL:
                        if (chkTUN.Checked) tx_freq += cw_pitch * 1e-6;
                        break;
                }

                if (rx_freq < min_freq) rx_freq = min_freq;
                else if (rx_freq > max_freq) rx_freq = max_freq;
                if (tx_freq < min_freq) tx_freq = min_freq;
                else if (tx_freq > max_freq) tx_freq = max_freq;



                if (chkPower.Checked)
                {

                    //----------------------------------------------------------------------------------
                    // ke9ns    play audio file
                    //----------------------------------------------------------------------------------
                    if (Audio.wave_playback) // this is true if playing back audio file
                    {
                        double f = (wave_freq - (VFOAFreq * 1e6) % sample_rate1);

                        //  Debug.WriteLine("f "+f);  // ke9ns test

                        if (f > sample_rate1 / 2) f -= sample_rate1;

                        if (f < -sample_rate1 / 2) f += sample_rate1;

                        dsp.GetDSPRX(0, 0).RXOsc = f;
                    }
                    else
                    {
                        switch (current_model) // SET RX FREQ HERE
                        {
                            case Model.FLEX5000:
                            case Model.FLEX3000:

                                //  if (setupForm != null && setupForm.chkAvgMove.Checked)
                                FWCDDSFreq = rx_freq;


                                break;
                            case Model.FLEX1500:
                                if (!mox)
                                    FWCDDSFreq = rx_freq;
                                break;
                        }

                        if (!chkVFOSplit.Checked && !chkFullDuplex.Checked && !rx1_spectrum_drag && !chkVFOBTX.Checked)
                        {
                            switch (current_model)
                            {
                                case Model.FLEX3000:
                                case Model.FLEX5000:
                                    uint tw = (uint)Freq2TW(tx_freq);
                                    //FWC.SetTXFreqTW(tw, (float)tx_freq); // ke9ns: using a thread instead of this
                                    tx_dds_freq_tw = tw;
                                    tx_dds_freq_mhz = (float)tx_freq;
                                    tx_dds_freq_updated = true;
                                    break;
                                case Model.FLEX1500:
                                    if (mox)
                                    {
                                        tw = (uint)Freq2TW(tx_freq);
                                        rx1_dds_freq_tw = tw;
                                        rx1_dds_freq_mhz = (float)tx_freq;
                                        rx1_dds_freq_updated = true;
                                    }
                                    break;
                            }
                        }

                        if (chkEnableMultiRX.Checked)
                        {
                            int diff;
                            if (rx2_enabled) diff = (int)((VFOASubFreq - VFOAFreq) * 1e6);
                            else diff = (int)((VFOBFreq - VFOAFreq) * 1e6);

                            if (chkRIT.Checked && !mox) diff -= (int)udRIT.Value;

                            int rx2_osc = (int)(dsp.GetDSPRX(0, 0).RXOsc - diff);

                            if (rx2_osc > -sample_rate1 / 2 && rx2_osc < sample_rate1 / 2)
                            {
                                dsp.GetDSPRX(0, 1).RXOsc = rx2_osc;
                            }
                            else if (chkEnableMultiRX.Checked) chkEnableMultiRX.Checked = false;
                        }

                    }
                }
            }
            else // ke9ns: SDR-1000 below
            {
                if (chkRIT.Checked && !mox) freq += (int)udRIT.Value * 0.000001;
                else if (chkXIT.Checked && mox && !chkVFOSplit.Checked && !chkVFOBTX.Checked) freq += (int)udXIT.Value * 0.000001;

                if (freq < min_freq) freq = min_freq;
                else if (freq > max_freq) freq = max_freq;

                if (mox && !chkVFOSplit.Checked && !chkVFOBTX.Checked)
                {
                    if (!CheckValidTXFreq(current_region, freq, dsp.GetDSPTX(0).CurrentDSPMode))
                    {
                        switch (dsp.GetDSPTX(0).CurrentDSPMode)
                        {
                            case DSPMode.CWL:
                            case DSPMode.CWU:
                                MessageBox.Show(new Form { TopMost = true }, "The frequency " + freq.ToString("f6") + "MHz is not within the\n" +
                                    "Band specifications for your country (" + ((int)current_region).ToString() + ").",
                                    "Transmit Error: Out Of Band",
                                    MessageBoxButtons.OK,
                                    MessageBoxIcon.Error);
                                break;
                            default:
                                MessageBox.Show(new Form { TopMost = true }, "The frequency " + freq.ToString("f6") + "MHz in combination with your TX filter\n" +
                                    "settings [" + Display.TXFilterLow.ToString() + ", " + Display.TXFilterHigh.ToString() + "] are not within the " +
                                    "Band specifications for your country (" + ((int)current_region).ToString() + ").",
                                    "Transmit Error: Out Of Band",
                                    MessageBoxButtons.OK,
                                    MessageBoxIcon.Error);
                                break;
                        }
                        chkMOX.Checked = false;
                        return;
                    }
                }


                if (rx1_dsp_mode == DSPMode.CWL)
                    freq += (double)cw_pitch * 0.0000010;
                else if (rx1_dsp_mode == DSPMode.CWU)
                    freq -= (double)cw_pitch * 0.0000010;


                switch (RX1DSPMode)
                {
                    case DSPMode.AM:
                    case DSPMode.SAM:
                    case DSPMode.FM:
                        if (mox) freq -= 0.011025;
                        break;
                    case DSPMode.USB:
                    case DSPMode.DIGU:
                        if (chkTUN.Checked) freq -= cw_pitch * 1e-6;
                        break;
                    case DSPMode.LSB:
                    case DSPMode.DIGL:
                        if (chkTUN.Checked) freq += cw_pitch * 1e-6;
                        break;
                }

                if (freq < min_freq) freq = min_freq;
                else if (freq > max_freq) freq = max_freq;

                if (chkPower.Checked)
                {
                    switch (current_model)
                    {
                        case Model.SDR1000:
                        case Model.DEMO:
                            if (Audio.wave_playback)
                            {
                                double f = (wave_freq - (VFOAFreq * 1e6) % sample_rate1);
                                if (f > sample_rate1 / 2) f -= sample_rate1;
                                if (f < -sample_rate1 / 2) f += sample_rate1;
                                dsp.GetDSPRX(0, 0).RXOsc = f;
                            }
                            else
                            {
                                if (!mox || (mox && !chkVFOSplit.Checked && !chkVFOBTX.Checked))
                                {
                                    DDSFreq = freq;

                                    if (chkEnableMultiRX.Checked)
                                    {
                                        int diff = (int)((VFOBFreq - VFOAFreq) * 1e6);
                                        if (chkRIT.Checked && !mox) diff -= (int)udRIT.Value;
                                        int rx2_osc = (int)(dsp.GetDSPRX(0, 0).RXOsc - diff);
                                        if (rx2_osc > -sample_rate1 / 2 && rx2_osc < sample_rate1 / 2)
                                        {
                                            dsp.GetDSPRX(0, 1).RXOsc = rx2_osc;
                                        }
                                        else chkEnableMultiRX.Checked = false;
                                    }
                                }
                            }
                            break;
                            /*	case Model.SOFTROCK40:
                                    //!!!!drm patch
                                    double osc_freq = soft_rock_center_freq*1e6 - freq*1e6;
                                    if ( rx1_dsp_mode  == DSPMode.DRM ) // if we're in DRM mode we need to be offset 12khz
                                    {
                                        osc_freq = osc_freq + 12000; 
                                        // System.Console.WriteLine("setting osc_freq: " + osc_freq); 
                                    }
                                    tuned_freq = freq;
                                    //Debug.WriteLine("osc_freq: "+osc_freq.ToString("f6" ));
                                    dsp.GetDSPRX(0, 0).RXOsc = osc_freq;
                                    break; */
                    }
                }
            }

            if (chkVFOSync.Checked && txtVFOBFreq.Text != txtVFOAFreq.Text)
            {
                txtVFOBFreq.Text = txtVFOAFreq.Text;
                txtVFOBFreq_LostFocus(this, EventArgs.Empty);
            }



            if (Display.PeakOn) Display.ResetRX1DisplayPeak();

            last_rx1_xvtr_index = rx1_xvtr_index;
            last_tx_xvtr_index = tx_xvtr_index;

            UpdateRX1Notches();


        } // txtVFOAFreq_LostFocus

        //================================================================



        //  private static double tuned_freq;
        private void txtVFOAFreq_KeyPress(object sender, System.Windows.Forms.KeyPressEventArgs e)
        {


            string separator = System.Globalization.CultureInfo.CurrentCulture.NumberFormat.NumberDecimalSeparator;

            int KeyCode = (int)e.KeyChar;

            if ((KeyCode < 48 || KeyCode > 57) &&           // numeric keys
                (KeyCode != 8) &&                               // backspace
                (!e.KeyChar.ToString().Equals(separator)) &&    // decimal
                (KeyCode != 27))                                // escape
            {
                e.Handled = true;  // you come here because your not valid
            }
            else // valid keys
            {
                if (e.KeyChar.ToString().Equals(separator))
                {
                    e.Handled = (((TextBoxTS)sender).Text.IndexOf(separator) >= 0);
                }
                else if (KeyCode == 27) // esc key
                {
                    VFOAFreq = saved_vfoa_freq;
                    btnHidden.Focus();
                }
            }
            if (e.KeyChar == (char)Keys.Enter)  // enter key
            {


                txtVFOAFreq_LostFocus(txtVFOAFreq, new System.EventArgs()); // udpate freq 


                btnHidden.Focus(); // just need to move focus off of freq onto something hidden
            }

        } // txtVFOAFreq_KeyPress



        //=============================================================================================================
        // ke9ns:  digit_index = 0123.456 789  digit position within the VFO readout) _01234.567 89A
        // 432.000000 = 123.456789
        private void txtVFOAFreq_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
        {
            if (this.ContainsFocus)
            {
                int old_digit = vfoa_hover_digit;

                int digit_index = 0;

                if (vfo_char_width == 0) GetVFOCharWidth();

                int x = txtVFOAFreq.Width - (vfo_pixel_offset - 10); // ke9ns mod: was -5 (this is the area which the mouse selects the digit
                                                                     // txtVFOAHover_Paint draws the under line
                                                                     // txtVFOAFreq.Width = 253pixel, vfo_pixel_offset =249 x= 14



                //    Debug.WriteLine("==WIDTH: " + txtVFOAFreq.Width + " , pixeloffset: " + vfo_pixel_offset + " , X:"+x);

                while (x < e.X) // ke9ns: while mouse is to the right side of (width of the box - width of the text )  pixel offset is the size in pixels of 9999.999999 in the font your currently using
                {

                    digit_index++; // ke9ns: x steps 24pixels per digit


                    if (small_lsd && txtVFOALSD.Visible)
                    {
                        if (digit_index < 6) //  6 ke9ns: if selecting 10khz or higher
                        {
                            x += (vfo_char_width + vfo_char_space); //ke9ns: LARGE FONT: x = x + char pixels + spacebetween pixels
                        }
                        else
                        {
                            x += (vfo_small_char_width + vfo_small_char_space); //ke9ns: SMALL FONT: x = x + small char pixels + small spacebetween pixels

                        }

                        if (digit_index == 3) // 3 this is the seperator 
                        {
                            x += (vfo_decimal_space - vfo_char_space); //ke9ns: LARGE FONT: x = x + decimal pixel size + char pixel size

                        }

                        if (digit_index == 6) // 6
                        {
                            x += vfo_small_char_width; //ke9ns: SMALL FONT: x = x + small char pixel size
                        }
                    }
                    else // only large digits below
                    {
                        x += vfo_char_width;         //ke9ns: LARGE FONT: x = x + char pixel size

                        if (digit_index == 3) // 3
                        {
                            x += vfo_decimal_space;   // ke9ns:LARGE FONT: x = x + decimal point pixel size
                        }
                        else
                        {
                            x += vfo_char_space;      // ke9ns:LARGE FONT: x = x + spacebetween pixels
                        }
                    }

                } // while



                if (digit_index < 3) // ke9ns: do not allow cursor digit select beyond xx.xxxxxx (up to 6m and thats it)
                {
                    digit_index = -1;  // -1
                }

                if (digit_index > 9) // ke9ns: only out to xx.xxxxxx (1 hz range)
                {
                    digit_index = 9;   // 9
                }

                vfoa_hover_digit = digit_index; // used by console_mousewheel

                if (vfoa_hover_digit != old_digit) panelVFOAHover.Invalidate(); // if you moved cursor redraw VFO

            } // if(this.ContainsFocus)

        } // txtVFOAFreq_MouseMove

        private void txtVFOAFreq_MouseLeave(object sender, System.EventArgs e)
        {
            vfoa_hover_digit = -1;
            panelVFOAHover.Invalidate();
        }

        private void txtVFOABand_LostFocus(object sender, System.EventArgs e)
        {


            if (!rx2_enabled || (!chkEnableMultiRX.Checked && !chkVFOSplit.Checked)) return;

            if (txtVFOABand.Text == separator || txtVFOABand.Text == "") // "."
            {
                VFOASubFreq = VFOAFreq;
                return;
            }

            double freq = VFOASubFreq;
            double vfoa = VFOAFreq;

            txtVFOABand.Text = freq.ToString("f6");
            Display.VFOASub = (long)(freq * 1e6); // ke9ns convert 14.123456 mhz to 14123456 hz
            if (chkTUN.Checked && chkVFOATX.Checked && chkVFOSplit.Checked)
            {
                switch (dsp.GetDSPTX(0).CurrentDSPMode)
                {
                    case DSPMode.CWL:
                    case DSPMode.LSB:
                    case DSPMode.DIGL:
                        Display.VFOASub += cw_pitch;
                        break;
                    case DSPMode.CWU:
                    case DSPMode.USB:
                    case DSPMode.DIGU:
                    case DSPMode.AM:
                    case DSPMode.SAM:
                    case DSPMode.FM:
                    case DSPMode.DSB:
                        Display.VFOASub -= cw_pitch;
                        break;
                }
            }
            saved_vfoa_sub_freq = freq;

            string bandInfo;
            bool transmit_allowed = DB.BandText(freq, out bandInfo);
            if (!CheckValidTXFreq(current_region, freq, dsp.GetDSPTX(0).CurrentDSPMode))
            {
                if (chkVFOSplit.Checked && mox && !extended) chkMOX.Checked = false;
            }

            if (chkEnableMultiRX.Checked)
            {
                int diff = (int)((freq - vfoa) * 1e6);
                double sub_osc = dsp.GetDSPRX(0, 0).RXOsc - diff;

                if (sub_osc < -sample_rate1 / 2)
                {
                    VFOASubFreq = vfoa + (sample_rate1 / 2 + dsp.GetDSPRX(0, 0).RXOsc - 1) * 1e-6;
                    return;
                }
                else if (sub_osc > sample_rate1 / 2)
                {
                    VFOASubFreq = vfoa + (-sample_rate1 / 2 + dsp.GetDSPRX(0, 0).RXOsc + 1) * 1e-6;
                    return;
                }

                if (sub_osc > -sample_rate1 / 2 && sub_osc < sample_rate1 / 2)
                {
                    dsp.GetDSPRX(0, 1).RXOsc = sub_osc;
                }

                UpdateRX1SubNotches();
            }

            if (chkVFOSplit.Checked)
            {
                tx_xvtr_index = xvtrForm.XVTRFreq(freq);

                Band old_tx_band = tx_band;

                Band b = BandByFreq(freq, tx_xvtr_index, true, current_region);

                Band b1 = b; // ke9ns add
                if ((extended) || (current_region == FRSRegion.Russia)) // ke9ns add if you have extended capabilities then SWL bands are really ham bands
                {
                    //.248 160m :0-2.099, 80M:2.1-4.099, 60-40M 4.1-7.399, 30-20m 7.4- 14.449, 17-15M 14.450-21.549,12-10m 21.550-29.799, 6m 29.8- ? mhz

                    if (Band.BLMF == b) b1 = Band.B160M; // .47 mhz  (160m LPF ends at 2.1mhz)

                    else if (Band.B120M == b) b1 = Band.B80M; // 2-3 mhz    (80m LPF ends at 4.1mhz)
                    else if (Band.B90M == b) b1 = Band.B80M; // 3-3.5 mhz

                    else if (Band.B61M == b) b1 = Band.B60M; // 4-5.25 mhz  (60m-40m LPF ends at 7.4mhz)
                    else if (Band.B49M == b) b1 = Band.B40M; // 5.45 - 7 mhz

                    else if (Band.B41M == b) b1 = Band.B30M; // 7.3-9 mhz   (30m-20m LPF ends at 14.45mhz)
                    else if (Band.B31M == b) b1 = Band.B30M; // 9-10.1 mhz
                    else if (Band.B25M == b) b1 = Band.B30M; // 10.15-13.75 mhz
                    else if (Band.B22M == b) b1 = Band.B20M; // 13.75-14 mhz

                    else if (Band.B19M == b) b1 = Band.B17M; // 14.35-17 mhz  (17m-15m LPF ends at 21.55mhz)
                    else if (Band.B16M == b) b1 = Band.B17M; // 17-18 mhz
                    else if (Band.B14M == b) b1 = Band.B15M; // 18-21.5 mhz

                    else if (Band.B13M == b) b1 = Band.B12M; // 21-25 mhz   (12-10m LPF ends at 29.8mhz)
                    else if (Band.B11M == b) b1 = Band.B10M; // 25-28 mhz
                }

                if (chkVFOSplit.Checked && old_tx_band != b1)
                {
                    SetTXBand(b1); // ke9ns mod b1

                }

                if (fwc_init && current_model == Model.FLEX5000 && FWCEEPROM.VUOK &&
                (tx_xvtr_index == 0 || tx_xvtr_index == 1))
                    ptbPWR_Scroll(this, EventArgs.Empty);

                //tx
                if (last_tx_xvtr_index != tx_xvtr_index)
                {
                    if (tx_xvtr_index >= 2)
                    {
                        switch (current_model)
                        {
                            case Model.FLEX5000:
                                FWC.SetXVTRTXOn(true);
                                break;
                            case Model.SDR1000:
                                break;
                            default:
                                break;
                        }
                        setupForm.RXOnly = xvtrForm.GetRXOnly(tx_xvtr_index);
                    }
                    else if (tx_xvtr_index < 0)    //exclude VU case
                    {
                        switch (current_model)
                        {
                            case Model.FLEX5000:
                                FWC.SetXVTRTXOn(false);
                                break;
                            case Model.SDR1000:
                                break;
                            default:
                                break;
                        }
                    }

                }

                if (tx_xvtr_index >= 0)
                    freq = xvtrForm.TranslateFreq(freq);

                if (old_tx_band != tx_band)
                {
                    if (tx_band == Band.B60M && RX1IsOn60mChannel())
                    {
                        chkXIT.Enabled = false;
                        chkXIT.Checked = false;
                    }
                    else
                        chkXIT.Enabled = true;
                }

                if (chkXIT.Checked)
                    freq += (int)udXIT.Value * 0.000001;

                if (freq < min_freq) freq = min_freq;
                else if (freq > max_freq) freq = max_freq;

                switch (dsp.GetDSPTX(0).CurrentDSPMode)
                {
                    case DSPMode.AM:
                    case DSPMode.SAM:
                    case DSPMode.FM:
                        freq -= 0.011025;
                        if (chkTUN.Checked) freq -= (double)cw_pitch * 1e-6;
                        break;
                    case DSPMode.USB:
                    case DSPMode.DIGU:
                    case DSPMode.DSB:
                        if (chkTUN.Checked) freq -= (double)cw_pitch * 1e-6;
                        break;
                    case DSPMode.LSB:
                    case DSPMode.DIGL:
                        if (chkTUN.Checked) freq += (double)cw_pitch * 1e-6;
                        break;
                    case DSPMode.CWL:
                        freq += (double)cw_pitch * 0.0000010;
                        break;
                    case DSPMode.CWU:
                        freq -= (double)cw_pitch * 0.0000010;
                        break;
                }

                //Debug.WriteLine("freq: "+freq.ToString("f6" ));
                if (!rx1_sub_drag)
                {
                    uint tw = (uint)Freq2TW(freq);
                    //FWC.SetTXFreqTW(tw, (float)freq);
                    tx_dds_freq_tw = tw;
                    tx_dds_freq_mhz = (float)freq;
                    tx_dds_freq_updated = true;
                }
                last_tx_xvtr_index = tx_xvtr_index;
            } // split

        } // txtvfoaband_lostfocus



        //=======================================================================================================
        private void txtVFOABand_KeyPress(object sender, System.Windows.Forms.KeyPressEventArgs e)
        {
            if (!rx2_enabled || (!chkEnableMultiRX.Checked && !chkVFOSplit.Checked))
            {
                e.Handled = true;
                return;              // return if you dont need the subVFOa 
            }

            string separator = System.Globalization.CultureInfo.CurrentCulture.NumberFormat.NumberDecimalSeparator;

            int KeyCode = (int)e.KeyChar;

            if ((KeyCode < 48 || KeyCode > 57) &&           // numeric keys
                KeyCode != 8 &&                             // backspace
                !e.KeyChar.ToString().Equals(separator) &&  // decimal
                KeyCode != 27)                              // escape
            {
                e.Handled = true;
            }
            else
            {
                if (e.KeyChar.ToString().Equals(separator))
                {
                    e.Handled = (((TextBoxTS)sender).Text.IndexOf(separator) >= 0);
                }
                else if (KeyCode == 27) // esc key
                {
                    VFOASubFreq = saved_vfoa_sub_freq; // used previously saved value
                    btnHidden.Focus();
                }
            }


            if (e.KeyChar == (char)Keys.Enter) // check for enter key
            {
                txtVFOABand_LostFocus(txtVFOABand, new System.EventArgs());
                btnHidden.Focus();
            }


        } // txtVFOABand_KeyPress

        //================================================================================ 
        //================================================================================ 
        //================================================================================ 
        // ke9ns mod: VFOB to allow khz freq(when in HF band) entry as well as standard mhz entry 
        //================================================================================ 
        //================================================================================ 
        //================================================================================   
        private void txtVFOBFreq_LostFocus(object sender, System.EventArgs e)
        {
            //  double freq = double.Parse(txtVFOAFreq.Text.Replace(",",".")); // ke9ns mod

            if (txtVFOBFreq.Text == "" || txtVFOBFreq.Text == separator) // "."
            {
                VFOBFreq = saved_vfob_freq;
                return;
            }


            //double freq = double.Parse(txtVFOBFreq.Text); // original

            double freq;

            try  // ke9ns add  the try to prevent a crash
            {
                freq = double.Parse(txtVFOBFreq.Text);  // ke9ns original
            }
            catch (Exception)
            {
                VFOBFreq = saved_vfob_freq;
                return;
            }


            // ke9ns mod khz
            if ((freq > 99.0) && (comboRX2Band.Text.StartsWith("V") == false) && (txtVFOBFreq.Text.Contains(separator) == false) ) // "." check for khz entry instead of mhz
            // check for khz entry instead of mhz
            {
                if (freq <= 999) // 3 digit must be khz 700 = 700 khz
                {
                    freq = freq / 1000;     // 721 = .721 mhz

                } // 3digite
                else if (freq <= 9999) // 4 digits  7123 = 7.123 mhz
                {
                    freq = freq / 1000;
                }
                else if (freq <= 99999) // 5 digits  12345 = 12.345 mhz
                {
                    if (freq < 65000) freq = freq / 1000; // 30123 = 30.123 mhz
                    else freq = freq / 10000;  //65123 = 6.5123 mhz

                }
                else if (freq <= 999999) // 6 digits  123456  = .123456
                {

                    freq = freq / 100000; // 123456  = .123456 

                }
                else if (freq <= 9999999) // 7 digits
                {
                    freq = freq / 1000000; // 1212345 = 1.212345
                }
                else // 8 digits
                {
                    freq = freq / 1000000; // 14123456 = 14.123456
                }

                txtVFOBFreq.Text = freq.ToString("0.######");

                Display.VFOB = (long)(freq * 1e6); // ke9ns in hz


            } // ke9ns


            //===============================

            if (chkEnableMultiRX.Checked && !rx2_enabled)  // check if multiRX1 or RX2 turned on here
            {
                int diff = (int)((VFOBFreq - VFOAFreq) * 1e6);
                double rx2_osc = dsp.GetDSPRX(0, 0).RXOsc - diff;

                if (rx2_osc < -sample_rate1 / 2)
                {
                    VFOBFreq = VFOAFreq + (sample_rate1 / 2 + dsp.GetDSPRX(0, 0).RXOsc - 1) * 1e-6;
                    return;
                }
                else if (rx2_osc > sample_rate1 / 2)
                {
                    VFOBFreq = VFOAFreq + (-sample_rate1 / 2 + dsp.GetDSPRX(0, 0).RXOsc + 1) * 1e-6;
                    return;
                }

                if (rx2_osc > -sample_rate1 / 2 && rx2_osc < sample_rate1 / 2)
                {
                    dsp.GetDSPRX(0, 1).RXOsc = rx2_osc;
                }

                UpdateRX1SubNotches();

            } // chkEnableMultiRX.Checked && !rx2_enabled

            //=================================================================
            //txtVFOBFreq.Text = freq.ToString("f6" ); 
            UpdateVFOBFreq(freq.ToString("f6"));

            FREQB = freq; // ke9ns: used in S9 determining routine (in meters)

            Display.VFOB = (long)(freq * 1e6); // ke9ns in hz

            Debug.WriteLine("5VFOALostFocus ");
            Band b2 = BandByFreq(freq, rx2_xvtr_index, false, current_region); // .209

            if (b2 != rx2_band) // ke9ns add .209
            {
                SetRX2Band(b2);
            }

            if (rx2_enabled)
            {
                Display.VFOB = (long)(freq * 1e6);

                if (chkTUN.Checked && chkVFOBTX.Checked)
                {
                    switch (dsp.GetDSPTX(0).CurrentDSPMode)
                    {
                        case DSPMode.CWL:
                        case DSPMode.LSB:
                        case DSPMode.DIGL:
                            Display.VFOB += cw_pitch;
                            break;
                        case DSPMode.CWU:
                        case DSPMode.USB:
                        case DSPMode.DIGU:
                        case DSPMode.AM:
                        case DSPMode.SAM:
                        case DSPMode.FM:
                        case DSPMode.DSB:
                            Display.VFOB -= cw_pitch;
                            break;
                    }
                }
            } //rx2_enabled
            else
            {
                Display.VFOASub = (long)(freq * 1e6);
                if (chkTUN.Checked && chkVFOBTX.Checked)
                {
                    switch (dsp.GetDSPTX(0).CurrentDSPMode)
                    {
                        case DSPMode.CWL:
                        case DSPMode.LSB:
                        case DSPMode.DIGL:
                            Display.VFOASub += cw_pitch;
                            break;
                        case DSPMode.CWU:
                        case DSPMode.USB:
                        case DSPMode.DIGU:
                        case DSPMode.AM:
                        case DSPMode.SAM:
                        case DSPMode.FM:
                        case DSPMode.DSB:
                            Display.VFOASub -= cw_pitch;
                            break;
                    }
                }
            } //rx2_enabled NOT

            int xvtr_index = 0;

            if (xvtrForm != null) //.253
            {
               xvtr_index = xvtrForm.XVTRFreq(freq);

                if (xvtr_index < 0) // ke9ns if no freq was found
                {
                    int old_xvtr_index = xvtrForm.XVTRFreq(saved_vfob_freq);
                    if (old_xvtr_index >= 0 && freq >= max_freq)
                    {
                        VFOBFreq = saved_vfob_freq;
                        return;
                    }
                }
            }
            // update Band Info
            string bandInfo;
            double db_freq = freq;
            if (fwc_init && current_model == Model.FLEX5000 && FWCEEPROM.RX2OK && RX1IsOn60mChannel())
                db_freq -= ModeFreqOffset(rx2_dsp_mode);
            else if (RX1IsOn60mChannel())
                db_freq -= ModeFreqOffset(rx1_dsp_mode);

            bool transmit = DB.BandText(db_freq, out bandInfo);

            if (transmit == false)
            {
                txtVFOBBand.BackColor = Color.DimGray;
                //if(chkVFOSplit.Checked && mox)
                //	chkMOX.Checked = false;
            }
            else txtVFOBBand.BackColor = band_background_color;

            txtVFOBBand.Text = bandInfo;

            saved_vfob_freq = freq;

            if ((fwc_init && (current_model == Model.FLEX5000 || current_model == Model.FLEX3000)) ||
                (hid_init && current_model == Model.FLEX1500))
            {
                if (chkVFOBTX.Checked) goto set_tx_freq;
                if (FWCEEPROM.RX2OK && rx2_enabled) goto set_rx2_freq;
                else if (chkVFOSplit.Checked || full_duplex)
                    goto set_tx_freq;
                else goto end;
            }
            else if (mox && chkVFOSplit.Checked)
                goto set_tx_freq;
            else goto end;

            set_tx_freq:
            //int old_tx_xvtr_index = tx_xvtr_index;
            tx_xvtr_index = xvtr_index;

            //if (old_tx_xvtr_index != tx_xvtr_index)
            //    last_tx_xvtr_index = old_tx_xvtr_index;

            if (fwc_init && current_model == Model.FLEX5000 && FWCEEPROM.VUOK &&
                tx_xvtr_index != last_tx_xvtr_index &&
                (tx_xvtr_index == 0 || tx_xvtr_index == 1))
                ptbPWR_Scroll(this, EventArgs.Empty);

            double tx_freq = freq;
            Band old_tx_band = tx_band;
            Debug.WriteLine("6VFOALostFocus ");
            Band b = BandByFreq(tx_freq, tx_xvtr_index, true, current_region);


            Band b1 = b; // ke9ns add
            if (extended) // ke9ns add if you have extended capabilities then SWL bands are really ham bands
            {
                //.248 160m :0-2.099, 80M:2.1-4.099, 60-40M 4.1-7.399, 30-20m 7.4- 14.449, 17-15M 14.450-21.549,12-10m 21.550-29.799, 6m 29.8- ? mhz

                if (Band.BLMF == b) b1 = Band.B160M; // .47 mhz  (160m LPF ends at 2.1mhz)

                else if (Band.B120M == b) b1 = Band.B80M; // 2-3 mhz    (80m LPF ends at 4.1mhz)
                else if (Band.B90M == b) b1 = Band.B80M; // 3-3.5 mhz

                else if (Band.B61M == b) b1 = Band.B60M; // 4-5.25 mhz  (60m-40m LPF ends at 7.4mhz)
                else if (Band.B49M == b) b1 = Band.B40M; // 5.45 - 7 mhz

                else if (Band.B41M == b) b1 = Band.B30M; // 7.3-9 mhz   (30m-20m LPF ends at 14.45mhz)
                else if (Band.B31M == b) b1 = Band.B30M; // 9-10.1 mhz
                else if (Band.B25M == b) b1 = Band.B30M; // 10.15-13.75 mhz
                else if (Band.B22M == b) b1 = Band.B20M; // 13.75-14 mhz

                else if (Band.B19M == b) b1 = Band.B17M; // 14.35-17 mhz  (17m-15m LPF ends at 21.55mhz)
                else if (Band.B16M == b) b1 = Band.B17M; // 17-18 mhz
                else if (Band.B14M == b) b1 = Band.B15M; // 18-21.5 mhz

                else if (Band.B13M == b) b1 = Band.B12M; // 21-25 mhz   (12-10m LPF ends at 29.8mhz)
                else if (Band.B11M == b) b1 = Band.B10M; // 25-28 mhz
            }
            if (old_tx_band != b1)
            {
                SetTXBand(b1); // ke9ns mod b1


            }

            if (xvtrForm != null)
            {
                if (tx_xvtr_index >= 0)
                    tx_freq = xvtrForm.TranslateFreq(tx_freq);

                if (ext_ctrl_enabled)
                    UpdateExtCtrl();

                //tx
                if (last_tx_xvtr_index != tx_xvtr_index)
                {
                    if (tx_xvtr_index >= 2)
                    {
                        switch (current_model)
                        {
                            case Model.FLEX5000:
                                FWC.SetXVTRTXOn(true);
                                break;
                        }

                        if (last_tx_xvtr_index == -1)
                            saved_rx_only = rx_only;

                        RXOnly = xvtrForm.GetRXOnly(tx_xvtr_index);
                    }
                    else if (tx_xvtr_index < 0) //exclude VU case
                    {
                        switch (current_model)
                        {
                            case Model.FLEX5000:
                                FWC.SetXVTRTXOn(false);
                                break;
                        }

                        if (last_tx_xvtr_index >= 0)
                        {

                            RXOnly = saved_rx_only;
                        }
                    }
                }

                if (tx_xvtr_index >= 0 && tx_xvtr_index != last_tx_xvtr_index)
                {
                    if ((current_model == Model.FLEX5000 && FWCEEPROM.VUOK) &&    //VU
                            tx_xvtr_index != last_tx_xvtr_index)           //tx xvtr band change
                    {
                        if ((rx1_xvtr_index == 0 || rx1_xvtr_index == 1) &&    //VFOA is V or U
                                tx_xvtr_index >= 2 && !swapping)  //VFOB is XVTR using Split (can't use XVTR with RX2)
                        {
                            MessageBox.Show(new Form { TopMost = true }, "Error: Cannot use Split with XVTR on VFOB.  Try swapping VFOs",
                                            "VU Error",
                                            MessageBoxButtons.OK,
                                            MessageBoxIcon.Error);
                            //Give an error message, set to the last set frequency
                            chkVFOBTX.Checked = false;
                            chkVFOATX.Checked = true;
                            return;
                        }
                    }

                }
                else if (tx_xvtr_index < 0) //tx on HF
                {
                    int old_xvtr_index = xvtrForm.XVTRFreq(saved_vfob_freq);
                    if (old_xvtr_index >= 0 && freq >= max_freq)
                    {
                        VFOBFreq = saved_vfob_freq;
                        return;
                    }
                }

            } // xvtrFrom null

            if (old_tx_band != tx_band)
            {
                if (tx_band == Band.B60M && RX1IsOn60mChannel())
                {
                    chkXIT.Enabled = false;
                    chkXIT.Checked = false;
                }
                else
                    chkXIT.Enabled = true;
            }

            if (chkXIT.Checked)
                tx_freq += (int)udXIT.Value * 0.000001;

            if (tx_freq < min_freq) tx_freq = min_freq;
            else if (tx_freq > max_freq) tx_freq = max_freq;

            /*if(!IsHamBand(current_band_plan, freq))	// out of band
				{
					MessageBox.Show(new Form { TopMost = true }, "The frequency "+freq.ToString("f6" )+"MHz is not within the "+
						"IARU Band specifications.",
						"Transmit Error: Out Of Band",
						MessageBoxButtons.OK,
						MessageBoxIcon.Error);
					chkMOX.Checked = false;
					return;
				}*/

            DSPMode tx_mode = dsp.GetDSPTX(0).CurrentDSPMode;

            if (mox)
            {
                if (!CheckValidTXFreq(current_region, tx_freq, tx_mode))
                {
                    switch (dsp.GetDSPTX(0).CurrentDSPMode)
                    {
                        case DSPMode.CWL:
                        case DSPMode.CWU:
                            MessageBox.Show(new Form { TopMost = true }, "The frequency " + tx_freq.ToString("f6" ) + "MHz is not within the\n" +
                                "Band specifications for your country (" + ((int)current_region).ToString() + ").",
                                "Transmit Error: Out Of Band",
                                MessageBoxButtons.OK,
                                MessageBoxIcon.Error);
                            break;
                        default:
                            MessageBox.Show(new Form { TopMost = true }, "The frequency " + tx_freq.ToString("f6" ) + "MHz in combination with your TX filter\n" +
                                "settings [" + Display.TXFilterLow.ToString() + ", " + Display.TXFilterHigh.ToString() + "] are not within the " +
                                "Band specifications for your country (" + ((int)current_region).ToString() + ").",
                                "Transmit Error: Out Of Band",
                                MessageBoxButtons.OK,
                                MessageBoxIcon.Error);
                            break;
                    }
                    chkMOX.Checked = false;
                    return;
                }
            }

            if (mox || (fwc_init && (current_model == Model.FLEX5000 || current_model == Model.FLEX3000)) ||
                (hid_init && current_model == Model.FLEX1500))
            {
                switch (tx_mode)
                {
                    case DSPMode.AM:
                    case DSPMode.SAM:
                    case DSPMode.FM:
                        tx_freq -= 0.011025;
                        if (chkTUN.Checked) tx_freq -= (double)cw_pitch * 1e-6;
                        break;
                    case DSPMode.USB:
                    case DSPMode.DIGU:
                    case DSPMode.DSB:
                        if (chkTUN.Checked) tx_freq -= (double)cw_pitch * 1e-6;
                        break;
                    case DSPMode.LSB:
                    case DSPMode.DIGL:
                        if (chkTUN.Checked) tx_freq += (double)cw_pitch * 1e-6;
                        break;
                }
            }

            if (tx_mode == DSPMode.CWL)
                tx_freq += (double)cw_pitch * 0.0000010;
            else if (tx_mode == DSPMode.CWU)
                tx_freq -= (double)cw_pitch * 0.0000010;

            //Debug.WriteLine("freq: "+freq.ToString("f6" ));
            if (!rx1_sub_drag)
            {
                if (!((fwc_init && (current_model == Model.FLEX5000 || current_model == Model.FLEX3000)) ||
                    (hid_init && current_model == Model.FLEX1500)))
                {
                    DDSFreq = tx_freq;
                }
                else
                {
                    switch (current_model)
                    {
                        case Model.FLEX3000:
                        case Model.FLEX5000:
                            uint tw = (uint)Freq2TW(tx_freq);
                            //FWC.SetTXFreqTW(tw, (float)tx_freq);
                            tx_dds_freq_tw = tw;
                            tx_dds_freq_mhz = (float)tx_freq;
                            tx_dds_freq_updated = true;
                            break;
                        case Model.FLEX1500:
                            if (mox)
                            {
                                tw = (uint)Freq2TW(tx_freq);
                                rx1_dds_freq_tw = tw;
                                rx1_dds_freq_mhz = (float)tx_freq;
                            }
                            break;
                    }
                    if (rx2_enabled) goto set_rx2_freq;
                }
            }
            goto end;

        set_rx2_freq:

            //int old_rx2_xvtr_index = rx2_xvtr_index;
            rx2_xvtr_index = xvtr_index;

            //if (old_rx2_xvtr_index != rx2_xvtr_index)
            //last_rx2_xvtr_index = old_rx2_xvtr_index;

            Debug.WriteLine("7VFOALostFocus ");
            SetRX2Band(BandByFreq(freq, rx2_xvtr_index, false, current_region)); //why?


            if (xvtrForm != null)
            {
                if (rx2_xvtr_index >= 0) freq = xvtrForm.TranslateFreq(freq);

                if (rx2_xvtr_index != last_rx2_xvtr_index)       //restrict to band changes
                {
                    //don't want to disable this because it works on RX2 IN
                    //if (rx2_xvtr_index >= 2)
                    //{
                    //    MessageBox.Show(new Form { TopMost = true }, "Error: Cannot recieve through XVTR interface on RX2",
                    //                        "RX2 XVTR Error",
                    //                        MessageBoxButtons.OK,
                    //                        MessageBoxIcon.Error);
                    //    VFOBFreq = saved_vfob_freq;
                    //    //Give an error message, set to the last set frequency
                    //    return;
                    //}
                    if (FWCEEPROM.VUOK)
                    {
                        if (rx1_xvtr_index == 0 && rx2_xvtr_index == 0 && !swapping)
                        {
                            MessageBox.Show(new Form { TopMost = true }, "Error: Cannot use VHF on both RX1 and RX2",
                                            "VU Error",
                                            MessageBoxButtons.OK,
                                            MessageBoxIcon.Error);

                            if (saved_vfob_freq >= 134.0 && saved_vfob_freq <= 163.0) chkRX2.Checked = false;  // ke9ns test was 144.0 and 148.0
                            else
                                VFOBFreq = saved_vfob_freq;
                            //Give an error message, set to the last set frequency
                            return;
                        }
                        else if (rx1_xvtr_index == 1 && rx2_xvtr_index == 1 && !swapping)
                        {
                            MessageBox.Show(new Form { TopMost = true }, "Error: Cannot use UHF on both RX1 and RX2",
                                            "VU Error",
                                            MessageBoxButtons.OK,
                                            MessageBoxIcon.Error);
                            if (saved_vfob_freq >= 430.0 && saved_vfob_freq <= 450.0)
                                chkRX2.Checked = false;
                            else
                                VFOBFreq = saved_vfob_freq;
                            //Give an error message, set to the last set frequency
                            return;
                        }


                        if (rx2_xvtr_index == 0 || rx2_xvtr_index == 1 ||           //going to VU band
                            last_rx2_xvtr_index == 0 || last_rx2_xvtr_index == 1)   //coming from VU band
                        {
                            SetVURXPath();
                            switch (rx2_xvtr_index)
                            {
                                case 0:
                                    if (xvtrForm.VIFGain)
                                        RX2XVTRGainOffset = vhf_level_table[1];
                                    else
                                        RX2XVTRGainOffset = vhf_level_table[0];
                                    break;
                                case 1:
                                    if (xvtrForm.UIFGain)
                                        RX2XVTRGainOffset = uhf_level_table[1];
                                    else
                                        RX2XVTRGainOffset = uhf_level_table[0];
                                    break;
                            }
                        }
                    }

                    if (rx2_xvtr_index < 0)
                    {
                        RX2XVTRGainOffset = 0.0f;
                    }
                    else if (rx2_xvtr_index > 1)
                    {
                        freq = xvtrForm.TranslateFreq(freq);
                        RX2XVTRGainOffset = xvtrForm.GetRXGain(rx2_xvtr_index);
                    }
                }
            } // xvtrForm null

            if (freq < min_freq) freq = min_freq;
            else if (freq > max_freq) freq = max_freq;

            if (rx2_dsp_mode == DSPMode.CWL)
                freq += (double)cw_pitch * 0.0000010;
            else if (rx2_dsp_mode == DSPMode.CWU)
                freq -= (double)cw_pitch * 0.0000010;

            RX2DDSFreq = freq;
            UpdateRX2Notches();
            goto end;


#if false
				// wjtFIXME! sr xmit support 
				else if ( current_model == Model.SOFTROCK40 )
				{
					SetSoftRockOscFreqs();
				}
#endif

        end:

            if (chkVFOSync.Checked && txtVFOAFreq.Text != txtVFOBFreq.Text)
            {
                txtVFOAFreq.Text = txtVFOBFreq.Text;
                txtVFOBFreq_LostFocus(this, EventArgs.Empty); //.211
                txtVFOAFreq_LostFocus(this, EventArgs.Empty);
            }

            //   if (small_lsd && VFOBFreq < 10000.0)
            //  {
            //     txtVFOBMSD.Visible = true;
            //     txtVFOBLSD.Visible = true;
            // }
            //  else
            //  {
            //    txtVFOBMSD.Visible = false;
            //    txtVFOBLSD.Visible = false;

            //  }

            //provides proper operation when using split with either V or U on VFOB
            if ((VFOBFreq >= 134.0 && VFOBFreq <= 163.0) || (VFOBFreq >= 420.0 && VFOBFreq <= 470.0)) // ke9ns test was 144.0 and 148.0 and 450.0

            // if ((VFOBfreq >= 134.0 && VFOBfreq <= 163.0) || (VFOBFreq >= 420.0 && VFOBFreq <= 450.0)) // ke9ns test was 144.0 and 148.0
            {
                //if (VFOAfreq >= 134.0 && VFOAfreq <= 163.0)
                //{
                //    FWC.SetXVTRSplit(true);
                //}
                //only do SetVURXPath() when receiving on VU (for VFOB, check if rx2 is being used.  If not, then VU is in TX mode (split) and SetVURXPath() shouldn't be called)
                if (last_rx2_xvtr_index != rx2_xvtr_index)
                {
                    if (rx2_xvtr_index == 0 || rx2_xvtr_index == 1)
                        SetVURXPath();
                }
            }
            last_tx_xvtr_index = tx_xvtr_index;
            last_rx2_xvtr_index = rx2_xvtr_index;

        } // RX2 lost focus

        //====================================================================

        private void txtVFOBFreq_KeyPress(object sender, System.Windows.Forms.KeyPressEventArgs e)
        {
            string separator = System.Globalization.CultureInfo.CurrentCulture.NumberFormat.NumberDecimalSeparator;

            int KeyCode = (int)e.KeyChar;
            if ((KeyCode < 48 || KeyCode > 57) &&           // numeric keys
                KeyCode != 8 &&                             // backspace
                !e.KeyChar.ToString().Equals(separator) &&  // decimal
                KeyCode != 27)                              // escape
            {
                e.Handled = true;
            }
            else
            {
                if (e.KeyChar.ToString().Equals(separator)) // separator = , or . depending on windows setup
                {
                    e.Handled = (((TextBoxTS)sender).Text.IndexOf(separator) >= 0);
                }
                else if (KeyCode == 27)
                {
                    VFOBFreq = saved_vfob_freq;
                    btnHidden.Focus();
                }
            }
            if (e.KeyChar == (char)Keys.Enter)
            {
                txtVFOBFreq_LostFocus(txtVFOBFreq, new System.EventArgs());
                btnHidden.Focus();
            }
        } //txtVFOBFreq_KeyPress


        private void txtVFOBFreq_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
        {
            if (this.ContainsFocus)
            {
                int old_digit = vfob_hover_digit;
                int digit_index = 0;
                if (vfo_char_width == 0) GetVFOCharWidth();

                int x = txtVFOBFreq.Width - (vfo_pixel_offset - 10); // ke9ns mod was -5 was -10

                while (x < e.X)
                {
                    digit_index++;

                    if (small_lsd && txtVFOBLSD.Visible)
                    {
                        if (digit_index < 6)
                            x += (vfo_char_width + vfo_char_space);
                        else
                            x += (vfo_small_char_width + vfo_small_char_space);

                        if (digit_index == 3) x += (vfo_decimal_space - vfo_char_space);
                        if (digit_index == 6) x += vfo_small_char_width;
                    }
                    else
                    {
                        x += vfo_char_width;
                        if (digit_index == 3) x += vfo_decimal_space;
                        else x += vfo_char_space;
                    }
                }

                if (digit_index < 3) digit_index = -1;
                if (digit_index > 9) digit_index = 9;

                vfob_hover_digit = digit_index;
                if (vfob_hover_digit != old_digit) panelVFOBHover.Invalidate();
            }

        } //  txtVFOBFreq_MouseMove

        private void txtVFOBFreq_MouseLeave(object sender, System.EventArgs e)
        {
            vfob_hover_digit = -1;
            panelVFOBHover.Invalidate();
        }


        //==============================================================================================
        private void panelVFOAHover_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
        {
            Control c1 = (Control)sender;
            Control c2 = txtVFOAFreq;

            int client_width = (c1.Size.Width - c1.ClientSize.Width) + (c2.Size.Width - c2.ClientSize.Width);
            int client_height = (c1.Size.Height - c1.ClientSize.Height) + (c2.Size.Height - c2.ClientSize.Height);

            int x_offset = c1.Left - c2.Left - client_width / 2;
            int y_offset = c1.Top - c2.Top - client_height / 2;

            txtVFOAFreq_MouseMove(sender, new MouseEventArgs(e.Button, e.Clicks, e.X + x_offset, e.Y + y_offset, e.Delta));

            /*txtVFOAFreq_MouseMove(sender, new MouseEventArgs(MouseButtons.None, 0,
				e.X+panelVFOAHover.Left-10, e.Y+panelVFOAHover.Top, 0));*/
        }

        private void panelVFOBHover_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
        {
            Control c1 = (Control)sender;
            Control c2 = txtVFOBFreq;
            int client_width = (c1.Size.Width - c1.ClientSize.Width) + (c2.Size.Width - c2.ClientSize.Width);
            int client_height = (c1.Size.Height - c1.ClientSize.Height) + (c2.Size.Height - c2.ClientSize.Height);
            int x_offset = c1.Left - c2.Left - client_width / 2;
            int y_offset = c1.Top - c2.Top - client_height / 2;
            txtVFOBFreq_MouseMove(sender, new MouseEventArgs(e.Button, e.Clicks, e.X + x_offset, e.Y + y_offset, e.Delta));

            /*txtVFOBFreq_MouseMove(sender, new MouseEventArgs(MouseButtons.None, 0,
				e.X+panelVFOBHover.Left-10, e.Y+panelVFOBHover.Top, 0));*/
        }

        private void txtVFOALSD_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
        {
            txtVFOAMSD.Visible = false;
            txtVFOALSD.Visible = false;
            txtVFOAFreq.Focus();
            txtVFOAFreq.SelectAll();
        }

        private void txtVFOALSD_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
        {
            Control c1 = (Control)sender;
            Control c2 = txtVFOAFreq;

            int client_width = (c1.Size.Width - c1.ClientSize.Width) + (c2.Size.Width - c2.ClientSize.Width);
            int client_height = (c1.Size.Height - c1.ClientSize.Height) + (c2.Size.Height - c2.ClientSize.Height);
            int x_offset = c1.Left - c2.Left - client_width / 2;
            int y_offset = c1.Top - c2.Top - client_height / 2;

            txtVFOAFreq_MouseMove(sender, new MouseEventArgs(e.Button, e.Clicks, e.X + x_offset, e.Y + y_offset, e.Delta));

            /*txtVFOAFreq_MouseMove(txtVFOALSD,
				new MouseEventArgs(e.Button, e.Clicks, e.X+165, e.Y+25, e.Delta));*/
        }


        //=====================================================================================
        private void txtVFOAMSD_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
        {
            txtVFOAMSD.Visible = false;
            txtVFOALSD.Visible = false;
            txtVFOAFreq.Focus();
            txtVFOAFreq.SelectAll();
        }

        private void txtVFOAMSD_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
        {
            //  Debug.WriteLine("VFOAmousemove");
            txtVFOAFreq_MouseMove(txtVFOAMSD, new MouseEventArgs(e.Button, e.Clicks, e.X, e.Y, e.Delta));
        }


        private void txtVFOAMSD_MouseLeave(object sender, System.EventArgs e)
        {
            // Debug.WriteLine("VFOAmouseleave");

            txtVFOAFreq_MouseLeave(txtVFOAMSD, e);
        }

        private void txtVFOBMSD_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
        {
            //  Debug.WriteLine("VFOAmousedown");

            txtVFOBMSD.Visible = false;
            txtVFOBLSD.Visible = false;
            txtVFOBFreq.Focus();
            txtVFOBFreq.SelectAll();
        }

        private void txtVFOBMSD_MouseLeave(object sender, System.EventArgs e)
        {
            txtVFOBFreq_MouseLeave(txtVFOBMSD, e);
        }

        private void txtVFOBMSD_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
        {
            txtVFOBFreq_MouseMove(txtVFOBMSD, new MouseEventArgs(e.Button, e.Clicks, e.X, e.Y, e.Delta));
        }

        private void txtVFOBLSD_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
        {
            txtVFOBMSD.Visible = false;
            txtVFOBLSD.Visible = false;
            txtVFOBFreq.Focus();
            txtVFOBFreq.SelectAll();
        }

        private void txtVFOBLSD_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
        {
            Control c1 = (Control)sender;
            Control c2 = txtVFOBFreq;
            int client_width = (c1.Size.Width - c1.ClientSize.Width) + (c2.Size.Width - c2.ClientSize.Width);
            int client_height = (c1.Size.Height - c1.ClientSize.Height) + (c2.Size.Height - c2.ClientSize.Height);
            int x_offset = c1.Left - c2.Left - client_width / 2;
            int y_offset = c1.Top - c2.Top - client_height / 2;

            txtVFOBFreq_MouseMove(sender, new MouseEventArgs(e.Button, e.Clicks, e.X + x_offset, e.Y + y_offset, e.Delta));

            /*txtVFOBFreq_MouseMove(txtVFOBLSD,
				new MouseEventArgs(e.Button, e.Clicks, e.X+165, e.Y+25, e.Delta));*/
        }

        #endregion

        #region Display Events

        private bool rx1_low_filter_drag = false;
        private bool rx1_high_filter_drag = false;
        private bool rx1_whole_filter_drag = false;
        private bool rx1_sub_drag = false;
        private bool rx1_spectrum_drag = false; // ke9ns: if click and drag the VFO, then dont update the TX freq until you let go of the click (VFO)

        private bool rx2_low_filter_drag = false;
        private bool rx2_high_filter_drag = false;
        private bool rx2_whole_filter_drag = false;
        //private bool rx2_sub_drag = false;
        private bool rx2_spectrum_drag = false;

        private bool tx_low_filter_drag = false;
        private bool tx_high_filter_drag = false;
        private bool tx_whole_filter_drag = false;

        private int whole_filter_start_x = 0;
        private int whole_filter_start_low = 0;
        private int whole_filter_start_high = 0;
        private int sub_drag_last_x = 0;
        private int spectrum_drag_last_x = 0;
        private double sub_drag_start_freq = 0.0;


        private bool notch_drag = false;
        private Point notch_drag_start_point = new Point(0, 0);
#if (!NO_TNF)
        private int notch_drag_max_delta_x = 0;
        private int notch_drag_max_delta_y = 0;
        private bool notch_zoom = false;
        private Notch notch_drag_start; // starting settings for notch
        private Notch notch_drag_active; // notch to use for modifying
#endif

        public static int H7 = 0; // ke9ns add  H7 size of RX1 total area
        public static int H8 = 0; // ke9ns add  H8 size of RX1 pan area 
        public static float H9 = 0; // ke9ns add  H9 divide factor for determining db 

        public static int H10 = 0; // ke9ns add .197 H value of DrawWaterfallGrid routine in Display

        public bool ZoomOn = false; //.241
        public int ZoomX = 0;
        public int ZoomY = 0;
        public float ZoomFactor = 2.0f; // .241 2 to 1 but may change to a slider

        public int ZoomRealX = 1000; // this is the actual size of the image before resizing to fit the display area
        public int ZoomRealY = 507;



        private void picDisplay_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
        {

            DX_X = e.X; //ke9ns add
            DX_Y = e.Y; //ke9ns add

            mouseinS = false; //ke9ns  .193 to turn off click to tune cross hair if adusting pan noise floor level, Agc-T level, or pan/water ratio

            if (ZoomOn) //.241
            {


                int xx = picDisplay.Width;  // size of picdisplay as user scales it to their screen
                int yy = picDisplay.Height;

                //  Debug.WriteLine("Zoom displayarea width " + xx);
                //  Debug.WriteLine("Zoom displayarea Height " + yy);


                //     if (p.Y > yy || p.Y < 0 || p.X > xx || p.X <0)
                //   {
                //     ZoomOn = false;
                //    if (SpotForm != null) SpotForm.Darken();
                //    return;
                //  }


                float scalex = ((float)ZoomRealX / (float)xx); // get the cursor position as if the image was 1000x507 and not the current window size
                ZoomX = (int)((float)e.X * scalex);

                float scaley = ((float)ZoomRealY / (float)yy);
                ZoomY = (int)((float)e.Y * scaley);

                //   Debug.WriteLine("Zoom cursor " + e.X + " , " +e.Y);

                //    Debug.WriteLine("Zoom scaled to 1000,507 X " + ZoomX); //.241

                //    Debug.WriteLine("Zoom scaled to 1000,50 Y " + ZoomY);




            } // ZoomOn



            if (AGCTDIS == true)
            {

                if ((e.X > 50) && (e.X < 150) && (e.Y < Display.AGCT_Y + 10 & e.Y > Display.AGCT_Y - 10)) // ke9ns: see if mouse close to AGCT line
                {
                    System.Windows.Forms.Cursor.Current = System.Windows.Forms.Cursors.Hand; // ke9ns: change cursor to HAND when over GRAB area
                    mouseinS = true;

                    if (mousestart == true) //  false do this below only 1 time unless you release the mouse (mouseup)
                    {
                        Debug.WriteLine("mouse moving");

                        mouse_X = e.X;
                        mouse_Y = e.Y + mouseoffset_Y; // ke9ns: if line is at 380 and you clicked at 385 then mouse_Y = 385 - 5 = 380

                        ptbRF_Scroll(this, EventArgs.Empty); // ke9ns: update the scroll bar acording to the new mouse movement up/down that moves the AGCT line

                        if (Display.AGCT_Y_BELOW == true) // because of the scale settings or auto pan (you may not have much below the noise floor showing up on the pan)
                        {

                            if (setupForm != null)
                            {
                                if (setupForm.tbGridOffset.Value < 40) setupForm.tbGridOffset.Value++; // move up
                                setupForm.tbGridOffset_Scroll(this, EventArgs.Empty); //move the noise floor up/down to allow the Green AGCT_Y line to show up on the screen (not drop below view)
                            }
                        }
                        return;
                    }

                }


            } //  if (AGCTDIS == true)


            if (comboDisplayMode.Text == "Panafall8020" && (!rx2_enabled)) // ke9ns add: .193
            {

                if (mousestartS == true || ((e.Y >= (H7 - 3 + mouseholdY)) && (e.Y <= (H7 + 15 + mouseholdY)))) // ke9ns: 
                {
                    //  Debug.WriteLine("8020MOUSE_POSITIONY "  + e.Y);
                    mouseinS = true;

                    System.Windows.Forms.Cursor.Current = System.Windows.Forms.Cursors.HSplit; // ke9ns: change cursor to horizontal slit icon when over GRAB area

                    int temp2 = H7 + mouseholdY;


                    if (mousestartS == true) //  false do this below only 1 time unless you release the mouse (mouseup)
                    {
                        //  Debug.WriteLine("8020MOUSE_OFFSET Y " + mouseoffsetS_Y + " , " + e.Y + " , " + H7 + " , " + mouseholdY + " , " + temp2);

                        mouseS_X = e.X;
                        mouseS_Y = e.Y;
                        mouseoffsetS_Y = mousefirstS_Y - mouseS_Y;

                        mouseholdY = mouseholdY - mouseoffsetS_Y;


                        setupForm.udSS1H.Value = setupForm.udSS1H.Value - (decimal)mouseoffsetS_Y;  // .197 


                        if (setupForm.udSS1H.Value < -((decimal)(H10 * 5 / 6) * .2M)) // .197
                        {
                            mousestartS = false;
                            mousewaitS = false;

                            setupForm.udSS1H.Value = -((decimal)(H10 * 5 / 6) * .19M);
                            mouseholdY = (int)setupForm.udSS1H.Value;
                        }
                        else if (setupForm.udSS1H.Value > ((decimal)(H10 * 5 / 6) * .1M)) // .197
                        {
                            mousestartS = false;
                            mousewaitS = false;

                            setupForm.udSS1H.Value = ((decimal)(H10 * 5 / 6) * .09M);
                            mouseholdY = (int)setupForm.udSS1H.Value;
                        }

                        //  Debug.WriteLine("-8020MOUSE_OFFSET Y SS1 " + mouseoffsetS_Y + " , " + setupForm.udSS1H.Value + " , " + (H10 * 5 / 6) *.1);
                        mousefirstS_Y = mouseS_Y;

                        return;
                    }

                } // if in the y window


            } // combodisplaymode is Panafall8020
            else if (comboDisplayMode.Text == "Panafall" && (!rx2_enabled)) // ke9ns add: .193
            {
                //  Debug.WriteLine("MOUSE_POSITIONY "  + e.Y + " , " + H10 +  " , " + H7 + " , " + mouseholdYY);

                if (mousestartS == true || ((e.Y >= (H7 - 3 + mouseholdYY)) && (e.Y <= (H7 + 15 + mouseholdYY)))) // ke9ns: 
                {
                    mouseinS = true;
                    //  Debug.WriteLine("MOUSE_POSITIONY "  + e.Y);
                    System.Windows.Forms.Cursor.Current = System.Windows.Forms.Cursors.HSplit; // ke9ns: change cursor to horizontal slit icon when over GRAB area

                    int temp2 = H7 + mouseholdYY;

                    if (mousestartS == true) //  false do this below only 1 time unless you release the mouse (mouseup)
                    {
                        //   Debug.WriteLine("MOUSE_OFFSET Y " + mouseoffsetS_Y + " , " + e.Y + " , " + H7 + " , " + mouseholdYY + " , " + temp2);

                        mouseS_X = e.X;
                        mouseS_Y = e.Y;
                        mouseoffsetS_Y = mousefirstS_Y - mouseS_Y;

                        mouseholdYY = mouseholdYY - mouseoffsetS_Y;

                        setupForm.udSS2H.Value = setupForm.udSS2H.Value - (decimal)mouseoffsetS_Y; // ke9ns .197

                        if (setupForm.udSS2H.Value < -((decimal)(H10 / 2) * .70M)) // .197
                        {
                            mousestartS = false;
                            mousewaitS = false;

                            setupForm.udSS2H.Value = -((decimal)(H10 / 2) * .69M);
                            mouseholdYY = (int)setupForm.udSS2H.Value;
                        }
                        else if (setupForm.udSS2H.Value > ((decimal)(H10 / 2) * .80M)) // .197
                        {
                            mousestartS = false;
                            mousewaitS = false;

                            setupForm.udSS2H.Value = ((decimal)(H10 / 2) * .79M);
                            mouseholdYY = (int)setupForm.udSS2H.Value;
                        }

                        //  Debug.WriteLine("MOUSE_OFFSET Y SS2 " + mouseoffsetS_Y + " , " + setupForm.udSS2H.Value);
                        mousefirstS_Y = mouseS_Y;

                        return;
                    }

                } // if in the y window
                else mouseinS = false;


            } // combodisplaymode is Panafall


            if ((e.X < 25)) // ke9ns: .141 see if mouse close to left side dBm line on display  (adjust Spectrum Grid MIN  or tbGriddoffset slider)
            {
                System.Windows.Forms.Cursor.Current = System.Windows.Forms.Cursors.Hand; // ke9ns: change cursor to HAND when over GRAB area
                mouseinS = true;

                if (mousestartP == true) //  false do this below only 1 time unless you release the mouse (mouseup)
                {

                    mouseP_X = e.X;
                    mouseP_Y = e.Y; // ke9ns: 

                    mouseoffsetP_Y = mousefirstP_Y - mouseP_Y;

                    Debug.WriteLine("mouse moving1 " + mouseoffsetP_Y + " , " + mousefirstP_Y);


                    if (setupForm != null)
                    {

                        if (mouseRight == false) // .195 adjust Spectrum grid MIN
                        {
                            var temp8 = setupForm.tbGridOffset.Value + (mouseoffsetP_Y / 2);

                            if (temp8 < 0) setupForm.tbGridOffset.Value = 0; // dont move anymore
                            else if (temp8 > 40) setupForm.tbGridOffset.Value = 40; // 
                            else setupForm.tbGridOffset.Value = temp8;

                            this.toolTip1.SetToolTip(this.picDisplay, setupForm.udDisplayGridMin.Value.ToString() + "dB Min");
                        }
                        else   // .195 adjust Spectrum grid MAX
                        {
                            var temp8 = setupForm.udDisplayGridMax.Value - (mouseoffsetP_Y / 2);
                            if (temp8 < -100) setupForm.udDisplayGridMax.Value = -100;
                            else if (temp8 > 50) setupForm.udDisplayGridMax.Value = 50;
                            else setupForm.udDisplayGridMax.Value = temp8;

                            this.toolTip1.SetToolTip(this.picDisplay, setupForm.udDisplayGridMax.Value.ToString() + "dB Max");

                        }


                        setupForm.tbGridOffset_Scroll(this, EventArgs.Empty); //move the noise floor up/down to allow the Green AGCT_Y line to show up on the screen (not drop below view)
                    }


                    mousefirstP_Y = mouseP_Y;

                    return;
                }



            } //   if ((e.X < 25)) 

            //---------------------------------------------------------------------------
            //---------------------------------------------------------------------------
            // ke9ns add  to allow proper click to tune operation between Rx1 and rx2

            if ((Display.CurrentDisplayModeBottom != DisplayMode.OFF) && (rx2_enabled))
            {

                if ((Display.K9 == 5) && (Display.K10 != 5))  //  RX1 panafall,  RX2 Panadapater or waterfall
                {
                    H7 = picDisplay.Height * 2 / 3;   // size of rx1 pan/water area
                    H8 = picDisplay.Height / 3;      // size of rx1 pan area
                    H9 = 3.0f;

                }
                else if ((Display.K9 == 5) && (Display.K10 == 5)) // RX1 panafall and RX2 panafall
                {
                    H7 = picDisplay.Height / 2;       // size of rx1 pan area
                    H8 = picDisplay.Height / 4;       // size of rx1 waterfall area
                    H9 = 4.0f;

                }
                else
                {
                    H7 = picDisplay.Height / 2; // ke9ns this was standard
                    H8 = picDisplay.Height / 2;
                    H9 = 2.0f;

                }

            }
            else if (Display.K9 == 7) // special panafall mode for grayline tracking
            {
                H7 = picDisplay.Height * 5 / 6; // size of panadapter area 83%
                H8 = picDisplay.Height * 5 / 6;
                H9 = 6.0f / 5.0f; // 1.2

            }
            else if (Display.K9 == 5) // RX2 OFF, RX1 Panafall
            {
                H7 = picDisplay.Height / 2;
                H8 = picDisplay.Height / 2;
                H9 = 2.0f;

            }
            else
            {
                H7 = picDisplay.Height / 2; // ke9ns this was standard
                H8 = picDisplay.Height / 2;
                H9 = 2.0f;

            }
            //--------------------------------------------------------------------------------

            Cursor next_cursor = null;
            try
            {
                // get filter location information
                int filt_low_x = 0;
                int filt_high_x = 0;
                if (rx2_enabled && e.Y > H7) // ke9ns mod: if RX2 is enabled and the cursor is in the lower half of the display
                {
                    if (mox && chkVFOBTX.Checked)
                    {
                        filt_low_x = HzToPixel2(dsp.GetDSPTX(0).TXFilterLow); //.219 mod 2
                        filt_high_x = HzToPixel2(dsp.GetDSPTX(0).TXFilterHigh);
                    }
                    else
                    {
                        filt_low_x = HzToPixel2(dsp.GetDSPRX(1, 0).RXFilterLow); //.219 mod 2
                        filt_high_x = HzToPixel2(dsp.GetDSPRX(1, 0).RXFilterHigh);
                    }
                }
                else
                {
                    if (mox && chkVFOATX.Checked)
                    {
                        filt_low_x = HzToPixel(dsp.GetDSPTX(0).TXFilterLow);
                        filt_high_x = HzToPixel(dsp.GetDSPTX(0).TXFilterHigh);
                    }
                    else
                    {
                        filt_low_x = HzToPixel(dsp.GetDSPRX(0, 0).RXFilterLow);
                        filt_high_x = HzToPixel(dsp.GetDSPRX(0, 0).RXFilterHigh);
                    }
                }

                // get VFO A Sub + Filter location information
                int vfoa_sub_x = 0;
                int vfoa_sub_low_x = 0;
                int vfoa_sub_high_x = 0;
                if (chkEnableMultiRX.Checked && !mox)
                {
                    if (!rx2_enabled)
                    {
                        vfoa_sub_x = HzToPixel((float)((VFOBFreq - VFOAFreq) * 1e6));
                        vfoa_sub_low_x = vfoa_sub_x + (HzToPixel(dsp.GetDSPRX(0, 0).RXFilterLow) - HzToPixel(0.0f));
                        vfoa_sub_high_x = vfoa_sub_x + (HzToPixel(dsp.GetDSPRX(0, 0).RXFilterHigh) - HzToPixel(0.0f));
                    }
                    else
                    {
                        vfoa_sub_x = HzToPixel((float)((VFOASubFreq - VFOAFreq) * 1e6));
                        vfoa_sub_low_x = vfoa_sub_x + (HzToPixel(dsp.GetDSPRX(0, 1).RXFilterLow) - HzToPixel(0.0f));
                        vfoa_sub_high_x = vfoa_sub_x + (HzToPixel(dsp.GetDSPRX(0, 1).RXFilterHigh) - HzToPixel(0.0f));
                    }
                }

                // get VFO B filter location information
                int vfob_x = 0;
                int vfob_low_x = 0;
                int vfob_high_x = 0;
                if (rx2_enabled && rx2_spectrum_drag)
                {
                    vfob_x = HzToPixel2((float)((VFOBFreq - VFOAFreq) * 1e6));  //.219 mod 2
                    vfob_low_x = vfob_x + (HzToPixel2(dsp.GetDSPRX(1, 0).RXFilterLow) - HzToPixel2(0.0f));
                    vfob_high_x = vfob_x + (HzToPixel2(dsp.GetDSPRX(1, 0).RXFilterHigh) - HzToPixel2(0.0f));
                }

                switch (Display.CurrentDisplayMode)
                {
                    case DisplayMode.HISTOGRAM:
                    case DisplayMode.SPECTRUM:
                        DisplayCursorX = e.X;
                        DisplayCursorY = e.Y;

                        float x = PixelToHz(e.X);
                        float y = PixelToDb(e.Y);


                        double rf_freq;
                        if (rx2_enabled && e.Y > H7)
                        {
                            x = PixelToHz2(e.X); // .219 add
                            rf_freq = VFOBFreq + (double)x * 0.0000010; // was picDisplay.Height/2
                        }
                        else
                        {
                            rf_freq = VFOAFreq + (double)x * 0.0000010;
                        }

                        if (rx1_dsp_mode == DSPMode.CWL)
                            rf_freq += (double)cw_pitch * 0.0000010;
                        else if (rx1_dsp_mode == DSPMode.CWU)
                            rf_freq -= (double)cw_pitch * 0.0000010;

                        txtDisplayCursorOffset.Text = x.ToString("f1") + "Hz";

                        txtDisplayCursorPower.Text = y.ToString("f1") + "dBm";

                        string temp_text = rf_freq.ToString("f6" ) + " MHz";
                        int jper = temp_text.IndexOf(separator) + 4;
                        txtDisplayCursorFreq.Text = String.Copy(temp_text.Insert(jper, " "));
                        break;
                    case DisplayMode.PANADAPTER:
                    case DisplayMode.WATERFALL:
                    case DisplayMode.PANAFALL:
                    case DisplayMode.PANASCOPE:
                        DisplayCursorX = e.X; // update display cursor position
                        DisplayCursorY = e.Y;

                        x = PixelToHz(e.X);

                        switch (Display.CurrentDisplayMode)
                        {
                            case DisplayMode.PANADAPTER:

                                if ((Display.CurrentDisplayModeBottom != DisplayMode.OFF) && RX2Enabled) // ke9ns mod and add
                                {

                                    if ((Display.K10 == 1)) // rx2 in water only
                                    {
                                        if (e.Y < H7) // RX1 pan area only   
                                        {
                                            y = PixelToDb(e.Y);
                                            txtDisplayCursorPower.Text = y.ToString("f1") + "dBm1";
                                        }
                                        else // rx2 water
                                        {
                                            x = PixelToHz2(e.X); //.219  (ke9ns: get offset from VFOB freq in hz here)


                                            y = WaterfallPixelToTime((e.Y) - H7);
                                            txtDisplayCursorPower.Text = (y / 1000.0f).ToString("f1") + "sec2";
                                        }

                                    }
                                    else if ((Display.K10 == 2)) // rx2 in pan only
                                    {
                                        if (e.Y < H7) // RX1 pan area only   
                                        {
                                            y = PixelToDb(e.Y);
                                            txtDisplayCursorPower.Text = y.ToString("f1") + "dBm1";
                                        }
                                        else // RX2 pan
                                        {
                                            x = PixelToHz2(e.X); //.219

                                            y = PixelToDb(e.Y);
                                            txtDisplayCursorPower.Text = y.ToString("f1") + "dBm2";
                                        }

                                    }
                                }
                                else // RX1 water only, no RX2
                                {
                                    y = PixelToDb(e.Y);
                                    txtDisplayCursorPower.Text = y.ToString("f1") + "dBm";

                                }

                                break;

                            case DisplayMode.WATERFALL:

                                if ((Display.CurrentDisplayModeBottom != DisplayMode.OFF) && RX2Enabled) // ke9ns mod and add
                                {

                                    if ((Display.K10 == 1)) // rx2 in water only
                                    {

                                        if (e.Y < H7)// rx1 water
                                        {
                                            y = WaterfallPixelToTime(e.Y);
                                            txtDisplayCursorPower.Text = (y / 1000.0f).ToString("f1") + "sec1";
                                        }
                                        else // rx2 water
                                        {
                                            y = WaterfallPixelToTime(e.Y);
                                            txtDisplayCursorPower.Text = (y / 1000.0f).ToString("f1") + "sec2";
                                        }

                                    }
                                    else if ((Display.K10 == 2)) // rx2 in pan only
                                    {

                                        if (e.Y < H7)// rx1 water
                                        {
                                            y = WaterfallPixelToTime(e.Y);
                                            txtDisplayCursorPower.Text = (y / 1000.0f).ToString("f1") + "sec1";
                                        }
                                        else // RX2 pan
                                        {
                                            y = PixelToDb(e.Y);
                                            txtDisplayCursorPower.Text = y.ToString("f1") + "dBm2";
                                        }

                                    }

                                }
                                else
                                {

                                    y = WaterfallPixelToTime(e.Y);
                                    txtDisplayCursorPower.Text = (y / 1000.0f).ToString("f1") + "sec";

                                }

                                break;


                            case DisplayMode.PANAFALL: // ke9ns pan

                                if ((Display.CurrentDisplayModeBottom != DisplayMode.OFF) && RX2Enabled) // ke9ns mod and add
                                {

                                    if ((Display.K10 == 1)) // rx2 in water only
                                    {
                                        if (e.Y < H8) // RX1 pan area only   (was picDisplay.Height/2)
                                        {
                                            y = PixelToDb(e.Y);
                                            txtDisplayCursorPower.Text = y.ToString("f1") + "dBm1";
                                        }
                                        else if (e.Y < H7)// rx1 water
                                        {
                                            y = WaterfallPixelToTime((e.Y) - H8);
                                            txtDisplayCursorPower.Text = (y / 1000.0f).ToString("f1") + "sec1";
                                        }
                                        else // rx2 water
                                        {
                                            y = WaterfallPixelToTime((e.Y) - H7);
                                            txtDisplayCursorPower.Text = (y / 1000.0f).ToString("f1") + "sec2";
                                        }

                                    }
                                    else if ((Display.K10 == 2)) // rx2 in pan only
                                    {
                                        if (e.Y < H8) // RX1 pan area only   (was picDisplay.Height/2)
                                        {
                                            y = PixelToDb(e.Y);
                                            txtDisplayCursorPower.Text = y.ToString("f1") + "dBm1";
                                        }
                                        else if (e.Y < H7)// rx1 water
                                        {
                                            y = WaterfallPixelToTime((e.Y) - H8);
                                            txtDisplayCursorPower.Text = (y / 1000.0f).ToString("f1") + "sec1";
                                        }
                                        else // RX2 pan
                                        {
                                            y = PixelToDb(e.Y);
                                            txtDisplayCursorPower.Text = y.ToString("f1") + "dBm2";
                                        }

                                    }
                                    else             // if (RX2Enabled)  // rx2 in panafall
                                    {
                                        if (e.Y < H8) // RX1 pan area only   (was picDisplay.Height/2)
                                        {
                                            y = PixelToDb(e.Y);
                                            txtDisplayCursorPower.Text = y.ToString("f1") + "dBm1";
                                        }
                                        else if (e.Y < H7)// rx1 water area
                                        {
                                            y = WaterfallPixelToTime((e.Y) - H8);
                                            txtDisplayCursorPower.Text = (y / 1000.0f).ToString("f1") + "sec1";
                                        }
                                        else if (e.Y < (H7 + H8)) // rx2 pan area
                                        {
                                            y = PixelToDb(e.Y);
                                            txtDisplayCursorPower.Text = y.ToString("f1") + "dBm2";
                                        }
                                        else // rx2 water area
                                        {
                                            y = WaterfallPixelToTime((e.Y) - H8);
                                            txtDisplayCursorPower.Text = (y / 1000.0f).ToString("f1") + "sec2";
                                        }

                                    }
                                }
                                else                     //if ((Display.K10 == 0)) // rx2 off
                                {
                                    if (e.Y < H8) // RX1 pan area only   (was picDisplay.Height/2)
                                    {
                                        y = PixelToDb(e.Y);
                                        txtDisplayCursorPower.Text = y.ToString("f1") + "dBm";
                                    }
                                    else // rx1 water
                                    {
                                        y = WaterfallPixelToTime(e.Y);
                                        txtDisplayCursorPower.Text = (y / 1000.0f).ToString("f1") + "sec";
                                    }

                                }


                                break;


                            case DisplayMode.PANASCOPE:
                                if (e.Y < picDisplay.Height / 2) // 
                                {
                                    y = PixelToDb(e.Y);
                                    txtDisplayCursorPower.Text = y.ToString("f1") + "dBm";
                                }
                                else
                                {
                                    txtDisplayCursorPower.Text = "";
                                }
                                break;
                        }

                        if (rx2_enabled && e.Y > H7) // ke9ns mod if RX2 is enabled and the cursor is in the lower half of the display
                        {
                            x = PixelToHz2(e.X); //.225 ke9ns: RX2 has its own zoom level, so get the cursor offset in hz here now
                            rf_freq = VFOBFreq + (double)x * 0.0000010;

                            if (rx2_dsp_mode == DSPMode.CWL)
                                rf_freq += (double)cw_pitch * 0.0000010;
                            else if (rx2_dsp_mode == DSPMode.CWU)
                                rf_freq -= (double)cw_pitch * 0.0000010;
                        }
                        else
                        {
                            rf_freq = VFOAFreq + (double)x * 0.0000010;
                            if (rx1_dsp_mode == DSPMode.CWL)
                                rf_freq += (double)cw_pitch * 0.0000010;
                            else if (rx1_dsp_mode == DSPMode.CWU)
                                rf_freq -= (double)cw_pitch * 0.0000010;
                        }

                        txtDisplayCursorOffset.Text = x.ToString("f1") + "Hz";

                        temp_text = rf_freq.ToString("f6" ) + " MHz";
                        jper = temp_text.IndexOf(separator) + 4;
                        txtDisplayCursorFreq.Text = String.Copy(temp_text.Insert(jper, " "));

                        // if near a notch and not already doing something else, display appropriate cursor
                        if (Cursor != Cursors.Hand && !mox)
                        {
                            if (!rx1_low_filter_drag && !rx1_high_filter_drag && !rx1_whole_filter_drag &&
                                !rx2_low_filter_drag && !rx2_high_filter_drag && !rx2_whole_filter_drag &&
                                !tx_low_filter_drag && !tx_high_filter_drag && !tx_whole_filter_drag &&
                                !rx1_sub_drag && !notch_drag)
                            {
                                rf_freq = VFOAFreq;

                                int low = (int)PixelToHz(e.X - 3);
                                int high = (int)PixelToHz(e.X + 3);

                                if (rx2_enabled && e.Y > H7) // ke9ns mod
                                {
                                    low = (int)PixelToHz2(e.X - 3); //.219
                                    high = (int)PixelToHz2(e.X + 3);

                                    rf_freq = VFOBFreq;

                                    switch (rx2_dsp_mode)
                                    {
                                        case (DSPMode.CWL):
                                            rf_freq += cw_pitch * 1e-6;
                                            break;
                                        case (DSPMode.CWU):
                                            rf_freq -= cw_pitch * 1e-6; ;
                                            break;
                                    }
                                }
                                else
                                {
                                    switch (rx1_dsp_mode)
                                    {
                                        case (DSPMode.CWL):
                                            rf_freq += cw_pitch * 1e-6; ;
                                            break;
                                        case (DSPMode.CWU):
                                            rf_freq -= cw_pitch * 1e-6; ;
                                            break;
                                    }
                                }

                                //Debug.WriteLine("x: " + e.X);


#if (!NO_TNF)
                                List<Notch> list = NotchList.NotchesInBW(rf_freq, low, high);
                                if (list.Count > 0)
                                {
                                    next_cursor = Cursors.VSplit;
                                }
                                else
                                {
                                    next_cursor = Cursors.Cross;
                                }
#endif
                            }
                        }

#if (!NO_TNF)
                        if (notch_drag)
                        {
                            double hz_per_pixel = PixelToHz(1) - PixelToHz(0);
                            int delta_x = e.X - notch_drag_start_point.X;
                            int delta_y = e.Y - notch_drag_start_point.Y;

                            if (Math.Abs(delta_x) > notch_drag_max_delta_x)
                                notch_drag_max_delta_x = Math.Abs(delta_x);
                            if (Math.Abs(delta_y) > notch_drag_max_delta_y)
                                notch_drag_max_delta_y = Math.Abs(delta_y);

                            // offset the notch frequency based on the current mouse position
                            double delta_freq = delta_x * hz_per_pixel;
                            if (notch_zoom) delta_freq /= 10.0;
                            notch_drag_active.Freq = notch_drag_start.Freq + delta_freq * 1e-6;

                            // change the BW of the notch filter once outside a 20 pixel boundary
                            if (delta_y > 10)
                            {
                                notch_drag_active.BW = notch_drag_start.BW - (delta_y - 10) * 5;
                                // don't go negative or less than 10Hz
                                if (notch_drag_active.BW < 10) notch_drag_active.BW = 10;
                            }
                            else if (delta_y < -10)
                                notch_drag_active.BW = notch_drag_start.BW - (delta_y + 10) * 5;

                            UpdateRX1Notches();
                            UpdateRX1SubNotches();
                            UpdateRX2Notches();
                        }
#endif

                        if (((!rx2_enabled && rx1_dsp_mode != DSPMode.DRM) || // exclude DRM for RX1
                            (rx2_enabled && rx1_dsp_mode != DSPMode.DRM && e.Y < H7) ||
                            (rx2_enabled && rx2_dsp_mode != DSPMode.DRM && e.Y >= H7)))
                        {
                            if (current_click_tune_mode == ClickTuneMode.Off &&
                                picDisplay.Cursor != Cursors.Hand && next_cursor != Cursors.SizeNS && next_cursor != Cursors.VSplit)
                            {
                                if (Math.Abs(e.X - filt_low_x) < 3 || // RX low filter edge
                                    Math.Abs(e.X - filt_high_x) < 3 || // RX high filter edge
                                    rx1_high_filter_drag || rx1_low_filter_drag || // already dragging a filter edge
                                    (chkEnableMultiRX.Checked && // RX1 Sub
                                        ((rx2_enabled && e.Y < H7) || !rx2_enabled) && (e.X > vfoa_sub_low_x - 3 && e.X < vfoa_sub_high_x + 3)) ||
                                    (rx2_enabled && e.Y > H7 && (Math.Abs(e.X - vfob_low_x) < 3)) || // RX2 low filter edge
                                    (rx2_enabled && e.Y > H7 && (Math.Abs(e.X - vfob_high_x) < 3)) ||
                                    rx2_high_filter_drag || rx2_low_filter_drag) // already dragging a filter edge
                                {
                                    next_cursor = Cursors.SizeWE;
                                }
                                else if (e.X > filt_low_x && e.X < filt_high_x)
                                {
                                    next_cursor = Cursors.NoMoveHoriz;
                                }
                                else
                                {
                                    next_cursor = Cursors.Cross;
                                }
                            }

                            if (notch_drag)
                            {
                                // do nothing -- already handled above
                            }
                            else if (rx1_high_filter_drag)
                            {
                                //   Debug.WriteLine("RX1 HIGH FILTER DRAG");

                                SelectRX1VarFilter();
                                int new_high = (int)Math.Max(PixelToHz(e.X), dsp.GetDSPRX(0, 0).RXFilterLow + 10);
                                UpdateRX1Filters(dsp.GetDSPRX(0, 0).RXFilterLow, new_high);
                            }
                            else if (rx1_low_filter_drag)
                            {
                                //   Debug.WriteLine("RX1 LOW FILTER DRAG");

                                SelectRX1VarFilter();
                                int new_low = (int)Math.Min(PixelToHz(e.X), dsp.GetDSPRX(0, 0).RXFilterHigh - 10);
                                UpdateRX1Filters(new_low, dsp.GetDSPRX(0, 0).RXFilterHigh);
                            }
                            else if (rx1_whole_filter_drag)
                            {
                                //  Debug.WriteLine("RX1 WHOLE FILTER DRAG");

                                SelectRX1VarFilter();
                                int diff = (int)(PixelToHz(e.X) - PixelToHz(whole_filter_start_x));
                                UpdateRX1Filters(whole_filter_start_low + diff, whole_filter_start_high + diff);
                            }
                            else if (rx1_sub_drag)
                            {
                                int diff = (int)(PixelToHz(e.X) - PixelToHz(sub_drag_last_x));
                                if (rx2_enabled)
                                    VFOASubFreq = sub_drag_start_freq + diff * 1e-6;
                                else VFOBFreq = sub_drag_start_freq + diff * 1e-6;
                            }
                            else if (rx2_high_filter_drag)
                            {
                                // Debug.WriteLine("RX2 HIGH FILTER DRAG");

                                SelectRX2VarFilter();
                                int new_high = (int)Math.Max(PixelToHz2(e.X), dsp.GetDSPRX(1, 0).RXFilterLow + 10);
                                UpdateRX2Filters(dsp.GetDSPRX(1, 0).RXFilterLow, new_high);
                            }
                            else if (rx2_low_filter_drag)
                            {
                                //  Debug.WriteLine("RX2 LOW FILTER DRAG");

                                SelectRX2VarFilter();
                                int new_low = (int)Math.Min(PixelToHz2(e.X), dsp.GetDSPRX(1, 0).RXFilterHigh - 10);
                                UpdateRX2Filters(new_low, dsp.GetDSPRX(1, 0).RXFilterHigh);
                            }
                            else if (rx2_whole_filter_drag)
                            {

                                // Debug.WriteLine("RX2 whole FILTER DRAG");

                                SelectRX2VarFilter();
                                int diff = (int)(PixelToHz2(e.X) - PixelToHz2(whole_filter_start_x));
                                UpdateRX2Filters(whole_filter_start_low + diff, whole_filter_start_high + diff);
                            }
                            else if (tx_high_filter_drag)
                            {
                                Debug.WriteLine("TX HIGH FILTER DRAG");

                                int new_high = (int)Math.Max(Math.Abs(PixelToHz(e.X)), tx_filter_low + 10);
                                setupForm.TXFilterHigh = new_high;

                                if (chkVFOBTX.Checked) //.219
                                {
                                    new_high = (int)Math.Max(Math.Abs(PixelToHz2(e.X)), tx_filter_low + 10);
                                    setupForm.TXFilterHigh = new_high;
                                }
                            }
                            else if (tx_low_filter_drag)
                            {

                                Debug.WriteLine("TX LOW FILTER DRAG");

                                int new_low = (int)(Math.Min(Math.Abs(PixelToHz(e.X)), tx_filter_high - 10));
                                setupForm.TXFilterLow = new_low;

                                if (chkVFOBTX.Checked) //.219
                                {
                                    new_low = (int)(Math.Min(Math.Abs(PixelToHz2(e.X)), tx_filter_high - 10));
                                    setupForm.TXFilterLow = new_low;
                                }

                            }
                            else if (tx_whole_filter_drag)
                            {

                                Debug.WriteLine("TX whole FILTER DRAG");

                                int diff = (int)(PixelToHz(e.X) - PixelToHz(whole_filter_start_x));

                                if (chkVFOBTX.Checked) //.219
                                {
                                    diff = (int)(PixelToHz2(e.X) - PixelToHz2(whole_filter_start_x));
                                }

                                switch (rx1_dsp_mode)
                                {
                                    case DSPMode.LSB:
                                    case DSPMode.DIGL:
                                        setupForm.TXFilterLow = whole_filter_start_low - diff;
                                        setupForm.TXFilterHigh = whole_filter_start_high - diff;
                                        break;
                                    case DSPMode.USB:
                                    case DSPMode.DIGU:
                                        setupForm.TXFilterLow = whole_filter_start_low + diff;
                                        setupForm.TXFilterHigh = whole_filter_start_high + diff;
                                        break;
                                    case DSPMode.AM:
                                    case DSPMode.SAM:
                                    case DSPMode.FM:
                                    case DSPMode.DSB:
                                        setupForm.TXFilterHigh = whole_filter_start_high + diff;
                                        break;
                                }
                            }

                        }
                        break;
                    default:
                        txtDisplayCursorOffset.Text = "";
                        txtDisplayCursorPower.Text = "";
                        txtDisplayCursorFreq.Text = "";
                        break;
                }

                if (rx1_spectrum_drag)
                {
                    //  Debug.WriteLine("RX1 SPECTRUM DRAG");

                    if (!mox || (rx2_enabled && chkVFOBTX.Checked))
                    {
                        float start_freq = PixelToHz(spectrum_drag_last_x);
                        float end_freq = PixelToHz(e.X);
                        spectrum_drag_last_x = e.X;
                        float delta = end_freq - start_freq;
                        VFOAFreq -= delta * 0.0000010;
                    }
                }
                else if (rx2_spectrum_drag)
                {

                    // Debug.WriteLine("RX2 SPECTRUM DRAG");

                    if (rx2_enabled && (!mox || chkVFOATX.Checked))
                    {
                        float start_freq = PixelToHz2(spectrum_drag_last_x);
                        float end_freq = PixelToHz2(e.X);
                        spectrum_drag_last_x = e.X;
                        float delta = end_freq - start_freq;
                        VFOBFreq -= delta * 0.0000010;
                    }
                }
            }
            catch (Exception)
            {

            }

            if (next_cursor != null && picDisplay.Cursor != next_cursor)
                picDisplay.Cursor = next_cursor;

            //   UpdateBandButtonColors();  // ke9ns add

        } // picdisplay mousemove

        private void picDisplay_MouseLeave(object sender, System.EventArgs e)
        {
            txtDisplayCursorOffset.Text = "";
            txtDisplayCursorPower.Text = "";
            txtDisplayCursorFreq.Text = "";
            DisplayCursorX = -1;
            DisplayCursorY = -1;
            Cursor = Cursors.Default;
        }

        public static int mouse_X = 0;   // ke9ns add: .134 all these for AGCT slider pan function
        public static int mousefirst_X = 0;
        public static int mouse_Y = 0;
        public static int mousefirst_Y = 0;
        public static int mouseoffset_Y = 0;
        public bool mousestart = false;


        public static int mouseP_X = 0;   // ke9ns add: .141 all these for grab and pull slider pan function spectrum grid MIN value change
        public static int mousefirstP_X = 0;
        public static int mouseP_Y = 0;
        public static int mousefirstP_Y = 0;
        public static int mouseoffsetP_Y = 0;
        public bool mousestartP = false;
        public bool mouseRight = false; // ke9ns .195 right click adjusts spectrum grid Max instead of MIN

        public static int mouseS_X = 0;   // ke9ns add: .193 all these for grab and pull slider Panafall8020 special function
        public static int mousefirstS_X = 0;
        public static int mouseS_Y = 0;
        public static int mousefirstS_Y = 0;
        public static int mouseoffsetS_Y = 0;
        public bool mousestartS = false;

        public int mouseholdY = 0; // holds total change in Y position of the waterfall grid freq display bar Panafall8020 .193
        public int mouseholdYY = 0; // holds total change in Y position of the waterfall grid freq display bar Panafall
        public bool mousewaitS = false; // reach limits wait to release mouse
        public bool mouseinS = false; // true = over the bar area

        private void picDisplay_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
        {

            switch (e.Button)
            {

                case MouseButtons.Left:
                    bool near_notch = false;
                    if (!mox)
                    {
                        // ke9ns add: allow to move the AGC via the line on the screen
                        if (AGCTDIS == true)
                        {

                            if ((e.X > 50) && (e.X < 150) && (e.Y < Display.AGCT_Y + 10 & e.Y > Display.AGCT_Y - 10)) // ke9ns: see if mouse close to AGCT line
                            {

                                if (mousestart == false) //  false do this below only 1 time unless you release the mouse (mouseup)
                                {
                                    Debug.WriteLine("mouse START"); // your dragging line

                                    mousestart = true;
                                    mousefirst_X = e.X;
                                    mousefirst_Y = Display.AGCT_Y; // e.Y;

                                    mouseoffset_Y = Display.AGCT_Y - e.Y; // ke9ns: if you clicked below the line (at the start), this is the offset (i.e. 380 - 381 = +1)
                                    mouse_Y = e.Y + mouseoffset_Y;

                                    return;
                                }

                            } //  if (mousestart == false)

                        } //  if (AGCTDIS == true)

                        if (comboDisplayMode.Text == "Panafall8020" && (!rx2_enabled)) // ke9ns add .193
                        {
                            int temp2 = H7 + mouseholdY;

                            Debug.WriteLine("e.Y" + e.Y + " , " + temp2);

                            if ((e.Y >= (H7 - 3 + mouseholdY)) && (e.Y <= (H7 + 15 + mouseholdY))) // ke9ns: 
                            {

                                System.Windows.Forms.Cursor.Current = System.Windows.Forms.Cursors.HSplit; // ke9ns: change cursor to horizontal slit icon when over GRAB area

                                if (mousestartS == false) // && mousewaitS == true) //  false do this below only 1 time unless you release the mouse (mouseup)
                                {

                                    mousestartS = true;
                                    mousefirstS_X = e.X;
                                    mousefirstS_Y = e.Y; // e.Y;

                                    mouseoffsetS_Y = 0; // ke9ns: 

                                    Debug.WriteLine("8020MOUSE DOWNFirst Y= " + mousefirstS_Y);
                                    return;
                                }
                            }

                        } // Panafall8020
                        else if (comboDisplayMode.Text == "Panafall" && (!rx2_enabled)) // ke9ns add .193
                        {
                            int temp2 = H7 + mouseholdYY;

                            Debug.WriteLine("e.Y" + e.Y + " , " + temp2);


                            if ((e.Y >= (H7 - 3 + mouseholdYY)) && (e.Y <= (H7 + 15 + mouseholdYY))) // ke9ns: .193 .197

                            {
                                System.Windows.Forms.Cursor.Current = System.Windows.Forms.Cursors.HSplit; // ke9ns: change cursor to horizontal slit icon when over GRAB area


                                if (mousestartS == false && mousewaitS == true) //  false do this below only 1 time unless you release the mouse (mouseup)
                                {

                                    mousestartS = true;
                                    mousefirstS_X = e.X;
                                    mousefirstS_Y = e.Y; // e.Y;

                                    mouseoffsetS_Y = 0; // ke9ns: 

                                    Debug.WriteLine("MOUSE DOWNFirst Y= " + mousefirstS_Y);
                                    return;
                                }
                            }

                        } // panafall

                        if ((e.X < 25)) // ke9ns: see if mouse close to left side dBm scale on Display (adjust Spectrum grid MIN or tbGridoffset)
                        {

                            if (mousestartP == false) //  false do this below only 1 time unless you release the mouse (mouseup)
                            {
                                mouseRight = false; // .195
                                mousestartP = true;
                                mousefirstP_X = e.X;
                                mousefirstP_Y = e.Y; // e.Y;

                                mouseoffsetP_Y = 0; // ke9ns: 

                                Debug.WriteLine("mouse START0 " + mousefirstP_Y);
                                return;
                            }

                        } //  if (mousestart == false)


                        switch (Display.CurrentDisplayMode)
                        {
                            case DisplayMode.PANADAPTER:
                            case DisplayMode.WATERFALL:
                            case DisplayMode.PANAFALL:
                            case DisplayMode.PANASCOPE:
                                // check first for being near a Notch
                                double rf_freq = VFOAFreq;

                                int low = (int)PixelToHz(e.X - 3);
                                int high = (int)PixelToHz(e.X + 3);

                                if ((Display.CurrentDisplayModeBottom != DisplayMode.OFF) && (rx2_enabled) && (e.Y > H7))  // ke9ns mod (in case when rX2 display is off)
                                {
                                    rf_freq = VFOBFreq;

                                    low = (int)PixelToHz2(e.X - 3); //.219
                                    high = (int)PixelToHz2(e.X + 3);

                                    N1MM_RX2 = true; //.219

                                    switch (rx2_dsp_mode)
                                    {
                                        case (DSPMode.CWL):
                                            rf_freq += cw_pitch * 1e-6;
                                            break;
                                        case (DSPMode.CWU):
                                            rf_freq -= cw_pitch * 1e-6;
                                            break;
                                    }
                                }
                                else
                                {
                                    N1MM_RX2 = false; //.219
                                    switch (rx1_dsp_mode)
                                    {
                                        case (DSPMode.CWL):
                                            rf_freq += cw_pitch * 1e-6;
                                            break;
                                        case (DSPMode.CWU):
                                            rf_freq -= cw_pitch * 1e-6;
                                            break;
                                    }
                                }


#if (!NO_TNF)
                                List<Notch> list = NotchList.NotchesInBW(rf_freq, low, high);

                                if (list.Count > 0)
                                {
                                    near_notch = true;

                                    int index = 0;
                                    if (list[index].Permanent)
                                    {
                                        list[index].Details = true;
                                        notch_drag_active = list[index];
                                    }
                                    else
                                    {
                                        notch_drag = true;
                                        timerNotchZoom.Enabled = true;
                                        notch_drag_active = list[index];
                                        notch_drag_start = list[index].Copy();
                                        notch_drag_start_point = new Point(e.X, e.Y);
                                        list[index].Details = true;
                                        // mark which receiver the click occurred on so that we can show the callout only there
                                        list[index].RX = 1;
                                        if ((Display.CurrentDisplayModeBottom != DisplayMode.OFF) && (rx2_enabled) && (e.Y > H7)) list[index].RX = 2; // ke9ns mod (in case when rX2 display is off)

                                    }
                                }
#endif
                                break;
                        }
                    } // !MOX


                    // ke9ns add (below)
                    if ((!near_notch) && (current_click_tune_mode != ClickTuneMode.Off)) // ke9ns: if in clicktune mode (selected by doing a right click first to lock in the mode)
                    {


                        switch (Display.CurrentDisplayMode)
                        {
                            case DisplayMode.SPECTRUM:
                            case DisplayMode.HISTOGRAM:
                            case DisplayMode.PANADAPTER:
                            case DisplayMode.WATERFALL:
                            case DisplayMode.PANAFALL:
                            case DisplayMode.PANASCOPE:

                                float x = PixelToHz(e.X);

                                double freq;


                                if ((Display.CurrentDisplayModeBottom != DisplayMode.OFF) && (rx2_enabled) && (e.Y > H7))  // ke9ns mod (in case when rX2 display is off)
                                {
                                    x = PixelToHz2(e.X); //.219

                                    N1MM_RX2 = true; //.219

                                    freq = double.Parse(txtVFOBFreq.Text) + (double)x * 0.0000010;
                                    switch (rx2_dsp_mode)
                                    {
                                        case DSPMode.CWL:
                                            freq += (float)cw_pitch * 0.0000010;
                                            break;
                                        case DSPMode.CWU:
                                            freq -= (float)cw_pitch * 0.0000010;
                                            break;
                                        case DSPMode.DIGL:
                                            freq += (float)digl_click_tune_offset * 0.0000010;
                                            break;
                                        case DSPMode.DIGU:
                                            freq -= (float)digu_click_tune_offset * 0.0000010;
                                            break;
                                    }

                                    if (snap_to_click_tuning &&
                                        rx2_dsp_mode != DSPMode.CWL &&
                                        rx2_dsp_mode != DSPMode.CWU &&
                                        rx2_dsp_mode != DSPMode.DIGL &&
                                        rx2_dsp_mode != DSPMode.DIGU &&
                                        Audio.wave_playback == false)
                                    {
                                        // round freq to the nearest tuning step
                                        long f = (long)(freq * 1e6);
                                        int mult = CurrentTuneStepHz;
                                        if (f % mult > mult / 2) f += (mult - f % mult);
                                        else f -= f % mult;
                                        freq = (double)f * 1e-6;
                                    }
                                }
                                else
                                {

                                    N1MM_RX2 = false; //.219

                                    freq = double.Parse(txtVFOAFreq.Text) + (double)x * 0.0000010;
                                    switch (rx1_dsp_mode)
                                    {
                                        case DSPMode.CWL:
                                            freq += (float)cw_pitch * 0.0000010;
                                            break;
                                        case DSPMode.CWU:
                                            freq -= (float)cw_pitch * 0.0000010;
                                            break;
                                        case DSPMode.DIGL:
                                            freq += (float)digl_click_tune_offset * 0.0000010;
                                            break;
                                        case DSPMode.DIGU:
                                            freq -= (float)digu_click_tune_offset * 0.0000010;
                                            break;
                                    }

                                    if (snap_to_click_tuning &&
                                        rx1_dsp_mode != DSPMode.CWL &&
                                        rx1_dsp_mode != DSPMode.CWU &&
                                        rx1_dsp_mode != DSPMode.DIGL &&
                                        rx1_dsp_mode != DSPMode.DIGU &&
                                        Audio.wave_playback == false)
                                    {
                                        Debug.WriteLine("SNAP TUNE..."); //.196

                                        // round freq to the nearest tuning step
                                        long f = (long)(freq * 1e6);
                                        int mult = CurrentTuneStepHz;
                                        if (f % mult > mult / 2) f += (mult - f % mult);
                                        else f -= f % mult;
                                        freq = (double)f * 1e-6;
                                    }
                                }

                                if ((Display.CurrentDisplayModeBottom == DisplayMode.OFF) || (!rx2_enabled)) // ke9ns mod (in case when rX2 display is off
                                {
                                    if (current_click_tune_mode == ClickTuneMode.VFOA)

                                        if (CTUN == true) // if click jump while in CTUN, then use CTUN method
                                        {

                                            if ((Display.CurrentDisplayMode == DisplayMode.PANADAPTER) || (Display.CurrentDisplayMode == DisplayMode.PANAFALL) || (Display.CurrentDisplayMode == DisplayMode.PANASCOPE) || (Display.CurrentDisplayMode == DisplayMode.WATERFALL))
                                            {
                                                UPDATEOFF = 2; // ke9ns let system know not to update screen for a little while pan

                                            }

                                            tempVFOAFreq = Math.Round(freq, 6); // ke9ns going to be new freq
                                            CTUN1_HZ = CTUN1_HZ + (long)((tempVFOAFreq - VFOAFreq) * 1e6);
                                            CalcDisplayFreq(); // ke9ns keep display from moving
                                        }
                                        else
                                        {
                                            VFOAFreq = Math.Round(freq, 6);
                                        }
                                    else
                                        VFOBFreq = Math.Round(freq, 6);
                                }
                                else
                                {
                                    if (current_click_tune_mode == ClickTuneMode.VFOB && // red cross hairs
                                        (chkVFOSplit.Checked || chkEnableMultiRX.Checked))
                                    {
                                        VFOASubFreq = Math.Round(freq, 6);
                                    }
                                    else
                                    {
                                        if (e.Y <= H7) VFOAFreq = Math.Round(freq, 6);
                                        else VFOBFreq = Math.Round(freq, 6);
                                    }
                                }

                                if (!chkMOX.Checked && chkRIT.Checked && current_click_tune_mode == ClickTuneMode.VFOA)
                                    udRIT.Value = 0;
                                else if (chkMOX.Checked && chkXIT.Checked && current_click_tune_mode == ClickTuneMode.VFOB)
                                    udXIT.Value = 0;
                                break;
                            default:
                                break;
                        }
                    } // if((!near_notch) && (current_click_tune_mode != ClickTuneMode.Off))
                    else if (!near_notch)  // current_click_tune_mode == ClickTuneMode.Off) 
                    {
                        switch (Display.CurrentDisplayMode)
                        {
                            case DisplayMode.PANADAPTER:
                            case DisplayMode.WATERFALL:
                            case DisplayMode.PANAFALL:
                            case DisplayMode.PANASCOPE:
                                int low_x = 0, high_x = 0;
                                int vfoa_sub_x = 0;
                                int vfoa_sub_low_x = 0;
                                int vfoa_sub_high_x = 0;

                                if ((Display.CurrentDisplayModeBottom != DisplayMode.OFF) && (rx2_enabled) && (e.Y > H7)) // ke9ns mod
                                {
                                    N1MM_RX2 = true; //.219

                                    if (mox && chkVFOBTX.Checked)
                                    {
                                        low_x = HzToPixel2(dsp.GetDSPTX(0).TXFilterLow); //.219 mod 2
                                        high_x = HzToPixel2(dsp.GetDSPTX(0).TXFilterHigh);//.219 mod 2
                                    }
                                    else if (rx2_dsp_mode != DSPMode.DRM)
                                    {
                                        low_x = HzToPixel2(dsp.GetDSPRX(1, 0).RXFilterLow);//.219 mod 2
                                        high_x = HzToPixel2(dsp.GetDSPRX(1, 0).RXFilterHigh);//.219 mod 2
                                    }
                                }
                                else
                                {

                                    N1MM_RX2 = false; //.219
                                    if (mox && chkVFOATX.Checked)
                                    {
                                        low_x = HzToPixel(dsp.GetDSPTX(0).TXFilterLow);
                                        high_x = HzToPixel(dsp.GetDSPTX(0).TXFilterHigh);
                                    }
                                    else if (rx1_dsp_mode != DSPMode.DRM)
                                    {
                                        low_x = HzToPixel(dsp.GetDSPRX(0, 0).RXFilterLow);
                                        high_x = HzToPixel(dsp.GetDSPRX(0, 0).RXFilterHigh);
                                    }

                                    if (chkEnableMultiRX.Checked && !mox)
                                    {
                                        if (!rx2_enabled)
                                        {
                                            vfoa_sub_x = HzToPixel((float)((VFOBFreq - VFOAFreq) * 1e6));
                                            vfoa_sub_low_x = vfoa_sub_x + (HzToPixel((int)udFilterLow.Value) - HzToPixel(0.0f));
                                            vfoa_sub_high_x = vfoa_sub_x + (HzToPixel((int)udFilterHigh.Value) - HzToPixel(0.0f));
                                        }
                                        else
                                        {
                                            vfoa_sub_x = HzToPixel((float)((VFOASubFreq - VFOAFreq) * 1e6));
                                            vfoa_sub_low_x = vfoa_sub_x + (HzToPixel((int)udFilterLow.Value) - HzToPixel(0.0f));
                                            vfoa_sub_high_x = vfoa_sub_x + (HzToPixel((int)udFilterHigh.Value) - HzToPixel(0.0f));
                                        }
                                    }
                                }

                                if (Math.Abs(e.X - low_x) < 3 && e.X < high_x)
                                {
                                    if ((Display.CurrentDisplayModeBottom != DisplayMode.OFF) && (rx2_enabled) && (e.Y > H7)) // ke9ns mod
                                    {
                                        N1MM_RX2 = true; //.219

                                        if (mox && chkVFOBTX.Checked)
                                        {
                                            switch (dsp.GetDSPTX(0).CurrentDSPMode)
                                            {
                                                case DSPMode.LSB:
                                                case DSPMode.CWL:
                                                case DSPMode.DIGL:
                                                case DSPMode.AM:
                                                case DSPMode.SAM:
                                                case DSPMode.FM:
                                                case DSPMode.DSB:
                                                    tx_high_filter_drag = true;
                                                    break;
                                                default:
                                                    tx_low_filter_drag = true;
                                                    break;
                                            }
                                        }
                                        else rx2_low_filter_drag = true;
                                    }
                                    else
                                    {

                                        N1MM_RX2 = false; //.219
                                        if (mox && (!chkSplitDisplay.Checked || chkVFOATX.Checked))
                                        {
                                            switch (dsp.GetDSPTX(0).CurrentDSPMode)
                                            {
                                                case DSPMode.LSB:
                                                case DSPMode.CWL:
                                                case DSPMode.DIGL:
                                                case DSPMode.AM:
                                                case DSPMode.SAM:
                                                case DSPMode.FM:
                                                case DSPMode.DSB:
                                                    tx_high_filter_drag = true;
                                                    break;
                                                default:
                                                    tx_low_filter_drag = true;
                                                    break;
                                            }
                                        }
                                        else rx1_low_filter_drag = true;
                                    }
                                }
                                else if (Math.Abs(e.X - high_x) < 3)
                                {
                                    if ((Display.CurrentDisplayModeBottom != DisplayMode.OFF) && (rx2_enabled) && (e.Y > H7)) // ke9ns mod
                                    {

                                        N1MM_RX2 = true; //.219
                                        if (mox && chkVFOBTX.Checked)
                                        {
                                            switch (dsp.GetDSPTX(0).CurrentDSPMode)
                                            {
                                                case DSPMode.LSB:
                                                case DSPMode.CWL:
                                                case DSPMode.DIGL:
                                                    tx_low_filter_drag = true;
                                                    break;
                                                default:
                                                    tx_high_filter_drag = true;
                                                    break;
                                            }
                                        }
                                        else rx2_high_filter_drag = true;
                                    }
                                    else if (mox && (!chkSplitDisplay.Checked || (chkSplitDisplay.Checked && chkVFOATX.Checked)))
                                    {
                                        N1MM_RX2 = false; //.219
                                        switch (dsp.GetDSPTX(0).CurrentDSPMode)
                                        {
                                            case DSPMode.LSB:
                                            case DSPMode.CWL:
                                            case DSPMode.DIGL:
                                                tx_low_filter_drag = true;
                                                break;
                                            default:
                                                tx_high_filter_drag = true;
                                                break;
                                        }
                                        // thank you for calling flexradio systems sales dept.  We are out for the holidays and will get back to you on Monday.  Thanks and have a great weekend.
                                    }
                                    else rx1_high_filter_drag = true;
                                }
                                else if (e.X > low_x && e.X < high_x)
                                {
                                    whole_filter_start_x = e.X;
                                    if ((Display.CurrentDisplayModeBottom != DisplayMode.OFF) && (rx2_enabled) && (e.Y > H7)) // ke9ns mod
                                    {
                                        N1MM_RX2 = true; //.219
                                        if (mox && chkVFOBTX.Checked)
                                        {
                                            tx_whole_filter_drag = true;
                                            whole_filter_start_low = setupForm.TXFilterLow;
                                            whole_filter_start_high = setupForm.TXFilterHigh;
                                        }
                                        else
                                        {
                                            rx2_whole_filter_drag = true;
                                            whole_filter_start_low = dsp.GetDSPRX(1, 0).RXFilterLow;
                                            whole_filter_start_high = dsp.GetDSPRX(1, 0).RXFilterHigh;
                                        }
                                    }
                                    else
                                    {
                                        N1MM_RX2 = false; //.219
                                        if (!mox)
                                        {
                                            rx1_whole_filter_drag = true;
                                            whole_filter_start_low = dsp.GetDSPRX(0, 0).RXFilterLow;
                                            whole_filter_start_high = dsp.GetDSPRX(0, 0).RXFilterHigh;
                                        }
                                        else
                                        {
                                            tx_whole_filter_drag = true;
                                            whole_filter_start_low = setupForm.TXFilterLow;
                                            whole_filter_start_high = setupForm.TXFilterHigh;
                                        }
                                    }
                                }
                                else if (chkEnableMultiRX.Checked && !mox && (e.X > vfoa_sub_low_x - 3 && e.X < vfoa_sub_high_x + 3))
                                {
                                    sub_drag_last_x = e.X;
                                    if (rx2_enabled) sub_drag_start_freq = VFOASubFreq;
                                    else sub_drag_start_freq = VFOBFreq;
                                    rx1_sub_drag = true;
                                }
                                else
                                {
                                    spectrum_drag_last_x = e.X;
                                    if ((Display.CurrentDisplayModeBottom != DisplayMode.OFF) && (rx2_enabled) && (e.Y > H7)) rx2_spectrum_drag = true; // ke9ns mod
                                    else rx1_spectrum_drag = true;
                                }
                                /*}
                                else
                                {
                                    spectrum_drag_last_x = e.X;
                                    if(rx2_enabled && e.Y > picDisplay.Height/2) rx2_spectrum_drag = true;
                                    else rx1_spectrum_drag = true;
                                }*/
                                // spaghetti?
                                break;
                        }
                    }
                    break;
                case MouseButtons.Right:
                    double cfreq;

                    if (!mox) // ke9ns .195
                    {
                        if ((e.X < 25)) // ke9ns: see if mouse close to left side dBm scale on Display (adjust Spectrum grid MIN or tbGridoffset)
                        {

                            if (mousestartP == false) //  false do this below only 1 time unless you release the mouse (mouseup)
                            {

                                mouseRight = true;
                                mousestartP = true;
                                mousefirstP_X = e.X;
                                mousefirstP_Y = e.Y; // e.Y;

                                mouseoffsetP_Y = 0; // ke9ns: 

                                Debug.WriteLine("1mouse START0 " + mousefirstP_Y);
                                return;
                            }

                        } //  if (mousestart == false)


                        if (AGCTDIS == true) // ke9ns: if AGCT Green line displayed, then now turn it off
                        {

                            if ((e.X < 150) && (e.Y < Display.AGCT_Y + 15 & e.Y > Display.AGCT_Y - 15)) // ke9ns: see if mouse close to AGCT line
                            {

                                AGCTDIS = false; // shut off.

                            }


                        } //  if (AGCTDIS == true)
                    }

                    if ((regBand == 0))  // ke9ns add (ignore a right click on the picdisplay if a CTRL key held first) wait for mouse button to be let go when ctrl held
                    {
                        int x = e.X; // get mouse pos
                        int y = e.Y; // get mouse pos


                        // ke9ns add this section 
                        if ((SpotControl.SP4_Active == 0) && (SpotControl.SP_Active > 2) && (SpotControl.DX_Index > 0))  // Do below if not in the middle of processing a DX spot, but DX spotting is Active
                        {

                            for (byte ii = 0; ii < DXK; ii++)
                            {

                                if ((x >= DXX[ii]) && (x <= (DXX[ii] + DXW[ii])) && (y >= DXY[ii]) && (y <= (DXY[ii] + DXH[ii])))
                                {

                                    var DXtemp = new StringBuilder("https://www.qrz.com/db/");
                                    DXtemp.Append(DXS[ii]);

                                    try
                                    {

                                        System.Diagnostics.Process.Start(DXtemp.ToString());

                                        //  SpotForm.DX_SELECTED = Display.holder[ii]; //ke9ns add
                                        //  SpotForm.textBox1.SelectionStart = SpotForm.DX_SELECTED * SpotForm.LineLength;      // start of each dx spot line
                                        //  SpotForm.textBox1.SelectionLength = SpotForm.LineLength;                    // length of each dx spot  line

                                        //  SpotForm.textBox1_MouseUp(this, new MouseEventArgs(MouseButtons.Left, 0, 0, 0, 0));

                                    }
                                    catch
                                    {
                                        Debug.WriteLine("bad station");
                                        // if not a URL then ignore
                                    }

                                    return; // if a QRZ spot is found, then done, dont process the right click any further

                                } // index



                            } // for loop

                            if (chkRX2.Checked == true)
                            {
                                for (byte ii = 0; ii < DXK2; ii++)
                                {


                                    if ((x >= DXX[ii + 50]) && (x <= (DXX[ii + 50] + DXW[ii + 50])) && (y >= DXY[ii + 50]) && (y <= (DXY[ii + 50] + DXH[ii + 50])))
                                    {

                                        var DXtemp = new StringBuilder("https://www.qrz.com/db/");
                                        DXtemp.Append(DXS[ii + 50]);

                                        try
                                        {
                                            System.Diagnostics.Process.Start(DXtemp.ToString());

                                        }
                                        catch
                                        {
                                            Debug.WriteLine("bad station");
                                            // if not a URL then ignore
                                        }

                                        return; // break;

                                    } // index



                                } // for loop

                            } // rx2 checked on 


                        } // sp4  QRZ lookup for DX spot RX1 and RX2 above



                        //-------------------------------------------------------------
                        //ke9ns memory in Pan
                        if ((SpotControl.SP6_Active == 1))
                        {
                            // int x = DX_X;
                            //  int y = DX_Y;


                            for (int ii = 0; ii < MMK3; ii++) // check all spot on Panadapter
                            {

                                if ((x >= MMX[ii]) && (x <= (MMX[ii] + MMW[ii])) && (y >= MMY[ii]) && (y <= (MMY[ii] + MMH[ii])))
                                {
                                    //  Debug.WriteLine("MEMORY: " + MMC[ii ]);

                                    if (MMC[ii].Contains("http") == true)
                                    {
                                        //  var SXtemp = new StringBuilder("https://www.google.com/search?q=");
                                        // SXtemp.Append(SXS[ii] + " shortwave");

                                        try
                                        {
                                            System.Diagnostics.Process.Start(MMC[ii].ToString());
                                        }
                                        catch
                                        {
                                            Debug.WriteLine("bad station");
                                        }

                                        return;
                                    }

                                } // index

                            } // for loop

                            //-------------------------------------------------------

                            if (chkRX2.Checked == true)  // check RX2 click
                            {
                                for (int ii = 0; ii < MMK4; ii++)
                                {

                                    if ((x >= MMX[ii + 50]) && (x <= (MMX[ii + 50] + DXW[ii + 50])) && (y >= MMY[ii + 50]) && (y <= (MMY[ii + 50] + MMH[ii + 50])))
                                    {
                                        //  Debug.WriteLine("MEMORY: "+ MMC[ii + 50]);

                                        if (MMC[ii + 50].Contains("http") == true)
                                        {
                                            //  var SXtemp = new StringBuilder("https://www.google.com/search?q=");
                                            // SXtemp.Append(SXS[ii] + " shortwave");

                                            try
                                            {
                                                System.Diagnostics.Process.Start(MMC[ii + 50].ToString());
                                            }
                                            catch
                                            {
                                                Debug.WriteLine("bad station");
                                            }

                                            return;
                                        }
                                    } // index


                                } // for loop

                            } // rx2 checked on 


                        } // memory ON pAN ACTIVE

                        //---------------------------------------------------------------------------------
                        //---------------------------------------------------------------------------------
                        //---------------------------------------------------------------------------------
                        //---------------------------------------------------------------------------------
                        //ke9ns: SWL lookup on google (mouse down right click)

                        if ((SpotControl.SP1_Active == 1))
                        {

                            Debug.WriteLine("SWL RIGHT CLICK test==== " + SXK + " , " + x + " , " + y);

                            //  int x = DX_X;
                            //  int y = DX_Y;

                            for (byte ii = 0; ii < SXK; ii++)
                            {

                                if ((x >= SXX[ii]) && (x <= (SXX[ii] + SXW[ii])) && (y >= SXY[ii]) && (y <= (SXY[ii] + SXH[ii])))
                                {
                                    Debug.WriteLine("FOUND STATION ==== " + SXS[ii]);

                                    var SXtemp = new StringBuilder("https://www.google.com/search?q=");
                                    SXtemp.Append(SXS[ii] + " shortwave");

                                    try
                                    {
                                        System.Diagnostics.Process.Start(SXtemp.ToString());
                                    }
                                    catch
                                    {
                                        Debug.WriteLine("bad station");
                                    }

                                    return;

                                } // index

                            } // for loop

                        } //  if ((SpotControl.SP3_Active == 1) && (SpotControl.SP1_Active ==1))



                        //---------------------------------------------------------
                        int clow = (int)PixelToHz(e.X - 3);
                        int chigh = (int)PixelToHz(e.X + 3);

                        if ((Display.CurrentDisplayModeBottom != DisplayMode.OFF) && (rx2_enabled) && (e.Y > H7)) // ke9ns mod
                        {
                            clow = (int)PixelToHz2(e.X - 3);
                            chigh = (int)PixelToHz2(e.X + 3);


                            cfreq = VFOBFreq;
                            switch (rx2_dsp_mode)
                            {
                                case DSPMode.CWU: cfreq -= cw_pitch * 1e-6; break;
                                case DSPMode.CWL: cfreq += cw_pitch * 1e-6; break;
                            }
                        }
                        else
                        {
                            cfreq = VFOAFreq;
                            switch (rx1_dsp_mode)
                            {
                                case DSPMode.CWU: cfreq -= cw_pitch * 1e-6; break;
                                case DSPMode.CWL: cfreq += cw_pitch * 1e-6; break;
                            }
                        }


#if (!NO_TNF)
                        List<Notch> lst = NotchList.NotchesInBW(cfreq, clow, chigh);



                        if ((lst.Count > 0) && (!mox))
                        {
                            // make sure we have a check mark on remembered in the context menu if necessary
                            toolStripNotchRemember.Checked = lst[0].Permanent;
                            // display the pop-up
                            contextMenuStripNotch.Show(Cursor.Position);
                            Context_Notch = lst[0];

                            if (toolStripNotchNormal.Checked) lst[0].Depth = 1; // ke9ns add this section
                            else if (toolStripNotchDeep.Checked) lst[0].Depth = 2;
                            else lst[0].Depth = 3;

                            toolStripNotchNormal.Checked = (lst[0].Depth == 1);
                            toolStripNotchDeep.Checked = (lst[0].Depth == 2);
                            toolStripNotchVeryDeep.Checked = (lst[0].Depth == 3);
                        }
                        else
#endif
                        {
                            switch (current_click_tune_mode)
                            {
                                case ClickTuneMode.Off:
                                    CurrentClickTuneMode = ClickTuneMode.VFOA;
                                    break;
                                case ClickTuneMode.VFOA:
                                    if (chkVFOSplit.Checked || chkEnableMultiRX.Checked)
                                        CurrentClickTuneMode = ClickTuneMode.VFOB;
                                    else
                                        CurrentClickTuneMode = ClickTuneMode.Off;
                                    break;
                                case ClickTuneMode.VFOB:
                                    CurrentClickTuneMode = ClickTuneMode.Off;
                                    break;
                            }
                        }
                    } // regband == 0
                    break;  // right button
                case MouseButtons.Middle:
                    if (mouse_tune_step)
                    {
                        if (shift_down) ChangeTuneStepDown();
                        else ChangeTuneStepUp();
                    }
                    break;



            } // switch e.button

        } //picdisplay mouse down


        //=================================================================================================
        // ke9ns mod 


        public static int[] SXX = new int[200]; // x ke9ns add used for qrz hyperlinking(these are the SWL locations on the screen)
        public static int[] SXY = new int[400]; // y
        public static int[] SXW = new int[400]; // width
        public static int[] SXH = new int[400]; // height
        public static int[] SXF = new int[400]; // freq
        public static string[] SXM = new string[400]; // mode

        public static string[] SXS = new string[400]; // ties it back to the real DX_Index
        public static int SXK = 0;               // number of spots on picdisplay RX1
        public static int SXK2 = 0;               // number of spots on picdisplay RX2
        public static int SXR = 0;               // 1=doing an QRZ hyperlink
        public static int SX_X = 0;               //x cursor pos inside picdisplay
        public static int SX_Y = 0;               //y  cursor pos inside picdisplay


        public static int[] DXX = new int[200]; // ke9ns add used for qrz hyperlinking(these are the dx spot callsign locations on the screen)
        public static int[] DXY = new int[200]; // 
        public static int[] DXW = new int[200]; //
        public static int[] DXH = new int[200]; //  
        public static string[] DXS = new string[200]; // ties it back to the real DX_Index
        public static int DXK = 0;               // number of spots on picdisplay RX1
        public static int DXK2 = 0;               // number of spots on picdisplay RX2
        public static int DXR = 0;               // 1=display SPOTTER call on screen instead of DX spot call, 0=DX Spot only


        public static int[] MMX = new int[200]; // ke9ns add X used for MEMORY hyperlinking(these are the callsign locations on the screen)
        public static int[] MMY = new int[200]; //           Y
        public static int[] MMW = new int[200]; //           W
        public static int[] MMH = new int[200]; //           H
        public static int[] MMM = new int[200]; //           Index postion in Memory.xml file
        public static string[] MMS = new string[200]; // ties it back to the real MEMORY NAME
        public static string[] MMC = new string[200]; // ties it back to the real memory comments hyperlink
        public static int MMK3 = 0;               // number of MEMORY spots on picdisplay RX1
        public static int MMK4 = 0;               // number of spots on picdisplay RX2


        public static int DX_X = 0;               //x cursor pos inside picdisplay e.X from a mousemove
        public static int DX_Y = 0;               //y  cursor pos inside picdisplay e.Y 

        // public static int CTM = 0;

        private void picDisplay_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
        {

            this.toolTip1.SetToolTip(this.picDisplay, ""); // ke9ns .195 turn off Spectrum Grid Min/Max tooltip values



            mousestart = false; // ke9ns add: .134 AGCT green line display. You let go mouse, so your no longer moving the line
            mousestartP = false; // ke9ns add: .141 grab pan side display. You let go mouse, so your no longer moving the line
            mousestartS = false; // ke9ns add: .193 grab pan bar between pan and water. You let go mouse, so your no longer resize the PanaFall8020
                                 //  mouseinS = false;//

            mousewaitS = true; // ke9ns add: .193

            if (e.Button == MouseButtons.Left)
            {
                switch (Display.CurrentDisplayMode)
                {
                    case DisplayMode.PANADAPTER:
                    case DisplayMode.WATERFALL:
                    case DisplayMode.PANAFALL:
                    case DisplayMode.PANASCOPE:
                        rx1_low_filter_drag = false;
                        rx1_high_filter_drag = false;
                        rx1_whole_filter_drag = false;
                        rx2_low_filter_drag = false;
                        rx2_high_filter_drag = false;
                        rx2_whole_filter_drag = false;
                        tx_low_filter_drag = false;
                        tx_high_filter_drag = false;
                        tx_whole_filter_drag = false;

#if (!NO_TNF)
                        notch_drag = false;
                        notch_drag_max_delta_x = 0;
                        notch_drag_max_delta_y = 0;
                        timerNotchZoom.Enabled = false;
                        notch_zoom = false;

                        if (Display.TNFZoom)
                        {
                            Display.TNFZoom = false; // ke9ns turn off ZOOM feature when you let go of mouse button
                        }

                        // stop showing details for this notch in the panadapter
                        if (notch_drag_active != null)
                        {
                            notch_drag_active.Details = false;
                            notch_drag_active = null;
                        }
#endif
                        //rx2_sub_drag = false;
                        break;
                }

                if (rx1_sub_drag)
                {
                    rx1_sub_drag = false;
                    if (rx2_enabled) txtVFOABand_LostFocus(this, EventArgs.Empty);
                    else txtVFOBFreq_LostFocus(this, EventArgs.Empty);
                }

                if (rx1_spectrum_drag)
                {
                    rx1_spectrum_drag = false;
                    txtVFOBFreq_LostFocus(this, EventArgs.Empty);
                    txtVFOAFreq_LostFocus(this, EventArgs.Empty);
                }
                rx2_spectrum_drag = false;
                //Cursor = Cursors.Default;

                //picDisplay_MouseMove(this, e);
            } // left click

            //--------------------------------------------------------
            // ke9ns: add hyperlink of SWL spots to google or DX Spots to QRZ

            else if (e.Button == MouseButtons.Right)
            {
                //  Debug.WriteLine("RIGHT CLICK "+regBand);



                if ((regBand == 1) && (e.Button == System.Windows.Forms.MouseButtons.Right)) //   indicates you must hold the CTRL key to set regBand = 1 
                {
                    regBand = 0;


                    // moved to mousedown routine



                } // hit ctrl key and right click



            } // Right click



        } //picDisplay mouseup



        private void picDisplay_DoubleClick(object sender, System.EventArgs e)
        {

            if ((chkRX2.Checked &&
                (display_cursor_y < H7 && rx1_dsp_mode == DSPMode.FM) ||
                (display_cursor_y >= H7 && rx2_dsp_mode == DSPMode.FM))
                 || !chkRX2.Checked && rx1_dsp_mode == DSPMode.FM)
                return;

            int new_val = (int)PixelToDb(display_cursor_y);

            if (!mox && chkRX2.Checked && display_cursor_y < H7) // ke9ns mod RX2
            {
                if (rx2_dsp_mode == DSPMode.FM)
                    return;

                if (new_val > ptbRX2Squelch.Maximum) new_val = ptbRX2Squelch.Maximum;
                if (new_val < ptbRX2Squelch.Minimum) new_val = ptbRX2Squelch.Minimum;
                ptbRX2Squelch.Value = new_val;
                ptbRX2Squelch_Scroll(this, EventArgs.Empty);
            }
            else if (!mox) // RX1
            {
                if (rx1_dsp_mode == DSPMode.FM)
                    return;

                if (new_val > ptbSquelch.Maximum) new_val = ptbSquelch.Maximum;
                if (new_val < ptbSquelch.Minimum) new_val = ptbSquelch.Minimum;
                ptbSquelch.Value = new_val;
                ptbSquelch_Scroll(this, EventArgs.Empty);
            }
            else // TX
            {
                new_val += 24;
                if (new_val > ptbNoiseGate.Maximum) new_val = ptbNoiseGate.Maximum;
                if (new_val < ptbNoiseGate.Minimum) new_val = ptbNoiseGate.Minimum;
                ptbNoiseGate.Value = new_val;
                ptbNoiseGate_Scroll(this, EventArgs.Empty);
            }

        } // picDisplay_DoubleClick



        private void picDisplay_Resize(object sender, System.EventArgs e)
        {
            //  Debug.WriteLine("picDisplay RESIZE  here");

            Display.Target = picDisplay;
            Display.Init();
            //Display.DrawBackground();
            UpdateDisplay();

            H10 = picDisplay.Height; // ke9ns add .197 (always show the full height of the display area
            Debug.WriteLine("H10 " + H10);

            // ke9ns: Panafall
            if (setupForm.udSS2H.Value < -((decimal)(H10 / 2) * .70M)) // .197
            {
                mousestartS = false;
                mousewaitS = false;

                setupForm.udSS2H.Value = -((decimal)(H10 / 2) * .69M);
                mouseholdYY = (int)setupForm.udSS2H.Value;
            }
            else if (setupForm.udSS2H.Value > ((decimal)(H10 / 2) * .80M)) // .197
            {
                mousestartS = false;
                mousewaitS = false;

                setupForm.udSS2H.Value = ((decimal)(H10 / 2) * .79M);
                mouseholdYY = (int)setupForm.udSS2H.Value;
            }

            // ke9ns: panafall 8020
            if (setupForm.udSS1H.Value < -((decimal)(H10 * 5 / 6) * .2M)) // .197
            {
                mousestartS = false;
                mousewaitS = false;

                setupForm.udSS1H.Value = -((decimal)(H10 * 5 / 6) * .19M);
                mouseholdY = (int)setupForm.udSS1H.Value;
            }
            else if (setupForm.udSS1H.Value > ((decimal)(H10 * 5 / 6) * .1M)) // .197
            {
                mousestartS = false;
                mousewaitS = false;

                setupForm.udSS1H.Value = ((decimal)(H10 * 5 / 6) * .09M);
                mouseholdY = (int)setupForm.udSS1H.Value;
            }

        } // picDisplay_Resize

        private void ptbDisplayPan_Scroll(object sender, System.EventArgs e)
        {
            //  CTUN1_HZ = 0; // ke9ns add

            CalcDisplayFreq();
            if (ptbDisplayPan.Focused) btnHidden.Focus();


        }

        private void ptbDisplayPan2_Scroll(object sender, System.EventArgs e) //.219 add
        {
            CalcDisplayFreq();
            if (ptbDisplayPan2.Focused) btnHidden.Focus();

        } // ptbDisplayPan2_Scroll

        private void btnDisplayPanCenter_Click(object sender, System.EventArgs e)
        {
            //double edge_alias = 7200.0;
            //double if_freq = 11025.0;

            CTUN1_HZ = 0; // reset CTUN to center

            double spur_tune_width = 200e6 / Math.Pow(2, 16);
            if (fwc_init && (current_model == Model.FLEX5000 || current_model == Model.FLEX3000))
                spur_tune_width = 500e6 / Math.Pow(2, 16);

            int width = Display.RXDisplayHigh - Display.RXDisplayLow;

            int max_pan_width = (int)(sample_rate1 - 2 * spur_tune_width - width);
            if (max_pan_width == 0)
            {
                ptbDisplayPan.Value = (ptbDisplayPan.Maximum - ptbDisplayPan.Minimum) / 2;
                ptbDisplayPan_Scroll(btnDisplayPanCenter, EventArgs.Empty);
                return;
            }

            int low = -width / 2; // target -- if width is centered at 0, low will be half the width below 0
            int abs_low = (int)(-(double)sample_rate1 * 0.5 - if_freq * 1e6 + spur_tune_width);
            int offset = low - abs_low;

            int new_val = (int)((double)offset * (double)ptbDisplayPan.Maximum / (double)max_pan_width);
            ptbDisplayPan.Value = Math.Min(Math.Max(ptbDisplayPan.Minimum, new_val), ptbDisplayPan.Maximum);
            ptbDisplayPan_Scroll(btnDisplayPanCenter, EventArgs.Empty);

        } // btnDisplayPanCenter_Click


        private void ptbDisplayZoom_Scroll(object sender, System.EventArgs e) // 10 to 240  
        {
            double zoom_factor = 1.0 / ((ptbDisplayZoom.Maximum + ptbDisplayZoom.Minimum - ptbDisplayZoom.Value) * 0.01); // ke9ns: 1/(260 - value)*.01 =   LEFT=.3846 <---> RIGHT= 10

            //   double zoom_factor = 1.0 / ((240 + 10 - ptbDisplayZoom.Value) * 0.01); // ke9ns: 1/(250 - value)*.01 =   LEFT=.4166 <---> RIGHT= 10

            Debug.WriteLine("zoom factor " + zoom_factor);
            if (zoom_factor == 0.5) radDisplayZoom05.Checked = true;
            else if (zoom_factor == 1.0) radDisplayZoom1x.Checked = true;
            else if (zoom_factor == 2.0) radDisplayZoom2x.Checked = true;
            else if (zoom_factor == 4.0) radDisplayZoom4x.Checked = true; // x4
            else
            {
                radDisplayZoom05.Checked = false;
                radDisplayZoom1x.Checked = false;
                radDisplayZoom2x.Checked = false;
                radDisplayZoom4x.Checked = false;
            }

            Debug.WriteLine("====0zoom factor");

            CalcDisplayFreq();

            if (ptbDisplayZoom.Focused) btnHidden.Focus();
            if (ptbDisplayZoom2.Focused) btnHidden.Focus();
            Debug.WriteLine("====1zoom factor");
        }


        private void radDisplayZoom05_CheckedChanged(object sender, System.EventArgs e)
        {
            if (radDisplayZoom05.Checked)
            {
                ptbDisplayZoom.Value = ptbDisplayZoom.Maximum + ptbDisplayZoom.Minimum - (int)(100.0 / 0.5);
                ptbDisplayZoom_Scroll(this, EventArgs.Empty);
                btnDisplayPanCenter_Click(this, EventArgs.Empty);
            }
        }

        private void radDisplayZoom1x_CheckedChanged(object sender, System.EventArgs e)
        {
            if (radDisplayZoom1x.Checked)
            {
                ptbDisplayZoom.Value = ptbDisplayZoom.Maximum + ptbDisplayZoom.Minimum - (int)(100.0 / 1.0);
                ptbDisplayZoom_Scroll(this, EventArgs.Empty);
                btnDisplayPanCenter_Click(this, EventArgs.Empty);
            }
        }

        private void radDisplayZoom2x_CheckedChanged(object sender, System.EventArgs e)
        {
            if (radDisplayZoom2x.Checked)
            {
                ptbDisplayZoom.Value = ptbDisplayZoom.Maximum + ptbDisplayZoom.Minimum - (int)(100.0 / 2.0);
                ptbDisplayZoom_Scroll(this, EventArgs.Empty);
                btnDisplayPanCenter_Click(this, EventArgs.Empty);
            }
        }

        private void radDisplayZoom4x_CheckedChanged(object sender, System.EventArgs e)
        {
            if (radDisplayZoom4x.Checked)
            {
                ptbDisplayZoom.Value = ptbDisplayZoom.Maximum + ptbDisplayZoom.Minimum - (int)(100.0 / 4.0); //
                ptbDisplayZoom_Scroll(this, EventArgs.Empty);
                btnDisplayPanCenter_Click(this, EventArgs.Empty);
            }


        }

        #endregion

        #region Band Button Events
        // ======================================================
        // Band Button Events
        // ======================================================

        private void radBand160_Click(object sender, EventArgs e)
        {

            SaveBandA(); // ke9ns save freq you were on prior to coming here
            if (last_band.Equals("160M"))
            {
                if ((Control.ModifierKeys & Keys.Shift) == Keys.Shift)
                    band_160m_index = (band_160m_index - 1 + band_160m_register) % band_160m_register;
                else
                    band_160m_index = (band_160m_index + 1) % band_160m_register;
            }
            last_band = "160M";

            string filter, mode;
            double freq;
            if (DB.GetBandStack(last_band, band_160m_index, out mode, out filter, out freq))
            {
                if (filter.Contains("@"))
                {
                    filter = filter.Substring(0, (filter.Length) - 1); // ke9ns add for bandstack lockout
                }
                SetBand(mode, filter, freq);
            }
            UpdateWaterfallLevelValues();
        }

        private void radBand80_Click(object sender, EventArgs e)
        {
            SaveBandA();
            if (last_band.Equals("80M"))
            {
                if ((Control.ModifierKeys & Keys.Shift) == Keys.Shift)
                    band_80m_index = (band_80m_index - 1 + band_80m_register) % band_80m_register;
                else
                    band_80m_index = (band_80m_index + 1) % band_80m_register;
            }
            last_band = "80M";

            string filter, mode;
            double freq;
            if (DB.GetBandStack(last_band, band_80m_index, out mode, out filter, out freq))
            {
                if (filter.Contains("@"))
                {
                    filter = filter.Substring(0, (filter.Length) - 1); // ke9ns add for bandstack lockout
                }
                SetBand(mode, filter, freq);
            }
            UpdateWaterfallLevelValues();
        }

        private void radBand60_Click(object sender, EventArgs e)
        {
            /* if (RX1IsIn60m() && !RX1IsOn60mChannel())
             {
                 // jump to nearest 60m band
                 double jump_freq = 0;
                 double min_delta = double.MaxValue;
                 double offset = ModeFreqOffset(rx1_dsp_mode);
                 int index = 0;
                 int min_index = 0;
                 foreach (Channel c in Display.Channels60m)
                 {
                     double freq = c.Freq + offset;
                     double delta = Math.Abs(freq-VFOAFreq);
                     if (delta < min_delta)
                     {
                         min_delta = delta;
                         jump_freq = freq;
                         min_index = index;
                     }
                     index++;
                 }

                 VFOAFreq = jump_freq;
                 band_60m_index = min_index; // sets the band stack index
                 last_band = "60M";
             }
             else
             { */
            SaveBandA();
            if (last_band.Equals("60M"))
            {
                if ((Control.ModifierKeys & Keys.Shift) == Keys.Shift)
                    band_60m_index = (band_60m_index - 1 + band_60m_register) % band_60m_register;
                else
                    band_60m_index = (band_60m_index + 1) % band_60m_register;
            }
            last_band = "60M";

            string filter, mode;
            double freq;
            if (DB.GetBandStack(last_band, band_60m_index, out mode, out filter, out freq))
            {
                if (filter.Contains("@"))
                {
                    filter = filter.Substring(0, (filter.Length) - 1); // ke9ns add for bandstack lockout
                }
                SetBand(mode, filter, freq);
            }
            /*  } */
            UpdateWaterfallLevelValues();
        }

        private void radBand40_Click(object sender, EventArgs e)
        {
            SaveBandA();

            if (last_band.Equals("40M"))
            {
                if ((Control.ModifierKeys & Keys.Shift) == Keys.Shift)
                    band_40m_index = (band_40m_index - 1 + band_40m_register) % band_40m_register;
                else
                    band_40m_index = (band_40m_index + 1) % band_40m_register;
            }
            last_band = "40M";

            string filter, mode;
            double freq;
            if (DB.GetBandStack(last_band, band_40m_index, out mode, out filter, out freq))
            {
                if (filter.Contains("@"))
                {
                    filter = filter.Substring(0, (filter.Length) - 1); // ke9ns add for bandstack lockout
                }
                SetBand(mode, filter, freq);
            }
            UpdateWaterfallLevelValues();
        }

        private void radBand30_Click(object sender, EventArgs e)
        {
            SaveBandA();
            if (last_band.Equals("30M"))
            {
                if ((Control.ModifierKeys & Keys.Shift) == Keys.Shift)
                    band_30m_index = (band_30m_index - 1 + band_30m_register) % band_30m_register;
                else
                    band_30m_index = (band_30m_index + 1) % band_30m_register;
            }
            last_band = "30M";

            string filter, mode;
            double freq;
            if (DB.GetBandStack(last_band, band_30m_index, out mode, out filter, out freq))
            {
                if (filter.Contains("@"))
                {
                    filter = filter.Substring(0, (filter.Length) - 1); // ke9ns add for bandstack lockout
                }
                SetBand(mode, filter, freq);
            }
            UpdateWaterfallLevelValues();
        }

        private void radBand20_Click(object sender, EventArgs e)
        {

            SaveBandA();


            if (last_band.Equals("20M"))
            {
                if ((Control.ModifierKeys & Keys.Shift) == Keys.Shift)
                    band_20m_index = (band_20m_index - 1 + band_20m_register) % band_20m_register;
                else
                    band_20m_index = (band_20m_index + 1) % band_20m_register;
            }
            last_band = "20M";


            string filter, mode;
            double freq;

            if (DB.GetBandStack(last_band, band_20m_index, out mode, out filter, out freq))
            {
                if (filter.Contains("@"))
                {
                    filter = filter.Substring(0, (filter.Length) - 1); // ke9ns add for bandstack lockout
                }


                SetBand(mode, filter, freq);


            }

            UpdateWaterfallLevelValues();


        }

        private void radBand17_Click(object sender, EventArgs e)
        {
            SaveBandA();
            if (last_band.Equals("17M"))
            {
                if ((Control.ModifierKeys & Keys.Shift) == Keys.Shift)
                    band_17m_index = (band_17m_index - 1 + band_17m_register) % band_17m_register;
                else
                    band_17m_index = (band_17m_index + 1) % band_17m_register;
            }
            last_band = "17M";

            string filter, mode;
            double freq;
            if (DB.GetBandStack(last_band, band_17m_index, out mode, out filter, out freq))
            {
                if (filter.Contains("@")) filter = filter.Substring(0, (filter.Length) - 1); // ke9ns add for bandstack lockout

                SetBand(mode, filter, freq);
            }
            UpdateWaterfallLevelValues();

        }

        private void radBand15_Click(object sender, EventArgs e)
        {
            SaveBandA();
            if (last_band.Equals("15M"))
            {
                if ((Control.ModifierKeys & Keys.Shift) == Keys.Shift)
                    band_15m_index = (band_15m_index - 1 + band_15m_register) % band_15m_register;
                else
                    band_15m_index = (band_15m_index + 1) % band_15m_register;
            }
            last_band = "15M";

            string filter, mode;
            double freq;
            if (DB.GetBandStack(last_band, band_15m_index, out mode, out filter, out freq))
            {
                if (filter.Contains("@")) filter = filter.Substring(0, (filter.Length) - 1); // ke9ns add for bandstack lockout

                SetBand(mode, filter, freq);
            }
            UpdateWaterfallLevelValues();
        }

        private void radBand12_Click(object sender, EventArgs e)
        {
            SaveBandA();
            if (last_band.Equals("12M"))
            {
                if ((Control.ModifierKeys & Keys.Shift) == Keys.Shift)
                    band_12m_index = (band_12m_index - 1 + band_12m_register) % band_12m_register;
                else
                    band_12m_index = (band_12m_index + 1) % band_12m_register;
            }
            last_band = "12M";

            string filter, mode;
            double freq;
            if (DB.GetBandStack(last_band, band_12m_index, out mode, out filter, out freq))
            {
                if (filter.Contains("@")) filter = filter.Substring(0, (filter.Length) - 1); // ke9ns add for bandstack lockout

                SetBand(mode, filter, freq);
            }
            UpdateWaterfallLevelValues();
        }

        private void radBand10_Click(object sender, EventArgs e)
        {
            SaveBandA();
            if (last_band.Equals("10M"))
            {
                if ((Control.ModifierKeys & Keys.Shift) == Keys.Shift)
                    band_10m_index = (band_10m_index - 1 + band_10m_register) % band_10m_register;
                else
                    band_10m_index = (band_10m_index + 1) % band_10m_register;
            }
            last_band = "10M";

            string filter, mode;
            double freq;
            if (DB.GetBandStack(last_band, band_10m_index, out mode, out filter, out freq))
            {
                if (filter.Contains("@")) filter = filter.Substring(0, (filter.Length) - 1); // ke9ns add for bandstack lockout

                SetBand(mode, filter, freq);
            }
            UpdateWaterfallLevelValues();
        }

        private void radBand6_Click(object sender, EventArgs e)
        {
            SaveBandA();
            if (last_band.Equals("6M"))
            {
                if ((Control.ModifierKeys & Keys.Shift) == Keys.Shift)
                    band_6m_index = (band_6m_index - 1 + band_6m_register) % band_6m_register;
                else
                    band_6m_index = (band_6m_index + 1) % band_6m_register;
            }
            last_band = "6M";

            string filter, mode;
            double freq;
            if (DB.GetBandStack(last_band, band_6m_index, out mode, out filter, out freq))
            {
                if (filter.Contains("@")) filter = filter.Substring(0, (filter.Length) - 1); // ke9ns add for bandstack lockout

                SetBand(mode, filter, freq);
            }
            UpdateWaterfallLevelValues();
        }

        // ke9ns mod
        private void radBand2_Click(object sender, EventArgs e)
        {
            SaveBandA();
            /*
            if (last_band.Equals("2M"))
            {
                if ((Control.ModifierKeys & Keys.Shift) == Keys.Shift)
                    band_2m_index = (band_2m_index - 1 + band_2m_register) % band_2m_register;
                else
                    band_2m_index = (band_2m_index + 1) % band_2m_register;
            }
            last_band = "2M";

            string filter, mode;
            double freq;
            if (DB.GetBandStack(last_band, band_2m_index, out mode, out filter, out freq))
            {
                if (filter.Contains("@")) filter = filter.Substring(0, (filter.Length) - 1); // ke9ns add for bandstack lockout

                SetBand(mode, filter, freq);
            }

            */
            RX1DSPMode = DSPMode.DIGU;
            RX1Filter = Filter.F5;
            VFOAFreq = 0.472;
            UpdateWaterfallLevelValues();
        }

        private void radBandWWV_Click(object sender, EventArgs e)
        {
            SaveBandA();
            if (last_band.Equals("WWV"))
            {
                if ((Control.ModifierKeys & Keys.Shift) == Keys.Shift)
                    band_wwv_index = (band_wwv_index - 1 + band_wwv_register) % band_wwv_register;
                else
                    band_wwv_index = (band_wwv_index + 1) % band_wwv_register;
            }
            last_band = "WWV";

            string filter, mode;
            double freq;
            if (DB.GetBandStack(last_band, band_wwv_index, out mode, out filter, out freq))
            {
                if (filter.Contains("@")) filter = filter.Substring(0, (filter.Length) - 1); // ke9ns add for bandstack lockout

                SetBand(mode, filter, freq);
            }
            UpdateWaterfallLevelValues();
        }


        //=============================================================================================
        private void radBandGEN_Click(object sender, EventArgs e)
        {

            return; // ke9ns add

            // ke9ns original code below
            /*
                        SaveBandA();

                        if (last_band == "GEN")
                        {
                            if ((Control.ModifierKeys & Keys.Shift) == Keys.Shift)
                                band_gen_index = (band_gen_index - 1 + band_gen_register) % band_gen_register;
                            else
                                band_gen_index = (band_gen_index + 1) % band_gen_register;
                        }
                        last_band = "GEN";

                        string filter, mode;
                        double freq;
                        if (DB.GetBandStack(last_band, band_gen_index, out mode, out filter, out freq))
                        {
                             if (filter.Contains("@"))  filter = filter.Substring(0, (filter.Length) - 1); // ke9ns add for bandstack lockout

                            SetBand(mode, filter, freq);
                        }
                        UpdateWaterfallLevelValues();

            */
        }

        /*
        private void radBandGEN_Click(object sender, EventArgs e)
        {
            SaveBandA();
            if (last_band == "GEN")
            {
                if ((Control.ModifierKeys & Keys.Shift) == Keys.Shift)
                    band_gen_index = (band_gen_index - 1 + band_gen_register) % band_gen_register;
                else
                    band_gen_index = (band_gen_index + 1) % band_gen_register;
            }
            last_band = "GEN";

            string filter, mode;
            double freq;
            if (DB.GetBandStack(last_band, band_gen_index, out mode, out filter, out freq))
            {
              if (filter.Contains("@"))  filter = filter.Substring(0, (filter.Length) - 1); // ke9ns add for bandstack lockout

                SetBand(mode, filter, freq);
            }
            UpdateWaterfallLevelValues();
        }

*/
        private void radBandVHF_Click(object sender, EventArgs e)
        {
            SaveBandA();

            string new_band = ((Control)sender).Name.Substring(7); // ke9ns look at button that sent you here and get the last VHF#
            int index = -1, register = -1;

            switch (new_band)
            {
                case "VHF0": index = band_vhf0_index; register = band_vhf0_register; break;
                case "VHF1": index = band_vhf1_index; register = band_vhf1_register; break;
                case "VHF2": index = band_vhf2_index; register = band_vhf2_register; break;
                case "VHF3": index = band_vhf3_index; register = band_vhf3_register; break;
                case "VHF4": index = band_vhf4_index; register = band_vhf4_register; break;
                case "VHF5": index = band_vhf5_index; register = band_vhf5_register; break;
                case "VHF6": index = band_vhf6_index; register = band_vhf6_register; break;
                case "VHF7": index = band_vhf7_index; register = band_vhf7_register; break;
                case "VHF8": index = band_vhf8_index; register = band_vhf8_register; break;
                case "VHF9": index = band_vhf9_index; register = band_vhf9_register; break;
                case "VHF10": index = band_vhf10_index; register = band_vhf10_register; break;
                case "VHF11": index = band_vhf11_index; register = band_vhf11_register; break;
                case "VHF12": index = band_vhf12_index; register = band_vhf12_register; break;
                case "VHF13": index = band_vhf13_index; register = band_vhf13_register; break;
            }

            int xvtr_index = Int32.Parse(new_band.Substring(3));

            double start_freq = xvtrForm.GetBegin(xvtr_index);
            double end_freq = xvtrForm.GetEnd(xvtr_index);

            if (register < 3) // ke9ns: create a bandstack since there is none in the database.cs file
            {
                for (int i = 0; i < 3 - register; i++)
                    DB.AddBandStack(new_band, "USB", "2600", start_freq + i * 0.0010);

                UpdateBandStackRegisters();
                register = 3;
            }
            else
            {
                if (last_band == new_band)
                {
                    if ((Control.ModifierKeys & Keys.Shift) == Keys.Shift)
                        index = (index - 1 + register) % register;
                    else
                        index = (index + 1) % register;
                }

                switch (new_band)
                {
                    case "VHF0": band_vhf0_index = index; break;
                    case "VHF1": band_vhf1_index = index; break;
                    case "VHF2": band_vhf2_index = index; break;
                    case "VHF3": band_vhf3_index = index; break;
                    case "VHF4": band_vhf4_index = index; break;
                    case "VHF5": band_vhf5_index = index; break;
                    case "VHF6": band_vhf6_index = index; break;
                    case "VHF7": band_vhf7_index = index; break;
                    case "VHF8": band_vhf8_index = index; break;
                    case "VHF9": band_vhf9_index = index; break;
                    case "VHF10": band_vhf10_index = index; break;
                    case "VHF11": band_vhf11_index = index; break;
                    case "VHF12": band_vhf12_index = index; break;
                    case "VHF13": band_vhf13_index = index; break;
                }
            }

            last_band = new_band; // ke9ns: let the rest of console know the new band

            string filter, mode;
            double freq;

            for (int i = 0; i < 3; i++)
            {
                DB.GetBandStack(last_band, i, out mode, out filter, out freq);

                if (filter.Contains("@")) filter = filter.Substring(0, (filter.Length) - 1); // ke9ns add for bandstack lockout

                if (freq < start_freq || freq > end_freq)
                    DB.SaveBandStack(last_band, i, mode, filter, start_freq + i * 0.001);
            }

            if (DB.GetBandStack(last_band, index, out mode, out filter, out freq))
            {
                if (filter.Contains("@")) filter = filter.Substring(0, (filter.Length) - 1); // ke9ns add for bandstack lockout

                SetBand(mode, filter, freq);
            }
            UpdateWaterfallLevelValues();
        }

        #endregion

        #region Mode Button Events
        // ======================================================
        // Mode Button Events
        // ======================================================

        public void SetRX1Mode(DSPMode new_mode)
        {

            RX1DSPMODE = new_mode; // .196

            AMSSBmodeFILT = false; // ke9ns add (only SetRX1Filter() can set it to true)

            if (new_mode == DSPMode.FIRST || new_mode == DSPMode.LAST) return;

            DSPMode old_mode = rx1_dsp_mode;


            // ke9ns add
            if (chkVFOSplit.Checked == true)
            {
                if (mox == true)
                {
                    SplitModeTX = new_mode; //  dsp.GetDSPTX(0).CurrentDSPMode = new_mode;
                }
                else
                {
                    SplitModeRX = new_mode;  // rx1_dsp_mode;
                }

            }
            else
            {
                if (mox == false) SplitModeRX = SplitModeTX = new_mode;  // reset them if you turn Split OFF
            }

            Debug.WriteLine("New_mode: " + new_mode);
            Debug.WriteLine("Old_mode: " + old_mode);

            grpVFOBetween.Invalidate();

            string current_txprofile = comboTXProfile.Text;

            dsp.GetDSPRX(0, 0).DSPMode = new_mode;  // set new DSP mode
            dsp.GetDSPRX(0, 1).DSPMode = new_mode; // ke9ns  ( 0,1) sets the multiRX receiver to the same DSP mode


            //    if (disable_split_on_modechange & !initializing) // .227 moved to bottom 
            //   {
            //      if (chkVFOSplit.Checked) chkVFOSplit.Checked = false;
            //  }

            if (chkVFOATX.Checked || !rx2_enabled)
            {
                Audio.TXDSPMode = new_mode;
                dsp.GetDSPTX(0).CurrentDSPMode = new_mode;

                if (fwc_init && (current_model == Model.FLEX5000 || current_model == Model.FLEX3000))
                {

                    FWC.SetTXDSPMode(new_mode);
                }
            }

            Display.RX1DSPMode = new_mode;

            if (fwc_init && (current_model == Model.FLEX5000 || current_model == Model.FLEX3000))
            {
                FWC.SetRX1DSPMode(new_mode);
            }

            double rx1_freq = VFOAFreq;
            int old_txosc = (int)dsp.GetDSPTX(0).TXOsc;

            ptbFilterShift.Value = 0;
            btnFilterShiftReset.BackColor = SystemColors.Control;

            switch (old_mode) // ke9ns put away old TX profile since your changing DSP modes
            {
                case DSPMode.LSB:
                    radModeLSB.BackColor = SystemColors.Control;
                    //  Debug.WriteLine("OLD LSB RADMODE ");

                    if (TXProfileByMode & !initializing) lsb_txprofile = comboTXProfile.Text;

                    break;
                case DSPMode.USB:
                    radModeUSB.BackColor = SystemColors.Control;
                    //  Debug.WriteLine("OLD USB RADMODE ");

                    if (TXProfileByMode & !initializing) usb_txprofile = comboTXProfile.Text;

                    break;
                case DSPMode.DSB:
                    radModeDSB.BackColor = SystemColors.Control;

                    if (TXProfileByMode & !initializing) dsb_txprofile = comboTXProfile.Text;

                    break;
                case DSPMode.CWL:
                    radModeCWL.BackColor = SystemColors.Control;

                    if (TXProfileByMode & !initializing) cwl_txprofile = comboTXProfile.Text;

                    if ((chkVFOATX.Checked || !rx2_enabled) && new_mode != DSPMode.CWU && new_mode != DSPMode.CWL)
                    {
                        moninit = 1;                 // ke9ns add
                        Audio.MON_PRE = mon2_recall; // ke9ns add  do this when coming out of CW mode and need to put MON back in correct setting
                        chkMON.Checked = mon_recall;
                    }

                    if (!RX1IsOn60mChannel())
                    {
                        switch (new_mode)
                        {
                            case DSPMode.USB:
                                rx1_freq -= (cw_pitch * 0.0000010);
                                break;
                            case DSPMode.CWU:
                                break;
                            default:
                                rx1_freq += (cw_pitch * 0.0000010);
                                break;
                        }
                        txtVFOAFreq.Text = rx1_freq.ToString("f6" );
                    }

                    break;
                case DSPMode.CWU:
                    radModeCWU.BackColor = SystemColors.Control;

                    if (TXProfileByMode & !initializing) cwu_txprofile = comboTXProfile.Text;

                    if ((chkVFOATX.Checked || !rx2_enabled) && new_mode != DSPMode.CWL && new_mode != DSPMode.CWU)
                    {
                        moninit = 1; // ke9ns add
                        Audio.MON_PRE = mon2_recall; // ke9ns add  do this when coming out of CW mode and need to put MON back in correct setting
                        chkMON.Checked = mon_recall;
                    }

                    if (!RX1IsOn60mChannel())
                    {
                        switch (new_mode)
                        {
                            case DSPMode.LSB:
                                rx1_freq += (cw_pitch * 0.0000010);
                                break;
                            case DSPMode.CWL:
                                break;
                            default:
                                rx1_freq -= (cw_pitch * 0.0000010);
                                break;
                        }
                        txtVFOAFreq.Text = rx1_freq.ToString("f6" );
                    }

                    break;
                case DSPMode.FM:
                    radModeFMN.BackColor = SystemColors.Control;

                    if (TXProfileByMode & !initializing) fm_txprofile = comboTXProfile.Text;

                    if (chkVFOATX.Checked || chkVFOBTX.Checked || !rx2_enabled)
                    {
                        if ((new_mode != DSPMode.AM) && (new_mode != DSPMode.SAM) && (new_mode != DSPMode.FM))
                        {
                            chkMON.Enabled = true;
                            chkBIN.Enabled = true;
                        }

                        ptbMic_Scroll(this, EventArgs.Empty);
                    }

                    if (new_mode != DSPMode.SPEC || new_mode != DSPMode.DRM)
                        EnableAllFilters();

                    if (!initializing)
                        rx1_fm_squelch_threshold_scroll = ptbSquelch.Value;

                    ptbSquelch.Minimum = -160;
                    ptbSquelch.Maximum = 0;

                    picSquelch.Visible = true;

                    ptbSquelch.Value = rx1_squelch_threshold_scroll;
                    break;

                case DSPMode.AM:
                    radModeAM.BackColor = SystemColors.Control;

                    if (TXProfileByMode & !initializing)
                        am_txprofile = comboTXProfile.Text;

                    if (chkVFOATX.Checked || chkVFOBTX.Checked || !rx2_enabled)
                    {
                        if (new_mode != DSPMode.AM && new_mode != DSPMode.SAM && new_mode != DSPMode.FM)
                        {
                            chkMON.Enabled = true;
                            chkBIN.Enabled = true;
                        }
                    }
                    break;
                case DSPMode.SAM:
                    radModeSAM.BackColor = SystemColors.Control;

                    if (TXProfileByMode & !initializing)
                        sam_txprofile = comboTXProfile.Text;

                    if (chkVFOATX.Checked || chkVFOBTX.Checked || !rx2_enabled)
                    {
                        if (new_mode != DSPMode.AM && new_mode != DSPMode.SAM && new_mode != DSPMode.FM)
                        {
                            chkMON.Enabled = true;
                            chkBIN.Enabled = true;
                        }
                    }
                    break;
                case DSPMode.SPEC:
                    radModeSPEC.BackColor = SystemColors.Control;

                    if (TXProfileByMode & !initializing)
                        spec_txprofile = comboTXProfile.Text;

                    comboDisplayMode.Items.Insert(1, "Panadapter");
                    comboDisplayMode.Items.Insert(5, "Waterfall");
                    ptbFilterShift.Enabled = true;
                    btnFilterShiftReset.Enabled = true;
                    if (new_mode != DSPMode.DRM || new_mode != DSPMode.FM)
                        EnableAllFilters();
                    RX1Filter = rx1_filter;
                    if_shift = true;
                    if (was_panadapter) comboDisplayMode.Text = "Panadapter";
                    else if (was_waterfall) comboDisplayMode.Text = "Waterfall";
                    switch (Display.CurrentDisplayMode)
                    {
                        case DisplayMode.PANADAPTER:
                        case DisplayMode.WATERFALL:
                        case DisplayMode.PANAFALL:
                        case DisplayMode.PANASCOPE:
                            dsp.GetDSPRX(0, 0).SpectrumPreFilter = true;
                            break;
                        default:
                            dsp.GetDSPRX(0, 0).SpectrumPreFilter = false;
                            break;
                    }
                    break;
                case DSPMode.DIGL:
                    radModeDIGL.BackColor = SystemColors.Control;

                    if (TXProfileByMode & !initializing)
                        digl_txprofile = comboTXProfile.Text;

                    if (vac_auto_enable &&
                        new_mode != DSPMode.DIGU &&
                        new_mode != DSPMode.DRM &&
                        new_mode != DSPMode.DIGL)
                    {
                        setupForm.VACEnable = false;
                    }
                    break;
                case DSPMode.DIGU:
                    radModeDIGU.BackColor = SystemColors.Control;

                    if (TXProfileByMode & !initializing)
                        digu_txprofile = comboTXProfile.Text;

                    if (vac_auto_enable &&
                        new_mode != DSPMode.DIGL &&
                        new_mode != DSPMode.DRM &&
                        new_mode != DSPMode.DIGU)
                    {
                        setupForm.VACEnable = false;
                    }
                    break;
                case DSPMode.DRM:
                    radModeDRM.BackColor = SystemColors.Control;

                    if (TXProfileByMode & !initializing) drm_txprofile = comboTXProfile.Text;

                    if_shift = true;
                    vfo_offset = 0.0;
                    if (vac_auto_enable &&
                        new_mode != DSPMode.DIGL &&
                        new_mode != DSPMode.DIGU &&
                        new_mode != DSPMode.DRM)
                    {
                        setupForm.VACEnable = false;
                    }
                    ptbFilterShift.Enabled = true;
                    btnFilterShiftReset.Enabled = true;
                    if (new_mode != DSPMode.SPEC || new_mode != DSPMode.FM)
                        EnableAllFilters();
                    if_freq = setupForm.IFFreq;
                    CalcDisplayFreq();
                    chkTNF.Enabled = true;
                    btnTNFAdd.Enabled = true;
                    break;



            } // SetRX1mode


            //----------------------------------------ke9ns NEW MODE
            switch (new_mode) //ke9ns  load up new TX profile 
            {
                case DSPMode.LSB:
                    radModeLSB.BackColor = button_selected_color;
                    //  Debug.WriteLine("NEW LSB RADMODE ");

                    if ((current_txprofile != lsb_txprofile) & (TXProfileByMode) & !initializing)
                        comboTXProfile.Text = lsb_txprofile;

                    //grpMode.Text = "Mode - LSB";
                    if (!rx_only && chkPower.Checked) chkMOX.Enabled = true;

                    if (chkVFOATX.Checked || !rx2_enabled)
                    {
                        //   Debug.WriteLine("LSB HIGH-LOW: " + tx_filter_high + " , " + tx_filter_low + " mode: " + new_mode + " band: " + rx1_band + " Tband: " + tx_band);
                        SetTXFilters(new_mode, tx_filter_low, tx_filter_high);

                        dsp.GetDSPTX(0).TXOsc = 0.0;
                    }
                    panelModeSpecificPhone.BringToFront();
                    break;

                case DSPMode.USB:
                    radModeUSB.BackColor = button_selected_color;
                    // Debug.WriteLine("NEW USB RADMODE ");

                    if ((current_txprofile != usb_txprofile) & (TXProfileByMode) & !initializing)
                        comboTXProfile.Text = usb_txprofile;

                    //grpMode.Text = "Mode - USB";
                    if (!rx_only && chkPower.Checked)
                        chkMOX.Enabled = true;
                    if (chkVFOATX.Checked || !rx2_enabled)
                    {
                        //  Debug.WriteLine("USB HIGH-LOW: " + tx_filter_high + " , " + tx_filter_low + " mode: " + new_mode + " band: " + rx1_band + " Tband: " + tx_band);
                        SetTXFilters(new_mode, tx_filter_low, tx_filter_high);

                        dsp.GetDSPTX(0).TXOsc = 0.0;
                    }
                    panelModeSpecificPhone.BringToFront();
                    break;

                case DSPMode.DSB:
                    radModeDSB.BackColor = button_selected_color;

                    if ((current_txprofile != dsb_txprofile) & (TXProfileByMode) & !initializing) comboTXProfile.Text = dsb_txprofile;

                    //grpMode.Text = "Mode - DSB";
                    if (!rx_only && chkPower.Checked)
                        chkMOX.Enabled = true;
                    if (chkVFOATX.Checked || !rx2_enabled)
                    {
                        SetTXFilters(new_mode, tx_filter_low, tx_filter_high);

                        dsp.GetDSPTX(0).TXOsc = 0.0;
                    }
                    panelModeSpecificPhone.BringToFront();
                    break;

                case DSPMode.CWL:
                    radModeCWL.BackColor = button_selected_color;

                    if ((current_txprofile != cwl_txprofile) & (TXProfileByMode) & !initializing)
                        comboTXProfile.Text = cwl_txprofile;

                    //grpMode.Text = "Mode - CWL";
                    if (chkVFOATX.Checked || !rx2_enabled)
                    {
                        CWPitch = cw_pitch;
                        dsp.GetDSPTX(0).TXOsc = 0.0;
                        //DSP.KeyerFreq = cw_pitch;
                        if (!rx_only && chkPower.Checked)
                        {
                            chkMOX.Enabled = true;
                            //DttSP.StopKeyer();
                            //DttSP.CWRingRestart();
                            //DttSP.StartKeyer();
                        }

                        if (old_mode != DSPMode.CWL && old_mode != DSPMode.CWU)
                        {
                            if (!initializing)
                            {
                                mon_recall = chkMON.Checked;
                                mon2_recall = Audio.MON_PRE; // ke9ns add 
                            }
                            chkMON.Checked = cw_sidetone;
                        }

                        SetTXFilters(new_mode, tx_filter_low, tx_filter_high);

                    }

                    if (!RX1IsOn60mChannel())
                    {
                        switch (rx1_dsp_mode)
                        {
                            case DSPMode.USB:
                                rx1_freq += (cw_pitch * 1e-6);
                                break;
                            case DSPMode.CWU:
                                break;
                            default:
                                rx1_freq -= (cw_pitch * 1e-6);
                                break;
                        }
                        txtVFOAFreq.Text = rx1_freq.ToString("f6" );
                    }

                    panelModeSpecificCW.BringToFront();
                    break;

                case DSPMode.CWU:
                    radModeCWU.BackColor = button_selected_color;

                    if ((current_txprofile != cwu_txprofile) & (TXProfileByMode) & !initializing)
                        comboTXProfile.Text = cwu_txprofile;

                    //grpMode.Text = "Mode - CWU";
                    if (chkVFOATX.Checked || !rx2_enabled)
                    {
                        CWPitch = cw_pitch;
                        dsp.GetDSPTX(0).TXOsc = 0.0;
                        //DSP.KeyerFreq = -cw_pitch;
                        if (!rx_only && chkPower.Checked)
                        {
                            chkMOX.Enabled = true;
                            //DttSP.StopKeyer();
                            //DttSP.CWRingRestart();
                            //DttSP.StartKeyer();
                        }

                        if (rx1_dsp_mode != DSPMode.CWL)
                        {
                            if (!initializing)
                            {
                                mon_recall = chkMON.Checked;
                                mon2_recall = Audio.MON_PRE; // ke9ns add 
                            }
                            chkMON.Checked = cw_sidetone;
                        }

                        SetTXFilters(new_mode, tx_filter_low, tx_filter_high);

                    }

                    if (!RX1IsOn60mChannel())
                    {
                        switch (rx1_dsp_mode)
                        {
                            case DSPMode.LSB:
                                rx1_freq -= (cw_pitch * 1e-6);
                                break;
                            case DSPMode.CWL:
                                break;
                            default:
                                rx1_freq += (cw_pitch * 1e-6);
                                break;
                        }
                        txtVFOAFreq.Text = rx1_freq.ToString("f6" );
                    }

                    panelModeSpecificCW.BringToFront();
                    break;

                case DSPMode.FM: // new mode
                    radModeFMN.BackColor = button_selected_color;

                    if ((current_txprofile != fm_txprofile) & (TXProfileByMode) & !initializing) comboTXProfile.Text = fm_txprofile;

                    DisableAllFilters();

                    if (!initializing) rx1_squelch_threshold_scroll = ptbSquelch.Value;

                    ptbSquelch.Minimum = 0;
                    ptbSquelch.Maximum = 100;

                    ptbSquelch.Value = rx1_fm_squelch_threshold_scroll;

                    picSquelch.Visible = false; //ke9ns: false

                    rx1_squelch_on = chkSquelch.Checked;    //save state of non-FM squelch
                    chkSquelch.Checked = true;

                    if (chkVFOATX.Checked || chkVFOBTX.Checked || !rx2_enabled)
                    {
                        if (!rx_only && chkPower.Checked) chkMOX.Enabled = true;

#if NO_MON // ke9ns off to allow mon function in FM mode
                        chkMON.Checked = false; // ke9ns test
                        chkMON.Enabled = false;
#endif
                        chkBIN.Checked = false;
                        chkBIN.Enabled = false;


                        if (!chkVFOBTX.Checked)
                        {
                            SetTXFilters(new_mode, tx_filter_low, tx_filter_high); //W0DHB TX

                        }
                        // SetTXFilters(new_mode, tx_filter_low, tx_filter_high); // ke9ns original code

                        dsp.GetDSPTX(0).TXOsc = 11025.0;

                        ptbFMMic_Scroll(this, EventArgs.Empty);
                    }
                    panelModeSpecificFM.BringToFront();


                    break;

                case DSPMode.AM:
                    radModeAM.BackColor = button_selected_color;

                    if ((current_txprofile != am_txprofile) & (TXProfileByMode) & !initializing)
                        comboTXProfile.Text = am_txprofile;

                    //grpMode.Text = "Mode - AM";
                    if (!rx_only && chkPower.Checked) chkMOX.Enabled = true;

                    if (chkVFOATX.Checked || chkVFOBTX.Checked || !rx2_enabled)
                    {

#if NO_MON  // ke9ns off to allow mon function in FM mode
                        chkMON.Checked = false; // ke9ns test
					    chkMON.Enabled = false;
#endif
                        chkBIN.Checked = false;
                        chkBIN.Enabled = false;

                        if ((!chkVFOBTX.Checked) || (AMMODE != AMMODE_LAST))
                        {
                            //   Debug.WriteLine("AM HIGH-LOW: " + tx_filter_high + " , " + tx_filter_low + " mode: " + new_mode + " band: " + rx1_band + " Tband: " + tx_band);
                            SetTXFilters(new_mode, tx_filter_low, tx_filter_high); //W0DHB TX (ke9ns mod)

                        }
                        //   SetTXFilters(new_mode, tx_filter_low, tx_filter_high);

                        AMMODE_LAST = AMMODE; // ke9ns add
                        dsp.GetDSPTX(0).TXOsc = 11025.0;
                    }
                    panelModeSpecificPhone.BringToFront();

                    break; // AM mode

                case DSPMode.SAM:
                    radModeSAM.BackColor = button_selected_color;

                    if ((current_txprofile != sam_txprofile) & (TXProfileByMode) & !initializing) comboTXProfile.Text = sam_txprofile;

                    //grpMode.Text = "Mode - SAM";
                    if (!rx_only && chkPower.Checked) chkMOX.Enabled = true;

                    if (chkVFOATX.Checked || chkVFOBTX.Checked || !rx2_enabled)
                    {
#if NO_MON  // ke9ns off to allow mon function in SAM mode
                        chkMON.Checked = false; // ke9ns test
                        chkMON.Enabled = false;
#endif
                        chkBIN.Checked = false;
                        chkBIN.Enabled = false;

                        if ((!chkVFOBTX.Checked) || (SAMMODE != SAMMODE_LAST))
                        {
                            //   Debug.WriteLine("SAM HIGH-LOW: " + tx_filter_high + " , " + tx_filter_low + " mode: " + new_mode + " band: " + rx1_band + " Tband: " + tx_band);
                            SetTXFilters(new_mode, tx_filter_low, tx_filter_high); //W0DHB TX  (ke9ns mod)

                        }
                        //  SetTXFilters(new_mode, tx_filter_low, tx_filter_high);

                        SAMMODE_LAST = SAMMODE; // ke9ns add  save 

                        dsp.GetDSPTX(0).TXOsc = 11025.0;
                    }
                    panelModeSpecificPhone.BringToFront();

                    break; // SAM mode

                case DSPMode.SPEC:
                    radModeSPEC.BackColor = button_selected_color;

                    if ((current_txprofile != spec_txprofile) & (TXProfileByMode) & !initializing)
                        comboTXProfile.Text = spec_txprofile;

                    //grpMode.Text = "Mode - SPEC";
                    if_shift = false;
                    dsp.GetDSPRX(0, 0).RXOsc = 0.0;
                    DisableAllFilters();
                    ptbFilterShift.Enabled = false;
                    btnFilterShiftReset.Enabled = false;
                    bool save_pan = (Display.CurrentDisplayMode == DisplayMode.PANADAPTER);
                    bool save_water = (Display.CurrentDisplayMode == DisplayMode.WATERFALL);
                    if (save_pan || save_water)
                    {
                        comboDisplayMode.Text = "Spectrum";
                    }
                    comboDisplayMode.Items.Remove("Panadapter");
                    comboDisplayMode.Items.Remove("Waterfall");
                    was_panadapter = save_pan;
                    was_waterfall = save_water;
                    dsp.GetDSPRX(0, 0).SpectrumPreFilter = true;
                    Display.RXDisplayLow = -(int)sample_rate1 / 2;
                    Display.RXDisplayHigh = (int)sample_rate1 / 2;
                    break;

                case DSPMode.DIGL:
                    radModeDIGL.BackColor = button_selected_color;

                    if ((current_txprofile != digl_txprofile) & (TXProfileByMode) & !initializing)
                        comboTXProfile.Text = digl_txprofile;

                    //grpMode.Text = "Mode - DIGL";
                    if (chkVFOATX.Checked || !rx2_enabled)
                    {
                        SetTXFilters(new_mode, tx_filter_low, tx_filter_high);

                        dsp.GetDSPTX(0).TXOsc = 0.0;
                    }
                    if (vac_auto_enable)
                        setupForm.VACEnable = true;

                    panelModeSpecificDigital.BringToFront();
                    break;

                case DSPMode.DIGU:
                    radModeDIGU.BackColor = button_selected_color;

                    if ((current_txprofile != digu_txprofile) & (TXProfileByMode) & !initializing)
                        comboTXProfile.Text = digu_txprofile;

                    //grpMode.Text = "Mode - DIGU";
                    if (chkVFOATX.Checked)
                    {
                        SetTXFilters(new_mode, tx_filter_low, tx_filter_high);

                        dsp.GetDSPTX(0).TXOsc = 0.0;
                    }
                    if (vac_auto_enable)
                        setupForm.VACEnable = true;

                    panelModeSpecificDigital.BringToFront();
                    break;

                case DSPMode.DRM:
                    if_shift = false;
                    vfo_offset = -0.012;
                    radModeDRM.BackColor = button_selected_color;

                    if ((current_txprofile != drm_txprofile) & (TXProfileByMode) & !initializing)
                        comboTXProfile.Text = drm_txprofile;

                    //grpMode.Text = "Mode - DRM";
                    if (vac_auto_enable)
                        setupForm.VACEnable = true;
                    //chkMOX.Enabled = false;
                    if (chkVFOATX.Checked || !rx2_enabled)
                    {
                        SetTXFilters(new_mode, tx_filter_low, tx_filter_high);

                        dsp.GetDSPTX(0).TXOsc = 0.0;
                    }
                    DisableAllFilters();
                    ptbFilterShift.Enabled = false;
                    btnFilterShiftReset.Enabled = false;
                    //grpFilter.Text = "Filter - DRM";
                    dsp.GetDSPRX(0, 0).SetRXFilter(7000, 17000);
                    /*Display.RXDisplayLow = -8000;
						Display.RXDisplayHigh = 8000;*/
                    panelModeSpecificDigital.BringToFront();
                    btnTNFAdd.Enabled = false;
                    chkTNF.Enabled = false;
                    chkTNF.Checked = false;
                    break; //DRM mode

            } // Switch (new mode)

            if (RX1IsOn60mChannel())
            {
                // adjust freq offset to ensure center of energy for new mode in 60m
                rx1_freq += (-ModeFreqOffset(old_mode) + ModeFreqOffset(new_mode));
                txtVFOAFreq.Text = rx1_freq.ToString("f6" );
            }

            int new_txosc = (int)dsp.GetDSPTX(0).TXOsc;

            if (new_txosc != old_txosc)
            {
                if (fwc_init && (current_model == Model.FLEX5000 || current_model == Model.FLEX3000)) FWC.SetTXOffset(new_txosc);
            }

            radFilter1.Text = rx1_filters[(int)new_mode].GetName(Filter.F1);
            radFilter2.Text = rx1_filters[(int)new_mode].GetName(Filter.F2);
            radFilter3.Text = rx1_filters[(int)new_mode].GetName(Filter.F3);
            radFilter4.Text = rx1_filters[(int)new_mode].GetName(Filter.F4);
            radFilter5.Text = rx1_filters[(int)new_mode].GetName(Filter.F5);
            radFilter6.Text = rx1_filters[(int)new_mode].GetName(Filter.F6);
            radFilter7.Text = rx1_filters[(int)new_mode].GetName(Filter.F7);
            radFilter8.Text = rx1_filters[(int)new_mode].GetName(Filter.F8);
            radFilter9.Text = rx1_filters[(int)new_mode].GetName(Filter.F9);
            radFilter10.Text = rx1_filters[(int)new_mode].GetName(Filter.F10);
            radFilterVar1.Text = rx1_filters[(int)new_mode].GetName(Filter.VAR1);
            radFilterVar2.Text = rx1_filters[(int)new_mode].GetName(Filter.VAR2);

            rx1_dsp_mode = new_mode;



            if (old_mode == DSPMode.FM) chkSquelch.Checked = rx1_squelch_on;  // ke9ns 

            if (old_mode == DSPMode.FM || new_mode == DSPMode.FM) ptbSquelch_Scroll(this, EventArgs.Empty);

            if (rx1_dsp_mode != DSPMode.SPEC && rx1_dsp_mode != DSPMode.FM && rx1_dsp_mode != DSPMode.DRM)
            {
                RX1Filter = rx1_filters[(int)new_mode].LastFilter; // ke9ns: pull up RX filter and choose the button to select (highlight)

                UpdateRX1Filters((int)udFilterLow.Value, (int)udFilterHigh.Value); // ke9nstest

            }
            else
            {
                if (rx1_dsp_mode == DSPMode.FM) //checkfm
                {
                    if (dsp.GetDSPTX(0).TXFMDeviation == FMDataDeviation) // ke9ns add WFM
                    {
                        UpdateRX1Filters(-FMDataLowHigh, FMDataLowHigh); // +/- 10000 (change to 20k .218)
                    }
                    else if (dsp.GetDSPTX(0).TXFMDeviation == 5000)
                    {
                        UpdateRX1Filters(-8000, 8000);
                    }
                    else // 2.5k
                    {
                        UpdateRX1Filters(-4000, 4000);
                    }
                }

                RX1Filter = Filter.NONE;
                //grpFilter.Text = "Filter - "+(sample_rate1/1000).ToString("f0")+"kHz";
            }

            tbFilterWidthScroll_newMode(); // wjt determine if your allowed to change the filter width or now.

            //Display.DrawBackground();

            UpdateDSPBufRX1();
            UpdateDSPBufTX();

            txtVFOAFreq_LostFocus(this, EventArgs.Empty);
            ptbPWR_Scroll(this, EventArgs.Empty);

            if (fwc_init && (current_model == Model.FLEX5000 || current_model == Model.FLEX3000))
            {
                if (chkVFOSplit.Checked || full_duplex) txtVFOBFreq_LostFocus(this, EventArgs.Empty);

                bool tx1, tx2, tx3;
                if (flex5000RelayForm != null) flex5000RelayForm.UpdateRelayState(out tx1, out tx2, out tx3);
            }

            //   Debug.WriteLine("New_mode: " + new_mode);
            //   Debug.WriteLine("Old_mode: " + old_mode);

            if (((new_mode == DSPMode.CWL) || (new_mode == DSPMode.CWU)) && (old_mode != DSPMode.CWL && old_mode != DSPMode.CWU))
            {
                if (setupForm != null)
                {
                    Debug.WriteLine("TuneStep CWMODE ");

                    setupForm.txtWheelTune9.Text = txtWheelTune.Text; //  Save the current SSB value in database
                    setupForm.txtWheelTune7.Text = setupForm.txtWheelTune2.Text; // 
                    setupForm.txtWheelTune8.Text = setupForm.txtWheelTune3.Text; // 

                    txtWheelTune.Text = setupForm.txtWheelTune4.Text; //load up CW tunestep
                    setupForm.txtWheelTune2.Text = setupForm.txtWheelTune5.Text; // 
                    setupForm.txtWheelTune3.Text = setupForm.txtWheelTune6.Text; // 

                    setupForm.tune_step_index2 = TuneStepLookup(setupForm.txtWheelTune2.Text);
                    setupForm.tune_step_index3 = TuneStepLookup(setupForm.txtWheelTune3.Text);


                }
            }
            else if ((old_mode == DSPMode.CWL || old_mode == DSPMode.CWU) && (new_mode != DSPMode.CWL && new_mode != DSPMode.CWU))
            {
                if (setupForm != null)
                {
                    if (initializing == false) // dont update if initializing
                    {
                        Debug.WriteLine("TuneStep OTHER mode ");

                        setupForm.txtWheelTune4.Text = txtWheelTune.Text; // SAVE the current CW value in database
                        setupForm.txtWheelTune5.Text = setupForm.txtWheelTune2.Text; // 
                        setupForm.txtWheelTune6.Text = setupForm.txtWheelTune3.Text; // 

                        txtWheelTune.Text = setupForm.txtWheelTune9.Text; //load up SSB
                        setupForm.txtWheelTune2.Text = setupForm.txtWheelTune7.Text; // for knob alt1
                        setupForm.txtWheelTune3.Text = setupForm.txtWheelTune8.Text; // for knob alt2

                        setupForm.tune_step_index2 = TuneStepLookup(setupForm.txtWheelTune2.Text);
                        setupForm.tune_step_index3 = TuneStepLookup(setupForm.txtWheelTune3.Text);


                    }
                }
            }

            if (disable_split_on_modechange & !initializing) //.227 moved to here
            {
                if (chkVFOSplit.Checked) chkVFOSplit.Checked = false;
            }

        } // SetRX1Mode()



        private void radModeLSB_CheckedChanged(object sender, System.EventArgs e)
        {
            AMSSBmodeON = false; // ke9ns add
            AMSSBmodeFILT = false; // ke9ns add 

            if (radModeLSB.Checked)
            {
                TXMode = DSPMode.LSB;// ke9ns add: to allow power change per band and per mode
                Debug.WriteLine("call LSB MODE ");
                SetRX1Mode(DSPMode.LSB);

                // ke9ns add: to restore after DIGU/L
                if (saveANF) chkANF.Checked = true;
                if (saveNR) chkNR.Checked = true;
                if (saveNB) chkNB.Checked = true;
                if (saveNB2) chkDSPNB2.Checked = true;

                saveANF = false;
                saveNR = false;
                saveNB = false;
                saveNB2 = false;

            }
        }

        private void radModeUSB_CheckedChanged(object sender, System.EventArgs e)
        {
            AMSSBmodeON = false; // ke9ns add
            AMSSBmodeFILT = false; // ke9ns add 

            if (radModeUSB.Checked)
            {
                TXMode = DSPMode.USB; // ke9ns add (to allow power change per band and per mode
                Debug.WriteLine("call USB MODE ");
                SetRX1Mode(DSPMode.USB);

                // ke9ns add: to restore after DIGU/L
                if (saveANF) chkANF.Checked = true;
                if (saveNR) chkNR.Checked = true;
                if (saveNB) chkNB.Checked = true;
                if (saveNB2) chkDSPNB2.Checked = true;

                saveANF = false;
                saveNR = false;
                saveNB = false;
                saveNB2 = false;

            }
        }

        private void radModeDSB_CheckedChanged(object sender, System.EventArgs e)
        {
            AMSSBmodeON = false; // ke9ns add
            AMSSBmodeFILT = false; // ke9ns add 

            if (radModeDSB.Checked)
            {
                TXMode = DSPMode.DSB;// ke9ns add (to allow power change per band and per mode
                SetRX1Mode(DSPMode.DSB);

                // ke9ns add: to restore after DIGU/L
                if (saveANF) chkANF.Checked = true;
                if (saveNR) chkNR.Checked = true;
                if (saveNB) chkNB.Checked = true;
                if (saveNB2) chkDSPNB2.Checked = true;

                saveANF = false;
                saveNR = false;
                saveNB = false;
                saveNB2 = false;

            }
        }

        private void radModeCWL_CheckedChanged(object sender, System.EventArgs e)
        {
            AMSSBmodeON = false; // ke9ns add
            AMSSBmodeFILT = false; // ke9ns add 

            if (radModeCWL.Checked)
            {
                TXMode = DSPMode.CWL;// ke9ns add (to allow power change per band and per mode

                if (chkANF.Checked == true) saveANF = true;
                else saveANF = false;

                chkANF.Checked = false;
                SetRX1Mode(DSPMode.CWL);

                // ke9ns add: to restore after DIGU/L

                if (saveNR) chkNR.Checked = true;
                if (saveNB) chkNB.Checked = true;
                if (saveNB2) chkDSPNB2.Checked = true;

                saveNR = false;
                saveNB = false;
                saveNB2 = false;
            }


        } // radModeCWL_CheckedChanged

        // Invoke(new MethodInvoker(radModeCWU.Select)); // switch RX1 to CWU mode
        private void radModeCWU_CheckedChanged(object sender, System.EventArgs e)
        {
            AMSSBmodeON = false; // ke9ns add
            AMSSBmodeFILT = false; // ke9ns add 


            if (radModeCWU.Checked)
            {
                TXMode = DSPMode.CWU;      // ke9ns add (to allow power change per band and per mode)

                if (chkANF.Checked == true) saveANF = true;
                else saveANF = false;

                chkANF.Checked = false;
                SetRX1Mode(DSPMode.CWU);

                // ke9ns add: to restore after DIGU/L

                if (saveNR) chkNR.Checked = true;
                if (saveNB) chkNB.Checked = true;
                if (saveNB2) chkDSPNB2.Checked = true;

                saveNR = false;
                saveNB = false;
                saveNB2 = false;
            }



        } // radModeCWU_CheckedChanged(

        private void radModeFMN_CheckedChanged(object sender, System.EventArgs e)
        {
            AMSSBmodeON = false; // ke9ns add
            AMSSBmodeFILT = false; // ke9ns add 

            if (radModeFMN.Checked)
            {
                TXMode = DSPMode.FM;// ke9ns add (to allow power change per band and per mode
                SetRX1Mode(DSPMode.FM);

                // ke9ns add: to restore after DIGU/L
                if (saveANF) chkANF.Checked = true;
                if (saveNR) chkNR.Checked = true;
                if (saveNB) chkNB.Checked = true;
                if (saveNB2) chkDSPNB2.Checked = true;

                saveANF = false;
                saveNR = false;
                saveNB = false;
                saveNB2 = false;

            }
            else
            {
                FMRESET = false;
            }

            //dsp.GetDSP(0, 0).SetRXFilter(-50000, 50000);
        }

        public int FMSEQ = 0; //.236
        public bool FMRESET = false; // ke9ns add true=FM button pushed
        public bool FMData = false; // ke9ns add true=FM data mode
        public double lastdeviation = 0; // ke9ns add false = 2k, true = 5k

        public const int FMDataDeviation = 17000; // ke9ns was 9000 deviation amount for FM Data mode (change to 17k .218)
        public const int FMDataLowHigh = 20000; // ke9ns +10000 or -10000 (change to 20k .218)

        // ke9ns add  (to allow a digital version of FM just like DIGU or DIGL)
        private void radModeFMN_MouseUp(object sender, MouseEventArgs e)
        {


        }




        private void radModeAM_CheckedChanged(object sender, System.EventArgs e)
        {
            AMSSBmodeON = false; // ke9ns add
            AMSSBmodeFILT = true; // ke9ns add am mode

            if (radModeAM.Checked)
            {
                Debug.WriteLine("call AM MODE ");
                SetRX1Mode(DSPMode.AM);

                // ke9ns add: to restore after DIGU/L
                if (saveANF) chkANF.Checked = true;
                if (saveNR) chkNR.Checked = true;
                if (saveNB) chkNB.Checked = true;
                if (saveNB2) chkDSPNB2.Checked = true;

                saveANF = false;
                saveNR = false;
                saveNB = false;
                saveNB2 = false;

                //  AMMODE = DSPISB.FIRST;

            }
            else
            {
                AMRESET = false;
            }

        } // radModeAM_CheckedChanged

        // ke9ns add
        private void radModeAM_MouseUp(object sender, MouseEventArgs e)
        {
            if ((radModeAM.Checked) && (AMRESET == true))
            {

                if (AMMODE == DSPISB.FIRST)
                {
                    AMMODE = DSPISB.AML;
                    radModeAM.Text = "AM-L";
                }
                else if (AMMODE == DSPISB.AML)
                {
                    AMMODE = DSPISB.AMU;
                    radModeAM.Text = "AM-U";
                }
                else if (AMMODE == DSPISB.AMU)
                {
                    AMMODE = DSPISB.FIRST;
                    radModeAM.Text = "AM";
                }

                SetRX1Mode(DSPMode.AM);

            } // if(radModeSAM.Checked)
            else
            {
                AMRESET = true;
            }

            Debug.WriteLine("1AM MODE " + AMMODE);
        } // radModeAM_MouseUp

        public DSPISB AMMODE = DSPISB.FIRST; // ke9ns add
        public DSPISB AMMODE_LAST = DSPISB.FIRST; // ke9ns add

        public bool AMRESET = false;

        public DSPISB SAMMODE = DSPISB.FIRST; // ke9ns add
        public DSPISB SAMMODE_LAST = DSPISB.FIRST; // ke9ns add

        public bool SAMRESET = false;

        // ke9ns add (for H3E mode)
        private void radModeSAM_MouseUp(object sender, MouseEventArgs e)
        {
            if ((radModeSAM.Checked) && (SAMRESET == true))
            {

                if (SAMMODE == DSPISB.FIRST)
                {
                    SAMMODE = DSPISB.AML;
                    radModeSAM.Text = "SAM-L";
                }
                else if (SAMMODE == DSPISB.AML)
                {
                    SAMMODE = DSPISB.AMU;
                    radModeSAM.Text = "SAM-U";
                }
                else if (SAMMODE == DSPISB.AMU)
                {
                    SAMMODE = DSPISB.FIRST;
                    radModeSAM.Text = "SAM";
                }
                Debug.WriteLine("MOUSE SAM MODE SELECTED ");
                SetRX1Mode(DSPMode.SAM);


            } // if(radModeSAM.Checked)
            else
            {
                SAMRESET = true;
            }

            //  Debug.WriteLine("1SAM MODE " + SAMMODE);

        } // radModeSAM_MouseUp


        private void radModeSAM_CheckedChanged(object sender, System.EventArgs e)
        {
            AMSSBmodeON = false; // ke9ns add
            AMSSBmodeFILT = true; // ke9ns add am mode

            if (radModeSAM.Checked)
            {
                TXMode = DSPMode.SAM;// ke9ns add (to allow power change per band and per mode
                Debug.WriteLine("call SAM MODE ");
                SetRX1Mode(DSPMode.SAM);


                // ke9ns add: to restore after DIGU/L
                if (saveANF) chkANF.Checked = true;
                if (saveNR) chkNR.Checked = true;
                if (saveNB) chkNB.Checked = true;
                if (saveNB2) chkDSPNB2.Checked = true;

                saveANF = false;
                saveNR = false;
                saveNB = false;
                saveNB2 = false;

            } // if(radModeSAM.Checked)
            else
            {
                SAMRESET = false;
            }

            Debug.WriteLine("SAM MODE: " + SAMMODE);


        } //radModeSAM_CheckedChanged

        bool saveANF = false; // ke9ns add
        bool saveNR = false; // ke9ns add
        bool saveNB = false; // ke9ns add
        bool saveNB2 = false; // ke9ns add

        private void radModeDIGU_CheckedChanged(object sender, System.EventArgs e)
        {
            AMSSBmodeON = false; // ke9ns add
            AMSSBmodeFILT = false; // ke9ns add 

            if (radModeDIGU.Checked)
            {
                TXMode = DSPMode.DIGU;// ke9ns add (to allow power change per band and per mode

                if (chkANF.Checked) saveANF = true;
                else saveANF = false;
                if (chkNR.Checked) saveNR = true;
                else saveNR = false;
                if (chkNB.Checked) saveNB = true;
                else saveNB = false;
                if (chkDSPNB2.Checked) saveNB2 = true;
                else saveNB2 = false;


                chkANF.Checked = false;
                chkNR.Checked = false;
                chkNB.Checked = false;
                chkDSPNB2.Checked = false;


                SetRX1Mode(DSPMode.DIGU);

            }
        }

        private void radModeSPEC_CheckedChanged(object sender, System.EventArgs e)
        {
            AMSSBmodeON = false; // ke9ns add
            AMSSBmodeFILT = false; // ke9ns add 

            if (radModeSPEC.Checked)
            {
                SetRX1Mode(DSPMode.SPEC);
                TXMode = DSPMode.SPEC;// ke9ns add (to allow power change per band and per mode

                // ke9ns add: to restore after DIGU/L
                if (saveANF) chkANF.Checked = true;
                if (saveNR) chkNR.Checked = true;
                if (saveNB) chkNB.Checked = true;
                if (saveNB2) chkDSPNB2.Checked = true;

                saveANF = false;
                saveNR = false;
                saveNB = false;
                saveNB2 = false;
            }
        }

        private void radModeDIGL_CheckedChanged(object sender, System.EventArgs e)
        {
            AMSSBmodeON = false; // ke9ns add
            AMSSBmodeFILT = false; // ke9ns add 


            if (radModeDIGL.Checked)
            {
                TXMode = DSPMode.DIGL;// ke9ns add (to allow power change per band and per mode

                if (chkANF.Checked) saveANF = true;
                else saveANF = false;
                if (chkNR.Checked) saveNR = true;
                else saveNR = false;
                if (chkNB.Checked) saveNB = true;
                else saveNB = false;
                if (chkDSPNB2.Checked) saveNB2 = true;
                else saveNB2 = false;


                chkANF.Checked = false;
                chkNR.Checked = false;
                chkNB.Checked = false;
                chkDSPNB2.Checked = false;
                SetRX1Mode(DSPMode.DIGL);

            }
        }

        private void radModeDRM_CheckedChanged(object sender, System.EventArgs e)
        {
            AMSSBmodeON = false; // ke9ns add
            AMSSBmodeFILT = false; // ke9ns add 

            if (radModeDRM.Checked)
            {
                TXMode = DSPMode.DRM;// ke9ns add (to allow power change per band and per mode
                SetRX1Mode(DSPMode.DRM);

                // ke9ns add: to restore after DIGU/L
                if (saveANF) chkANF.Checked = true;
                if (saveNR) chkNR.Checked = true;
                if (saveNB) chkNB.Checked = true;
                if (saveNB2) chkDSPNB2.Checked = true;

                saveANF = false;
                saveNR = false;
                saveNB = false;
                saveNB2 = false;

            }
        }

        #endregion

        #region Filter Button Events
        // ======================================================
        // Filter Button Events
        // ======================================================

        public void SetRX1Filter(Filter new_filter)
        {
            if (rx1_dsp_mode == DSPMode.FIRST || rx1_dsp_mode == DSPMode.LAST) return;

            int low = 0, high = 0;

            switch (rx1_filter)
            {
                case Filter.F1:
                    radFilter1.BackColor = SystemColors.Control;
                    break;
                case Filter.F2:
                    radFilter2.BackColor = SystemColors.Control;
                    break;
                case Filter.F3:
                    radFilter3.BackColor = SystemColors.Control;
                    break;
                case Filter.F4:
                    radFilter4.BackColor = SystemColors.Control;
                    break;
                case Filter.F5:
                    radFilter5.BackColor = SystemColors.Control;
                    break;
                case Filter.F6:
                    radFilter6.BackColor = SystemColors.Control;
                    break;
                case Filter.F7:
                    radFilter7.BackColor = SystemColors.Control;
                    break;
                case Filter.F8:
                    radFilter8.BackColor = SystemColors.Control;
                    break;
                case Filter.F9:
                    radFilter9.BackColor = SystemColors.Control;
                    break;
                case Filter.F10:
                    radFilter10.BackColor = SystemColors.Control;
                    break;
                case Filter.VAR1:
                    radFilterVar1.BackColor = SystemColors.Control;
                    //udFilterLow.BackColor = SystemColors.Window;
                    //udFilterHigh.BackColor = SystemColors.Window;
                    udFilterLow.Enabled = false;
                    udFilterHigh.Enabled = false;
                    break;
                case Filter.VAR2:
                    radFilterVar2.BackColor = SystemColors.Control;
                    //udFilterLow.BackColor = SystemColors.Window;
                    //udFilterHigh.BackColor = SystemColors.Window;
                    udFilterLow.Enabled = false;
                    udFilterHigh.Enabled = false;
                    break;
            } // switch(rx1_filter)

            rx1_filter = new_filter;

            low = rx1_filters[(int)rx1_dsp_mode].GetLow(new_filter);

            high = rx1_filters[(int)rx1_dsp_mode].GetHigh(new_filter);

            rx1_filters[(int)rx1_dsp_mode].LastFilter = new_filter;

            Debug.WriteLine("RX1_FILTERS: " + low + " , " + high);

            //grpFilter.Text = "Filter - "+rx1_filters[(int)rx1_dsp_mode].GetName(new_filter);

            switch (new_filter)
            {
                case Filter.F1:
                    radFilter1.BackColor = button_selected_color;
                    break;
                case Filter.F2:
                    radFilter2.BackColor = button_selected_color;
                    break;
                case Filter.F3:
                    radFilter3.BackColor = button_selected_color;
                    break;
                case Filter.F4:
                    radFilter4.BackColor = button_selected_color;
                    break;
                case Filter.F5:
                    radFilter5.BackColor = button_selected_color;
                    break;
                case Filter.F6:
                    radFilter6.BackColor = button_selected_color;
                    break;
                case Filter.F7:
                    radFilter7.BackColor = button_selected_color;
                    break;
                case Filter.F8:
                    radFilter8.BackColor = button_selected_color;
                    break;
                case Filter.F9:
                    radFilter9.BackColor = button_selected_color;
                    break;
                case Filter.F10:
                    radFilter10.BackColor = button_selected_color;
                    break;
                case Filter.VAR1:
                    radFilterVar1.BackColor = button_selected_color;
                    //udFilterLow.BackColor = button_selected_color;
                    //udFilterHigh.BackColor = button_selected_color;
                    udFilterLow.Enabled = true;
                    udFilterHigh.Enabled = true;
                    break;
                case Filter.VAR2:
                    radFilterVar2.BackColor = button_selected_color;
                    //udFilterLow.BackColor = button_selected_color;
                    //udFilterHigh.BackColor = button_selected_color;
                    udFilterLow.Enabled = true;
                    udFilterHigh.Enabled = true;
                    break;
                case Filter.NONE:
                    foreach (Control c in panelFilter.Controls)
                    {
                        if (c.GetType() == typeof(RadioButtonTS))
                        {
                            ((RadioButtonTS)c).Checked = false;

                            if (c.BackColor != SystemColors.Control)
                                ((RadioButtonTS)c).BackColor = SystemColors.Control;
                        }
                    }
                    return;
            } // switch(new_filter)
              //    udFilterLow.ValueChanged -= udFilterLow_ValueChanged;  //.170  ke9ns turn off valuechanged temporarily   
              //    udFilterHigh.ValueChanged -= udFilterHigh_ValueChanged;  // ke9ns turn off valuechanged temporarily   
              //    udRX2FilterLow.ValueChanged -= udRX2FilterLow_ValueChanged;  //.170  ke9ns turn off valuechanged temporarily   
              //    udRX2FilterHigh.ValueChanged -= udRX2FilterHigh_ValueChanged;  // ke9ns turn off valuechanged temporarily   

            UpdateRX1Filters(low, high);

            //    udFilterLow.ValueChanged += udFilterLow_ValueChanged;  // ke9ns turn on valuechanged temporarily   
            //    udFilterHigh.ValueChanged += udFilterHigh_ValueChanged;  // ke9ns turn on valuechanged temporarily   
            //    udRX2FilterLow.ValueChanged += udRX2FilterLow_ValueChanged;  // ke9ns turn on valuechanged temporarily   
            //   udRX2FilterHigh.ValueChanged += udRX2FilterHigh_ValueChanged;  // ke9ns turn on valuechanged temporarily   


            AMSSBmodeFILT = true; // ke9ns add to signal RX filter updated


        } // SetRX1Filter()

        private void radFilter1_CheckedChanged(object sender, System.EventArgs e)
        {
            if (radFilter1.Checked)
            {
                SetRX1Filter(Filter.F1);
            }
        }

        private void radFilter2_CheckedChanged(object sender, System.EventArgs e)
        {
            if (radFilter2.Checked)
                SetRX1Filter(Filter.F2);
        }

        private void radFilter3_CheckedChanged(object sender, System.EventArgs e)
        {
            if (radFilter3.Checked)
                SetRX1Filter(Filter.F3);
        }

        private void radFilter4_CheckedChanged(object sender, System.EventArgs e)
        {
            if (radFilter4.Checked)
                SetRX1Filter(Filter.F4);
        }

        private void radFilter5_CheckedChanged(object sender, System.EventArgs e)
        {
            if (radFilter5.Checked)
                SetRX1Filter(Filter.F5);
        }

        private void radFilter6_CheckedChanged(object sender, System.EventArgs e)
        {
            if (radFilter6.Checked)
                SetRX1Filter(Filter.F6);
        }

        private void radFilter7_CheckedChanged(object sender, System.EventArgs e)
        {
            if (radFilter7.Checked)
                SetRX1Filter(Filter.F7);
        }

        private void radFilter8_CheckedChanged(object sender, System.EventArgs e)
        {
            if (radFilter8.Checked)
                SetRX1Filter(Filter.F8);
        }

        private void radFilter9_CheckedChanged(object sender, System.EventArgs e)
        {
            if (radFilter9.Checked)
                SetRX1Filter(Filter.F9);
        }

        private void radFilter10_CheckedChanged(object sender, System.EventArgs e)
        {
            if (radFilter10.Checked)
                SetRX1Filter(Filter.F10);
        }

        private void radFilterVar1_CheckedChanged(object sender, System.EventArgs e)
        {
            if (radFilterVar1.Checked)
                SetRX1Filter(Filter.VAR1);
        }

        private void radFilterVar2_CheckedChanged(object sender, System.EventArgs e)
        {
            if (radFilterVar2.Checked)
                SetRX1Filter(Filter.VAR2);
        }

        private void udFilterLow_ValueChanged(object sender, System.EventArgs e)
        {

            if (udFilterLow.Focused)
            {
                if (udFilterLow.Value >= udFilterHigh.Value - 10)
                {
                    udFilterLow.Value = udFilterHigh.Value - 10;
                    return;
                }

                UpdateRX1Filters((int)udFilterLow.Value, (int)udFilterHigh.Value);

                if (!save_filter_changes) rx1_filters[(int)rx1_dsp_mode].SetLow(rx1_filter, (int)udFilterLow.Value);
            }

            if (save_filter_changes && rx1_filter >= Filter.F1 && rx1_filter <= Filter.VAR2)
            {
                Debug.WriteLine("RX1_Filters SAVE: mode=" + rx1_dsp_mode + " , " + (int)udFilterLow.Value);

                rx1_filters[(int)rx1_dsp_mode].SetLow(rx1_filter, (int)udFilterLow.Value);

                Debug.WriteLine("RX1_Filters get: " + rx1_filters[(int)rx1_dsp_mode].GetLow(rx1_filter));

            }





        } // udFilterLow_ValueChanged



        //=========================================================================================
        private void udFilterHigh_ValueChanged(object sender, System.EventArgs e)
        {
            if (udFilterHigh.Focused)
            {
                if (udFilterHigh.Value <= udFilterLow.Value + 10)
                {
                    udFilterHigh.Value = udFilterLow.Value + 10;
                    return;
                }

                UpdateRX1Filters((int)udFilterLow.Value, (int)udFilterHigh.Value);

                if (!save_filter_changes) rx1_filters[(int)rx1_dsp_mode].SetHigh(rx1_filter, (int)udFilterHigh.Value);
            }

            if (save_filter_changes && rx1_filter >= Filter.F1 && rx1_filter <= Filter.VAR2)
            {
                rx1_filters[(int)rx1_dsp_mode].SetHigh(rx1_filter, (int)udFilterHigh.Value);
            }


        } // udFilterHigh_ValueChanged



        //==========================================================================================================
        private void DoFilterShift(int shift, bool redraw)
        {
            // VK6APH: Does the Filter Shift function, alters the filter low and high frequency values 
            // as the Filter Shift slider is moved. We need to keep the last Filter Shift values
            // that the variable filters use since, unlike the other filters, there are 
            // no pre-set bandwidths that they can default to when the Filter Shift is 
            // turned off. These values are stored in the public variables last_var1_shift and
            // last_var2_shift. 
            int IFShift;
            int low;
            int high;
            int bandwidth;
            int max_shift = 9999;       // needed when using variable filters so we can't exceed +/- 10kHz DSP limits

            if (rx1_dsp_mode == DSPMode.SPEC ||
                rx1_dsp_mode == DSPMode.DRM)
                return;

            bandwidth = (int)Math.Abs(udFilterHigh.Value - udFilterLow.Value); // calculate current filter bandwidth 

            // set the maximum IF Shift depending on filter bandwidth in use 
            if (bandwidth > 800)
            {
                ptbFilterShift.Maximum = 1000;  // max IF Shift +/- 1kHz for filters > 800Hz wide
                ptbFilterShift.Minimum = -1000;
            }
            else
            {
                ptbFilterShift.Maximum = 500;   // max IF Shift +/- 500Hz for filters < 800Hz wide
                ptbFilterShift.Minimum = -500;
            }
            // calculate how far the IF Shift slider has moved
            // if we are using variable bandwidth filters need to use their last shift value
            if (rx1_filter == Filter.VAR1)
                IFShift = shift - last_var1_shift;
            else if (rx1_filter == Filter.VAR2)
                IFShift = shift - last_var2_shift;
            else
                IFShift = shift - last_filter_shift;

            high = (int)Math.Min(udFilterHigh.Value + IFShift, max_shift);  // limit high shift to maximum value
            low = (int)Math.Max(udFilterLow.Value + IFShift, -max_shift);   // limit low shift to maximum value

            dsp.GetDSPRX(0, 0).SetRXFilter(low, high);          // select new filters
            udFilterLow.Value = low;                        // display new low value 
            udFilterHigh.Value = high;                      // display new high value
            if (redraw) Display.DrawBackground();           // draw new background for updated filter values

            // store the last IF Shift applied for use next time
            if (rx1_filter == Filter.VAR1)
                last_var1_shift = last_var1_shift + IFShift;
            else if (rx1_filter == Filter.VAR2)
                last_var2_shift = last_var2_shift + IFShift;
            else
                last_filter_shift = last_filter_shift + IFShift;
            // show the IF Shift is active by setting the zero button colour
            if (shift != 0)
                btnFilterShiftReset.BackColor = button_selected_color;
        } //




        private void ptbFilterShift_Scroll(object sender, System.EventArgs e)
        {
            SelectRX1VarFilter();

            int bw = (int)udFilterHigh.Value - (int)udFilterLow.Value;
            int default_center = 0;

            switch (rx1_dsp_mode)
            {
                case DSPMode.USB:
                    default_center = default_low_cut + bw / 2;
                    break;
                case DSPMode.LSB:
                    default_center = -default_low_cut - bw / 2;
                    break;
                case DSPMode.CWU:
                    default_center = cw_pitch;
                    break;
                case DSPMode.CWL:
                    default_center = -cw_pitch;
                    break;
                case DSPMode.DIGU:
                    default_center = digu_click_tune_offset;
                    break;
                case DSPMode.DIGL:
                    default_center = -digl_click_tune_offset;
                    break;
            }

            int adjusted_max = max_filter_shift;
            if (default_center > 0)
            {
                if (ptbFilterShift.Value > 0)
                {
                    adjusted_max = Math.Min(max_filter_shift, 9999 - (Math.Abs(default_center) + bw / 2));
                }
            }
            else if (default_center < 0)
            {
                if (ptbFilterShift.Value < 0)
                {
                    adjusted_max = Math.Min(max_filter_shift, 9999 - (Math.Abs(default_center) + bw / 2));
                }
            }
            else //default_center == 0
            {
                adjusted_max = Math.Min(max_filter_shift, 9999 - bw / 2);
            }

            int range = ptbFilterShift.Maximum - ptbFilterShift.Minimum;
            int new_center = default_center + (int)((float)ptbFilterShift.Value / (range / 2) * adjusted_max);
            UpdateRX1Filters(new_center - bw / 2, new_center + bw / 2);

            btnFilterShiftReset.BackColor = button_selected_color;

            if (ptbFilterShift.Focused)
                btnHidden.Focus();
        }

        private void ptbFilterShift_Update(int low, int high)
        {
            int bw = (int)udFilterHigh.Value - (int)udFilterLow.Value;
            int default_center = 0;
            int current_center = (low + high) / 2;

            switch (rx1_dsp_mode)
            {
                case DSPMode.USB:
                    default_center = default_low_cut + bw / 2;
                    break;
                case DSPMode.LSB:
                    default_center = -default_low_cut - bw / 2;
                    break;
                case DSPMode.CWU:
                    default_center = cw_pitch;
                    break;
                case DSPMode.CWL:
                    default_center = -cw_pitch;
                    break;
                case DSPMode.DIGU:
                    default_center = digu_click_tune_offset;
                    break;
                case DSPMode.DIGL:
                    default_center = -digl_click_tune_offset;
                    break;
            }

            int adjusted_max = max_filter_shift;
            if (default_center > 0)
            {
                if (current_center > default_center)
                {
                    adjusted_max = Math.Min(max_filter_shift, 9999 - (Math.Abs(default_center) + bw / 2));
                }
            }
            else if (default_center < 0)
            {
                if (current_center < default_center)
                {
                    adjusted_max = Math.Min(max_filter_shift, 9999 - (Math.Abs(default_center) + bw / 2));
                }
            }
            else //default_center == 0
            {
                adjusted_max = Math.Min(max_filter_shift, 9999 - bw / 2);
            }

            int range = ptbFilterShift.Maximum - ptbFilterShift.Minimum;
            int delta = current_center - default_center;
            int new_val = (int)((float)delta / adjusted_max * (range / 2));
            if (new_val > ptbFilterShift.Maximum) new_val = ptbFilterShift.Maximum;
            if (new_val < ptbFilterShift.Minimum) new_val = ptbFilterShift.Minimum;
            ptbFilterShift.Value = new_val;
        }
        /*
				private void tbFilterShift_Scroll(object sender, System.EventArgs e)
				{
					DoFilterShift(tbFilterShift.Value, true);

					if(tbFilterShift.Focused)
						btnHidden.Focus();
				}
		*/
        private void btnFilterShiftReset_Click(object sender, System.EventArgs e)
        {
            int bw = (int)udFilterHigh.Value - (int)udFilterLow.Value;
            int low, high;
            switch (rx1_dsp_mode)
            {
                case DSPMode.AM:
                case DSPMode.SAM:
                case DSPMode.FM:
                case DSPMode.DSB:
                    ptbFilterShift.Value = 0;
                    ptbFilterShift_Scroll(this, EventArgs.Empty);
                    break;
                case DSPMode.USB:
                    low = default_low_cut;
                    high = low + bw;
                    UpdateRX1Filters(low, high);
                    break;
                case DSPMode.CWU:
                    if (setupForm != null && setupForm.chkOptCWFilterPitch.Checked) // .170
                    {
                        low = default_low_cut;
                        high = low + bw;
                    }
                    else
                    {


                        low = cw_pitch - bw / 2;
                        high = cw_pitch + bw / 2;
                        if (low < 0)
                        {
                            int delta = -low;
                            low += delta;
                            high += delta;
                        }
                        else if (high > 9999)
                        {
                            int delta = high - 9999;
                            high -= delta;
                            low -= delta;
                        }
                    }
                    UpdateRX1Filters(low, high);
                    break;
                case DSPMode.DIGU:
                    low = digu_click_tune_offset - bw / 2;
                    high = digu_click_tune_offset + bw / 2;
                    if (low < 0)
                    {
                        int delta = -low;
                        low += delta;
                        high += delta;
                    }
                    else if (high > 9999)
                    {
                        int delta = high - 9999;
                        high -= delta;
                        low -= delta;
                    }
                    UpdateRX1Filters(low, high);
                    break;
                case DSPMode.LSB:
                    high = -default_low_cut;
                    low = high - bw;
                    UpdateRX1Filters(low, high);
                    break;
                case DSPMode.CWL:

                    if (setupForm != null && setupForm.chkOptCWFilterPitch.Checked) // .170
                    {
                        high = -default_low_cut;
                        low = high - bw;
                    }
                    else
                    {
                        high = -cw_pitch + bw / 2;
                        low = -cw_pitch - bw / 2;

                        if (high > 0)
                        {
                            int delta = -high;
                            low -= delta;
                            high -= delta;
                        }
                        else if (low < -9999)
                        {
                            int delta = low + 9999;
                            high += delta;
                            low += delta;
                        }
                    }
                    UpdateRX1Filters(low, high);
                    break;
                case DSPMode.DIGL:
                    high = -digl_click_tune_offset + bw / 2;
                    low = -digl_click_tune_offset - bw / 2;
                    if (high > 0)
                    {
                        int delta = -high;
                        low -= delta;
                        high -= delta;
                    }
                    else if (low < -9999)
                    {
                        int delta = low + 9999;
                        high += delta;
                        low += delta;
                    }
                    UpdateRX1Filters(low, high);
                    break;
            }
            btnFilterShiftReset.BackColor = SystemColors.Control;   // make button grey
        }

        private FilterWidthMode current_filter_width_mode = FilterWidthMode.Linear;
        public FilterWidthMode CurrentFilterWidthMode
        {
            get { return current_filter_width_mode; }
            set
            {
                current_filter_width_mode = value;
                UpdateRX1Filters((int)udFilterLow.Value, (int)udFilterHigh.Value);
            }
        }

        private void ptbFilterWidth_Update(int low, int high)
        {
            int bw = high - low;
            switch (rx1_dsp_mode)
            {
                case DSPMode.AM:
                case DSPMode.SAM:
                case DSPMode.FM:
                case DSPMode.DSB:
                    bw /= 2;
                    break;
            }

            int range = ptbFilterWidth.Maximum - ptbFilterWidth.Minimum;
            int new_val = 0;

            switch (current_filter_width_mode)
            {
                case FilterWidthMode.Linear:
                    new_val = ptbFilterWidth.Minimum + (int)((float)bw / max_filter_width * range);
                    break;
                case FilterWidthMode.Log:
                    double max_log = Math.Log(ptbFilterWidth.Maximum);
                    double temp = max_log - (float)bw / max_filter_width * max_log;
                    new_val = ptbFilterWidth.Maximum - (int)Math.Pow(Math.E, temp);
                    break;
                case FilterWidthMode.Log10:
                    max_log = Math.Log10(ptbFilterWidth.Maximum);
                    temp = max_log - (float)bw / max_filter_width * max_log;
                    new_val = ptbFilterWidth.Maximum - (int)Math.Pow(10, temp);
                    break;
            }

            if (new_val > ptbFilterWidth.Maximum) new_val = ptbFilterWidth.Maximum;
            if (new_val < ptbFilterWidth.Minimum) new_val = ptbFilterWidth.Minimum;
            ptbFilterWidth.Value = new_val;

        } // ptbFilterWidth_Update

        //==========================================================================================================
        private void ptbFilterWidth_Scroll(object sender, System.EventArgs e)
        {
            if (rx1_dsp_mode == DSPMode.DRM || rx1_dsp_mode == DSPMode.SPEC)
            {
                return;  // no good in this mode 
            }

            SelectRX1VarFilter();

            int range = ptbFilterWidth.Maximum - ptbFilterWidth.Minimum;
            int new_bw = 0;

            switch (current_filter_width_mode)
            {
                case FilterWidthMode.Linear:
                    new_bw = (int)((float)(ptbFilterWidth.Value - ptbFilterWidth.Minimum) / range * max_filter_width);
                    break;
                case FilterWidthMode.Log:
                    double max_log = Math.Log(ptbFilterWidth.Maximum);
                    double temp = Math.Log(Math.Max((ptbFilterWidth.Maximum - ptbFilterWidth.Value), 1.0));
                    temp = max_log - temp;
                    new_bw = (int)((float)(temp / max_log * max_filter_width));
                    break;
                case FilterWidthMode.Log10:
                    max_log = Math.Log10(ptbFilterWidth.Maximum);
                    temp = Math.Log10(Math.Max((ptbFilterWidth.Maximum - ptbFilterWidth.Value), 1.0));
                    temp = max_log - temp;
                    new_bw = (int)((float)(temp / max_log * max_filter_width));
                    break;
            }

            new_bw = Math.Max(new_bw, 10);

            int current_center = ((int)udFilterLow.Value + (int)udFilterHigh.Value) / 2;

            int low = 0, high = 0;
            switch (rx1_dsp_mode)
            {
                case DSPMode.AM:
                case DSPMode.SAM:
                case DSPMode.FM:
                case DSPMode.DSB:
                    low = current_center - new_bw;
                    high = current_center + new_bw;

                    if (low < -max_filter_width)
                    {
                        low += (-max_filter_width - low);
                        high += (-max_filter_width - low);
                    }
                    else if (high > max_filter_width)
                    {
                        high -= (high - max_filter_width);
                        low -= (high - max_filter_width);
                    }
                    break;
                case DSPMode.LSB:
                    high = -default_low_cut;
                    low = high - new_bw;
                    break;
                case DSPMode.CWL:
                case DSPMode.DIGL:
                    low = current_center - new_bw / 2;
                    high = current_center + new_bw / 2;
                    /*if(high > -default_low_cut && (int)udFilterHigh.Value <= -default_low_cut)
					{
						high = -default_low_cut;
						low = high - new_bw;
					}
					else*/
                    if (low < -9999)
                    {
                        low = -9999;
                        high = low + new_bw;
                    }
                    break;
                case DSPMode.USB:
                    low = default_low_cut;
                    high = low + new_bw;
                    break;
                case DSPMode.CWU:
                case DSPMode.DIGU:
                    low = current_center - new_bw / 2;
                    high = current_center + new_bw / 2;
                    /*if(low < default_low_cut && (int)udFilterLow.Value >= default_low_cut)
					{
						low = default_low_cut;
						high = low + new_bw;
					}
					else*/
                    if (high > 9999)
                    {
                        high = 9999;
                        low = high - new_bw;
                    }
                    break;
            }
            UpdateRX1Filters(low, high);

            if (ptbFilterWidth.Focused)
                btnHidden.Focus();
        } // ptbFilterWidth_Scroll



        private void tbFilterWidthScroll_newMode()
        {
            //centerSave = 0;  // dump any save center with scroller is keeping 
            switch (rx1_dsp_mode)
            {
                case DSPMode.SPEC:
                case DSPMode.DRM:
                    ptbFilterWidth.Enabled = false;
                    break;

                default:
                    ptbFilterWidth.Enabled = true;
                    break;
            }
        }

        #endregion

        #region VFO Button Events
        // ======================================================
        // VFO Button Events
        // ======================================================

        // Added 6/20/05 BT for CAT commands
        public void CATVFOSwap(string pChangec)
        {
            string c = pChangec;
            if (c.Length > 0)
            {
                switch (c)
                {
                    case "0":
                        btnVFOAtoB_Click(btnVFOAtoB, EventArgs.Empty);
                        break;
                    case "1":
                        btnVFOBtoA_Click(btnVFOBtoA, EventArgs.Empty);
                        break;
                    case "2":
                        btnVFOSwap_Click(btnVFOSwap, EventArgs.Empty);
                        break;
                    case "3":
                        btnIFtoVFO_Click(btnIFtoVFO, EventArgs.Empty);
                        break;
                }
            }
        }

        public void CopyVFOAtoB() // ke9ns used by flexcontroller
        {
            btnVFOAtoB_Click(this, EventArgs.Empty);
        }

        private void btnVFOAtoB_Click(object sender, System.EventArgs e)
        {
            if (rx2_enabled)
            {
                RX2DSPMode = rx1_dsp_mode;
                txtVFOBFreq.Text = txtVFOAFreq.Text;
                txtVFOBFreq_LostFocus(this, EventArgs.Empty);
                switch (rx1_filter)
                {
                    case Filter.F8:
                    case Filter.F9:
                    case Filter.F10:
                        RX2Filter = Filter.F1;
                        break;
                    case Filter.VAR1:
                    case Filter.VAR2:
                        RX2Filter = RX1Filter;
                        RX2FilterLow = RX1FilterLow;
                        RX2FilterHigh = RX2FilterHigh;
                        break;
                    default:
                        RX2Filter = rx1_filter;
                        break;
                }
                vfob_dsp_mode = rx1_dsp_mode;
                vfob_filter = rx1_filter;

                chkRX2SR.Checked = chkSR.Checked;
                comboRX2AGC.Text = comboAGC.Text;
            }
            else
            {
                txtVFOBFreq.Text = txtVFOAFreq.Text;
                txtVFOBFreq_LostFocus(this, EventArgs.Empty);
                vfob_dsp_mode = rx1_dsp_mode;
                vfob_filter = rx1_filter;
            }
        }

        public void CopyVFOBtoA()
        {
            btnVFOBtoA_Click(this, EventArgs.Empty);
        }

        private void btnVFOBtoA_Click(object sender, System.EventArgs e)
        {
            if (!rx2_enabled)
            {
                if (!chkEnableMultiRX.Checked)
                {
                    RX1DSPMode = vfob_dsp_mode;
                    RX1Filter = vfob_filter;
                }
                txtVFOAFreq.Text = txtVFOBFreq.Text;
                txtVFOAFreq_LostFocus(this, EventArgs.Empty);
            }
            else
            {
                RX1DSPMode = rx2_dsp_mode;
                txtVFOAFreq.Text = txtVFOBFreq.Text;

                txtVFOAFreq_LostFocus(this, EventArgs.Empty);
                switch (rx2_filter)
                {
                    case Filter.VAR1:
                    case Filter.VAR2:
                        RX1Filter = RX2Filter;
                        RX1FilterLow = RX2FilterLow;
                        RX1FilterHigh = RX2FilterHigh;
                        break;
                    default:
                        RX1Filter = RX2Filter;
                        break;
                }

                chkSR.Checked = chkRX2SR.Checked;
                comboAGC.Text = comboRX2AGC.Text;
            }
        }

        public void VFOSwap() // ke9ns called by flexcontroller button push
        {
            btnVFOSwap_Click(this, EventArgs.Empty);
        }

        // A <> B swap
        private void btnVFOSwap_Click(object sender, System.EventArgs e)
        {
            swapping = true;
            if (!rx2_enabled)
            {
                string temp = txtVFOAFreq.Text;

                if (!chkEnableMultiRX.Checked)
                {
                    DSPMode mode = rx1_dsp_mode;
                    Filter filter = rx1_filter;

                    RX1DSPMode = vfob_dsp_mode;
                    RX1Filter = vfob_filter;
                    vfob_dsp_mode = mode;
                    vfob_filter = filter;
                }

                txtVFOAFreq.Text = txtVFOBFreq.Text;
                txtVFOBFreq.Text = temp;

                txtVFOAFreq_LostFocus(this, EventArgs.Empty);
                txtVFOBFreq_LostFocus(this, EventArgs.Empty);
            }
            else // if RX2 ON
            {
                string a_freq = txtVFOAFreq.Text;      // STORE VFOA info
                string b_freq = txtVFOBFreq.Text;      // ke9ns add STORE VFOB info 

                DSPMode a_mode = rx1_dsp_mode;
                Filter a_filter = rx1_filter;

                int a_filter_low = 0, a_filter_high = 0;
                if (a_filter == Filter.VAR1 || a_filter == Filter.VAR2)
                {
                    a_filter_low = RX1FilterLow;
                    a_filter_high = RX1FilterHigh;
                }

                RX1DSPMode = rx2_dsp_mode;              // put VFOB into VFOA
                VFOAFreq = VFOBFreq;
                RX1Filter = rx2_filter;

                RX2DSPMode = a_mode;

                txtVFOAFreq.Text = b_freq;
                txtVFOBFreq.Text = a_freq;

                txtVFOAFreq_LostFocus(this, EventArgs.Empty);
                txtVFOBFreq_LostFocus(this, EventArgs.Empty);

                switch (a_filter)
                {
                    case Filter.F8:
                    case Filter.F9:
                    case Filter.F10:
                        RX2Filter = Filter.F1;
                        break;
                    case Filter.VAR1:
                    case Filter.VAR2:
                        RX2Filter = a_filter;
                        RX2FilterLow = a_filter_low;
                        RX2FilterHigh = a_filter_high;
                        break;
                    default:
                        RX2Filter = a_filter;
                        break;
                }

                bool sr = chkSR.Checked;
                chkSR.Checked = chkRX2SR.Checked;
                chkRX2SR.Checked = sr;

                string agc = comboAGC.Text;
                comboAGC.Text = comboRX2AGC.Text;
                comboRX2AGC.Text = agc;



            } // if RX2 ON

            swapping = false; // to handle VU swapping

            if (fwc_init && current_model == Model.FLEX5000 && FWCEEPROM.VUOK)
            {
                SetVURXPath();
            }
        } // A <> B

        private void UpdateVFOASub()
        {
            if (rx2_enabled)
            {
                if (chkVFOSplit.Checked)
                {

                    if (saved_vfoa_sub_freq == 7.0)
                    {
                        saved_vfoa_sub_freq = VFOAFreq; // saved_vfoa_freq;
                        Debug.WriteLine("VFOSYNC1");

                    }

                    txtVFOABand.Font = ff3; // new Font("Swis721 BT", 14.0f,  FontStyle.Italic | FontStyle.Bold); //Microsoft Sans Sarif FontStyle.Regular

                    if (saved_vfoa_sub_freq == Display.CLEAR_FLAG) saved_vfoa_sub_freq = saved_vfoa_freq;

                    txtVFOABand.Text = saved_vfoa_sub_freq.ToString("f6" );
                    tx_xvtr_index = xvtrForm.XVTRFreq(VFOASubFreq);

                    Debug.WriteLine("9VFOALostFocus ");
                    TXBand = BandByFreq(VFOASubFreq, tx_xvtr_index, true, current_region);

                    if (chkPower.Checked) txtVFOABand.ForeColor = Color.Red;
                    else txtVFOABand.ForeColor = Color.DarkRed;

                    txtVFOABand.TextAlign = HorizontalAlignment.Right;
                    txtVFOABand.ReadOnly = false;

                    txtVFOABand_LostFocus(this, EventArgs.Empty);
                    panelVFOASubHover.Visible = true;

                    return;
                }
                else if (chkEnableMultiRX.Checked)
                {
                    txtVFOABand.Font = ff3; // new Font("Swis721 BT", 14.0f,  FontStyle.Italic | FontStyle.Bold);
                    txtVFOABand.Text = saved_vfoa_sub_freq.ToString("f6" );
                    if (chkPower.Checked) txtVFOABand.ForeColor = vfo_text_light_color;
                    else txtVFOABand.ForeColor = vfo_text_dark_color;
                    txtVFOABand.TextAlign = HorizontalAlignment.Right;
                    txtVFOABand.ReadOnly = false;
                    txtVFOABand_LostFocus(this, EventArgs.Empty);
                    panelVFOASubHover.Visible = true;

                    return;
                }

            } // if (rx2_enabled)

            if (chkPower.Checked)
            {
                txtVFOBFreq_LostFocus(this, EventArgs.Empty); //.211

                txtVFOABand.Font = ff4; // new Font("Swis721 BT", 12.0f,  FontStyle.Italic | FontStyle.Bold);
                txtVFOABand.ForeColor = band_text_light_color;
                txtVFOABand.TextAlign = HorizontalAlignment.Center;
                txtVFOAFreq_LostFocus(this, EventArgs.Empty);
                panelVFOASubHover.Visible = false;
            }
            else
            {
                txtVFOBFreq_LostFocus(this, EventArgs.Empty); //.211
                txtVFOABand.Font = ff4; // new Font("Swis721 BT", 12.0f, FontStyle.Italic | FontStyle.Bold);
                txtVFOABand.ForeColor = band_text_dark_color;
                txtVFOABand.TextAlign = HorizontalAlignment.Center;
                txtVFOAFreq_LostFocus(this, EventArgs.Empty);
                panelVFOASubHover.Visible = false;
            }

        } // UpdateVFOASub()

        private void chkVFOSplit_CheckedChanged(object sender, System.EventArgs e)
        {
            Display.SplitEnabled = chkVFOSplit.Checked;

            if (chkVFOSplit.Checked)
            {

                chkVFOSplit.BackColor = button_selected_color; // red
                //FM front panel
                chkFMTXHigh.Enabled = false;
                chkFMTXHigh.Checked = false;
                chkFMTXLow.Enabled = false;
                chkFMTXLow.Checked = false;
                chkFMTXSimplex.Enabled = false;
                chkFMTXSimplex.Checked = false;
                chkFMTXRev.Enabled = false;
                chkFMTXRev.Checked = false;
                udFMOffset.Enabled = false;
                current_fm_tx_mode = FMTXMode.Simplex;
                //fm_tx_offset_mhz = 0;

            }
            else
            {
                chkVFOSplit.BackColor = SystemColors.Control; // black
                //FM front panel
                chkFMTXHigh.Enabled = true;
                chkFMTXLow.Enabled = true;
                chkFMTXSimplex.Enabled = true;
                chkFMTXSimplex.Checked = true;
                chkFMTXRev.Enabled = true;
                udFMOffset.Enabled = true;
                //fm_tx_offset_mhz = 0;

                if (setupForm != null) // ke9ns add (turn off split TX listen if it was on
                {
                    if (setupForm.chkBoxSplitListen.Checked == true)
                    {
                        chkEnableMultiRX.Checked = false;
                    }
                }

            }

            if (rx2_enabled)
            {
                if (chkVFOSplit.Checked)
                {
                    UpdateVFOASub();
                    if (chkVFOSplit.Checked) // ke9ns add .200  (fix.. resync SubVFOA and VFOA without using MultiRX)
                    {
                        VFOASubFreq = VFOAFreq;
                        UpdateVFOASub();
                    }

                    if (chkVFOBTX.Checked) chkVFOATX.Checked = true; // ke9ns: but the sub VFOA is TX
                }
                else
                {
                    txtVFOBFreq_LostFocus(this, EventArgs.Empty); //.211

                    UpdateVFOASub();

                    txtVFOAFreq_LostFocus(this, EventArgs.Empty);
                }
            }
            else // RX2 OFF (or NO RX2)
            {
                if (chkVFOSplit.Checked)
                {
                    if (chkVFOSync.Checked) chkVFOSync.Checked = false;

                    TXBand = BandByFreq(VFOBFreq, tx_xvtr_index, true, current_region);
                    grpVFOB.Font = ff5; // new Font("Swis721 BT", 8.25F, FontStyle.Regular | FontStyle.Italic);
                    grpVFOB.ForeColor = Color.Red;
                    chkVFOBTX.Checked = true;
                    //chkVFOBTX.ForeColor = Color.Black;
                    if (chkPower.Checked)
                    {
                        txtVFOBFreq.ForeColor = Color.Red;
                        txtVFOBMSD.ForeColor = Color.Red;
                        txtVFOBLSD.ForeColor = small_vfo_color;
                        txtVFOBBand.ForeColor = band_text_light_color;

                        if (current_model == Model.FLEX5000 && fwc_init)
                            txtVFOBFreq_LostFocus(this, EventArgs.Empty);
                    }
                }
                else
                {

                    grpVFOB.Font = ff5; //new Font("Swis721 BT", 8.25F, FontStyle.Italic | FontStyle.Regular);
                    grpVFOB.ForeColor = SystemColors.ControlLightLight;
                    chkVFOATX.Checked = true;
                    if (chkPower.Checked)
                    {
                        if (chkEnableMultiRX.Checked)
                        {
                            txtVFOBFreq.ForeColor = vfo_text_light_color;
                            txtVFOBMSD.ForeColor = vfo_text_light_color;
                            txtVFOBLSD.ForeColor = small_vfo_color;
                            txtVFOBBand.ForeColor = band_text_light_color;
                        }
                        else
                        {
                            txtVFOBFreq.ForeColor = vfo_text_dark_color;
                            txtVFOBMSD.ForeColor = vfo_text_dark_color;
                            txtVFOBLSD.ForeColor = vfo_text_dark_color;
                            txtVFOBBand.ForeColor = band_text_dark_color;
                        }

                        if (fwc_init && current_model == Model.FLEX5000 && !full_duplex)
                        {
                            txtVFOBFreq_LostFocus(this, EventArgs.Empty); //.211
                            txtVFOAFreq_LostFocus(this, EventArgs.Empty);
                        }
                    }
                    if (current_click_tune_mode == ClickTuneMode.VFOB && !chkEnableMultiRX.Checked && !chkFullDuplex.Checked)
                        CurrentClickTuneMode = ClickTuneMode.VFOA;
                }
            }
#if false
			// wjtFIXME! 
			// if we're doing soft rock stuff may need to update osc (tx mainly) when split is on
			if ( current_model ==  Model.SOFTROCK40 )
			
			{
				SetSoftRockOscFreqs();
			}
#endif
        } // chkVFOSplit_CheckedChanged


        private void chkXIT_CheckedChanged(object sender, System.EventArgs e)
        {
            if (chkXIT.Checked)
            {
                chkXIT.BackColor = button_selected_color;
                Display.XIT = (int)udXIT.Value;
            }
            else
            {
                chkXIT.BackColor = SystemColors.Control;
                Display.XIT = 0;
            }
#if false
			// wjtFIXME!
			if ( current_model == Model.SOFTROCK40 )			
			{
				SetSoftRockOscFreqs();
			}
#endif

            if (fwc_init && (current_model == Model.FLEX5000 || current_model == Model.FLEX3000))
            {
                if (chkVFOSplit.Checked || full_duplex)
                    txtVFOBFreq_LostFocus(this, EventArgs.Empty);
                else
                    txtVFOAFreq_LostFocus(this, EventArgs.Empty);
            }
            else
            {
                if (mox)
                {
                    if (chkVFOSplit.Checked)
                        txtVFOBFreq_LostFocus(this, EventArgs.Empty);
                    else
                        txtVFOAFreq_LostFocus(this, EventArgs.Empty);
                }
            }
        }

        private void chkRIT_CheckedChanged(object sender, System.EventArgs e)
        {
            if (chkRIT.Checked)
            {
                chkRIT.BackColor = button_selected_color;
                Display.RIT = (int)udRIT.Value;
            }
            else
            {
                chkRIT.BackColor = SystemColors.Control;
                Display.RIT = 0;
            }

            if (!mox)
                txtVFOAFreq_LostFocus(this, EventArgs.Empty);
        }

        private void udRIT_ValueChanged(object sender, System.EventArgs e)
        {
            if (chkRIT.Checked && !mox)
                txtVFOAFreq_LostFocus(this, EventArgs.Empty);
            if (chkRIT.Checked) Display.RIT = (int)udRIT.Value;

            /*if(udRIT.Focused)
				btnHidden.Focus();*/
        }

        private void udXIT_ValueChanged(object sender, System.EventArgs e)
        {
            if (chkXIT.Checked && mox)
            {
                if (fwc_init && (current_model == Model.FLEX5000 || current_model == Model.FLEX3000))
                {
                    if (chkVFOSplit.Checked || full_duplex)
                        txtVFOBFreq_LostFocus(this, EventArgs.Empty);
                    else
                        txtVFOAFreq_LostFocus(this, EventArgs.Empty);
                }
                else
                {
                    if (chkVFOSplit.Checked)
                        txtVFOBFreq_LostFocus(this, EventArgs.Empty);
                    else
                        txtVFOAFreq_LostFocus(this, EventArgs.Empty);
                }
            }
#if false
			//wjtFIXME
			else if ( current_model == Model.SOFTROCK40 )			
			{
				SetSoftRockOscFreqs();
			}
#endif


            if (chkXIT.Checked) Display.XIT = (int)udXIT.Value;

            /*if(udXIT.Focused)
				btnHidden.Focus();*/
        }

        private void btnXITReset_Click(object sender, System.EventArgs e)
        {
            udXIT.Value = 0;
        }

        private void btnRITReset_Click(object sender, System.EventArgs e)
        {
            udRIT.Value = 0;
        }

        public void ZeroBeat()
        {
            if (btnZeroBeat.Enabled)
                btnZeroBeat_Click(this, EventArgs.Empty);
        }

        private void btnZeroBeat_Click(object sender, System.EventArgs e)
        {
            int peak_hz = FindPeakFreqInPassband();
            if (peak_hz == -1)
            {
                return; // find peak croaked - bail
            }
            // Debug.WriteLine("peak: " + peak_hz);
            int delta_hz = 0;

            // if we're in CW mode, zero beat to CWPitch, provided it is in the passband
            switch (rx1_dsp_mode)
            {
                case DSPMode.CWL:
                case DSPMode.CWU:
                case DSPMode.USB:
                case DSPMode.LSB:
                    int local_pitch = CWPitch;
                    if (rx1_dsp_mode == DSPMode.CWL || rx1_dsp_mode == DSPMode.LSB)
                    {
                        local_pitch = -local_pitch;
                    }
                    // is cwoffset in passband?
                    if (local_pitch >= udFilterLow.Value &&
                        local_pitch <= udFilterHigh.Value)
                    {
                        delta_hz = peak_hz - local_pitch;
                        // Debug.WriteLine("delta(cw): " + delta_hz);
                    }
                    else
                    {
                        // if we get here and delta_hz is still 0, the current
                        // CW pitch is not within the passband.
                        // Put strongest peak @ center of passband
                        int center_hz = ((int)udFilterHigh.Value + (int)udFilterLow.Value) / 2;
                        delta_hz = peak_hz - center_hz;
                    }
                    break;
                case DSPMode.DIGL:
                    local_pitch = -digl_click_tune_offset;
                    if (local_pitch >= udFilterLow.Value &&
                        local_pitch <= udFilterHigh.Value)
                    {
                        delta_hz = peak_hz - local_pitch;
                    }
                    else
                    {
                        // if we get here and delta_hz is still 0, the current
                        // pitch is not within the passband.
                        // Put strongest peak @ center of passband
                        int center_hz = ((int)udFilterHigh.Value + (int)udFilterLow.Value) / 2;
                        delta_hz = peak_hz - center_hz;
                    }
                    break;
                case DSPMode.DIGU:
                    local_pitch = digu_click_tune_offset;
                    if (local_pitch >= udFilterLow.Value &&
                        local_pitch <= udFilterHigh.Value)
                    {
                        delta_hz = peak_hz - local_pitch;
                    }
                    else
                    {
                        // if we get here and delta_hz is still 0, the current
                        // pitch is not within the passband.
                        // Put strongest peak @ center of passband
                        int center_hz = ((int)udFilterHigh.Value + (int)udFilterLow.Value) / 2;
                        delta_hz = peak_hz - center_hz;
                    }
                    break;
                case DSPMode.AM:
                case DSPMode.SAM:
                case DSPMode.FM:
                    delta_hz = peak_hz;
                    break;
            }

            //          Debug.WriteLine("peak: " + peak_hz);
            //          Debug.WriteLine("center: " + center_hz);
            //          Debug.WriteLine("delta: " + delta_hz + "\n");

            if (zero_beat_rit)
            {
                udRIT.Value += delta_hz;
                chkRIT.Checked = true;
            }
            else
            {
                VFOAFreq += delta_hz * 1e-6;
            }
        }

        unsafe private int FindPeakFreqInPassband()
        {
            // convert hz to buckets in the averaging data
            int lo_cut_hz = (int)udFilterLow.Value;
            int hi_cut_hz = (int)udFilterHigh.Value;
            double hz_per_bucket = sample_rate1 / (double)Display.BUFFER_SIZE;
            int zero_hz_bucket = Display.BUFFER_SIZE / 2;
            int lo_bucket = (int)(lo_cut_hz / hz_per_bucket) + zero_hz_bucket;
            int hi_bucket = (int)(hi_cut_hz / hz_per_bucket) + zero_hz_bucket;

            //~~~~ 
            float max_val = float.MinValue;
            int max_bucket = 0;

            float[] spectrum_data;

            // reuse the existing display data if there is any
            switch (Display.CurrentDisplayMode)
            {
                case DisplayMode.PANADAPTER:
                case DisplayMode.HISTOGRAM:
                case DisplayMode.SPECTRUM:
                case DisplayMode.WATERFALL:
                case DisplayMode.PANAFALL:
                case DisplayMode.PANASCOPE:
                    if (chkDisplayAVG.Checked)
                    {
                        spectrum_data = Display.rx1_average_buffer; // force avg data into spectrum
                    }
                    else
                    {
                        spectrum_data = Display.current_display_data;
                    }
                    break;

                // no specturm data - go get some 
                default:
                    spectrum_data = new float[Display.BUFFER_SIZE];
                    if (spectrum_data == null)
                    {
                        return -1; // bail out - not buffer 
                    }
                    fixed (float* ptr = &(spectrum_data[0]))
                        DttSP.GetSpectrum(0, ptr);
                    break;
            }

            for (int i = lo_bucket; i <= hi_bucket; i++)
            {
                if (spectrum_data[i] > max_val)
                {
                    max_bucket = i;
                    max_val = spectrum_data[i];
                }
            }
            int peak_hz = (int)((max_bucket - zero_hz_bucket) * hz_per_bucket);
            return peak_hz;
        }

        private void btnIFtoVFO_Click(object sender, System.EventArgs e)
        {
            int current_if_shift;

            bool is_centered_mode = false;
            bool is_cw_mode = false;
            bool is_lower_sb_mode = false;

            current_if_shift = ptbFilterShift.Value;

            //			Debug.WriteLine("current if shift: " + current_if_shift);

            if (current_if_shift == 0) return; // nothing to do

            switch (RX1DSPMode)
            {
                case DSPMode.DRM:
                case DSPMode.SPEC:
                case DSPMode.DIGL:
                case DSPMode.DIGU:
                    return; // nothing to do for these modes

                case DSPMode.AM:
                case DSPMode.FM:
                case DSPMode.DSB:
                case DSPMode.SAM:
                    is_centered_mode = true;
                    break;

                case DSPMode.CWL:
                    is_cw_mode = true;
                    is_lower_sb_mode = true;
                    break;
                case DSPMode.CWU:
                    is_cw_mode = true;
                    break;
                case DSPMode.LSB:
                    is_lower_sb_mode = true;
                    break;
                case DSPMode.USB:
                    break;
                default:
                    // no clue what the mode is -- bail out
                    return;
            }

            int current_width = (int)udFilterHigh.Value - (int)udFilterLow.Value;
            int current_center = (int)udFilterLow.Value + (current_width / 2);
            //			Debug.WriteLine("w: " + current_width + " center: " + current_center + " vfo: " +  VFOAFreq);

            double new_vfo = 0;
            int new_lo = 0;
            int new_hi = 0;

            if (is_centered_mode)
            {
                new_vfo = VFOAFreq + ((double)current_center) / (1e6);
                new_lo = -(current_width / 2);
                new_hi = current_width / 2;
            }
            else  // sideband style mode
            {
                int new_center;
                if (is_cw_mode)
                {
                    new_center = cw_pitch;
                }
                else  // sideband mode
                {
                    new_center = default_low_cut + (current_width / 2);
                }
                if (is_lower_sb_mode)
                {
                    new_center = -new_center;
                }
                new_vfo = VFOAFreq + ((double)(current_center - new_center)) / (1e6);
                // now figure out filter limits
                new_lo = new_center - (current_width / 2);
                new_hi = new_center + (current_width / 2);
            }
            //			Debug.WriteLine("new vfo: " + new_vfo + " lo: " + new_lo + " hi: " + new_hi );
            if (VFOAFreq > new_vfo)  // need to change this in the right order!
            {
                udFilterHigh.Value = new_hi;
                udFilterLow.Value = new_lo;
            }
            else
            {
                udFilterLow.Value = new_lo;
                udFilterHigh.Value = new_hi;
            }

            VFOAFreq = new_vfo;
            switch (RX1Filter)
            {
                case Filter.VAR1:
                    last_var1_shift = 0;
                    break;
                case Filter.VAR2:
                    last_var2_shift = 0;
                    break;
                default:
                    last_filter_shift = 0;
                    break;
            }
            btnFilterShiftReset_Click(this, EventArgs.Empty);
        }

        #endregion

        #region DSP Button Events

        private void chkNR_CheckedChanged(object sender, System.EventArgs e)
        {
            if (chkNR.Checked) chkNR.BackColor = button_selected_color;
            else chkNR.BackColor = SystemColors.Control;
            dsp.GetDSPRX(0, 0).NoiseReduction = chkNR.Checked;
            dsp.GetDSPRX(0, 1).NoiseReduction = chkNR.Checked;
            cat_nr_status = Convert.ToInt32(chkNR.Checked);


        }

        private void chkANF_CheckedChanged(object sender, System.EventArgs e)
        {
            if (chkANF.Checked) chkANF.BackColor = button_selected_color;
            else chkANF.BackColor = SystemColors.Control;
            dsp.GetDSPRX(0, 0).AutoNotchFilter = chkANF.Checked;
            dsp.GetDSPRX(0, 1).AutoNotchFilter = chkANF.Checked;
            cat_anf_status = Convert.ToInt32(chkANF.Checked);
        }

        private void chkNB_CheckedChanged(object sender, System.EventArgs e)
        {
            if (chkNB.Checked) chkNB.BackColor = button_selected_color;
            else chkNB.BackColor = SystemColors.Control;
            dsp.GetDSPRX(0, 0).NBOn = chkNB.Checked;
            dsp.GetDSPRX(0, 1).NBOn = chkNB.Checked;
            cat_nb1_status = Convert.ToInt32(chkNB.Checked);
        }

        private void chkDSPNB2_CheckedChanged(object sender, System.EventArgs e)
        {
            if (chkDSPNB2.Checked) chkDSPNB2.BackColor = button_selected_color;
            else chkDSPNB2.BackColor = SystemColors.Control;
            dsp.GetDSPRX(0, 0).SDROM = chkDSPNB2.Checked;
            dsp.GetDSPRX(0, 1).SDROM = chkDSPNB2.Checked;
            cat_nb2_status = Convert.ToInt32(chkDSPNB2.Checked);
        }

        #endregion

        #region Mode Specific Events

        private void chkCPDR_CheckedChanged(object sender, System.EventArgs e)
        {
            if (chkCPDR.Checked)
            {
                chkCPDR.BackColor = button_selected_color;
                chkDX.Checked = false;
                ptbCPDR_Scroll(this, EventArgs.Empty);
            }
            else
            {
                chkCPDR.BackColor = SystemColors.Control;
            }
            if (chkDX.Checked || chkCPDR.Checked)
                dsp.GetDSPTX(0).TXCompandOn = true;
            else dsp.GetDSPTX(0).TXCompandOn = false;
            cat_cmpd_status = Convert.ToInt32(chkCPDR.Checked);
        }

        private void ptbCPDR_Scroll(object sender, System.EventArgs e)
        {
            lblCPDRVal.Text = ptbCPDR.Value.ToString();

            if (chkCPDR.Checked)
                dsp.GetDSPTX(0).TXCompandLevel = 0.1 * (double)ptbCPDR.Value;

            if (ptbCPDR.Focused) btnHidden.Focus();
        }

        private void chkDX_CheckedChanged(object sender, System.EventArgs e)
        {
            if (chkDX.Checked)
            {
                chkDX.BackColor = button_selected_color;
                if (chkCPDR.Checked) chkCPDR.Checked = false;
                ptbDX_Scroll(this, EventArgs.Empty);
            }
            else
            {
                chkDX.BackColor = SystemColors.Control;
            }
            if (chkDX.Checked || chkCPDR.Checked)
                dsp.GetDSPTX(0).TXCompandOn = true;
            else dsp.GetDSPTX(0).TXCompandOn = false;
        }

        private void ptbDX_Scroll(object sender, System.EventArgs e)
        {
            lblDXVal.Text = ptbDX.Value.ToString();

            if (chkDX.Checked)
                dsp.GetDSPTX(0).TXCompandLevel = 1.0 + 0.4 * (double)ptbDX.Value;
            if (ptbDX.Focused) btnHidden.Focus();
        }

        #endregion

        #region Memory Events
        // ======================================================
        // Memory Events
        // ======================================================

        private void btnMemoryQuickSave_Click(object sender, System.EventArgs e)
        {
            txtMemoryQuick.Text = txtVFOAFreq.Text;
            quick_save_mode = RX1DSPMode;
            quick_save_filter = RX1Filter;
        }

        private void btnMemoryQuickRestore_Click(object sender, System.EventArgs e)
        {
            SaveBandA();
            last_band = "";
            RX1DSPMode = quick_save_mode;
            txtVFOAFreq.Text = txtMemoryQuick.Text;
            txtVFOAFreq_LostFocus(this, EventArgs.Empty);
            RX1Filter = quick_save_filter;
        }

        #endregion

        #region Menu Events
        // ======================================================
        // Menu Events
        // ======================================================

        private void menu_setup_Click(object sender, System.EventArgs e)
        {
            if (setupForm.IsDisposed)
                setupForm = new Setup(this);
            setupForm.Show();
            setupForm.Focus();
            setupForm.WindowState = FormWindowState.Normal; // ke9ns add
        }

        private void menu_wave_Click(object sender, System.EventArgs e)
        {
            if (WaveForm.IsDisposed)
                WaveForm = new WaveControl(this);
            WaveForm.Show();
            WaveForm.Focus();
            WaveForm.WindowState = FormWindowState.Normal; // ke9ns add
        }

        private void mnuEQ_Click(object sender, System.EventArgs e)
        {
            if (eqForm == null || eqForm.IsDisposed)
                eqForm = new EQForm(this);
            eqForm.Show();
            eqForm.Focus();
            eqForm.WindowState = FormWindowState.Normal; // ke9ns add
        }

        private void mnuUCB_Click(object sender, System.EventArgs e)
        {
            if (ucbForm == null || ucbForm.IsDisposed)
                ucbForm = new UCBForm(this);
            ucbForm.Show();
            ucbForm.Focus();
        }

        private void mnuXVTR_Click(object sender, System.EventArgs e)
        {
            if (xvtrForm == null || xvtrForm.IsDisposed)
                xvtrForm = new XVTRForm(this);

            xvtrForm.Show();
            xvtrForm.Focus();
            xvtrForm.WindowState = FormWindowState.Normal; // ke9ns add
        }
        /*
                private void mnuCWX_Click(object sender, System.EventArgs e) // click on CWX button
                {
                    if (setupForm == null || setupForm.IsDisposed)   setupForm = new Setup(this);

                    if ((setupForm != null) && (setupForm.chkKeyPoll.Checked == false))
                    {
                        if (rx1_dsp_mode == DSPMode.LSB) RX1DSPMode = DSPMode.CWL;
                        else if (rx1_dsp_mode == DSPMode.USB) RX1DSPMode = DSPMode.CWU;

                        if (rx1_dsp_mode != DSPMode.CWL && rx1_dsp_mode != DSPMode.CWU)
                        {
                            RX1DSPMode = DSPMode.CWU;
                            // MessageBox.Show(new Form { TopMost = true }, "The radio must be in CWL or CWU mode in order to open the " +
                            //    "CWX Control Form.",
                            //    "CWX Error: Wrong Mode",
                            //   MessageBoxButtons.OK,
                            //  MessageBoxIcon.Error);
                            // return;
                        }

                    }
                    //	cw_key_mode = true;
                    if(cwxForm == null || cwxForm.IsDisposed)
                    {
                        cwxForm = new CWX(this);
                    }

                    cwxForm.Show();
                    cwxForm.Focus();
                    cwxForm.WindowState = FormWindowState.Normal; // ke9ns add

                } // mnuCWX_Click
        */
        private void menuItemFilterConfigure_Click(object sender, System.EventArgs e)
        {
            if (rx1_dsp_mode == DSPMode.DRM || rx1_dsp_mode == DSPMode.SPEC) return;

            if (filterRX1Form == null || filterRX1Form.IsDisposed)
                filterRX1Form = new FilterForm(this, rx1_filters, false);

            filterRX1Form.DSPMode = rx1_dsp_mode;
            filterRX1Form.CurrentFilter = rx1_filter;
            filterRX1Form.Show();
            filterRX1Form.Focus();
            filterRX1Form.WindowState = FormWindowState.Normal; // ke9ns add
        }

        private void menuItemRX2FilterConfigure_Click(object sender, System.EventArgs e)
        {
            if (rx2_dsp_mode == DSPMode.DRM || rx2_dsp_mode == DSPMode.SPEC) return;

            if (filterRX2Form == null || filterRX2Form.IsDisposed)
                filterRX2Form = new FilterForm(this, rx2_filters, true);

            filterRX2Form.DSPMode = rx2_dsp_mode;
            filterRX2Form.CurrentFilter = rx2_filter;
            filterRX2Form.Show();
            filterRX2Form.Focus();
            filterRX2Form.WindowState = FormWindowState.Normal; // ke9ns add
        }

        private void mnuReportBug_Click(object sender, System.EventArgs e)
        {
            Thread t = new Thread(new ThreadStart(LaunchBugLink));
            t.Name = "Launch HelpDesk Link Thread";  //W4TME
            t.IsBackground = true;
            t.Priority = ThreadPriority.Normal;
            t.Start();
        }

        private void LaunchBugLink()
        {
            try
            {
                Process.Start("http://helpdesk.flexradio.com"); // W4TME
            }
            catch (Exception) { }
        }

        private void mnuAbout_Click(object sender, System.EventArgs e)                  // W4TME
        {
            // launch about form here
            AboutForm form = new AboutForm();
            form.ShowDialog();
            form.Focus();
        }

        private void mnuMixer_Click(object sender, System.EventArgs e)
        {
            if (fwc_init || hid_init)
            {
                switch (current_model)
                {
                    case Model.FLEX5000:
                        if (fwcMixForm == null || fwcMixForm.IsDisposed)
                            fwcMixForm = new FWCMixForm(this);
                        fwcMixForm.Show();
                        fwcMixForm.Focus();
                        fwcMixForm.WindowState = FormWindowState.Normal; // ke9ns add
                        break;
                    case Model.FLEX3000:
                        if (flex3000MixerForm == null || flex3000MixerForm.IsDisposed)
                            flex3000MixerForm = new FLEX3000MixerForm(this);
                        flex3000MixerForm.Show();
                        flex3000MixerForm.Focus();
                        flex3000MixerForm.WindowState = FormWindowState.Normal; // ke9ns add
                        break;
                    case Model.FLEX1500:
                        if (flex1500MixerForm == null || flex1500MixerForm.IsDisposed)
                            flex1500MixerForm = new FLEX1500MixerForm(this);
                        flex1500MixerForm.Show();
                        flex1500MixerForm.Focus();
                        flex1500MixerForm.WindowState = FormWindowState.Normal; // ke9ns add
                        break;
                }
            }
        }

        private void mnuAntenna_Click(object sender, System.EventArgs e)
        {
            if (fwc_init && current_model == Model.FLEX5000)
            {
                if (fwcAntForm == null || fwcAntForm.IsDisposed)
                    fwcAntForm = new FWCAntForm(this);
                fwcAntForm.Show();
                fwcAntForm.Focus();
                fwcAntForm.WindowState = FormWindowState.Normal; // ke9ns add
            }
            else if (hid_init && current_model == Model.FLEX1500)
            {
                if (hidAntForm == null || hidAntForm.IsDisposed)
                    hidAntForm = new HIDAntForm(this);
                hidAntForm.Show();
                hidAntForm.Focus();
                hidAntForm.WindowState = FormWindowState.Normal; // ke9ns add
            }
        }

        private void mnuRelays_Click(object sender, System.EventArgs e)
        {
            //if(fwc_init && current_model == Model.FLEX5000)
            {
                if (flex5000RelayForm == null || flex5000RelayForm.IsDisposed)
                    flex5000RelayForm = new FLEX5000RelayForm(this);
                flex5000RelayForm.Show();
                flex5000RelayForm.Focus();
                flex5000RelayForm.WindowState = FormWindowState.Normal; // ke9ns add
            }
        }

        private void mnuATU_Click(object sender, System.EventArgs e)
        {
            if (fwc_init && current_model == Model.FLEX5000)
            {
                if (fwcAtuForm == null || fwcAtuForm.IsDisposed)
                    fwcAtuForm = new FWCATUForm(this);
                fwcAtuForm.Show();
                fwcAtuForm.Focus();
                fwcAtuForm.WindowState = FormWindowState.Normal; // ke9ns add
            }
            else if (fwc_init && current_model == Model.FLEX3000)
            {
                if (flex3000ATUForm == null || flex3000ATUForm.IsDisposed)
                    flex3000ATUForm = new FLEX3000ATUForm(this);
                flex3000ATUForm.Show();
                flex3000ATUForm.Focus();
                flex3000ATUForm.WindowState = FormWindowState.Normal; // ke9ns add
            }
        }

        private void mnuProfiles_Click(object sender, System.EventArgs e)
        {
            if (File.Exists(Application.StartupPath + "\\command.xml"))
            {
                if (ProfileForm == null || ProfileForm.IsDisposed)
                    ProfileForm = new RemoteProfiles(this);
                ProfileForm.Show();
                ProfileForm.Focus();
                ProfileForm.WindowState = FormWindowState.Normal; // ke9ns add
            }
            else
                MessageBox.Show(new Form { TopMost = true }, "You must create at least one remote profile first", "No Profiles Available", MessageBoxButtons.OK);
        }

        #endregion

        #region Sub RX Events
        // ======================================================
        // Sub RX Events
        // ======================================================

        private void ptbPanMainRX_Scroll(object sender, System.EventArgs e)
        {
            //if(chkEnableMultiRX.Checked)
            {
                float val = (int)ptbPanMainRX.Value / 100.0f;
                if (chkPanSwap.Checked) val = 1.0f - val;
                dsp.GetDSPRX(0, 0).Pan = val;
            }
            if (ptbPanMainRX.Focused)
                btnHidden.Focus();
        }

        private void ptbPanSubRX_Scroll(object sender, System.EventArgs e)
        {
            float val = (int)ptbPanSubRX.Value / 100.0f;
            if (chkPanSwap.Checked) val = 1.0f - val;
            dsp.GetDSPRX(0, 1).Pan = val;

            if (ptbPanSubRX.Focused)
                btnHidden.Focus();
        }


        //==================================================================================
        private void chEnableMultiRX_CheckedChanged(object sender, System.EventArgs e)
        {
            dsp.GetDSPRX(0, 1).Active = chkEnableMultiRX.Checked;

            if (chkEnableMultiRX.Checked)
            {

                //tbPanMainRX_Scroll(this, EventArgs.Empty);
                //tbRX0Gain_Scroll(this, EventArgs.Empty);

                chkEnableMultiRX.BackColor = button_selected_color;
                if (chkPower.Checked)
                {
                    if (rx2_enabled)
                    {
                        if (setupForm.chkBoxMRX.Checked == true) VFOASubFreq = VFOAFreq; // ke9ns add: start with sub on top of vfoA

                        UpdateVFOASub();

                    }
                    else
                    {
                        if (setupForm.chkBoxMRX.Checked == true) VFOBFreq = VFOAFreq; // ke9ns add:  start with B synced to A

                        txtVFOBFreq_LostFocus(this, EventArgs.Empty);
                        if (chkVFOSplit.Checked) chkVFOSplit_CheckedChanged(this, EventArgs.Empty);
                        else
                        {
                            txtVFOBFreq.ForeColor = vfo_text_light_color;
                            txtVFOBMSD.ForeColor = vfo_text_light_color;
                            txtVFOBLSD.ForeColor = small_vfo_color;
                            txtVFOBBand.ForeColor = band_text_light_color;
                        }
                        Debug.WriteLine("MULTIRX HERE");

                    }
                }

                dsp.GetDSPRX(0, 1).SetRXFilter(dsp.GetDSPRX(0, 0).RXFilterLow, dsp.GetDSPRX(0, 0).RXFilterHigh);   // turn on sub receiver 
            }
            else // ke9ns: if multiRX turned OFF (below)
            {
                //dsp.GetDSPRX(0, 0).RXOutputGain = 1.0;
                //dsp.GetDSPRX(0, 0).Pan = 0.5f;
                chkEnableMultiRX.BackColor = SystemColors.Control;
                //if(chkPower.Checked)
                {
                    if (rx2_enabled)
                    {
                        UpdateVFOASub();
                    }
                    else
                    {
                        if (chkVFOSplit.Checked && !rx2_enabled) chkVFOSplit_CheckedChanged(this, EventArgs.Empty);
                        else if (rx2_enabled) chkRX2_CheckedChanged(this, EventArgs.Empty);
                        else
                        {
                            txtVFOBFreq.ForeColor = vfo_text_dark_color;
                            txtVFOBMSD.ForeColor = vfo_text_dark_color;
                            txtVFOBLSD.ForeColor = vfo_text_dark_color;
                            txtVFOBBand.ForeColor = band_text_dark_color;
                        }
                    }
                }
                if (current_click_tune_mode == ClickTuneMode.VFOB && !chkFullDuplex.Checked && !chkVFOSplit.Checked)
                    CurrentClickTuneMode = ClickTuneMode.VFOA;
            } // multiRX off

            Display.SubRX1Enabled = chkEnableMultiRX.Checked;
            UpdateRX1SubNotches();

        } // chEnableMultiRX_CheckedChanged



        private void chkPanSwap_CheckedChanged(object sender, System.EventArgs e)
        {
            //if(chkEnableMultiRX.Checked)
            {
                ptbPanMainRX_Scroll(this, EventArgs.Empty);
                ptbPanSubRX_Scroll(this, EventArgs.Empty);
            }
        }

        private void ptbRX0Gain_Scroll(object sender, System.EventArgs e)
        {
            //if(chkEnableMultiRX.Checked)
            dsp.GetDSPRX(0, 0).RXOutputGain = (double)ptbRX0Gain.Value / ptbRX0Gain.Maximum * 0.5;  //max 0.5 to allow for headroom  (top = .5, bottom = 0
            if (ptbRX0Gain.Focused)
                btnHidden.Focus();
        }

        private void ptbRX1Gain_Scroll(object sender, System.EventArgs e)
        {
            dsp.GetDSPRX(0, 1).RXOutputGain = (double)ptbRX1Gain.Value / ptbRX1Gain.Maximum * 0.5;  //max 0.5 to allow for headroom

            if (ptbRX1Gain.Focused)
                btnHidden.Focus();
        }

        #endregion

        /*private void button1_Click(object sender, System.EventArgs e)
		{
            p = new Progress("Test TX Spur");
            Thread t = new Thread(new ThreadStart(CallCalTXSpur));
            t.Name = "Test TX Spur Thread";
            t.IsBackground = true;
            t.Priority = ThreadPriority.Normal;
            t.Start();
            p.Show();
		}*/

        public void TestTXCarrier()
        {
            if (!chkPower.Checked)
            {
                MessageBox.Show(new Form { TopMost = true }, "Power must be on.");
                return;
            }

            double vfoa = VFOAFreq;
            double vfob = VFOBFreq;

            bool duplex = full_duplex;
            FullDuplex = true;

            bool spur_red = chkSR.Checked;                  // save current spur reduction setting
            chkSR.Checked = false;                          // turn spur reduction off

            bool polyphase = setupForm.Polyphase;           // save current polyphase setting
            setupForm.Polyphase = false;                    // disable polyphase

            int dsp_buf_size = setupForm.DSPPhoneRXBuffer;      // save current DSP buffer size
            setupForm.DSPPhoneRXBuffer = 4096;                  // set DSP Buffer Size to 4096

            // setup display mode
            string display = comboDisplayMode.Text;
            comboDisplayMode.Text = "Spectrum";

            // setup dsp mode
            DSPMode dsp_mode = RX1DSPMode;
            RX1DSPMode = DSPMode.DSB;

            // setup filter
            Filter filter = RX1Filter;
            UpdateRX1Filters(-500, 500);

            FullDuplex = true;
            FWC.SetQSD(true);
            FWC.SetQSE(true);
            FWC.SetTR(true);
            FWC.SetSig(true);
            FWC.SetGen(false);
            FWC.SetTest(true);
            FWC.SetTXMon(false);

            Audio.TXInputSignal = Audio.SignalSource.SILENCE;
            //Audio.SourceScale = 1.0;

            double start = 14.0;
            double end = 14.350;
            double step = 0.001;
            float[] a = new float[Display.BUFFER_SIZE];
            StringBuilder s = new StringBuilder();

            for (double freq = start; freq < end; freq += step)
            {
                VFOAFreq = freq;
                VFOBFreq = freq;
                Thread.Sleep(100);

                float sum = 0.0f;
                for (int i = 0; i < 5; i++)
                {
                    calibration_mutex.WaitOne();
                    fixed (float* ptr = &a[0])
                        DttSP.GetSpectrum(0, ptr);// get the spectrum values
                    calibration_mutex.ReleaseMutex();
                    Thread.Sleep(50);

                    sum += a[2048];
                }
                float avg = (sum / 5) + Display.RX1DisplayCalOffset + Display.RX1PreampOffset;
                s.Append(freq.ToString("f6" ) + "," + avg.ToString("f1") + "\n");
            }

            StreamWriter writer = new StreamWriter(app_data_path + "tx_carrier" + start.ToString("f6" ) + "-" + end.ToString("f6" ) + ".csv"); // "\\tx_carrier"

            writer.WriteLine("freq,carrier");
            writer.Write(s.ToString());
            writer.Close();

            // return output tone
            Audio.TXInputSignal = Audio.SignalSource.RADIO;

            // return hardware to normal operation
            FWC.SetSig(false);
            FWC.SetTest(false);
            FWC.SetQSE(false);

            setupForm.Polyphase = polyphase;
            setupForm.DSPPhoneRXBuffer = dsp_buf_size;
            chkSR.Checked = spur_red;
            FullDuplex = duplex;

            VFOAFreq = vfoa;
            VFOBFreq = vfob;

            comboDisplayMode.Text = display;

            RX1DSPMode = dsp_mode;
            RX1Filter = filter;
        }

        public void CallCalStepGen()
        {
            p = new Progress("Calibrate Gen");
            Thread t = new Thread(new ThreadStart(CalStepGen));
            t.Name = "Run Calibrate Gen Thread";
            t.IsBackground = true;
            t.Priority = ThreadPriority.Normal;
            t.Start();
            p.Show();
        }

        public void CalStepGen()
        {
            if (!chkPower.Checked)
            {
                MessageBox.Show(new Form { TopMost = true }, "Power must be on.");
                return;
            }

            if (current_model != Model.FLEX5000) return;

            VFOAFreq = 14.100;
            VFOBFreq = 14.004;

            for (int i = 0; i < 100; i++)
            {
                VFOBFreq = 14.004 + i * 0.001920;
                Thread.Sleep(100);
            }

            p.Hide();
        }

        private bool full_duplex = false;
        public bool FullDuplex
        {
            get { return full_duplex; }
            set
            {
                full_duplex = value;
                if (fwc_init && (current_model == Model.FLEX5000 || current_model == Model.FLEX3000))
                {
                    FWC.SetFullDuplex(chkFullDuplex.Checked);
                }
                chkFullDuplex.Checked = value;
            }
        }

        private void chkFullDuplex_CheckedChanged(object sender, System.EventArgs e)
        {
            FullDuplex = chkFullDuplex.Checked;
            Audio.FullDuplex = chkFullDuplex.Checked;
            if (chkFullDuplex.Checked)
            {
                //MessageBox.Show(new Form { TopMost = true }, "Full Duplex is On");
                chkFullDuplex.BackColor = Color.Red;
                txtVFOBFreq_LostFocus(this, EventArgs.Empty);
                DttSP.SetThreadProcessingMode(0, 2);
                DttSP.SetThreadProcessingMode(1, 2);
            }
            else
            {
                chkFullDuplex.BackColor = SystemColors.Control;
                txtVFOAFreq_LostFocus(this, EventArgs.Empty);
                if (chkMOX.Checked)
                {
                    DttSP.SetThreadProcessingMode(0, 0);
                    DttSP.SetThreadProcessingMode(1, 2);
                }
                else
                {
                    DttSP.SetThreadProcessingMode(0, 2);
                    DttSP.SetThreadProcessingMode(1, 0);
                }
                if (current_click_tune_mode == ClickTuneMode.VFOB && !chkVFOSplit.Checked && !chkEnableMultiRX.Checked)
                    CurrentClickTuneMode = ClickTuneMode.VFOA;
            }
        }

        private static Console theConsole = null;

        public static Console getConsole()
        {
            return theConsole;
        }

        //=====================================================
        // ke9ns message pump

        private static bool systemShutDown = false;

        [System.Security.Permissions.PermissionSet(System.Security.Permissions.SecurityAction.Demand, Name = "FullTrust")]
        protected override void WndProc(ref Message m)
        {
            const int WM_QUERYENDSESSION = 0x0011;
            const int WM_320 = 0x320; // ke9ns: this occurs when you shutdown windows
            const int WM_Quit = 18;
            //  const int WM_Close = 16; // ke9ns triggered if you hit the X button
            const int WM_EndSession = 0x0016; // ke9ns shutdown
            const int WM_DEVICECHANGE = 0x0219;



            // Listen for operating system messages. 
            //   Debug.WriteLine("PROC: " + m.ToString());

            switch (m.Msg)
            {

                /*

                 // ke9ns: turned off. This was supposed to only happen when you shut windows down with powerSDR running, but its not the case

                                case WM_QUERYENDSESSION: // this indicates windows is shutting down
                                case WM_320:


                                    StreamWriter writer = new StreamWriter(app_data_path + "shutdown0.log", append: true); //   // look for %userprofile%\AppData\Roaming\FlexRadio Systems\PowerSDR v2.8.0\
                                    writer.WriteLine("This is PowerSDR finding out that Windows want to shut down");

                                    writer.WriteLine("Message: " + m.ToString());
                                    writer.Close();


                                    Debug.WriteLine("QUERYENDSESSION " + m.Msg);

                                    //   MessageBox.Show(new Form { TopMost = true }, "Message " + m.Msg);

                                    if (setupForm != null && setupForm.chkBoxShutdown.Checked == true)
                                    {

                                        if (SpotForm != null) // ke9ns add .198
                                        {
                                            Debug.WriteLine("SPOT TURNED OFF " + SpotForm.checkBoxMUF.Checked + " , " + SpotForm.VOARUN + " , " + SpotForm.VOARUN + " , " + SpotControl.SP5_Active + " , " + SpotForm.mapon);

                                            SpotForm.checkBoxMUF.CheckedChanged -= SpotForm.checkBoxMUF_CheckedChanged;
                                            SpotForm.checkBoxMUF.Checked = false;
                                            SpotControl.Map_Last = SpotControl.Map_Last | 2;    // force update of world map


                                            SpotControl.SP5_Active = 0;                     // turn off tracking



                                            Debug.WriteLine("SPOT TURNED OFF- " + SpotForm.checkBoxMUF.Checked + " , " + SpotForm.VOARUN + " , " + SpotForm.VOARUN + " , " + SpotControl.SP5_Active + " , " + SpotForm.mapon);

                                        } //  if (SpotForm != null) 

                                        systemShutDown = true;
                                        chkPower.Checked = false;


                                        this.Close();
                                    }
                                    else
                                    {
                                        base.WndProc(ref m);
                                    }

                                    //  Environment.Exit(0);
                                    //  ExitConsole();


                                    base.WndProc(ref m);
                                    break;
                */

                case WM_DEVICECHANGE: // 0x219
                    if (flexcontrol_autodetect) FlexControlScan();
                    break;
                default:

                    //   StreamWriter writer1 = new StreamWriter(app_data_path + "shutdown8.log", append:true); //   // look for %userprofile%\AppData\Roaming\FlexRadio Systems\PowerSDR v2.8.0\
                    //  writer1.WriteLine("Message: "+ m.ToString());     
                    //   writer1.Close();

                    base.WndProc(ref m);

                    break;
            }
        }

        public void FWCATUBypass()
        {
            chkFWCATU.Checked = false;
            chkFWCATUBypass.Checked = true;
        }

        public void FWCATUTuned()
        {
            chkFWCATU.Checked = true;
            chkFWCATUBypass.Checked = false;
        }

        public void FWCATUFailed()
        {
            chkFWCATU.Checked = false;
            chkFWCATUBypass.Checked = true;
        }

        public void SetATUFeedback(string s)
        {
            toolTip1.SetToolTip(chkFWCATU, s);
        }

        // ke9ns add  if in pulser and just checked tun, then 
        private void chkFWCATU_CheckedChanged(object sender, EventArgs e)
        {
            //  if (chkFWCATU.Checked == false)
            //  {
            //     if (setupForm.chkBoxPulser.Checked == true)
            //    {
            //       chkFWCATU.Checked = false; // ke9ns keep ATU off until you set TUNp back to TUN

            //  }
            //   }


        } // chkFWCATU_CheckedChanged

        private void chkFWCATU_Click(object sender, System.EventArgs e)
        {
            if (fwc_init && current_model == Model.FLEX5000 &&
                fwcAtuForm != null && !fwcAtuForm.IsDisposed)
            {
                if (!chkTUN.Checked)
                {
                    fwcAtuForm.DoTuneMemory();
                    FWCATUTuned();
                }
                else
                {
                    chkTUN.Checked = false;
                    chkFWCATUBypass_Click(this, EventArgs.Empty);
                }
            }
            else if (fwc_init && current_model == Model.FLEX3000 &&
                flex3000ATUForm != null && !flex3000ATUForm.IsDisposed)
            {
                if (!chkTUN.Checked)
                {
                    flex3000ATUForm.DoTune();
                    chkFWCATU.Checked = true;
                    chkFWCATUBypass.Checked = false;
                }
                else
                {
                    chkTUN.Checked = false;
                    flex3000ATUForm.AbortTune();
                }
            }
        }

        private void chkFWCATUBypass_Click(object sender, System.EventArgs e)
        {
            if (fwc_init && current_model == Model.FLEX5000 &&
                fwcAtuForm != null && !fwcAtuForm.IsDisposed)
            {
                fwcAtuForm.DoBypass();
                FWCATUBypass();
            }
            else if (fwc_init && current_model == Model.FLEX3000 &&
                flex3000ATUForm != null && !flex3000ATUForm.IsDisposed)
            {
                if (tuning)
                {
                    flex3000ATUForm.AbortTune();
                }
                flex3000ATUForm.DoBypass();
                FWCATUBypass();
            }
        }

        private void chkSplitDisplay_CheckedChanged(object sender, System.EventArgs e)
        {
            if (chkSplitDisplay.Checked)
                chkSplitDisplay.BackColor = button_selected_color;
            else
                chkSplitDisplay.BackColor = SystemColors.Control;

            Display.SplitDisplay = chkSplitDisplay.Checked;
        }

        private void comboDisplayModeTop_SelectedIndexChanged(object sender, System.EventArgs e)
        {
            /*switch(comboDisplayModeTop.Text)
			{
				case "Spectrum":
					Display.CurrentDisplayModeTop = DisplayMode.SPECTRUM;
					if(chkSplitDisplay.Checked) UpdateRXDisplayVars((int)udFilterLow.Value, (int)udFilterHigh.Value);
					break;
				case "Panadapter":
					Display.CurrentDisplayModeTop = DisplayMode.PANADAPTER;
					if(chkSplitDisplay.Checked) CalcDisplayFreq();
					break;
				case "Scope":
					Display.CurrentDisplayModeTop = DisplayMode.SCOPE;
					break;
				case "Phase":
					Display.CurrentDisplayModeTop = DisplayMode.PHASE;
					break;
				case "Phase2":
					Display.CurrentDisplayModeTop = DisplayMode.PHASE2;
					break;
				case "Waterfall":
					Display.CurrentDisplayModeTop = DisplayMode.WATERFALL;
					if(chkSplitDisplay.Checked) CalcDisplayFreq();
					break;
				case "Histogram":
					Display.CurrentDisplayModeTop = DisplayMode.HISTOGRAM;
					break;
				case "Off":
					Display.CurrentDisplayModeTop = DisplayMode.OFF;
					break;
			}*/
        }

        private void comboDisplayModeBottom_SelectedIndexChanged(object sender, System.EventArgs e)
        {
            switch (comboDisplayModeBottom.Text)
            {
                case "Spectrum":
                    Display.CurrentDisplayModeBottom = DisplayMode.SPECTRUM;
                    if (chkSplitDisplay.Checked) UpdateRXDisplayVars((int)udFilterLow.Value, (int)udFilterHigh.Value);
                    break;
                case "Panadapter":
                    Display.CurrentDisplayModeBottom = DisplayMode.PANADAPTER;
                    if (chkSplitDisplay.Checked) CalcDisplayFreq();
                    break;
                case "Panafall":                                                // ke9ns added
                    Display.CurrentDisplayModeBottom = DisplayMode.PANAFALL;
                    if (chkSplitDisplay.Checked) CalcDisplayFreq();
                    break;
                case "Scope":
                    Display.CurrentDisplayModeBottom = DisplayMode.SCOPE;
                    break;
                case "Phase":
                    Display.CurrentDisplayModeBottom = DisplayMode.PHASE;
                    break;
                case "Phase2":
                    Display.CurrentDisplayModeBottom = DisplayMode.PHASE2;
                    break;
                case "Waterfall":
                    Display.CurrentDisplayModeBottom = DisplayMode.WATERFALL;
                    if (chkSplitDisplay.Checked) CalcDisplayFreq();
                    break;
                case "Histogram":
                    Display.CurrentDisplayModeBottom = DisplayMode.HISTOGRAM;
                    break;
                case "Off":
                    Display.CurrentDisplayModeBottom = DisplayMode.OFF;
                    break;
            }
        } //combodisplaymodebottom


        //=============================================================================================
        // ke9ns mod  PLAY button
        public void ckQuickPlay_CheckedChanged(object sender, System.EventArgs e)
        {
            if ((checkBoxID.Checked != true) && (!mox)) // ke9ns checkboxID is the REC/PLAY ID box
            {
                ckQuickPlay.Checked = false; // if not transmitting then dont do anything and return.

                MessageBox.Show(new Form() { TopMost = true }, "You need to be Transmitting First,\n OR, check the Rec/Play ID box");
                return;
            }

            string file_name2 = AppDataPath + "SDRQuickAudio.wav"; // ke9ns save data for my mods

            //---------------------------------------------------------------------
            if (WaveForm.chkQuickAudioFolder.Checked == true)  // ke9ns add
            {
                string filePath = AppDataPath + "QuickAudio\\";

                if (!Directory.Exists(filePath))
                {
                    MessageBox.Show(new Form() { TopMost = true }, "QuickAudio Folder missing, Make a recording first");
                    return;

                }
            }
            else if (!File.Exists(file_name2)) // ke9ns add
            {
                ckQuickPlay.Checked = false; // if file does not exist then dont do anything and return.
                MessageBox.Show(new Form() { TopMost = true }, "You need to Record a File First\n Missing the SDRQuickAudio.wav file\nUncheck Wave->QuickAudio Save Folder\nMake a recording.\n Now you can Reselect Wave->QuickAudio Save Folder");
                return;
            }

            AudioMOXChanged(mox); // ke9ns add:  change the slider to MON from AF if transmitting. Needed becuase of other changes made for use with cross band work.

            ptbAF_Scroll(this, EventArgs.Empty); // update AF to MON slider now

            if ((checkBoxID.Checked == true) && (chkPower.Checked)) // ke9ns add allow tx on play directly so you dont need to mox and play
            {
                if ((ckQuickPlay.Checked))
                {
                    if (chkVAC1.Checked)
                    {
                        vac1 = 1;
                        chkVAC1.Checked = false; // need to shut it off, otherwise it expects audio to come from the PC
                    }

                    chkMOX.Checked = true;     // key radio 
                    WaveForm.QuickPlay = true;
                    ckQuickPlay.BackColor = button_selected_color;
                }
                else
                {
                    WaveForm.QuickPlay = false;
                    chkMOX.Checked = false;     // unkey radio
                    ckQuickPlay.BackColor = SystemColors.Control;//k6jca 1/13/08

                    if (vac1 == 1)
                    {
                        vac1 = 0;
                        Thread.Sleep(100);
                        chkVAC1.Checked = true;
                    }

                } // unkey radio

                ckQuickRec.Enabled = !ckQuickPlay.Checked;

            }
            else // ke9ns this is the original way below
            {
                if (ckQuickPlay.Checked)
                {
                    WaveForm.QuickPlay = true;
                    ckQuickPlay.BackColor = button_selected_color;
                }
                else
                {
                    WaveForm.QuickPlay = false;
                    ckQuickPlay.BackColor = SystemColors.Control;//k6jca 1/13/08
                }

                ckQuickRec.Enabled = !ckQuickPlay.Checked;
            }

        } // ckQuickPlay_CheckedChanged



        private static int temp_PWR = 0; // ke9ns add to remember the original power output value to put it back when done
        DSPMode oldmode = DSPMode.FIRST;
        //==========================================================================================
        public void ckQuickRec_CheckedChanged(object sender, System.EventArgs e)
        {
            if ((checkBoxID.Checked == true)) // ke9ns add (Rec/Play ID box checked) allow tx on play directly so you dont need to mox and play
            {

                if ((ckQuickRec.Checked)) // if enabled (recording)
                {
                    oldmode = RX1DSPMode;
                    if ((oldmode == DSPMode.FM) || (oldmode == DSPMode.AM) || (oldmode == DSPMode.SAM) || (oldmode == DSPMode.DSB)) RX1DSPMode = DSPMode.USB; // record only in SSB mode

                    if (chkVAC1.Checked)
                    {
                        vac1 = 1;
                        //  chkVAC1.Checked = false; // ke9ns mod  .122 bypass this to allow PC mic to be used to record voice keyer audio recordings.
                    }

                    chkMOX.Checked = true;     // key radio 
                    QuickRec2 = false; // .252
                    WaveForm.QuickRec = true;
                    ckQuickPlay.Enabled = true;
                    ckQuickRec.BackColor = button_selected_color;
                    temp_PWR = PWR; // ptbPWR.Value; // record current drive settings
                    PWR = 0; // ptbPWR.Value = 0; // turn drive off for recording


                }
                else
                {
                    QuickRec2 = false; // .252
                    WaveForm.QuickRec = false;
                    chkMOX.Checked = false;     // unkey radio
                    ckQuickRec.BackColor = SystemColors.Control;//k6jca 1/13/08
                                                                //ptbPWR.Value
                    PWR = temp_PWR; // turn drive level back up to prior setting

                    if (oldmode != DSPMode.FIRST)
                    {
                        RX1DSPMode = oldmode;
                        oldmode = DSPMode.FIRST;
                    }

                    if (vac1 == 1)
                    {
                        vac1 = 0;
                        Thread.Sleep(100);
                        chkVAC1.Checked = true;
                    }

                }

                ckQuickPlay.Enabled = !ckQuickRec.Checked;
            }

            //--------------------------------------------------
            else // ke9ns original way to doing quickaudio
            {
                if (ckQuickRec.Checked && QuickRec2 == false)
                {
                    QuickRec2 = false; // .252
                    WaveForm.QuickRec = true;  // wave.cs chkQuickRec_CheckedChanged will trigger
                    ckQuickPlay.Enabled = true;
                    ckQuickRec.BackColor = button_selected_color;

                }
                else
                {
                    QuickRec2 = false; // .252
                    WaveForm.QuickRec = false;
                    ckQuickRec.BackColor = SystemColors.Control;//k6jca 1/13/08
                }

                ckQuickPlay.Enabled = !ckQuickRec.Checked;
            }


        }//ckQuickRec_CheckedChanged

        //==========================================================================================================
        //==========================================================================================================
        //==========================================================================================================
        // ke9ns mod:  this is where you control each button panel movement as the console window changes size
        //==========================================================================================================
        //==========================================================================================================
        //==========================================================================================================

        int MeterMoveY = 30;
        int MeterMoveY1 = 30;

        public void ResizeConsole(int h_delta1, int v_delta)        //k6jca 1/15/08
        {
            //  if (FirstDown == true) return;

            // This routine captures the size and location parameters *after* windows
            // has resized the image, (if the video is set for "120 dpi" in lieu of the
            // normal 96 dpi).  These will be used as the "basis" for all new size calcs.


            if (setupForm != null) TXMeter2 = setupForm.chkTXMeter2.Checked; // update 2nd tx meter

            if ((h_delta1 == 0) && (v_delta == 0) && (previous_delta == 0))
            {
                // do nothing - this only occurs for my first call to Resize with both deltas zero during init
                // and at that time windows hasn't resized the display if in 120 dpi mode.
                // Use the "previous_delta" variable to ensure that if we *reduce* size back
                // to original, we do the calcs for that, too (previous_delta won't be 0 in that case);
            }
            else
            {


                //this.Size = new Size (console_basis_size.Width + h_delta1,console_basis_size.Height + v_delta);
                //this.Width = console_basis_size.Width + h_delta1;
                //this.Height = console_basis_size.Height + v_delta;

                grpVFOBetween.Location = new Point(gr_vfobetween_basis_location.X + (h_delta1 / 2), gr_vfobetween_basis_location.Y); // ke9ns: move here from below


                // Debug.WriteLine("console size " + this.Size.Height);

                //-------------------------------------------------------------------
                // ke9ns add: if section for smaller 768H screen sizes
                if ((this.Size.Height < 850))
                {
                    //  MeterTop = false; // ke9ns add

                    if (FWCEEPROM.RX2OK) // if you have RX2 installed
                    {
                        // ke9ns 1st

                        grpMultimeter.Location = new Point(gr_Multimeter_basis_location.X + h_delta1, gr_Multimeter_basis_location.Y - 2); // RX1/TX meter


                        if ((setupForm != null) && (setupForm.chk2ndMeter.Checked == true)) // ke9ns add: true= move 2nd meter below the grpMultimeter
                        {

                            // ke9ns 2nd

                            grpRX2Meter.Location = new Point(gr_Multimeter_basis_location.X + h_delta1, gr_Multimeter_basis_location.Y - 2 + grpMultimeter.Height + 6);

                            panelBandHFRX2.Location = new Point(gr_BandHFRX2_basis_location.X + h_delta1, gr_BandHFRX2_basis_location.Y + v_delta);  // ke9ns .203
                            panelBandGNRX2.Location = new Point(gr_BandGENRX2_basis_location.X + h_delta1, gr_BandGENRX2_basis_location.Y + v_delta);  // ke9ns stay where rx2 meter would have been
                            panelBandVHFRX2.Location = new Point(gr_BandVHFRX2_basis_location.X + h_delta1, gr_BandVHFRX2_basis_location.Y + v_delta);
                            //  grpRX2Meter.Location = new Point(gr_rx2_meter_basis.X + h_delta1, gr_rx2_meter_basis.Y + v_delta);

                            // ke9ns 3nd
                            panelBandHF.Location = new Point(gr_BandHF_basis_location.X + h_delta1, grpMultimeter.Height + gr_BandHF_basis_location.Y + (v_delta / 8));  // ke9ns have it stay close to rx1 meter
                            panelBandGN.Location = new Point(gr_BandGEN_basis_location.X + h_delta1, grpMultimeter.Height + gr_BandGEN_basis_location.Y + (v_delta / 8));  // ke9ns have it stay close to rx1 meter
                            panelBandVHF.Location = new Point(gr_BandVHF_basis_location.X + h_delta1, grpMultimeter.Height + gr_BandVHF_basis_location.Y + (v_delta / 8));

                            // ke9ns 4rd
                            panelMode.Location = new Point(gr_Mode_basis_location.X + h_delta1, grpMultimeter.Height + gr_Mode_basis_location.Y + (v_delta / 6)); // ke9ns have it stay close to band

                            // ke9ns 5th
                            panelFilter.Location = new Point(gr_filter_basis_location.X + h_delta1, grpMultimeter.Height + gr_filter_basis_location.Y + (v_delta / 5)); // ke9ns have it stay close to mode



                        } // 2nd meter just under 1st meter
                        else
                        {

                            // ke9ns 2nd
                            panelBandHF.Location = new Point(gr_BandHF_basis_location.X + h_delta1, gr_BandHF_basis_location.Y + (v_delta / 8));  // ke9ns have it stay close to rx1 meter
                            panelBandGN.Location = new Point(gr_BandGEN_basis_location.X + h_delta1, gr_BandGEN_basis_location.Y + (v_delta / 8));  // ke9ns have it stay close to rx1 meter
                            panelBandVHF.Location = new Point(gr_BandVHF_basis_location.X + h_delta1, gr_BandVHF_basis_location.Y + (v_delta / 8));

                            // ke9ns 3rd
                            panelMode.Location = new Point(gr_Mode_basis_location.X + h_delta1, gr_Mode_basis_location.Y + (v_delta / 6)); // ke9ns have it stay close to band

                            // ke9ns 4th
                            panelFilter.Location = new Point(gr_filter_basis_location.X + h_delta1, gr_filter_basis_location.Y + (v_delta / 5)); // ke9ns have it stay close to mode

                            // ke9ns 5th
                            grpRX2Meter.Location = new Point(gr_rx2_meter_basis.X + h_delta1, gr_rx2_meter_basis.Y + v_delta);

                        } // 2nd meter in original bottom location

                    }
                    else // no RX2 installed
                    {

                        if ((setupForm != null) && (setupForm.chk2ndMeter.Checked == true) && (setupForm.chkTXMeter2.Checked))
                        {
                            // ke9ns 1st
                            grpMultimeter.Location = new Point(gr_Multimeter_basis_location.X + h_delta1, gr_Multimeter_basis_location.Y - 2); // RX1/TX meter

                            // ke9ns 2th
                            grpRX2Meter.Location = new Point(gr_Multimeter_basis_location.X + h_delta1, grpMultimeter.Height + gr_Multimeter_basis_location.Y - 2); // ke9ns have it stay close to mode

                            // ke9ns 3nd
                            panelBandHF.Location = new Point(gr_BandHF_basis_location.X + h_delta1, grpMultimeter.Height + gr_BandHF_basis_location.Y + (v_delta / 24));  // ke9ns have it stay close to rx1 meter
                            panelBandGN.Location = new Point(gr_BandGEN_basis_location.X + h_delta1, grpMultimeter.Height + gr_BandGEN_basis_location.Y + (v_delta / 24));  // ke9ns have it stay close to rx1 meter
                            panelBandVHF.Location = new Point(gr_BandVHF_basis_location.X + h_delta1, grpMultimeter.Height + gr_BandVHF_basis_location.Y + (v_delta / 24));

                            // ke9ns 4rd
                            panelMode.Location = new Point(gr_Mode_basis_location.X + h_delta1, grpMultimeter.Height + gr_Mode_basis_location.Y + (v_delta / 12)); // ke9ns have it stay close to band

                            // ke9ns 5th
                            panelFilter.Location = new Point(gr_filter_basis_location.X + h_delta1, grpMultimeter.Height + gr_filter_basis_location.Y + (v_delta / 9)); // ke9ns have it stay close to mode


                        } // 2nd meter on top
                        else
                        {
                            // ke9ns 1st
                            grpMultimeter.Location = new Point(gr_Multimeter_basis_location.X + h_delta1, gr_Multimeter_basis_location.Y - 2); // RX1/TX meter

                            // ke9ns 2nd
                            panelBandHF.Location = new Point(gr_BandHF_basis_location.X + h_delta1, gr_BandHF_basis_location.Y + (v_delta / 24));  // ke9ns have it stay close to rx1 meter
                            panelBandGN.Location = new Point(gr_BandGEN_basis_location.X + h_delta1, gr_BandGEN_basis_location.Y + (v_delta / 24));  // ke9ns have it stay close to rx1 meter
                            panelBandVHF.Location = new Point(gr_BandVHF_basis_location.X + h_delta1, gr_BandVHF_basis_location.Y + (v_delta / 24));

                            // ke9ns 3rd
                            panelMode.Location = new Point(gr_Mode_basis_location.X + h_delta1, gr_Mode_basis_location.Y + (v_delta / 12)); // ke9ns have it stay close to band

                            // ke9ns 4th
                            panelFilter.Location = new Point(gr_filter_basis_location.X + h_delta1, gr_filter_basis_location.Y + (v_delta / 9)); // ke9ns have it stay close to mode

                            // ke9ns 5th
                            grpRX2Meter.Location = new Point(gr_filter_basis_location.X + h_delta1, gr_filter_basis_location.Y + (v_delta / 9) + 180); // ke9ns have it stay close to mode

                        } // 2nd meter on bottom



                    } // no rx2 installed

                } // if ((this.Size.Height < 850))
                else // larger screen size (original settings)
                {

                    if ((setupForm != null) && ((setupForm.chk2ndMeter.Checked == true) && (FWCEEPROM.RX2OK)) || ((setupForm.chk2ndMeter.Checked == true) && (setupForm.chkTXMeter2.Checked == true))) // if you have RX2 installed
                    {

                        //-------------------------------------------------------------------

                        // ke9ns 1st
                        grpMultimeter.Location = new Point(gr_Multimeter_basis_location.X + h_delta1, gr_Multimeter_basis_location.Y); // RX1/TX meter
                                                                                                                                       // ke9ns 2th
                        grpRX2Meter.Location = new Point(gr_Multimeter_basis_location.X + h_delta1, gr_Multimeter_basis_location.Y + grpMultimeter.Height + 6);

                        panelBandHFRX2.Location = new Point(gr_BandHFRX2_basis_location.X + h_delta1, gr_BandHFRX2_basis_location.Y + (v_delta));  // ke9ns have it stay close to rx1 meter
                        panelBandGNRX2.Location = new Point(gr_BandGENRX2_basis_location.X + h_delta1, gr_BandGENRX2_basis_location.Y + (v_delta));  // ke9ns have it stay close to rx1 meter
                        panelBandVHFRX2.Location = new Point(gr_BandVHFRX2_basis_location.X + h_delta1, gr_BandVHFRX2_basis_location.Y + (v_delta));


                        // ke9ns 3nd
                        panelBandHF.Location = new Point(gr_BandHF_basis_location.X + h_delta1, grpMultimeter.Height + gr_BandHF_basis_location.Y + (v_delta / 6));  // ke9ns have it stay close to rx1 meter
                        panelBandGN.Location = new Point(gr_BandGEN_basis_location.X + h_delta1, grpMultimeter.Height + gr_BandGEN_basis_location.Y + (v_delta / 6));  // ke9ns have it stay close to rx1 meter
                        panelBandVHF.Location = new Point(gr_BandVHF_basis_location.X + h_delta1, grpMultimeter.Height + gr_BandVHF_basis_location.Y + (v_delta / 6));

                        // ke9ns 4rd
                        panelMode.Location = new Point(gr_Mode_basis_location.X + h_delta1, grpMultimeter.Height + gr_Mode_basis_location.Y + (v_delta / 4)); // ke9ns have it stay close to band

                        // ke9ns 5th
                        panelFilter.Location = new Point(gr_filter_basis_location.X + h_delta1, grpMultimeter.Height + gr_filter_basis_location.Y + (v_delta / 3)); // ke9ns have it stay close to mode



                    } // 2nd meter under 1st meter
                    else
                    {

                        //-------------------------------------------------------------------
                        // ke9ns 1st
                        grpMultimeter.Location = new Point(gr_Multimeter_basis_location.X + h_delta1, gr_Multimeter_basis_location.Y); // RX1/TX meter


                        // ke9ns 2nd
                        panelBandHF.Location = new Point(gr_BandHF_basis_location.X + h_delta1, gr_BandHF_basis_location.Y + (v_delta / 6));  // ke9ns have it stay close to rx1 meter
                        panelBandGN.Location = new Point(gr_BandGEN_basis_location.X + h_delta1, gr_BandGEN_basis_location.Y + (v_delta / 6));  // ke9ns have it stay close to rx1 meter
                        panelBandVHF.Location = new Point(gr_BandVHF_basis_location.X + h_delta1, gr_BandVHF_basis_location.Y + (v_delta / 6));

                        // ke9ns 3rd
                        panelMode.Location = new Point(gr_Mode_basis_location.X + h_delta1, gr_Mode_basis_location.Y + (v_delta / 4)); // ke9ns have it stay close to band

                        // ke9ns 4th
                        panelFilter.Location = new Point(gr_filter_basis_location.X + h_delta1, gr_filter_basis_location.Y + (v_delta / 3)); // ke9ns have it stay close to mode

                        // ke9ns 5th
                        if (!FWCEEPROM.RX2OK)
                        {
                            grpRX2Meter.Location = new Point(gr_filter_basis_location.X + h_delta1, gr_filter_basis_location.Y + (v_delta / 3) + 200); // ke9ns have it stay close to mode

                        }
                        else
                        {
                            grpRX2Meter.Location = new Point(gr_rx2_meter_basis.X + h_delta1, gr_rx2_meter_basis.Y + v_delta - 10);

                            panelBandHFRX2.Location = new Point(gr_BandHFRX2_basis_location.X + h_delta1, gr_BandHFRX2_basis_location.Y + (v_delta - 10));  // ke9ns have it stay close to rx1 meter
                            panelBandGNRX2.Location = new Point(gr_BandGENRX2_basis_location.X + h_delta1, gr_BandGENRX2_basis_location.Y + (v_delta - 10));  // ke9ns have it stay close to rx1 meter
                            panelBandVHFRX2.Location = new Point(gr_BandVHFRX2_basis_location.X + h_delta1, gr_BandVHFRX2_basis_location.Y + (v_delta - 10));

                        }

                    } // 2nd meter original location on bottom




                } // if height of this is > 850





                //-------------------------------------------------------------------------------

                panelModeSpecificPhone.Location = new Point(gr_ModePhone_basis_location.X + h_delta1 - (h_delta1 / 4), gr_ModePhone_basis_location.Y + v_delta);
                panelModeSpecificCW.Location = new Point(gr_ModeCW_basis_location.X + h_delta1 - (h_delta1 / 4), gr_ModeCW_basis_location.Y + v_delta);
                panelModeSpecificDigital.Location = new Point(gr_ModeDig_basis_location.X + h_delta1 - (h_delta1 / 4), gr_ModeDig_basis_location.Y + v_delta);
                panelModeSpecificFM.Location = new Point(gr_ModeFM_basis_location.X + h_delta1 - (h_delta1 / 4), gr_ModeFM_basis_location.Y + v_delta);

                panelVFO.Location = new Point(gr_VFO_basis_location.X + (h_delta1 / 4), gr_VFO_basis_location.Y + v_delta);

                panelTS1.Location = new Point(130, (gr_VFO_basis_location.Y + v_delta) - 10); // ke9ns add



                //grpVFOBetween.Location = new Point(gr_vfobetween_basis_location.X+(h_delta1/2),gr_vfobetween_basis_location.Y);




                if ((MeterTop == true) && (this.Size.Width >= 1200)) // ke9ns add
                {
                    panelTSBandStack.Location = new Point(gr_BandHF_basis_location.X + h_delta1 + 2, 22); // ke9ns add move to upper right corner



                    textBox1.Size = new Size(161, 100); // .228 ke9ns add .211 
                    textBox2.Location = new Point(4, 120);
                    textBox2.Size = new Size(161, 100); // .228

                    panelBandHFRX2.Location = new Point(gr_BandHFRX2_basis_location.X + h_delta1, gr_BandHFRX2_basis_location.Y + v_delta);  // ke9ns have it stay close to rx1 meter
                    panelBandGNRX2.Location = new Point(gr_BandGENRX2_basis_location.X + h_delta1, gr_BandGENRX2_basis_location.Y + (v_delta));  // ke9ns have it stay close to rx1 meter
                    panelBandVHFRX2.Location = new Point(gr_BandVHFRX2_basis_location.X + h_delta1, gr_BandVHFRX2_basis_location.Y + (v_delta));


                    panelBandHF.Location = new Point(gr_BandHF_basis_location.X + h_delta1, grpMultimeter.Height + gr_BandHF_basis_location.Y + (v_delta / 6));  // ke9ns have it stay close to rx1 meter
                    panelBandGN.Location = new Point(gr_BandGEN_basis_location.X + h_delta1, grpMultimeter.Height + gr_BandGEN_basis_location.Y + (v_delta / 6));  // ke9ns have it stay close to rx1 meter
                    panelBandVHF.Location = new Point(gr_BandVHF_basis_location.X + h_delta1, grpMultimeter.Height + gr_BandVHF_basis_location.Y + (v_delta / 6));

                    // ke9ns 4rd
                    panelMode.Location = new Point(gr_Mode_basis_location.X + h_delta1, grpMultimeter.Height + gr_Mode_basis_location.Y + (v_delta / 4)); // ke9ns have it stay close to band

                    // ke9ns 5th
                    panelFilter.Location = new Point(gr_filter_basis_location.X + h_delta1, grpMultimeter.Height + gr_filter_basis_location.Y + (v_delta / 3)); // ke9ns have it stay close to mode


                    panelDisplay.Location = new Point(120, 105 + MeterMoveY); // move down panafall area to allow meters 30pix in y direction

                    panelDisplay.Size = new Size(gr_display_size_basis.Width + h_delta1, gr_display_size_basis.Height + v_delta - MeterMoveY);
                    picDisplay.Size = new Size(pic_display_size_basis.Width + h_delta1, pic_display_size_basis.Height + v_delta - MeterMoveY);

                    //-----------------------------
                    ptbDisplayZoom.Location = new Point(tb_display_zoom_basis.X + h_delta1, tb_display_zoom_basis.Y + v_delta - MeterMoveY);
                    ptbDisplayZoom2.Location = new Point(tb2_display_zoom_basis.X + h_delta1, tb2_display_zoom_basis.Y + v_delta - MeterMoveY); //.219

                    lblDisplayZoom1.Location = new Point(lbl_display_zoom_basis.X + h_delta1, lbl_display_zoom_basis.Y + v_delta - MeterMoveY);
                    btnDisplayPanCenter.Location = new Point(btn_display_pan_center_basis.X + (h_delta1), btn_display_pan_center_basis.Y + v_delta - MeterMoveY);


                    if (RX2Enabled == false) //.219
                    {
                        ptbDisplayPan2.Visible = false;

                        ptbDisplayPan.Size = new Size(tb_display_pan_size_basis.Width + (h_delta1), tb_display_pan_size_basis.Height);
                        ptbDisplayPan.Location = new Point(tb_displaypan_basis.X, tb_displaypan_basis.Y + v_delta - MeterMoveY);

                        ptbDisplayPan2.Size = new Size(tb_display_pan2_size_basis.Width + (h_delta1 / 2), tb_display_pan2_size_basis.Height); //.219
                        ptbDisplayPan2.Location = new Point(tb_displaypan2_basis.X + (h_delta1 / 2), tb_displaypan2_basis.Y + v_delta - MeterMoveY);
                    }
                    else
                    {
                        ptbDisplayPan2.Visible = true;

                        ptbDisplayPan.Size = new Size(tb_display_pan_size_basis.Width + (h_delta1 / 2), tb_display_pan_size_basis.Height);
                        ptbDisplayPan.Location = new Point(tb_displaypan_basis.X, tb_displaypan_basis.Y + v_delta - MeterMoveY);

                        ptbDisplayPan2.Size = new Size(tb_display_pan2_size_basis.Width + (h_delta1 / 2), tb_display_pan2_size_basis.Height); //.219
                        ptbDisplayPan2.Location = new Point(tb_displaypan2_basis.X + (h_delta1 / 2), tb_displaypan2_basis.Y + v_delta - MeterMoveY);
                    }


                    lblDisplayPan1.Location = new Point(lbl_displaypan_basis.X, lbl_displaypan_basis.Y + v_delta - MeterMoveY);
                    udCQCQRepeat.Location = new Point(gr_udcqcqrepeat_location.X, gr_udcqcqrepeat_location.Y + v_delta - MeterMoveY); // ke9ns add
                    ScreenCap.Location = new Point(gr_screencap_location.X, gr_screencap_location.Y + v_delta - MeterMoveY); // ke9ns add
                    buttonCall1.Location = new Point(gr_buttoncall_location.X, gr_buttoncall_location.Y + v_delta - MeterMoveY); // ke9ns add
                    buttonVK1.Location = new Point(gr_buttonVK1_location.X, gr_buttonVK1_location.Y + v_delta - MeterMoveY); // ke9ns add
                    buttonVK2.Location = new Point(gr_buttonVK2_location.X, gr_buttonVK2_location.Y + v_delta - MeterMoveY); // ke9ns add .189

                    buttonCQ1.Location = new Point(gr_buttoncq_location.X, gr_buttoncq_location.Y + v_delta - MeterMoveY); // ke9ns add
                    radDisplayZoom4x.Location = new Point(btn_display_zoom_4x_basis.X + h_delta1, btn_display_zoom_4x_basis.Y + v_delta - MeterMoveY);
                    radDisplayZoom2x.Location = new Point(btn_display_zoom_2x_basis.X + h_delta1, btn_display_zoom_2x_basis.Y + v_delta - MeterMoveY);
                    radDisplayZoom1x.Location = new Point(btn_display_zoom_1x_basis.X + h_delta1, btn_display_zoom_1x_basis.Y + v_delta - MeterMoveY);
                    radDisplayZoom05.Location = new Point(btn_display_zoom_05_basis.X + h_delta1, btn_display_zoom_05_basis.Y + v_delta - MeterMoveY);
                    txtDisplayPeakOffset.Location = new Point(txt_display_peak_offset_basis.X + h_delta1, txt_display_peak_offset_basis.Y + v_delta - MeterMoveY);
                    txtDisplayCursorOffset.Location = new Point(txt_display_cursor_offset_basis.X, txt_display_cursor_offset_basis.Y + v_delta - MeterMoveY);
                    autoBrightBox.Size = new Size(textbox1_size_basis.Width + h_delta1, textbox1_size_basis.Height - MeterMoveY); // ke9ns add
                    autoBrightBox.Location = new Point(textbox1_basis.X, textbox1_basis.Y + v_delta - MeterMoveY);
                    txtDisplayCursorPower.Location = new Point(txt_display_cursor_power_basis.X, txt_display_cursor_power_basis.Y + v_delta - MeterMoveY);
                    txtDisplayCursorFreq.Location = new Point(txt_display_cursor_freq_basis.X, txt_display_cursor_freq_basis.Y + v_delta - MeterMoveY);

                    txtDisplayPeakFreq.Location = new Point(txt_display_peak_freq_basis.X + h_delta1, txt_display_peak_freq_basis.Y + v_delta - MeterMoveY);
                    txtDisplayPeakPower.Location = new Point(txt_display_peak_power_basis.X + h_delta1, txt_display_peak_power_basis.Y + v_delta - MeterMoveY);

                    // ScreenCap.Location = new Point(txt_screen_save_offset_basis.X, txt_screen_save_offset_basis.Y + v_delta); // ke9ns add
                    ScreenCap1.Location = new Point(txt_screen_save_offset_basis.X, txt_screen_save_offset_basis.Y + v_delta - MeterMoveY);

                    //------------------------
                    //  panelTSRadar.Location = new Point(panelModeSpecificPhone.Location.X + 346, panelModeSpecificPhone.Location.Y); // .246
                    //   panelTSRadar.Size = new Size(panelFilter.Location.X - (panelModeSpecificPhone.Location.X + 356), panelRX2Filter.Location.Y + 97 - panelModeSpecificPhone.Location.Y); //.246 


                } //  if ( (MeterTop == true)  && (this.Size.Width >= 850)) 
                else
                {
                    panelDisplay.Location = new Point(120, 105); // move down panafall area to allow meters 20pix in y direction
                    panelDisplay.Invalidate();

                    panelDisplay.Size = new Size(gr_display_size_basis.Width + h_delta1, gr_display_size_basis.Height + v_delta);
                    picDisplay.Size = new Size(pic_display_size_basis.Width + h_delta1, pic_display_size_basis.Height + v_delta);

                    //-----------------------------


                    panelTSBandStack.Location = new Point(gr_display_size_basis.Width + h_delta1 - 173, 6); // 162.230  ke9ns add: move next to band buttons in the panadapter area
                    panelTSBandStack.Size = new Size(168, picDisplay.Size.Height - 6); // .228 was 158



                    textBox1.Size = new Size(161, 200); // ke9ns add .211  .228 was 151
                    textBox2.Location = new Point(4, 220);
                    textBox2.Size = new Size(161, 200); // .228 was 151

                    ptbDisplayZoom.Location = new Point(tb_display_zoom_basis.X + h_delta1, tb_display_zoom_basis.Y + v_delta);
                    ptbDisplayZoom2.Location = new Point(tb2_display_zoom_basis.X + h_delta1, tb2_display_zoom_basis.Y + v_delta); //.219

                    lblDisplayZoom1.Location = new Point(lbl_display_zoom_basis.X + h_delta1, lbl_display_zoom_basis.Y + v_delta);
                    btnDisplayPanCenter.Location = new Point(btn_display_pan_center_basis.X + (h_delta1), btn_display_pan_center_basis.Y + v_delta);

                    if (RX2Enabled == false) //.219
                    {
                        ptbDisplayPan2.Visible = false;

                        ptbDisplayPan.Size = new Size(tb_display_pan_size_basis.Width + (h_delta1), tb_display_pan_size_basis.Height);
                        ptbDisplayPan.Location = new Point(tb_displaypan_basis.X, tb_displaypan_basis.Y + v_delta);

                        ptbDisplayPan2.Size = new Size(tb_display_pan2_size_basis.Width + (h_delta1 / 2), tb_display_pan2_size_basis.Height);
                        ptbDisplayPan2.Location = new Point(tb_displaypan2_basis.X + (h_delta1 / 2), tb_displaypan2_basis.Y + v_delta);
                    }
                    else
                    {
                        ptbDisplayPan2.Visible = true;

                        ptbDisplayPan.Size = new Size(tb_display_pan_size_basis.Width + (h_delta1 / 2), tb_display_pan_size_basis.Height);
                        ptbDisplayPan.Location = new Point(tb_displaypan_basis.X, tb_displaypan_basis.Y + v_delta);

                        ptbDisplayPan2.Size = new Size(tb_display_pan2_size_basis.Width + (h_delta1 / 2), tb_display_pan2_size_basis.Height);
                        ptbDisplayPan2.Location = new Point(tb_displaypan2_basis.X + (h_delta1 / 2), tb_displaypan2_basis.Y + v_delta);
                    }

                    lblDisplayPan1.Location = new Point(lbl_displaypan_basis.X, lbl_displaypan_basis.Y + v_delta);
                    udCQCQRepeat.Location = new Point(gr_udcqcqrepeat_location.X, gr_udcqcqrepeat_location.Y + v_delta); // ke9ns add
                    ScreenCap.Location = new Point(gr_screencap_location.X, gr_screencap_location.Y + v_delta); // ke9ns add
                    buttonCall1.Location = new Point(gr_buttoncall_location.X, gr_buttoncall_location.Y + v_delta); // ke9ns add
                    buttonVK1.Location = new Point(gr_buttonVK1_location.X, gr_buttonVK1_location.Y + v_delta); // ke9ns add
                    buttonVK2.Location = new Point(gr_buttonVK2_location.X, gr_buttonVK2_location.Y + v_delta); // ke9ns add

                    buttonCQ1.Location = new Point(gr_buttoncq_location.X, gr_buttoncq_location.Y + v_delta); // ke9ns add
                    radDisplayZoom4x.Location = new Point(btn_display_zoom_4x_basis.X + h_delta1, btn_display_zoom_4x_basis.Y + v_delta);
                    radDisplayZoom2x.Location = new Point(btn_display_zoom_2x_basis.X + h_delta1, btn_display_zoom_2x_basis.Y + v_delta);
                    radDisplayZoom1x.Location = new Point(btn_display_zoom_1x_basis.X + h_delta1, btn_display_zoom_1x_basis.Y + v_delta);
                    radDisplayZoom05.Location = new Point(btn_display_zoom_05_basis.X + h_delta1, btn_display_zoom_05_basis.Y + v_delta);
                    txtDisplayPeakOffset.Location = new Point(txt_display_peak_offset_basis.X + h_delta1, txt_display_peak_offset_basis.Y + v_delta);
                    txtDisplayCursorOffset.Location = new Point(txt_display_cursor_offset_basis.X, txt_display_cursor_offset_basis.Y + v_delta);
                    autoBrightBox.Size = new Size(textbox1_size_basis.Width + h_delta1, textbox1_size_basis.Height); // ke9ns add
                    autoBrightBox.Location = new Point(textbox1_basis.X, textbox1_basis.Y + v_delta);
                    txtDisplayCursorPower.Location = new Point(txt_display_cursor_power_basis.X, txt_display_cursor_power_basis.Y + v_delta);
                    txtDisplayCursorFreq.Location = new Point(txt_display_cursor_freq_basis.X, txt_display_cursor_freq_basis.Y + v_delta);

                    txtDisplayPeakFreq.Location = new Point(txt_display_peak_freq_basis.X + h_delta1, txt_display_peak_freq_basis.Y + v_delta);
                    txtDisplayPeakPower.Location = new Point(txt_display_peak_power_basis.X + h_delta1, txt_display_peak_power_basis.Y + v_delta);

                    // ScreenCap.Location = new Point(txt_screen_save_offset_basis.X, txt_screen_save_offset_basis.Y + v_delta); // ke9ns add
                    ScreenCap1.Location = new Point(txt_screen_save_offset_basis.X, txt_screen_save_offset_basis.Y + v_delta);

                    //------------------------

                    //   panelTSRadar.Location = new Point(panelModeSpecificPhone.Location.X + 346, panelModeSpecificPhone.Location.Y ); // .246
                    //   panelTSRadar.Size = new Size(panelFilter.Location.X - (panelModeSpecificPhone.Location.X + 356), panelRX2Filter.Location.Y + 97 - panelModeSpecificPhone.Location.Y); //.246 


                } // meters not on top




                panelDisplay2.Location = new Point(gr_display2_basis.X + (h_delta1 / 2), gr_display2_basis.Y + v_delta);
                panelDSP.Location = new Point(gr_dsp_basis.X + (h_delta1 / 2), gr_dsp_basis.Y + v_delta);

                panelMultiRX.Location = new Point(gr_multirx_basis.X + (h_delta1 / 2), gr_multirx_basis.Y + v_delta);


                chkPower.Location = new Point(chk_power_basis.X, chk_power_basis.Y + (v_delta / 8));
                panelOptions.Location = new Point(gr_options_basis.X, gr_options_basis.Y + (v_delta / 4));

                panelSoundControls.Location = new Point(gr_sound_controls_basis.X, gr_sound_controls_basis.Y + (v_delta / 8) + (v_delta / 4));

                chkSquelch.Location = new Point(chk_squelch_basis.X, chk_squelch_basis.Y + (v_delta / 2));
                picSquelch.Location = new Point(pic_sql_basis.X, pic_sql_basis.Y + (v_delta / 2));
                ptbSquelch.Location = new Point(tb_sql_basis.X, tb_sql_basis.Y + (v_delta / 2));

                panelAntenna.Location = new Point(gr_antenna_basis.X, gr_antenna_basis.Y + (v_delta / 8) + (v_delta / 2)); // ke9ns mod was /8 /2
                chkBCI.Location = new Point(chk_bci_basis.X, chk_bci_basis.Y + (v_delta / 8) + (v_delta / 2));
                //button1.Location = new Point(button1_basis.X,button1_basis.Y+(v_delta/8)+(v_delta/2));
                panelDateTime.Location = new Point(gr_date_time_basis.X, gr_date_time_basis.Y + (v_delta / 2) + (v_delta / 4)); // ke9ns mod was /2  /4

                //lblCPUMeter.Location = new Point(lbl_cpu_meter_basis.X,lbl_cpu_meter_basis.Y+(v_delta/8)+(v_delta/2)+(v_delta/4));

                //panelRX2Divider.Location = new Point(pan_rx2_divider_basis.X, pan_rx2_divider_basis.Y+v_delta);
                //panelRX2Divider.Size = new Size(pan_rx2_divider_size_basis.Width+h_delta1, pan_rx2_divider_size_basis.Height);

                grpDisplaySplit.Location = new Point(gr_display_split_basis.X + (h_delta1 / 2), gr_display_split_basis.Y + v_delta);


                panelRX2Filter.Location = new Point(gr_rx2_filter_basis.X + (int)(h_delta1 * 0.66), gr_rx2_filter_basis.Y + v_delta);
                panelRX2Mode.Location = new Point(gr_rx2_mode_basis.X + (int)(h_delta1 * 0.492), gr_rx2_mode_basis.Y + v_delta);
                panelRX2Display.Location = new Point(gr_rx2_display_basis.X + (int)(h_delta1 * 0.383), gr_rx2_display_basis.Y + v_delta);
                panelRX2DSP.Location = new Point(gr_rx2_dsp_basis.X + (int)(h_delta1 * 0.258), gr_rx2_dsp_basis.Y + v_delta);

                lblRX2RF.Location = new Point(lbl_rx2_rf_basis.X + (int)(h_delta1 * 0.164), lbl_rx2_rf_basis.Y + v_delta);
                ptbRX2RF.Location = new Point(tb_rx2_rf_basis.X + (int)(h_delta1 * 0.164), tb_rx2_rf_basis.Y + v_delta);
                chkRX2Squelch.Location = new Point(chk_rx2_squelch_basis.X + (int)(h_delta1 * 0.164), chk_rx2_squelch_basis.Y + v_delta);
                ptbRX2Squelch.Location = new Point(tb_rx2_squelch_basis.X + (int)(h_delta1 * 0.164), tb_rx2_squelch_basis.Y + v_delta);
                picRX2Squelch.Location = new Point(pic_rx2_squelch_basis.X + (int)(h_delta1 * 0.164), pic_rx2_squelch_basis.Y + v_delta);

                panelRX2Mixer.Location = new Point(gr_rx2_mixer_basis.X + (int)(h_delta1 * 0.078), gr_rx2_mixer_basis.Y + v_delta);
                chkRX2.Location = new Point(chk_rx2_enable_basis.X, chk_rx2_enable_basis.Y + v_delta);
                chkRX2Preamp.Location = new Point(chk_rx2_preamp_basis.X, chk_rx2_preamp_basis.Y + v_delta);
                lblRX2Band.Location = new Point(lbl_rx2_band_basis.X, lbl_rx2_band_basis.Y + v_delta);
                comboRX2Band.Location = new Point(combo_rx2_band_basis.X, combo_rx2_band_basis.Y + v_delta);


                //--------------------------------------------------------------------------------------------------------------
                // ke9ns weather option


                //  Debug.WriteLine("CHECK WEATHER");

                if ((localweather == false) || (this.Size.Width < 1350)) // normal location of VFOA and B
                {
                    panelTS1.Visible = false;
                    panelTS1.Enabled = false;
                    Debug.WriteLine("WEATHER TOO SMALL1");
                    localweatherblock = true;
                    panelTS1.Invalidate();
                }
                else
                {

                    // right edge of panelTS1 = 245
                    int temp = gr_VFO_basis_location.X + (h_delta1 / 4); // left edge location of panelVFO (136 wide)
                    int temp1 = gr_dsp_basis.X + (h_delta1 / 2); // left edge location of panelDSP

                    int x1 = temp1 - 275;
                    int x2 = (x1 / 2) + 275;
                    int x3 = x2 - 68;

                    //  Debug.WriteLine("X1 " + x1 + ", " + x2 + " ," + x3 + " ," + this.Size.Width);


                    localweatherblock = false;

                    panelTS1.Visible = true;
                    panelTS1.Enabled = true;
                    Debug.WriteLine("WEATHER BIG ENOUGH");
                    panelVFO.Location = new Point(x3, gr_VFO_basis_location.Y + v_delta); // move panelVFO to fill the empy space equally
                    panelTS1.Invalidate();


                }


                //--------------------------------------------------------------------------------------------------------------
                // ke9ns VFO DIAL option

                if ((MeterTop == true) && (this.Size.Width >= 1200)) // ke9ns add
                {

                    if (this.Size.Width < 1600)
                    {
                        VFODialA.Visible = false;
                        VFODialB.Visible = false;
                        VFODialAA.Visible = false;
                        VFODialBB.Visible = false;



                        grpMultimeter.Location = new Point(grpVFOBetween.Location.X - grpMultimeter.Size.Width - 6, grpVFOBetween.Location.Y);
                        grpRX2Meter.Location = new Point(grpVFOBetween.Location.X + grpVFOBetween.Size.Width + 6, grpVFOBetween.Location.Y);

                        int grpV = ((grpMultimeter.Location.X - panelDisplay.Location.X) / 2) + panelDisplay.Location.X - (grpVFOA.Size.Width / 2); // half way between panelDisplay 0x and grpMultimeter 0x

                        grpVFOA.Location = new Point(grpV, gr_VFOA_basis_location.Y + MeterMoveY1); //ke9ns if gap between VFOA and CENTER is large, then move VFOA closer to Center


                        grpV = (((panelDisplay.Location.X + panelDisplay.Size.Width) - (grpRX2Meter.Location.X + grpRX2Meter.Size.Width)) / 2) + (grpRX2Meter.Location.X + grpRX2Meter.Size.Width) - (grpVFOB.Size.Width / 2);

                        grpVFOB.Location = new Point(grpV, gr_VFOB_basis_location.Y + MeterMoveY1); // 

                        grpVFOBetween.Location = new Point(gr_vfobetween_basis_location.X + (h_delta1 / 2), gr_vfobetween_basis_location.Y + MeterMoveY1); // ke9ns: move here from below


                    }
                    else // full screen
                    {

                        if (vfodial == true)
                        {

                            VFODialA.Visible = true;
                            VFODialB.Visible = true;
                            VFODialAA.Visible = true;
                            VFODialBB.Visible = true;

                            VFODialB.SendToBack();

                            grpMultimeter.Location = new Point(grpVFOBetween.Location.X - grpMultimeter.Size.Width - 5, grpVFOBetween.Location.Y);
                            grpRX2Meter.Location = new Point(grpVFOBetween.Location.X + grpVFOBetween.Size.Width + 5, grpVFOBetween.Location.Y);

                            // dials on inside
                            grpVFOA.Location = new Point(panelDisplay.Location.X + 10, gr_VFOA_basis_location.Y + MeterMoveY1); //ke9ns if gap between VFOA and CENTER is large, then move VFOA closer to Center

                            grpVFOB.Location = new Point(panelDisplay.Location.X + panelDisplay.Size.Width - grpVFOB.Size.Width - 10, gr_VFOB_basis_location.Y + MeterMoveY1); // 


                            int tempa = ((grpMultimeter.Location.X - (grpVFOA.Location.X + grpVFOA.Size.Width)) / 2) + (grpVFOA.Location.X + grpVFOA.Size.Width);
                            int tempb = ((grpVFOB.Location.X - (grpRX2Meter.Location.X + grpRX2Meter.Size.Width)) / 2) + (grpRX2Meter.Location.X + grpRX2Meter.Size.Width);

                            VFODialA.Location = new Point(tempa - 150 - 2, 79);// 72 ke9ns: when meters at top  improved .158
                            VFODialB.Location = new Point(tempb - 150 - 1, 79); // 72

                            VFODialAA.Location = new Point(tempa - (VFODialAA.Size.Width / 2) - 1, 49); // 46
                            VFODialBB.Location = new Point(tempb - (VFODialBB.Size.Width / 2) - 1, 49);


                            grpVFOBetween.Location = new Point(gr_vfobetween_basis_location.X + (h_delta1 / 2), gr_vfobetween_basis_location.Y + MeterMoveY1); // ke9ns: move here from below



                            /* // dials on outside
                            int grpV = (grpMultimeter.Location.X - 6) - grpVFOA.Size.Width;
                            //  int grpV = ((grpMultimeter.Location.X - panelDisplay.Location.X) / 2) + panelDisplay.Location.X - (grpVFOA.Size.Width / 2);
                            grpVFOA.Location = new Point(grpV, gr_VFOA_basis_location.Y + MeterMoveY1); //ke9ns if gap between VFOA and CENTER is large, then move VFOA closer to Center

                            grpV = grpRX2Meter.Location.X + grpRX2Meter.Size.Width + 6;
                            //  grpV = (((panelDisplay.Location.X + panelDisplay.Size.Width) - (grpRX2Meter.Location.X + grpRX2Meter.Size.Width)) / 2) + (grpRX2Meter.Location.X + grpRX2Meter.Size.Width) - (grpVFOB.Size.Width / 2);
                            grpVFOB.Location = new Point(grpV, gr_VFOB_basis_location.Y + MeterMoveY1); // 

                            grpVFOBetween.Location = new Point(gr_vfobetween_basis_location.X + (h_delta1 / 2), gr_vfobetween_basis_location.Y + MeterMoveY1); // ke9ns: move here from below

                            VFODialA.Location = new Point(((grpVFOA.Location.X - panelDisplay.Location.X) / 2 - 5) + panelDisplay.Location.X - (VFODialA.Size.Width / 2), 72);
                            VFODialB.Location = new Point((((panelDisplay.Location.X + panelDisplay.Size.Width - 5) - (grpVFOB.Location.X + grpVFOB.Size.Width)) / 2) + (grpVFOB.Location.X + grpVFOB.Size.Width) - (VFODialB.Size.Width / 2), 72);

                            VFODialAA.Location = new Point(((grpVFOA.Location.X - panelDisplay.Location.X) / 2 ) + panelDisplay.Location.X - 5 - (VFODialAA.Size.Width/2), 45);
                            VFODialBB.Location = new Point((((panelDisplay.Location.X + panelDisplay.Size.Width ) - (grpVFOB.Location.X + grpVFOB.Size.Width)) / 2) + (grpVFOB.Location.X + grpVFOB.Size.Width) -5 - (VFODialBB.Size.Width / 2), 45);

*/


                        } //  if (vfodial == true)
                        else //
                        {

                            VFODialA.Visible = false;
                            VFODialB.Visible = false;
                            VFODialAA.Visible = false;
                            VFODialBB.Visible = false;

                            grpMultimeter.Location = new Point(grpVFOBetween.Location.X - grpMultimeter.Size.Width - 5, grpVFOBetween.Location.Y);
                            grpRX2Meter.Location = new Point(grpVFOBetween.Location.X + grpVFOBetween.Size.Width + 5, grpVFOBetween.Location.Y);

                            //   int grpV = (grpMultimeter.Location.X - 6) - grpVFOA.Size.Width;
                            int grpV = ((grpMultimeter.Location.X - panelDisplay.Location.X) / 2) + panelDisplay.Location.X - (grpVFOA.Size.Width / 2);
                            grpVFOA.Location = new Point(grpV, gr_VFOA_basis_location.Y + MeterMoveY1); //ke9ns if gap between VFOA and CENTER is large, then move VFOA closer to Center

                            //   grpV = grpRX2Meter.Location.X + grpRX2Meter.Size.Width + 6;
                            grpV = (((panelDisplay.Location.X + panelDisplay.Size.Width) - (grpRX2Meter.Location.X + grpRX2Meter.Size.Width)) / 2) + (grpRX2Meter.Location.X + grpRX2Meter.Size.Width) - (grpVFOA.Size.Width / 2);
                            grpVFOB.Location = new Point(grpV, gr_VFOB_basis_location.Y + MeterMoveY1); // 

                            grpVFOBetween.Location = new Point(gr_vfobetween_basis_location.X + (h_delta1 / 2), gr_vfobetween_basis_location.Y + MeterMoveY1); // ke9ns: move here from below
                        }

                    } // full screen




                }
                else if ((vfodial == false) || (this.Size.Width < 1400)) // normal location of VFOA and B
                {


                    VFODialA.Visible = false;
                    VFODialB.Visible = false;
                    VFODialAA.Visible = false;
                    VFODialBB.Visible = false;

                    grpVFOA.Location = new Point(gr_VFOA_basis_location.X + (h_delta1 / 4), gr_VFOA_basis_location.Y);  // ke9ns was 4
                    grpVFOB.Location = new Point(gr_VFOB_basis_location.X + h_delta1 - (h_delta1 / 4), gr_VFOB_basis_location.Y); // ke9ns was 4


                }
                else // ke9ns special location of VFOA and B when VFO Dial is ON
                {

                    // meters on side, not top

                    VFODialA.Visible = true;
                    VFODialB.Visible = true;
                    VFODialAA.Visible = true;
                    VFODialBB.Visible = true;


                    if ((grpVFOBetween.Location.X - (panelOptions.Location.X + 115 + 262)) > 275)
                    {
                        grpVFOA.Location = new Point(grpVFOBetween.Location.X - 300 - 262 - 5, gr_VFOA_basis_location.Y); //ke9ns if gap between VFOA and CENTER is large, then move VFOA closer to Center
                    }
                    else
                    {
                        grpVFOA.Location = new Point(panelOptions.Location.X + 115 + 5, gr_VFOA_basis_location.Y); // ke9ns if gap between VFOA and CENTER is small, the just keep VFOA on left side
                    }


                    if (((grpMultimeter.Location.X - 262) - (grpVFOBetween.Location.X + 240)) > 275) // 
                    {
                        grpVFOB.Location = new Point(grpVFOBetween.Location.X + 240 + 275, gr_VFOB_basis_location.Y); // 
                    }
                    else
                    {
                        grpVFOB.Location = new Point(grpMultimeter.Location.X - 262 - 5, gr_VFOB_basis_location.Y); // ke9ns 
                    }


                    int dialAPos = ((grpVFOBetween.Location.X - (grpVFOA.Location.X + 262)) / 2) + (grpVFOA.Location.X + 262);
                    int dialBPos = ((grpVFOB.Location.X - (grpVFOBetween.Location.X + 240)) / 2) + (grpVFOBetween.Location.X + 240);

                    int dialAP = dialAPos - (VFODialA.Width / 2);
                    int dialBP = dialBPos - (VFODialB.Width / 2);

                    VFODialA.Location = new Point(dialAP, 52);  // 42 ke9ns add dial VFOA
                    VFODialB.Location = new Point(dialBP, 52); // 42 ke9ns add dial VFOB

                    int dialAPo = dialAPos - (VFODialAA.Width / 2) - 1;
                    int dialBPo = dialBPos - (VFODialBB.Width / 2) - 1;


                    VFODialAA.Location = new Point(dialAPo, 22);  // ke9ns add dial VFOA
                    VFODialBB.Location = new Point(dialBPo, 22); // ke9ns add dial VFOB



                }

            }
            previous_delta = h_delta1 + v_delta; //we'll check this next time through...



            panelTSRadar.Location = new Point(panelModeSpecificPhone.Location.X + 350, panelModeSpecificPhone.Location.Y); // .246
            panelTSRadar.Size = new Size(panelFilter.Location.X - (panelModeSpecificPhone.Location.X + 360), panelRX2Filter.Location.Y + 97 - panelModeSpecificPhone.Location.Y); //.246 

            panelTSRadar.Invalidate(); //.246


        } // resizeconsole




        public int HDelta
        {
            get { return h_delta; }
            set
            {
                h_delta = value;
                ResizeConsole(h_delta, v_delta);
            }
        }

        public int VDelta
        {
            get { return v_delta; }
            set
            {
                v_delta = value;
                ResizeConsole(h_delta, v_delta);
            }
        }

        public void GrabConsoleSizeBasis()
        {
            console_basis_size = this.Size;

            //   int yyy = this.Size.Height;

            gr_filter_basis_location = this.panelFilter.Location;

            //Debug.WriteLine("console basis:  "+console_basis_size+"  "+gr_filter_basis_location);

            gr_Multimeter_basis_location = this.grpMultimeter.Location;

            gr_BandHF_basis_location = this.panelBandHF.Location;
            gr_BandGEN_basis_location = this.panelBandGN.Location; // ke9ns add
            gr_BandVHF_basis_location = this.panelBandVHF.Location;

            gr_BandHFRX2_basis_location = this.panelBandHFRX2.Location;
            gr_BandGENRX2_basis_location = this.panelBandGNRX2.Location; // ke9ns add
            gr_BandVHFRX2_basis_location = this.panelBandVHFRX2.Location;


            gr_Mode_basis_location = this.panelMode.Location;
            gr_VFOB_basis_location = this.grpVFOB.Location;
            gr_VFOA_basis_location = this.grpVFOA.Location;

            gr_VFODialA_location = this.VFODialA.Location; // ke9ns add
            gr_VFODialB_location = this.VFODialB.Location; // ke9ns add

            gr_VFODialAA_location = this.VFODialA.Location; // ke9ns add
            gr_VFODialBB_location = this.VFODialB.Location; // ke9ns add

            gr_ModePhone_basis_location = this.panelModeSpecificPhone.Location;
            gr_ModeCW_basis_location = this.panelModeSpecificCW.Location;
            gr_ModeDig_basis_location = this.panelModeSpecificDigital.Location;
            gr_ModeFM_basis_location = this.panelModeSpecificFM.Location;
            gr_VFO_basis_location = this.panelVFO.Location;
            gr_vfobetween_basis_location = this.grpVFOBetween.Location;
            btn_display_pan_center_basis = this.btnDisplayPanCenter.Location;

            tb_display_pan_size_basis = this.ptbDisplayPan.Size;
            tb_display_pan2_size_basis = this.ptbDisplayPan2.Size; //.219


            btn_display_zoom_4x_basis = this.radDisplayZoom4x.Location;
            btn_display_zoom_2x_basis = this.radDisplayZoom2x.Location;
            btn_display_zoom_1x_basis = this.radDisplayZoom1x.Location;
            btn_display_zoom_05_basis = this.radDisplayZoom05.Location;
            tb_display_zoom_basis = this.ptbDisplayZoom.Location;
            tb2_display_zoom_basis = this.ptbDisplayZoom2.Location; //.219

            txt_display_peak_freq_basis = this.txtDisplayPeakFreq.Location;
            txt_display_peak_power_basis = this.txtDisplayPeakPower.Location;
            txt_display_peak_offset_basis = this.txtDisplayPeakOffset.Location;
            lbl_display_zoom_basis = this.lblDisplayZoom1.Location;

            autobrightbox_basis = this.autoBrightBox.Location; // ke9ns add
            gr_buttoncall_location = this.buttonCall1.Location; // ke9ns add
            gr_buttonVK1_location = this.buttonVK1.Location; // ke9ns add .189
            gr_buttonVK2_location = this.buttonVK2.Location; // ke9ns add .189
            gr_buttoncq_location = this.buttonCQ1.Location; // ke9ns add
            gr_udcqcqrepeat_location = this.udCQCQRepeat.Location; // ke9ns add
            gr_screencap_location = this.ScreenCap.Location; // ke9ns add


            gr_display_size_basis = this.panelDisplay.Size;
            pic_display_size_basis = this.picDisplay.Size;
            textbox1_size_basis = this.autoBrightBox.Size;
            textbox1_basis = this.autoBrightBox.Location;
            gr_display2_basis = this.panelDisplay2.Location;
            gr_dsp_basis = this.panelDSP.Location;
            gr_multirx_basis = this.panelMultiRX.Location;

            tb_displaypan_basis = this.ptbDisplayPan.Location;
            tb_displaypan2_basis = this.ptbDisplayPan2.Location; //.219

            lbl_displaypan_basis = this.lblDisplayPan1.Location;
            buttonVK1_basis = this.buttonVK1.Location;
            buttonVK2_basis = this.buttonVK2.Location;

            txt_display_cursor_freq_basis = this.txtDisplayCursorFreq.Location;
            txt_display_cursor_power_basis = this.txtDisplayCursorPower.Location;
            txt_display_cursor_offset_basis = this.txtDisplayCursorOffset.Location;
            txt_screen_save_offset_basis = this.ScreenCap.Location;

            chk_power_basis = this.chkPower.Location;
            gr_options_basis = this.panelOptions.Location;
            gr_sound_controls_basis = this.panelSoundControls.Location;
            chk_squelch_basis = this.chkSquelch.Location;
            pic_sql_basis = this.picSquelch.Location;
            tb_sql_basis = this.ptbSquelch.Location;
            gr_antenna_basis = this.panelAntenna.Location;
            chk_bci_basis = this.chkBCI.Location;
            //button1_basis = this.button1.Location;
            gr_date_time_basis = this.panelDateTime.Location;
            //lbl_cpu_meter_basis = this.lblCPUMeter.Location;

            //pan_rx2_divider_basis = this.panelRX2Divider.Location;
            //pan_rx2_divider_size_basis = this.panelRX2Divider.Size;

            gr_display_split_basis = this.grpDisplaySplit.Location;
            gr_rx2_meter_basis = this.grpRX2Meter.Location;
            gr_rx2_filter_basis = this.panelRX2Filter.Location;
            gr_rx2_mode_basis = this.panelRX2Mode.Location;
            gr_rx2_display_basis = this.panelRX2Display.Location;
            gr_rx2_dsp_basis = this.panelRX2DSP.Location;

            lbl_rx2_rf_basis = this.lblRX2RF.Location;
            tb_rx2_rf_basis = this.ptbRX2RF.Location;
            chk_rx2_squelch_basis = this.chkRX2Squelch.Location;
            tb_rx2_squelch_basis = this.ptbRX2Squelch.Location;
            pic_rx2_squelch_basis = this.picRX2Squelch.Location;

            gr_rx2_mixer_basis = this.panelRX2Mixer.Location;
            chk_rx2_enable_basis = this.chkRX2.Location;
            chk_rx2_preamp_basis = this.chkRX2Preamp.Location;
            lbl_rx2_band_basis = this.lblRX2Band.Location;
            combo_rx2_band_basis = this.comboRX2Band.Location;

        } // grabconsolesize


        //==============================================================
        // ke9ns come here when you turn on/off RX2 button
        //==============================================================
        private bool rx2_enabled = false;
        public bool RX2Enabled
        {
            get { return rx2_enabled; }
            set
            {
                rx2_enabled = value;
                chkRX2.Checked = value;

                if (rx2_enabled)
                {
                    ptbDisplayPan2.Visible = true; //.219
                    ptbDisplayZoom2.Visible = true; //.219

                    if (setupForm != null) //.219
                    {
                        setupForm.checkBoxRX2.Visible = true;
                    }

                    RX2Band = StringToBand(comboRX2Band.Text); // ke9ns ADD

                    if (chkPower.Checked)
                    {
                        if (rx2_meter_thread == null || !rx2_meter_thread.IsAlive)
                        {
                            Debug.Write(" 999 ");
                            rx2_meter_thread = new Thread(new ThreadStart(UpdateRX2MeterData));
                            rx2_meter_thread.Name = "RX2 Meter Thread";
                            rx2_meter_thread.Priority = ThreadPriority.Lowest;
                            rx2_meter_thread.IsBackground = true;
                            rx2_meter_thread.Start();
                        }

                        if (rx2_sql_update_thread == null || !rx2_sql_update_thread.IsAlive)
                        {
                            rx2_sql_update_thread = new Thread(new ThreadStart(UpdateRX2SQL));
                            rx2_sql_update_thread.Name = "Update RX2 SQL";
                            rx2_sql_update_thread.Priority = ThreadPriority.Normal;
                            rx2_sql_update_thread.IsBackground = true;
                            rx2_sql_update_thread.Start();
                        }

                        txtVFOBFreq_LostFocus(this, EventArgs.Empty);
                        if (!rx2_enabled) return;

                        grpVFOB.Font = ff5; // new Font("Swis721 BT", 8.25F, FontStyle.Italic | FontStyle.Bold);
                        grpVFOB.ForeColor = SystemColors.ControlLightLight;
                        txtVFOBFreq.ForeColor = vfo_text_light_color;
                        txtVFOBMSD.ForeColor = vfo_text_light_color;
                        txtVFOBLSD.ForeColor = small_vfo_color;
                        txtVFOBBand.ForeColor = band_text_light_color;

                        if (chkVFOSplit.Checked) chkVFOSplit_CheckedChanged(this, EventArgs.Empty);
                        if (chkEnableMultiRX.Checked) chEnableMultiRX_CheckedChanged(this, EventArgs.Empty);

                    }// do if power ON

                    //=================================
                    // 
                    dsp.GetDSPRX(1, 0).Active = true;
                    DttSP.SetThreadProcessingMode(2, 2);
                    DSP.SetThreadNumber(3);

                    if (chkEnableMultiRX.Checked)
                        txtVFOABand_LostFocus(this, EventArgs.Empty);

                    //  if (comboDisplayMode.Items.Contains("Panafall"))   // ke9ns mod dont remove panafall from the list
                    //	comboDisplayMode.Items.Remove("Panafall");
                    if (comboDisplayMode.SelectedIndex < 0)
                        comboDisplayMode.Text = "Panadapter";

                    if (comboDisplayMode.Items.Contains("Panascope"))
                        comboDisplayMode.Items.Remove("Panascope");
                    if (comboDisplayMode.SelectedIndex < 0)
                        comboDisplayMode.Text = "Panadapter";
                } // if rx2 enabled
                else
                {
                    ptbDisplayPan2.Visible = false; //.219
                    ptbDisplayZoom2.Visible = false; //.219

                    if (setupForm != null) //.219
                    {
                        N1MM_RX2 = false;
                        setupForm.checkBoxRX2.Visible = false;

                    }

                    // rx2_xvtr_index = -1;
                    if (chkPower.Checked)
                    {
                        if (chkVFOSplit.Checked) chkVFOSplit_CheckedChanged(this, EventArgs.Empty);
                        else if (chkEnableMultiRX.Checked) chEnableMultiRX_CheckedChanged(this, EventArgs.Empty);
                        else
                        {
                            txtVFOBFreq.ForeColor = vfo_text_dark_color;
                            txtVFOBMSD.ForeColor = vfo_text_dark_color;
                            txtVFOBLSD.ForeColor = vfo_text_dark_color;
                            txtVFOBBand.ForeColor = band_text_dark_color;
                            panelVFOASubHover.Visible = false;
                        }
                        if (chkVFOBTX.Checked && FWCEEPROM.RX2OK && !chkVFOSplit.Checked)
                            chkVFOATX.Checked = true;
                        UpdateVFOASub();
                    }

                    dsp.GetDSPRX(1, 0).Active = false;
                    DttSP.SetThreadProcessingMode(2, 0);
                    DSP.SetThreadNumber(2);

                    /*if(comboMeterRXMode.Items.Contains("ADC2_L"))
						comboMeterRXMode.Items.Remove("ADC2_L");
					if(comboMeterRXMode.Items.Contains("ADC2_R"))
						comboMeterRXMode.Items.Remove("ADC2_R");*/

                    if (chkEnableMultiRX.Checked)
                        txtVFOBFreq_LostFocus(this, EventArgs.Empty);

                    if (!comboDisplayMode.Items.Contains("Panafall"))
                        comboDisplayMode.Items.Insert(comboDisplayMode.Items.Count - 1, "Panafall");
                    if (!comboDisplayMode.Items.Contains("Panascope"))
                        comboDisplayMode.Items.Insert(comboDisplayMode.Items.Count - 1, "Panascope");
                } // rx2 off

                Audio.RX2Enabled = rx2_enabled;
                chkSplitDisplay.Checked = rx2_enabled;
            } // set 

        } // RX2Enabled


        public bool PowerRX2Pause = false; // .233 ke9ns add true: VAC toggling or buffer size change, will pause (Power OFF/ON) to prevent a crash of Win10

        //=========================================================================================
        private void chkRX2_CheckedChanged(object sender, System.EventArgs e)
        {


            RX2Enabled = chkRX2.Checked;

            if (chkRX2.Checked == true) // .157
            {

                if (setupForm != null) // .231
                {
                    if (setupForm.chkRX2AutoVAC2.Checked == true && PowerRX2Pause == false)
                    {

                        setupForm.chkVAC2Enable.Checked = true;

                    }



                }

                CalcDisplayFreq(); //.225 add

                if (SpotForm != null)
                {
                    SpotForm.hkBoxSpotRX2.Enabled = true;


                }

                if (ptbRX2Gain.Value < ptbRX2Gain.Maximum) // ke9ns add .200 to get the volume level of RX2 adjusted at startup or RX2
                {
                    ptbRX2Gain.Value++;
                    ptbRX2Gain.Value--;

                }


            }
            else // ke9ns: RX2 now OFF
            {
                if (SpotForm != null)
                {
                    SpotForm.hkBoxSpotRX2.Checked = false;
                    SpotForm.hkBoxSpotRX2.Enabled = false;
                }

                if (setupForm != null) // .231
                {
                    if (setupForm.chkRX2AutoVAC2.Checked == true && PowerRX2Pause == false)
                    {

                        setupForm.chkVAC2Enable.Checked = false;

                    }

                }

            }

            if (chkVFOBTX.Checked && chkVAC2.Checked && chkRX2.Checked)  // if TX set on VFOB & RX2 ON & VAC2 ON 
            {
                ptbVACRXGain.Value = vac2_rx_gain;
                ptbVACRXGain_Scroll(this, EventArgs.Empty);

                ptbVACTXGain.Value = vac2_tx_gain;
                ptbVACTXGain_Scroll(this, EventArgs.Empty);

                comboVACSampleRate.Text = vac2_sample_rate;

                chkVACStereo.Checked = vac2_stereo;
            } // RX2 ON
            else
            {
                ptbVACRXGain.Value = vac_rx_gain;
                ptbVACRXGain_Scroll(this, EventArgs.Empty);

                ptbVACTXGain.Value = vac_tx_gain;
                ptbVACTXGain_Scroll(this, EventArgs.Empty);

                comboVACSampleRate.Text = vac_sample_rate;

                chkVACStereo.Checked = vac_stereo;
            } // RX2 OFF

            if (chkRX2.Checked)
            {
                chkRX2.BackColor = button_selected_color;

                if ((current_model == Model.FLEX5000) && fwcAntForm != null) // ke9ns add
                {
                    fwcAntForm.comboBand2.Visible = true;
                    fwcAntForm.lblBand2.Visible = true;
                }
            }
            else
            {
                chkRX2.BackColor = SystemColors.Control;

                if ((current_model == Model.FLEX5000) && fwcAntForm != null) // ke9ns add
                {
                    fwcAntForm.comboBand2.Visible = false;
                    fwcAntForm.lblBand2.Visible = false;
                }
            }

            if (FWCEEPROM.VUOK) SetVURXPath();

            int h_delta = this.Width - console_basis_size.Width;
            int v_delta = this.Height - console_basis_size.Height;

            if (chkRX2.Checked == true) // ke9ns add
            {
                // label2.Visible = true;
                chkRX1MUTE.Visible = true;

                ptbDisplayZoom.Size = new Size(77, 23);

                ptbDisplayPan.Size = new Size(tb_display_pan_size_basis.Width + (h_delta / 2), tb_display_pan_size_basis.Height);

                ptbDisplayPan2.Size = new Size(tb_display_pan2_size_basis.Width + (h_delta / 2), tb_display_pan2_size_basis.Height); //.219

                panelDisplay.Invalidate();

            }
            else
            {
                chkRX1MUTE.Checked = false;   // ke9ns add    uncheck when RX2 turned off
                                              //  label2.Visible = false;        // and hide box and text
                                              //   chkRX1MUTE.Visible = false;
                chkRX1MUTE.Visible = true;

                ptbDisplayZoom.Size = new Size(160, 23); //.219 add

                ptbDisplayPan.Size = new Size(tb_display_pan_size_basis.Width + (h_delta), tb_display_pan_size_basis.Height);

                ptbDisplayPan2.Size = new Size(tb_display_pan2_size_basis.Width, tb_display_pan2_size_basis.Height); //.219

                panelDisplay.Invalidate();
            }

            comboRX2MeterMode_SelectedIndexChanged(this, EventArgs.Empty); // ke9ns add to update lblrx2meter text
            comboMeterTX1Mode_SelectedIndexChanged(this, EventArgs.Empty); // ke9ns add to update lblrx2meter text

            int DP = ptbDisplayPan.Value;
            ptbDisplayPan.Value = 1;
            ptbDisplayPan_Scroll(this, EventArgs.Empty);    //.225
            ptbDisplayPan.Value = DP;
            ptbDisplayPan_Scroll(this, EventArgs.Empty);    //.225

            DP = ptbDisplayZoom.Value;
            ptbDisplayZoom.Value = 1;
            ptbDisplayZoom_Scroll(this, EventArgs.Empty);    //.225
            ptbDisplayZoom.Value = DP;
            ptbDisplayZoom_Scroll(this, EventArgs.Empty);    //.225


        }  // RX2 ON/OFF button


        private void chkRX2SR_CheckedChanged(object sender, System.EventArgs e)
        {
            if (chkRX2SR.Checked) chkRX2SR.BackColor = button_selected_color;
            else chkRX2SR.BackColor = SystemColors.Control;
            RX2SpurReduction = chkRX2SR.Checked;
        }

        private void panelVFOASubHover_Paint(object sender, System.Windows.Forms.PaintEventArgs e)
        {
            if (!rx2_enabled || (!chkEnableMultiRX.Checked && !chkVFOSplit.Checked)) return;
            if (vfoa_sub_hover_digit < 0) return;

            int x = 0;
            int width = 0;

            /*if(small_lsd && txtVFOALSD.Visible)
			{
				x += (vfo_char_width+vfo_char_space)*vfoa_hover_digit;
				if(vfoa_hover_digit > 3)
					x += (vfo_decimal_space-vfo_char_space);
				
				if(vfoa_hover_digit > 6)
				{
					x += vfo_small_char_width;
					x += (vfo_small_char_width+vfo_small_char_space-vfo_char_width-vfo_char_space)*(vfoa_hover_digit-6);
					width = x+vfo_small_char_width;
				}
				else width = x+vfo_char_width;
			}
			else*/
            {
                x += (vfo_sub_char_width + vfo_sub_char_space) * vfoa_sub_hover_digit;

                if (vfoa_sub_hover_digit > 3) x += (vfo_sub_decimal_space - vfo_sub_char_space);

                width = x + vfo_sub_char_width;
            }

            e.Graphics.DrawLine(new Pen(txtVFOABand.ForeColor, 2.0f), x, 1, width, 1);
        }

        private void panelVFOASubHover_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
        {
            if (!rx2_enabled || (!chkEnableMultiRX.Checked && !chkVFOSplit.Checked)) return;
            Control c1 = (Control)sender;
            Control c2 = txtVFOABand;
            int client_width = (c1.Size.Width - c1.ClientSize.Width) + (c2.Size.Width - c2.ClientSize.Width);
            int client_height = (c1.Size.Height - c1.ClientSize.Height) + (c2.Size.Height - c2.ClientSize.Height);
            int x_offset = c1.Left - c2.Left - client_width / 2;
            int y_offset = c1.Top - c2.Top - client_height / 2;
            txtVFOABand_MouseMove(sender, new MouseEventArgs(e.Button, e.Clicks, e.X + x_offset, e.Y + y_offset, e.Delta));
        }

        private void txtVFOABand_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
        {
            if (!rx2_enabled || (!chkEnableMultiRX.Checked && !chkVFOSplit.Checked) || !chkPower.Checked) return;

            panelVFOASubHover.Visible = true;

            if (this.ContainsFocus)
            {
                int old_digit = vfoa_sub_hover_digit;
                int digit_index = 0;
                if (vfo_sub_char_width == 0) GetVFOSubCharWidth();

                int x = txtVFOABand.Width - (vfo_sub_pixel_offset - 5);

                while (x < e.X)
                {
                    digit_index++;

                    /*if(small_lsd && txtVFOALSD.Visible)
					{
						if(digit_index < 6)
							x += (vfo_char_width+vfo_char_space);
						else 
							x += (vfo_small_char_width+vfo_small_char_space);

						if(digit_index == 3)
							x += (vfo_decimal_space-vfo_char_space);
						if(digit_index == 6)
							x += vfo_small_char_width;
					}
					else
					{*/
                    x += vfo_sub_char_width;
                    if (digit_index == 3) x += vfo_sub_decimal_space;
                    else x += vfo_sub_char_space;
                    //}
                }

                if (digit_index < 3) digit_index = -1;

                if (digit_index > 9) digit_index = 9;

                vfoa_sub_hover_digit = digit_index;

                if (vfoa_sub_hover_digit != old_digit) panelVFOASubHover.Invalidate();
                //Debug.WriteLine("vfoa_sub_hover_digit:"+vfoa_sub_hover_digit);
            }

        } // txtVFOABand_MouseMove(

        private void txtVFOABand_MouseLeave(object sender, System.EventArgs e)
        {
            vfoa_sub_hover_digit = -1;
            panelVFOASubHover.Invalidate();
        }

        private void SetRX2Mode(DSPMode new_mode)
        {

            RX2DSPMODE = new_mode; // .196

            if (current_model != Model.FLEX5000 || !FWCEEPROM.RX2OK) return; //.236

            // if (!fwc_init || current_model != Model.FLEX5000 || !FWCEEPROM.RX2OK) return;
            if (new_mode == DSPMode.FIRST || new_mode == DSPMode.LAST) return;

            DSPMode old_mode = rx2_dsp_mode;

            //  if (rx2_enabled)
            //  {
            dsp.GetDSPRX(1, 0).DSPMode = new_mode;              // set new DSP mode
            dsp.GetDSPRX(1, 1).DSPMode = new_mode;

            if (chkVFOBTX.Checked)
            {
                Audio.TXDSPMode = new_mode;
                dsp.GetDSPTX(0).CurrentDSPMode = new_mode;

                if (fwc_init && (current_model == Model.FLEX5000)) FWC.SetTXDSPMode(new_mode);
            }
            // }

            Display.RX2DSPMode = new_mode;
            //if(fwc_init && current_model == Model.FLEX5000)
            //FWC.SetRX2DSPMode(new_mode);

            double rx2_freq = VFOBFreq;
            int old_txosc = (int)dsp.GetDSPTX(0).TXOsc;

            switch (old_mode)
            {
                case DSPMode.LSB:
                    radRX2ModeLSB.BackColor = SystemColors.Control;
                    break;
                case DSPMode.USB:
                    radRX2ModeUSB.BackColor = SystemColors.Control;
                    break;
                case DSPMode.DSB:
                    radRX2ModeDSB.BackColor = SystemColors.Control;
                    break;
                case DSPMode.CWL:
                    radRX2ModeCWL.BackColor = SystemColors.Control;

                    if (!RX2IsOn60mChannel())
                    {
                        switch (new_mode)
                        {
                            case DSPMode.USB:
                                rx2_freq -= (cw_pitch * 1e-6);
                                break;
                            case DSPMode.CWU:
                                break;
                            default:
                                rx2_freq += (cw_pitch * 1e-6);
                                break;
                        }
                        txtVFOBFreq.Text = rx2_freq.ToString("f6" );
                    }
                    break;
                case DSPMode.CWU:
                    radRX2ModeCWU.BackColor = SystemColors.Control;

                    if (!RX2IsOn60mChannel())
                    {
                        switch (new_mode)
                        {
                            case DSPMode.LSB:
                                rx2_freq += (cw_pitch * 1e-6);
                                break;
                            case DSPMode.CWL:
                                break;
                            default:
                                rx2_freq -= (cw_pitch * 1e-6);
                                break;
                        }
                        txtVFOBFreq.Text = rx2_freq.ToString("f6" );
                    }
                    break;
                case DSPMode.FM:
                    radRX2ModeFMN.BackColor = SystemColors.Control;
                    if (rx2_enabled)
                    {
                        if (new_mode != DSPMode.AM && new_mode != DSPMode.SAM && new_mode != DSPMode.FM)
                        {
                            if (chkVFOBTX.Checked) chkMON.Enabled = true;

                            chkRX2BIN.Enabled = true;
                        }

                        if (chkVFOBTX.Checked)
                            ptbMic_Scroll(this, EventArgs.Empty);
                    }

                    if (new_mode != DSPMode.DRM) EnableAllRX2Filters();

                    if (!initializing) rx2_fm_squelch_threshold_scroll = ptbRX2Squelch.Value;

                    ptbRX2Squelch.Minimum = -160;
                    ptbRX2Squelch.Maximum = 0;

                    picRX2Squelch.Visible = true;

                    ptbRX2Squelch.Value = rx2_squelch_threshold_scroll;
                    break;
                case DSPMode.AM:
                    radRX2ModeAM.BackColor = SystemColors.Control;
                    if (rx2_enabled)
                    {
                        if (new_mode != DSPMode.AM &&
                            new_mode != DSPMode.SAM &&
                            new_mode != DSPMode.FM)
                        {
                            if (chkVFOBTX.Checked)
                                chkMON.Enabled = true;

                            chkRX2BIN.Enabled = true;
                        }
                        if (chkVFOBTX.Checked)
                            ptbMic_Scroll(this, EventArgs.Empty);
                    }

                    if (new_mode != DSPMode.SPEC || new_mode != DSPMode.DRM)
                        EnableAllRX2Filters();
                    break;
                case DSPMode.SAM:
                    radRX2ModeSAM.BackColor = SystemColors.Control;
                    if (rx2_enabled)
                    {
                        if (new_mode != DSPMode.AM &&
                            new_mode != DSPMode.SAM &&
                            new_mode != DSPMode.FM)
                        {
                            if (chkVFOBTX.Checked)
                                chkMON.Enabled = true;

                            chkRX2BIN.Enabled = true;
                        }

                        if (chkVFOBTX.Checked)
                            ptbMic_Scroll(this, EventArgs.Empty);
                    }
                    break;
                case DSPMode.DIGL:
                    radRX2ModeDIGL.BackColor = SystemColors.Control;
                    if (rx2_enabled && vac2_auto_enable &&
                        new_mode != DSPMode.DIGU &&
                        new_mode != DSPMode.DRM &&
                        new_mode != DSPMode.DIGL)
                    {
                        setupForm.VAC2Enable = false;
                    }
                    break;
                case DSPMode.DIGU:
                    radRX2ModeDIGU.BackColor = SystemColors.Control;
                    if (rx2_enabled && vac2_auto_enable &&
                        new_mode != DSPMode.DIGL &&
                        new_mode != DSPMode.DRM &&
                        new_mode != DSPMode.DIGU)
                    {
                        setupForm.VAC2Enable = false;
                    }
                    break;
                case DSPMode.DRM:
                    radRX2ModeDRM.BackColor = SystemColors.Control;
                    rx2_if_shift = true;
                    rx2_vfo_offset = 0.0;
                    if (rx2_enabled && vac2_auto_enable &&
                        new_mode != DSPMode.DIGL &&
                        new_mode != DSPMode.DIGU &&
                        new_mode != DSPMode.DRM)
                    {
                        setupForm.VAC2Enable = false;
                    }
                    if (new_mode != DSPMode.FM)
                        EnableAllRX2Filters();
                    rx2_if_freq = setupForm.IFFreq;
                    CalcDisplayFreq();
                    break;
            } // old mode


            //---------------------------------ke9ns NEW MODE
            switch (new_mode)
            {
                case DSPMode.LSB:
                    radRX2ModeLSB.BackColor = button_selected_color;
                    //panelRX2Mode.Text = "RX2 Mode - LSB";
                    if (chkVFOBTX.Checked && rx2_enabled)
                    {
                        SetTXFilters(new_mode, tx_filter_low, tx_filter_high);
                        dsp.GetDSPTX(0).TXOsc = 0.0;
                    }
                    break;
                case DSPMode.USB:
                    radRX2ModeUSB.BackColor = button_selected_color;
                    // panelRX2Mode.Text = "RX2 Mode - USB";
                    if (chkVFOBTX.Checked && rx2_enabled)
                    {
                        SetTXFilters(new_mode, tx_filter_low, tx_filter_high);
                        dsp.GetDSPTX(0).TXOsc = 0.0;
                    }
                    break;
                case DSPMode.DSB:
                    radRX2ModeDSB.BackColor = button_selected_color;
                    //grpRX2Mode.Text = "RX2 Mode - DSB";
                    if (chkVFOBTX.Checked && rx2_enabled)
                    {
                        SetTXFilters(new_mode, tx_filter_low, tx_filter_high);
                        dsp.GetDSPTX(0).TXOsc = 0.0;
                    }
                    break;
                case DSPMode.CWL:
                    radRX2ModeCWL.BackColor = button_selected_color;
                    //grpRX2Mode.Text = "RX2 Mode - CWL";

                    if (chkVFOBTX.Checked && rx2_enabled)
                    {
                        dsp.GetDSPTX(0).TXOsc = 0.0;
                        SetTXFilters(new_mode, tx_filter_low, tx_filter_high);

                        CWPitch = cw_pitch;
                    }

                    if (!RX2IsOn60mChannel())
                    {
                        switch (rx2_dsp_mode)
                        {
                            case DSPMode.USB:
                                rx2_freq += (cw_pitch * 1e-6);
                                break;
                            case DSPMode.CWU:
                                break;
                            default:
                                rx2_freq -= (cw_pitch * 1e-6);
                                break;
                        }
                        txtVFOBFreq.Text = rx2_freq.ToString("f6" );
                    }
                    break;
                case DSPMode.CWU:
                    radRX2ModeCWU.BackColor = button_selected_color;
                    //grpRX2Mode.Text = "RX2 Mode - CWU";

                    if (chkVFOBTX.Checked && rx2_enabled)
                    {
                        dsp.GetDSPTX(0).TXOsc = 0.0;
                        SetTXFilters(new_mode, tx_filter_low, tx_filter_high);

                        CWPitch = cw_pitch;
                    }

                    if (!RX2IsOn60mChannel())
                    {
                        switch (rx2_dsp_mode)
                        {
                            case DSPMode.LSB:
                                rx2_freq -= (cw_pitch * 1e-6);
                                break;
                            case DSPMode.CWL:
                                break;
                            default:
                                rx2_freq += (cw_pitch * 1e-6);
                                break;
                        }
                        txtVFOBFreq.Text = rx2_freq.ToString("f6" );
                    }
                    break;
                case DSPMode.FM: // new mode
                    radRX2ModeFMN.BackColor = button_selected_color;


                    radFMDeviation2kHz_CheckedChanged(this, EventArgs.Empty); // .236check which width
                    radFMDeviation5kHz_CheckedChanged(this, EventArgs.Empty); //.236

                    if (radFMDeviation2kHz.Checked == false && radFMDeviation5kHz.Checked == false) FMDeviation10khz(); //.236


                    DisableAllRX2Filters();    //this needs to be for RX2 only

                    if (!initializing) rx2_squelch_threshold_scroll = ptbRX2Squelch.Value;

                    ptbRX2Squelch.Minimum = 0;
                    ptbRX2Squelch.Maximum = 100;

                    ptbRX2Squelch.Value = rx2_fm_squelch_threshold_scroll;

                    picRX2Squelch.Visible = false;

                    //chkRX2Squelch.Enabled = false;
                    rx2_squelch_on = chkRX2Squelch.Checked;    //save state of non-FM squelch
                    chkRX2Squelch.Checked = true;

                    if (rx2_enabled)
                    {
                        if (chkVFOBTX.Checked)
                        {
                            if (!rx_only && chkPower.Checked) chkMOX.Enabled = true;


#if NO_MON // ke9ns off to allow mon function in FM mode
                        chkMON.Checked = false; // ke9ns test
                        chkMON.Enabled = false;
#endif


                            SetTXFilters(new_mode, tx_filter_low, tx_filter_high);

                            dsp.GetDSPTX(0).TXOsc = 11025.0;  // was 0

                            ptbFMMic_Scroll(this, EventArgs.Empty);
                        }

                        chkRX2BIN.Checked = false;
                        chkRX2BIN.Enabled = false;
                    }
                    break;
                case DSPMode.AM:
                    radRX2ModeAM.BackColor = button_selected_color;
                    //grpRX2Mode.Text = "RX2 Mode - AM";
                    if (chkVFOBTX.Checked)
                    {
                        if (!rx_only && chkPower.Checked) chkMOX.Enabled = true;

#if NO_MON  // ke9ns off to allow mon function in FM mode
                        chkMON.Checked = false; // ke9ns test
					    chkMON.Enabled = false;
#endif
                        SetTXFilters(new_mode, tx_filter_low, tx_filter_high);

                        dsp.GetDSPTX(0).TXOsc = 11025.0;

                        ptbFMMic_Scroll(this, EventArgs.Empty);
                    }

                    chkRX2BIN.Checked = false;
                    chkRX2BIN.Enabled = false;
                    break;
                case DSPMode.SAM:
                    radRX2ModeSAM.BackColor = button_selected_color;
                    //grpRX2Mode.Text = "RX2 Mode - SAM";

                    if (chkVFOBTX.Checked)
                    {
                        if (!rx_only && chkPower.Checked) chkMOX.Enabled = true;

#if NO_MON  // ke9ns off to allow mon function in FM mode
                        chkMON.Checked = false; // ke9ns test
					    chkMON.Enabled = false;
#endif
                        SetTXFilters(new_mode, tx_filter_low, tx_filter_high);

                        dsp.GetDSPTX(0).TXOsc = 11025.0;

                        ptbFMMic_Scroll(this, EventArgs.Empty);
                    }

                    chkRX2BIN.Checked = false;
                    chkRX2BIN.Enabled = false;
                    break;
                case DSPMode.DIGL:
                    radRX2ModeDIGL.BackColor = button_selected_color;
                    //grpRX2Mode.Text = "RX2 Mode - DIGL";

                    if (chkVFOBTX.Checked && rx2_enabled)
                    {
                        SetTXFilters(new_mode, tx_filter_low, tx_filter_high);

                        dsp.GetDSPTX(0).TXOsc = 0.0;
                    }

                    if (rx2_enabled && vac2_auto_enable)
                        setupForm.VAC2Enable = true;
                    break;
                case DSPMode.DIGU:
                    radRX2ModeDIGU.BackColor = button_selected_color;
                    //grpRX2Mode.Text = "RX2 Mode - DIGU";

                    if (chkVFOBTX.Checked && rx2_enabled)
                    {
                        SetTXFilters(new_mode, tx_filter_low, tx_filter_high);

                        dsp.GetDSPTX(0).TXOsc = 0.0;
                    }
                    if (rx2_enabled && vac2_auto_enable)
                        setupForm.VAC2Enable = true;
                    break;
                case DSPMode.DRM:
                    rx2_if_shift = false;
                    rx2_vfo_offset = -0.012;
                    radRX2ModeDRM.BackColor = button_selected_color;
                    //grpRX2Mode.Text = "RX2 Mode - DRM";
                    if (rx2_enabled && vac2_auto_enable)
                        setupForm.VAC2Enable = true;

                    if (chkVFOBTX.Checked && rx2_enabled)
                    {
                        SetTXFilters(new_mode, tx_filter_low, tx_filter_high);

                        dsp.GetDSPTX(0).TXOsc = 0.0;
                    }
                    //DisableAllRX2Filters(); // !FIXME

                    //grpFilter.Text = "Filter - DRM";
                    dsp.GetDSPRX(1, 0).SetRXFilter(7000, 17000);
                    /*Display.RXDisplayLow = -8000;
						Display.RXDisplayHigh = 8000;*/
                    break;
            }

            if (RX2IsOn60mChannel())
            {
                // adjust freq offset to ensure center of energy for new mode in 60m
                rx2_freq += (-ModeFreqOffset(old_mode) + ModeFreqOffset(new_mode));
                txtVFOBFreq.Text = rx2_freq.ToString("f6" );
            }

            int new_txosc = (int)dsp.GetDSPTX(0).TXOsc;
            if (new_txosc != old_txosc)
            {
                if (fwc_init && (current_model == Model.FLEX5000))
                    FWC.SetTXOffset(new_txosc);
            }

            radRX2Filter1.Text = rx2_filters[(int)new_mode].GetName(Filter.F1);
            radRX2Filter2.Text = rx2_filters[(int)new_mode].GetName(Filter.F2);
            radRX2Filter3.Text = rx2_filters[(int)new_mode].GetName(Filter.F3);
            radRX2Filter4.Text = rx2_filters[(int)new_mode].GetName(Filter.F4);
            radRX2Filter5.Text = rx2_filters[(int)new_mode].GetName(Filter.F5);
            radRX2Filter6.Text = rx2_filters[(int)new_mode].GetName(Filter.F6);
            radRX2Filter7.Text = rx2_filters[(int)new_mode].GetName(Filter.F7);
            radRX2FilterVar1.Text = rx2_filters[(int)new_mode].GetName(Filter.VAR1);
            radRX2FilterVar2.Text = rx2_filters[(int)new_mode].GetName(Filter.VAR2);

            rx2_dsp_mode = new_mode;

            if (old_mode == DSPMode.FM)
                chkRX2Squelch.Checked = rx2_squelch_on;

            if (old_mode == DSPMode.FM || new_mode == DSPMode.FM)
                ptbRX2Squelch_Scroll(this, EventArgs.Empty);

            if (rx2_dsp_mode != DSPMode.FM && rx2_dsp_mode != DSPMode.DRM)
            {
                RX2Filter = rx2_filters[(int)new_mode].LastFilter;
            }
            else
            {
                if (rx2_dsp_mode == DSPMode.FM) //checkfm
                {
                    /* was this until .236
                    if (dsp.GetDSPRX(1, 0).RXFMDeviation == FMDataDeviation) // ke9ns add
                    {
                        UpdateRX2Filters(-FMDataLowHigh, FMDataLowHigh); // update 2nd receiver
                    }
                    else if (dsp.GetDSPRX(1, 0).RXFMDeviation == 5000)
                    {
                        UpdateRX2Filters(-8000, 8000); // mod index of .625
                    }
                    else
                    {
                        UpdateRX2Filters(-4000, 4000); // mod index of .5
                    }
*/
                    //.236 now like rx1
                    if (dsp.GetDSPTX(0).TXFMDeviation == FMDataDeviation) // ke9ns add WFM
                    {
                        UpdateRX2Filters(-FMDataLowHigh, FMDataLowHigh); // +/- 10000 (change to 20k .218)
                    }
                    else if (dsp.GetDSPTX(0).TXFMDeviation == 5000)
                    {
                        UpdateRX2Filters(-8000, 8000);
                    }
                    else // 2.5k
                    {
                        UpdateRX2Filters(-4000, 4000);
                    }



                }
                RX2Filter = Filter.NONE;
            }

            if (rx2_dsp_mode != DSPMode.FM && rx2_dsp_mode != DSPMode.DRM)
            {
                RX2Filter = rx2_filters[(int)new_mode].LastFilter;
            }
            else
            {
                RX2Filter = Filter.NONE;
            }

            tbFilterWidthScroll_newMode(); // wjt */

            //Display.DrawBackground();

            if (rx2_enabled)
            {
                UpdateDSPBufRX2();
                if (chkVFOBTX.Checked) UpdateDSPBufTX();
            }

            txtVFOBFreq_LostFocus(this, EventArgs.Empty);
            ptbPWR_Scroll(this, EventArgs.Empty);

            if (fwc_init && current_model == Model.FLEX5000)
            {
                bool tx1, tx2, tx3;
                if (flex5000RelayForm != null) flex5000RelayForm.UpdateRelayState(out tx1, out tx2, out tx3);
            }

        } // SetRX2Mode

        private void radRX2ModeLSB_CheckedChanged(object sender, System.EventArgs e)
        {
            if (radRX2ModeLSB.Checked)
            {
                SetRX2Mode(DSPMode.LSB);
            }
        }

        private void radRX2ModeUSB_CheckedChanged(object sender, System.EventArgs e)
        {
            if (radRX2ModeUSB.Checked)
            {
                SetRX2Mode(DSPMode.USB);
            }
        }

        private void radRX2ModeDSB_CheckedChanged(object sender, System.EventArgs e)
        {
            if (radRX2ModeDSB.Checked)
            {
                SetRX2Mode(DSPMode.DSB);
            }
        }

        private void radRX2ModeCWL_CheckedChanged(object sender, System.EventArgs e)
        {
            if (radRX2ModeCWL.Checked)
            {
                SetRX2Mode(DSPMode.CWL);
            }
        }

        private void radRX2ModeCWU_CheckedChanged(object sender, System.EventArgs e)
        {
            if (radRX2ModeCWU.Checked)
            {
                SetRX2Mode(DSPMode.CWU);
            }
        }

        private void radRX2ModeFMN_CheckedChanged(object sender, System.EventArgs e)
        {
            if (radRX2ModeFMN.Checked)
            {
                SetRX2Mode(DSPMode.FM);
            }
        }

        private void radRX2ModeAM_CheckedChanged(object sender, System.EventArgs e)
        {
            if (radRX2ModeAM.Checked)
            {
                SetRX2Mode(DSPMode.AM);
            }
        }

        private void radRX2ModeSAM_CheckedChanged(object sender, System.EventArgs e)
        {
            if (radRX2ModeSAM.Checked)
            {
                SetRX2Mode(DSPMode.SAM);
            }
        }

        private void radRX2ModeDIGL_CheckedChanged(object sender, System.EventArgs e)
        {
            if (radRX2ModeDIGL.Checked)
            {
                chkRX2ANF.Checked = false;
                chkRX2NR.Checked = false;
                chkRX2NB.Checked = false;
                chkRX2NB2.Checked = false;
                SetRX2Mode(DSPMode.DIGL);
            }
        }

        private void radRX2ModeDIGU_CheckedChanged(object sender, System.EventArgs e)
        {
            if (radRX2ModeDIGU.Checked)
            {
                chkRX2ANF.Checked = false;
                chkRX2NR.Checked = false;
                chkRX2NB.Checked = false;
                chkRX2NB2.Checked = false;
                SetRX2Mode(DSPMode.DIGU);
            }
        }

        private void radRX2ModeDRM_CheckedChanged(object sender, System.EventArgs e)
        {
            if (radRX2ModeDRM.Checked)
            {
                SetRX2Mode(DSPMode.DRM);
            }
        }

        public void SetRX2Filter(Filter new_filter)
        {
            if (!fwc_init || current_model != Model.FLEX5000 || !FWCEEPROM.RX2OK) return;
            if (rx2_dsp_mode == DSPMode.FIRST || rx2_dsp_mode == DSPMode.LAST) return;

            int low = 0, high = 0;

            switch (rx2_filter)
            {
                case Filter.F1:
                    radRX2Filter1.BackColor = SystemColors.Control;
                    break;
                case Filter.F2:
                    radRX2Filter2.BackColor = SystemColors.Control;
                    break;
                case Filter.F3:
                    radRX2Filter3.BackColor = SystemColors.Control;
                    break;
                case Filter.F4:
                    radRX2Filter4.BackColor = SystemColors.Control;
                    break;
                case Filter.F5:
                    radRX2Filter5.BackColor = SystemColors.Control;
                    break;
                case Filter.F6:
                    radRX2Filter6.BackColor = SystemColors.Control;
                    break;
                case Filter.F7:
                    radRX2Filter7.BackColor = SystemColors.Control;
                    break;
                case Filter.VAR1:
                    //radRX2FilterVar1.BackColor = SystemColors.Control;
                    //udRX2FilterLow.BackColor = SystemColors.Window;
                    //udRX2FilterHigh.BackColor = SystemColors.Window;
                    udRX2FilterLow.Enabled = false;
                    udRX2FilterHigh.Enabled = false;
                    break;
                case Filter.VAR2:
                    //radRX2FilterVar2.BackColor = SystemColors.Control;
                    //udRX2FilterLow.BackColor = SystemColors.Window;
                    //udRX2FilterHigh.BackColor = SystemColors.Window;
                    udRX2FilterLow.Enabled = false;
                    udRX2FilterHigh.Enabled = false;
                    break;
            }

            rx2_filter = new_filter;

            low = rx2_filters[(int)rx2_dsp_mode].GetLow(new_filter);
            high = rx2_filters[(int)rx2_dsp_mode].GetHigh(new_filter);
            rx2_filters[(int)rx2_dsp_mode].LastFilter = new_filter;

            panelRX2Filter.Text = "RX2 Filter - " + rx2_filters[(int)rx2_dsp_mode].GetName(new_filter);

            switch (new_filter)
            {
                case Filter.F1:
                    radRX2Filter1.BackColor = button_selected_color;
                    break;
                case Filter.F2:
                    radRX2Filter2.BackColor = button_selected_color;
                    break;
                case Filter.F3:
                    radRX2Filter3.BackColor = button_selected_color;
                    break;
                case Filter.F4:
                    radRX2Filter4.BackColor = button_selected_color;
                    break;
                case Filter.F5:
                    radRX2Filter5.BackColor = button_selected_color;
                    break;
                case Filter.F6:
                    radRX2Filter6.BackColor = button_selected_color;
                    break;
                case Filter.F7:
                    radRX2Filter7.BackColor = button_selected_color;
                    break;
                case Filter.VAR1:
                    //radRX2FilterVar1.BackColor = button_selected_color;
                    //udRX2FilterLow.BackColor = button_selected_color;
                    //udRX2FilterHigh.BackColor = button_selected_color;
                    udRX2FilterLow.Enabled = true;
                    udRX2FilterHigh.Enabled = true;
                    break;
                case Filter.VAR2:
                    //radRX2FilterVar2.BackColor = button_selected_color;
                    //udRX2FilterLow.BackColor = button_selected_color;
                    //udRX2FilterHigh.BackColor = button_selected_color;
                    udRX2FilterLow.Enabled = true;
                    udRX2FilterHigh.Enabled = true;
                    break;
                case Filter.NONE:
                    foreach (Control c in panelRX2Filter.Controls)
                    {
                        if (c.GetType() == typeof(RadioButtonTS))
                        {
                            ((RadioButtonTS)c).Checked = false;

                            if (c.BackColor != SystemColors.Control)
                                ((RadioButtonTS)c).BackColor = SystemColors.Control;
                        }
                    }
                    return;
            }

            UpdateRX2Filters(low, high);
        }

        private void radRX2Filter1_CheckedChanged(object sender, System.EventArgs e)
        {
            if (radRX2Filter1.Checked)
                SetRX2Filter(Filter.F1);
        }

        private void radRX2Filter2_CheckedChanged(object sender, System.EventArgs e)
        {
            if (radRX2Filter2.Checked)
                SetRX2Filter(Filter.F2);
        }

        private void radRX2Filter3_CheckedChanged(object sender, System.EventArgs e)
        {
            if (radRX2Filter3.Checked)
                SetRX2Filter(Filter.F3);
        }

        private void radRX2Filter4_CheckedChanged(object sender, System.EventArgs e)
        {
            if (radRX2Filter4.Checked)
                SetRX2Filter(Filter.F4);
        }

        private void radRX2Filter5_CheckedChanged(object sender, System.EventArgs e)
        {
            if (radRX2Filter5.Checked)
                SetRX2Filter(Filter.F5);
        }

        private void radRX2Filter6_CheckedChanged(object sender, System.EventArgs e)
        {
            if (radRX2Filter6.Checked)
                SetRX2Filter(Filter.F6);
        }

        private void radRX2Filter7_CheckedChanged(object sender, System.EventArgs e)
        {
            if (radRX2Filter7.Checked)
                SetRX2Filter(Filter.F7);
        }

        private void radRX2FilterVar1_CheckedChanged(object sender, System.EventArgs e)
        {
            if (radRX2FilterVar1.Checked)
                SetRX2Filter(Filter.VAR1);
        }

        private void radRX2FilterVar2_CheckedChanged(object sender, System.EventArgs e)
        {
            if (radRX2FilterVar2.Checked)
                SetRX2Filter(Filter.VAR2);
        }

        private void udRX2FilterLow_ValueChanged(object sender, System.EventArgs e)
        {
            if (!FWCEEPROM.RX2OK) return;

            picRadar.Invalidate(); //.246

            if (udRX2FilterLow.Focused)
            {
                if (udRX2FilterLow.Value >= udRX2FilterHigh.Value - 10)
                {
                    udRX2FilterLow.Value = udRX2FilterHigh.Value - 10;
                    return;
                }

                UpdateRX2Filters((int)udRX2FilterLow.Value, (int)udRX2FilterHigh.Value);

                if (!save_filter_changes) rx2_filters[(int)rx2_dsp_mode].SetLow(rx2_filter, (int)udRX2FilterLow.Value);
            }

            if (save_filter_changes && rx2_filter >= Filter.F1 && rx2_filter <= Filter.VAR2)
                rx2_filters[(int)rx2_dsp_mode].SetLow(rx2_filter, (int)udRX2FilterLow.Value);

            /*if(udFilterLow.Focused)
				btnHidden.Focus();*/
        }

        private void udRX2FilterHigh_ValueChanged(object sender, System.EventArgs e)
        {
            picRadar.Invalidate(); //.246

            if (!FWCEEPROM.RX2OK) return;
            if (udRX2FilterHigh.Focused)
            {
                if (udRX2FilterHigh.Value <= udRX2FilterLow.Value + 10)
                {
                    udRX2FilterHigh.Value = udRX2FilterLow.Value + 10;
                    return;
                }

                UpdateRX2Filters((int)udRX2FilterLow.Value, (int)udRX2FilterHigh.Value);

                if (!save_filter_changes) rx2_filters[(int)rx2_dsp_mode].SetHigh(rx2_filter, (int)udRX2FilterHigh.Value);
            }

            if (save_filter_changes && rx2_filter >= Filter.F1 && rx2_filter <= Filter.VAR2)
                rx2_filters[(int)rx2_dsp_mode].SetHigh(rx2_filter, (int)udRX2FilterHigh.Value);

            /*if(udFilterHigh.Focused)
				btnHidden.Focus();*/
        }

        private void chkRX2NR_CheckedChanged(object sender, System.EventArgs e)
        {
            if (!FWCEEPROM.RX2OK) return;
            if (chkRX2NR.Checked) chkRX2NR.BackColor = button_selected_color;
            else chkRX2NR.BackColor = SystemColors.Control;
            dsp.GetDSPRX(1, 0).NoiseReduction = chkRX2NR.Checked;
            dsp.GetDSPRX(1, 1).NoiseReduction = chkRX2NR.Checked;
            //cat_nr_status = Convert.ToInt32(chkRX2NR.Checked);
        }

        private void chkRX2ANF_CheckedChanged(object sender, System.EventArgs e)
        {
            if (!FWCEEPROM.RX2OK) return;
            if (chkRX2ANF.Checked) chkRX2ANF.BackColor = button_selected_color;
            else chkRX2ANF.BackColor = SystemColors.Control;
            dsp.GetDSPRX(1, 0).AutoNotchFilter = chkRX2ANF.Checked;
            dsp.GetDSPRX(1, 1).AutoNotchFilter = chkRX2ANF.Checked;
            //cat_anf_status = Convert.ToInt32(chkRX2ANF.Checked);
        }

        private void chkRX2NB_CheckedChanged(object sender, System.EventArgs e)
        {
            if (!FWCEEPROM.RX2OK) return;
            if (chkRX2NB.Checked) chkRX2NB.BackColor = button_selected_color;
            else chkRX2NB.BackColor = SystemColors.Control;
            dsp.GetDSPRX(1, 0).NBOn = chkRX2NB.Checked;
            dsp.GetDSPRX(1, 1).NBOn = chkRX2NB.Checked;
            cat_rx2nb1_status = Convert.ToInt32(chkRX2NB.Checked);
        }

        private void chkRX2NB2_CheckedChanged(object sender, System.EventArgs e)
        {
            if (!FWCEEPROM.RX2OK) return;
            if (chkRX2NB2.Checked) chkRX2NB2.BackColor = button_selected_color;
            else chkRX2NB2.BackColor = SystemColors.Control;
            dsp.GetDSPRX(1, 0).SDROM = chkRX2NB2.Checked;
            dsp.GetDSPRX(1, 1).SDROM = chkRX2NB2.Checked;
            cat_rx2nb2_status = Convert.ToInt32(chkRX2NB2.Checked);
        }

        private void chkRX2BIN_CheckedChanged(object sender, System.EventArgs e)
        {
            if (!FWCEEPROM.RX2OK) return;
            if (chkRX2BIN.Checked) chkRX2BIN.BackColor = button_selected_color;
            else chkRX2BIN.BackColor = SystemColors.Control;
            dsp.GetDSPRX(1, 0).BinOn = chkRX2BIN.Checked;
            dsp.GetDSPRX(1, 1).BinOn = chkRX2BIN.Checked;
        }

        //==============================================================================
        // ke9ns add for 2nd meter with a 2nd receiver






        //============================================================
        private void comboRX2MeterMode_SelectedIndexChanged(object sender, System.EventArgs e)
        {
            if (!FWCEEPROM.RX2OK) return;

            if (comboRX2MeterMode.Items.Count == 0 || comboRX2MeterMode.SelectedIndex < 0)
            {
                rx2_meter_mode = MeterRXMode.FIRST;
            }
            else
            {
                MeterRXMode mode = MeterRXMode.FIRST;
                switch (comboRX2MeterMode.Text)
                {
                    case "Signal":
                        mode = MeterRXMode.SIGNAL_STRENGTH;
                        break;
                    case "Sig Avg":
                        rx2_meter_avg = Display.CLEAR_FLAG;
                        mode = MeterRXMode.SIGNAL_AVERAGE;
                        break;
                    case "Sig Pk":      // ke9ns ADD
                        rx2_meter_peak = Display.CLEAR_FLAG;
                        mode = MeterRXMode.SIGNAL_PEAK;
                        break;
                    case "ADC L":
                        mode = MeterRXMode.ADC_L;
                        break;
                    case "ADC R":
                        mode = MeterRXMode.ADC_R;
                        break;
                    case "ADC2 L":
                        mode = MeterRXMode.ADC2_L;
                        break;
                    case "ADC2 R":
                        mode = MeterRXMode.ADC2_R;
                        break;
                    case "Off":
                        mode = MeterRXMode.OFF;
                        break;
                }
                rx2_meter_mode = mode;

                bool mox2 = false; // ke9ns add  false = rx    true = 2nd tx meter active

                //---------------------------
                // ke9ns add
                if ((setupForm != null) && (setupForm.chkRX2AutoMuteRX2OnVFOATX.Checked == false) || (TXMeter2 == false) || ((TXMeter2 == true) && (!MOX))) // ke9ns do RX2 if in duplex mode and not in special 2nd TX meter mode
                {
                    if ((!FWCEEPROM.RX2OK) || (FWCEEPROM.RX2OK && chkRX2.Checked == false)) mox2 = true; // ke9ns keep meter set for the TX type you wanted all the time
                    else mox2 = false; // receiving on RX2 or dont want 2nd tX meter

                }
                else
                {
                    mox2 = true; // transmitting and want 2nd tx meter to function
                }

                if (!mox2)
                {
                    switch (mode)
                    {
                        case MeterRXMode.SIGNAL_STRENGTH:
                        case MeterRXMode.SIGNAL_PEAK:  // ke9ns ADD
                        case MeterRXMode.SIGNAL_AVERAGE:
                            lblRX2Meter.Text = "  1   3   5   7   9  +20 +40 +60";
                            break;

                        case MeterRXMode.ADC_L:
                        case MeterRXMode.ADC_R:
                            lblRX2Meter.Text = "-100  -80   -60   -40   -20    0";
                            break;
                        case MeterRXMode.OFF:
                            lblRX2Meter.Text = "";
                            break;
                    }
                    ResetRX2MeterPeak();
                }
            }

            if (meterCombo == true) picRX3Meter.Invalidate(); // ke9ns12 add
            else picRX2Meter.Invalidate(); // ke9ns12 add
                                           //	picRX2Meter.Invalidate();

            if (comboRX2MeterMode.Focused) btnHidden.Focus();
        } //comboRx2metermode_selectedindexchanged




        private void chkRX2Preamp_CheckedChanged(object sender, System.EventArgs e)
        {
            //    Debug.WriteLine("chkRX2PREAMP mode0 " + chkRX2Preamp.Checked + " , " + RX2PreampMode);

            if (!fwc_init || current_model != Model.FLEX5000 || !FWCEEPROM.RX2OK) return;


            if (chkRX2Preamp.Checked)
            {
                chkRX2Preamp.BackColor = button_selected_color;
                RX2PreampMode = PreampMode.HIGH;
            }
            else
            {
                chkRX2Preamp.BackColor = SystemColors.Control;
                RX2PreampMode = PreampMode.OFF;
            }

        } // chkRX2Preamp_CheckedChanged

        private void ptbRX2RF_Scroll(object sender, System.EventArgs e)
        {
            if (!FWCEEPROM.RX2OK) return;
            lblRX2RF.Text = "AGC-T:  " + ptbRX2RF.Value.ToString();
            switch (RX2AGCMode)
            {
                case AGCMode.FIXD:
                    dsp.GetDSPRX(1, 0).RXFixedAGC = (double)ptbRX2RF.Value;
                    dsp.GetDSPRX(1, 1).RXFixedAGC = (double)ptbRX2RF.Value;
                    rx2_fixed_gain = ptbRX2RF.Value;
                    break;
                default:
                    dsp.GetDSPRX(1, 0).RXAGCMaxGain = (double)ptbRX2RF.Value;
                    dsp.GetDSPRX(1, 1).RXAGCMaxGain = (double)ptbRX2RF.Value;
                    rx2_max_gain = ptbRX2RF.Value;
                    break;
            }

            rx2_agct_by_band[(int)rx2_band] = ptbRX2RF.Value;
            if (ptbRX2RF.Focused) btnHidden.Focus();
        }

        private void chkRX2Squelch_CheckedChanged(object sender, System.EventArgs e)
        {
            if (!FWCEEPROM.RX2OK) return;
            if (rx2_dsp_mode == DSPMode.FM && !chkRX2Squelch.Checked)
                chkRX2Squelch.Checked = true;

            dsp.GetDSPRX(1, 0).RXSquelchOn = chkRX2Squelch.Checked;
            dsp.GetDSPRX(1, 1).RXSquelchOn = chkRX2Squelch.Checked;
        }

        private void ptbRX2Squelch_Scroll(object sender, System.EventArgs e)
        {
            if (!FWCEEPROM.RX2OK) return;

            chkRX2Squelch.Text = "SQL:  " + ptbRX2Squelch.Value.ToString();

            if (rx2_dsp_mode == DSPMode.FM)
            {
                dsp.GetDSPRX(1, 0).FMSquelchThreshold = (float)Math.Pow(10.0, -2 * ptbRX2Squelch.Value / 100.0);
                dsp.GetDSPRX(1, 1).FMSquelchThreshold = (float)Math.Pow(10.0, -2 * ptbRX2Squelch.Value / 100.0);
            }
            else
            {
                dsp.GetDSPRX(1, 0).RXSquelchThreshold = ((float)ptbRX2Squelch.Value -
                    rx2_meter_cal_offset -
                    rx2_preamp_offset[(int)rx2_preamp_mode] -
                    rx2_filter_size_cal_offset -
                    rx2_path_offset);

                dsp.GetDSPRX(1, 1).RXSquelchThreshold = ((float)ptbRX2Squelch.Value -
                    rx2_meter_cal_offset -
                    rx2_preamp_offset[(int)rx2_preamp_mode] -
                    rx2_filter_size_cal_offset -
                    rx2_path_offset);
            }

            if (ptbRX2Squelch.Focused) btnHidden.Focus();
        }

        private void picRX2Squelch_Paint(object sender, System.Windows.Forms.PaintEventArgs e)
        {
            if (!FWCEEPROM.RX2OK) return;
            int signal_x = (int)((rx2_sql_data + 160.0) * (picRX2Squelch.Width - 1) / 160.0);
            int sql_x = (int)(((float)ptbRX2Squelch.Value + 160.0) * (picRX2Squelch.Width - 1) / 160.0);

            e.Graphics.FillRectangle(new SolidBrush(Color.LimeGreen), 0, 0, signal_x, picRX2Squelch.Height);
            if (sql_x < signal_x)
            {
                e.Graphics.FillRectangle(new SolidBrush(Color.Red), sql_x + 1, 0, signal_x - sql_x - 1, picRX2Squelch.Height);
                ScanControl.ScanStop2 = 1; // ke9ns add .244
            }


            ScanControl.SQL2 = (int)ptbRX2Squelch.Value;
            ScanControl.SIG2 = (int)rx2_sql_data;


        } // picRX2Squelch

        // ke9ns: for Flex_5000 only
        private void chkRX1Preamp_CheckedChanged(object sender, System.EventArgs e)
        {
            if (!(fwc_init && current_model == Model.FLEX5000)) return;

            if (chkRX1Preamp.Checked)
            {
                chkRX1Preamp.BackColor = button_selected_color;
                chkRX1Preamp.Text = "On";
                RX1PreampMode = PreampMode.HIGH;
            }
            else
            {
                chkRX1Preamp.BackColor = SystemColors.Control;
                chkRX1Preamp.Text = "Off";
                RX1PreampMode = PreampMode.OFF;
            }
        }

        private void ptbRX2Pan_Scroll(object sender, System.EventArgs e)
        {
            float val = (int)ptbRX2Pan.Value / 100.0f;
            dsp.GetDSPRX(1, 0).Pan = val;

            if (ptbRX2Pan.Focused)
                btnHidden.Focus();
        }

        //===================================================================
        private void ptbRX2Gain_Scroll(object sender, System.EventArgs e)
        {
            if (chkRX2Mute.Checked) return;

            dsp.GetDSPRX(1, 0).RXOutputGain = (double)ptbRX2Gain.Value / ptbRX2Gain.Maximum * 0.5;  // max 0.5 to allow for headroom (value = 1 to 100)

            if (ptbRX2Gain.Focused) btnHidden.Focus();
        }

        private void chkRX2Mute_CheckedChanged(object sender, System.EventArgs e)
        {
            if (chkRX2Mute.Checked) dsp.GetDSPRX(1, 0).RXOutputGain = 0.0;
            else ptbRX2Gain_Scroll(this, EventArgs.Empty);

            if (chkRX2Mute.Focused) btnHidden.Focus();
        }


        //==============================================================
        //==============================================================
        // ke9ns mod: this is RX2 display mode selection
        //==============================================================
        //==============================================================
        private void comboRX2DisplayMode_SelectedIndexChanged(object sender, System.EventArgs e)
        {
            switch (comboRX2DisplayMode.Text)  // ke9ns list of modes is not this complete list
            {
                case "Spectrum":

                    Display.CurrentDisplayModeBottom = DisplayMode.SPECTRUM;
                    if (chkSplitDisplay.Checked) UpdateRXDisplayVars2((int)udFilterLow.Value, (int)udFilterHigh.Value);
                    break;
                case "Panadapter":

                    Display.CurrentDisplayModeBottom = DisplayMode.PANADAPTER;
                    if (chkSplitDisplay.Checked) CalcDisplayFreq();
                    break;
                case "Panafall":  // ke9ns pan

                    Display.CurrentDisplayModeBottom = DisplayMode.PANAFALL;
                    if (chkSplitDisplay.Checked) CalcDisplayFreq();

                    break;
                case "Scope":

                    Display.CurrentDisplayModeBottom = DisplayMode.SCOPE;
                    break;
                case "Phase":

                    Display.CurrentDisplayModeBottom = DisplayMode.PHASE;
                    break;
                case "Phase2":

                    Display.CurrentDisplayModeBottom = DisplayMode.PHASE2;
                    break;
                case "Waterfall":

                    Display.CurrentDisplayModeBottom = DisplayMode.WATERFALL;
                    if (chkSplitDisplay.Checked) CalcDisplayFreq();
                    break;
                case "Histogram":

                    Display.CurrentDisplayModeBottom = DisplayMode.HISTOGRAM;
                    break;
                case "Off":

                    Display.CurrentDisplayModeBottom = DisplayMode.OFF;
                    break;
            }


            // ke9ns add this section since rx2 can now do panafall
            switch (Display.CurrentDisplayModeBottom)
            {
                case DisplayMode.PANADAPTER:
                case DisplayMode.WATERFALL:
                    chkRX2DisplayAVG.Text = "Avg"; // ke9ns  add
                    break;

                case DisplayMode.PANAFALL:

                    if ((Display.PW_AVG2 == 0))
                    {
                        if (chkRX2DisplayAVG.Checked == true) chkRX2DisplayAVG.Text = "AvgB"; // ke9ns add 
                        else chkRX2DisplayAVG.Text = "Avg"; // ke9ns add 
                    }
                    break;

                default:
                    break;
            }



            if (comboRX2DisplayMode.Focused)
                btnHidden.Focus();

        } // rx2 combodisplaymode


        //==============================================================
        //==============================================================
        // ke9ns mod: allows rx2 to have avgB, avgP, and off between the panadapter and waterfall
        //==============================================================
        //==============================================================
        private void chkRX2DisplayAVG_CheckedChanged(object sender, System.EventArgs e)
        {

            if (Display.CurrentDisplayModeBottom == DisplayMode.PANAFALL) // ke9ns pan
            {

                chkRX2DisplayAVG.CheckedChanged -= chkRX2DisplayAVG_CheckedChanged; // turn eventoff

                // PW_AVG 0 = water AVG follows Panadapter AVG ON/OFF
                //        1 = water AVG OFF no matter

                if ((Display.PW_AVG2 & 1) == 0) // 0=  avg ON waterfall if its ON panadater
                {

                    if (chkRX2DisplayAVG.Checked == false)   // if AVG on both panadapter and waterfall and you click the avg button then do below
                    {
                        // AVG ONLY ON PANADAPTER
                        Display.PW_AVG2 = 1;             // waterfall avg OFF 
                        chkRX2DisplayAVG.Checked = true;   // Panadapter avg ON (keeping the button ON)
                        chkRX2DisplayAVG.Text = "AvgP"; // ke9ns 

                    }
                    else // true
                    {
                        // AVG ON FULL PANAFALL
                        Display.PW_AVG2 = 0;             // waterfall avg ON    
                        chkRX2DisplayAVG.Checked = true;   // Panadapter avg ON  (simply flipping the button ON)
                        chkRX2DisplayAVG.Text = "AvgB"; // ke9ns 
                    }

                }
                else //  1=panafall mode, and waterfall AVG OFF 
                {

                    if (chkRX2DisplayAVG.Checked == false)   // if AVG on both panadapter and waterfall and you click the avg button then do below
                    {
                        // TURN OFF ALL AVG 
                        Display.PW_AVG2 = 0;             // waterfall avg OFF 
                        chkRX2DisplayAVG.Checked = false;   // Panadapter avg OFF (keeping the button ON)
                        chkRX2DisplayAVG.Text = "Avg"; // ke9ns 

                    }
                    else // true  (pw_avg=1 and panafall mode and button was OFF, now ON) impossibility
                    {

                        Display.PW_AVG2 = 0;             // waterfall avg ON    
                        chkRX2DisplayAVG.Checked = true;   // Panadapter avg ON  (simply flipping the button ON)
                        chkRX2DisplayAVG.Text = "Avg"; // ke9ns 
                    }

                }

                chkRX2DisplayAVG.CheckedChanged += chkRX2DisplayAVG_CheckedChanged; // turn event back on


            } // in panafallmode ?


            Display.RX2AverageOn = chkRX2DisplayAVG.Checked;

            if (chkRX2DisplayAVG.Checked)
            {
                chkRX2DisplayAVG.BackColor = button_selected_color;
            }
            else
            {
                chkRX2DisplayAVG.BackColor = SystemColors.Control;
            }

            /*if(chkRX2DisplayAVG.Checked)
			{
				switch(Display.CurrentDisplayMode)
				{
					case DisplayMode.PANADAPTER:
					case DisplayMode.HISTOGRAM:
					case DisplayMode.SPECTRUM:
					case DisplayMode.WATERFALL:
						btnZeroBeat.Enabled = true; // only allow zerobeat when avg is on 
						break;
					default:
						btnZeroBeat.Enabled = false;
						break;
				}
			}
			else btnZeroBeat.Enabled = false;*/
        }

        private void chkRX2DisplayPeak_CheckedChanged(object sender, System.EventArgs e)
        {
            Display.RX2PeakOn = chkRX2DisplayPeak.Checked;
            if (chkRX2DisplayPeak.Checked)
            {
                chkRX2DisplayPeak.BackColor = button_selected_color;
            }
            else
            {
                chkRX2DisplayPeak.BackColor = SystemColors.Control;
            }
        }

        private void UpdateDSPBufRX1()
        {
            int size = 2048;
            switch (rx1_dsp_mode)
            {
                case DSPMode.LSB:
                case DSPMode.USB:
                case DSPMode.DSB:
                case DSPMode.AM:
                case DSPMode.SAM:
                    //  case DSPMode.FM:

                    size = dsp_buf_phone_rx; // ke9ns filter buffer size from setup dsp form
                    break;
                case DSPMode.CWL:
                case DSPMode.CWU:
                    size = dsp_buf_cw_rx;
                    break;
                case DSPMode.DIGL:
                case DSPMode.DIGU:
                case DSPMode.DRM:
                    size = dsp_buf_dig_rx;
                    break;
                case DSPMode.FM:

                    if (FMData == true)
                    {
                        size = dsp_buf_dig_rx;
                    }
                    else
                    {
                        size = dsp_buf_phone_rx; // ke9ns filter buffer size from setup dsp form
                    }
                    break;

            }

            int offset = 0;
            switch (size)
            {
                case 4096: offset = 0; break;
                case 2048: offset = 3; break;
                case 1024: offset = 6; break;
                case 512: offset = 9; break;
                case 256: offset = 12; break;
            }

            if (dsp.GetDSPRX(0, 0).BufferSize != size || dsp.GetDSPRX(0, 1).BufferSize != size)
            {
                bool poweron = PowerOn;

                if (poweron) //.204 pause to prevent a PFN_ BSOD
                {
                    PowerOn = false;
                    Thread.Sleep(700);
                }

                RX1FilterSizeCalOffset = (float)offset;

                dsp.GetDSPRX(0, 0).BufferSize = size;
                dsp.GetDSPRX(0, 1).BufferSize = size;

                if (!initializing)
                {
                    DSP.SyncStatic();

                    for (int i = 0; i < 1; i++)
                    {
                        for (int j = 0; j < 2; j++)
                        {
                            DSPRX dsp_rx = dsp.GetDSPRX(i, j);
                            dsp_rx.Update = false;
                            dsp_rx.Force = true;
                            dsp_rx.Update = true;
                            dsp_rx.Force = false;
                        }
                    }

                    for (int i = 0; i < 1; i++)
                    {
                        DSPTX dsp_tx = dsp.GetDSPTX(i);
                        dsp_tx.Update = false;
                        dsp_tx.Force = true;
                        dsp_tx.Update = true;
                        dsp_tx.Force = false;
                    }
                }

                if (poweron) PowerOn = true;
            }
        } // update dsp rx1 buffer

        private void UpdateDSPBufRX2()
        {
            int size = 2048;
            switch (rx2_dsp_mode)
            {
                case DSPMode.LSB:
                case DSPMode.USB:
                case DSPMode.DSB:
                case DSPMode.AM:
                case DSPMode.SAM:
                    //case DSPMode.FM:
                    size = dsp_buf_phone_rx;
                    break;
                case DSPMode.CWL:
                case DSPMode.CWU:
                    size = dsp_buf_cw_rx;
                    break;
                case DSPMode.DIGL:
                case DSPMode.DIGU:
                case DSPMode.DRM:
                    size = dsp_buf_dig_rx;
                    break;
                case DSPMode.FM:

                    if (FMData == true)
                    {
                        size = dsp_buf_dig_rx;
                    }
                    else
                    {
                        size = dsp_buf_phone_rx; // ke9ns filter buffer size from setup dsp form
                    }
                    break;

            }

            int offset = 0;
            switch (size)
            {
                case 4096: offset = 0; break;
                case 2048: offset = 3; break;
                case 1024: offset = 6; break;
                case 512: offset = 9; break;
                case 256: offset = 12; break;
            }

            if (dsp.GetDSPRX(1, 0).BufferSize != size || dsp.GetDSPRX(1, 1).BufferSize != size)
            {
                bool poweron = PowerOn;
                if (poweron)  //.204
                {
                    PowerOn = false;
                    Thread.Sleep(700);
                }

                RX2FilterSizeCalOffset = (float)offset;
                dsp.GetDSPRX(1, 0).BufferSize = size;
                dsp.GetDSPRX(1, 1).BufferSize = size;

                if (!initializing)
                {
                    DSP.SyncStatic();

                    for (int i = 0; i < 1; i++)
                    {
                        for (int j = 0; j < 2; j++)
                        {
                            DSPRX dsp_rx = dsp.GetDSPRX(i, j);
                            dsp_rx.Update = false;
                            dsp_rx.Force = true;
                            dsp_rx.Update = true;
                            dsp_rx.Force = false;
                        }
                    }

                    for (int i = 0; i < 1; i++)
                    {
                        DSPTX dsp_tx = dsp.GetDSPTX(i);
                        dsp_tx.Update = false;
                        dsp_tx.Force = true;
                        dsp_tx.Update = true;
                        dsp_tx.Force = false;
                    }
                }

                if (poweron) PowerOn = true;
            }
        }

        private void UpdateDSPBufTX()
        {
            int size = 2048;
            DSPMode mode = rx1_dsp_mode;
            if (chkVFOBTX.Checked) mode = rx2_dsp_mode;
            switch (mode)
            {
                case DSPMode.LSB:
                case DSPMode.USB:
                case DSPMode.DSB:
                case DSPMode.AM:
                case DSPMode.SAM:
                case DSPMode.FM:
                    size = dsp_buf_phone_tx;
                    break;
                case DSPMode.CWL:
                case DSPMode.CWU:
                    size = dsp_buf_cw_tx;
                    break;
                case DSPMode.DIGL:
                case DSPMode.DIGU:
                case DSPMode.DRM:
                    size = dsp_buf_dig_tx;
                    break;
            }

            if (dsp.GetDSPTX(0).BufferSize != size)
            {
                bool poweron = PowerOn;
                if (poweron)  //.204
                {
                    PowerOn = false;
                    Thread.Sleep(700);
                }

                dsp.GetDSPTX(0).BufferSize = size;

                if (!initializing)
                {
                    DSP.SyncStatic();

                    for (int i = 0; i < 2; i++)
                    {
                        for (int j = 0; j < 2; j++)
                        {
                            DSPRX dsp_rx = dsp.GetDSPRX(i, j);
                            dsp_rx.Update = false;
                            dsp_rx.Force = true;
                            dsp_rx.Update = true;
                            dsp_rx.Force = false;
                        }
                    }

                    for (int i = 0; i < 1; i++)
                    {
                        DSPTX dsp_tx = dsp.GetDSPTX(i);
                        dsp_tx.Update = false;
                        dsp_tx.Force = true;
                        dsp_tx.Update = true;
                        dsp_tx.Force = false;
                    }
                }

                if (poweron) PowerOn = true; //.204
            }
        }


        //=========================================================
        // ke9ns value passed from setup->dsp->rx buffer size
        private int dsp_buf_phone_rx = 4096;
        public int DSPBufPhoneRX
        {
            get { return dsp_buf_phone_rx; }
            set
            {
                dsp_buf_phone_rx = value;
                UpdateDSPBufRX1();
                UpdateDSPBufRX2();
            }
        }

        private int dsp_buf_phone_tx = 2048;
        public int DSPBufPhoneTX
        {
            get { return dsp_buf_phone_tx; }
            set
            {
                dsp_buf_phone_tx = value;
                UpdateDSPBufTX();
            }
        }

        private int dsp_buf_cw_rx = 4096;
        public int DSPBufCWRX
        {
            get { return dsp_buf_cw_rx; }
            set
            {
                dsp_buf_cw_rx = value;
                UpdateDSPBufRX1();
                UpdateDSPBufRX2();
            }
        }

        private int dsp_buf_cw_tx = 2048;
        public int DSPBufCWTX
        {
            get { return dsp_buf_cw_tx; }
            set
            {
                dsp_buf_cw_tx = value;
                UpdateDSPBufTX();
            }
        }

        private int dsp_buf_dig_rx = 4096;
        public int DSPBufDigRX
        {
            get { return dsp_buf_dig_rx; }
            set
            {
                dsp_buf_dig_rx = value;
                UpdateDSPBufRX1();
                UpdateDSPBufRX2();
            }
        }


        bool RX2BandButton = false; //ke9ns add .203 true = press the band button instead
        private int dsp_buf_dig_tx = 2048;
        private void comboRX2Band_SelectedIndexChanged(object sender, System.EventArgs e)
        {


            if (comboRX2Band.Focused || RX2BandButton)
            {
                RX2BandButton = false;
                string filter = "", mode = "", band = "";
                double freq = 0.0;
                bool b = false;

                SaveBandB(); // ke9ns save freq you were on prior to coming here

                RX2Band = StringToBand(comboRX2Band.Text); // ke9ns ADD .210

                Debug.WriteLine("RX2BAND: " + RX2Band);

                switch (comboRX2Band.Text)
                {
                    case "160m":
                        band = "160M";
                        // setupForm.WaterfallLowRX2Threshold = WaterfallLowThreshold160m; // ke9ns not needed here
                        break;
                    case "80m":
                        band = "80M";
                        // setupForm.WaterfallLowRX2Threshold = WaterfallLowThreshold80m;
                        break;
                    case "60m":
                        band = "60M";
                        //  setupForm.WaterfallLowRX2Threshold = WaterfallLowThreshold60m;
                        break;
                    case "40m":
                        band = "40M";
                        //  setupForm.WaterfallLowRX2Threshold = WaterfallLowThreshold40m;
                        break;
                    case "30m":
                        band = "30M";
                        //  setupForm.WaterfallLowRX2Threshold = WaterfallLowThreshold30m;
                        break;
                    case "20m":
                        band = "20M";
                        //  setupForm.WaterfallLowRX2Threshold = WaterfallLowThreshold20m;
                        break;
                    case "17m":
                        band = "17M";
                        //  setupForm.WaterfallLowRX2Threshold = WaterfallLowThreshold17m;
                        break;
                    case "15m":
                        band = "15M";
                        //  setupForm.WaterfallLowRX2Threshold = WaterfallLowThreshold15m;
                        break;
                    case "12m":
                        band = "12M";
                        //  setupForm.WaterfallLowRX2Threshold = WaterfallLowThreshold12m;
                        break;
                    case "10m":
                        band = "10M";
                        //  setupForm.WaterfallLowRX2Threshold = WaterfallLowThreshold10m;
                        break;
                    case "6m":
                        band = "6M";
                        //  setupForm.WaterfallLowRX2Threshold = WaterfallLowThreshold6m;
                        break;
                    case "2m":
                        band = "2M";
                        // setupForm.WaterfallLowRX2Threshold = WaterfallLowThresholdXVTR;
                        break;
                    case "GEN":
                        band = "GEN";
                        //  setupForm.WaterfallLowRX2Threshold = WaterfallLowThresholdGEN;
                        break;
                    case "WWV":
                        band = "WWV";
                        //  setupForm.WaterfallLowRX2Threshold = WaterfallLowThresholdWWV;
                        break;
                    case "VU 2m":
                        band = "VHF0";
                        // setupForm.WaterfallLowRX2Threshold = WaterfallLowThresholdXVTR;
                        break;
                    case "VU 70cm":
                        band = "VHF1";
                        //  setupForm.WaterfallLowRX2Threshold = WaterfallLowThresholdXVTR;
                        break;
                    case "VHF2":
                        band = "VHF2";
                        //  setupForm.WaterfallLowRX2Threshold = WaterfallLowThresholdXVTR;
                        break;
                    case "VHF3":
                        band = "VHF3";
                        //  setupForm.WaterfallLowRX2Threshold = WaterfallLowThresholdXVTR;
                        break;
                    case "VHF4":
                        band = "VHF4";
                        // setupForm.WaterfallLowRX2Threshold = WaterfallLowThresholdXVTR;
                        break;
                    case "VHF5":
                        band = "VHF5";
                        //  setupForm.WaterfallLowRX2Threshold = WaterfallLowThresholdXVTR;
                        break;
                    case "VHF6":
                        band = "VHF6";
                        //  setupForm.WaterfallLowRX2Threshold = WaterfallLowThresholdXVTR;
                        break;
                    case "VHF7":
                        band = "VHF7";
                        //  setupForm.WaterfallLowRX2Threshold = WaterfallLowThresholdXVTR;
                        break;
                    case "VHF8":
                        band = "VHF8";
                        //  setupForm.WaterfallLowRX2Threshold = WaterfallLowThresholdXVTR;
                        break;
                    case "VHF9":
                        band = "VHF9";
                        //  setupForm.WaterfallLowRX2Threshold = WaterfallLowThresholdXVTR;
                        break;
                    case "VHF10":
                        band = "VHF10";
                        // setupForm.WaterfallLowRX2Threshold = WaterfallLowThresholdXVTR;
                        break;
                    case "VHF11":
                        band = "VHF11";
                        //  setupForm.WaterfallLowRX2Threshold = WaterfallLowThresholdXVTR;
                        break;
                    case "VHF12":
                        band = "VHF12";
                        //  setupForm.WaterfallLowRX2Threshold = WaterfallLowThresholdXVTR;
                        break;
                    case "VHF13":
                        band = "VHF13";
                        //  setupForm.WaterfallLowRX2Threshold = WaterfallLowThresholdXVTR;
                        break;



                    case "LMF":
                        band = "LMF";
                        break;

                    case "120m":
                        band = "120m";
                        break;
                    case "90m":
                        band = "90m";
                        break;
                    case "61m":
                        band = "61m";
                        break;
                    case "49m":
                        band = "49m";
                        break;
                    case "41m":
                        band = "41m";
                        break;
                    case "31m":
                        band = "31m";
                        break;
                    case "25m":
                        band = "25m";
                        break;
                    case "22m":
                        band = "22m";
                        break;
                    case "19m":
                        band = "19m";
                        break;
                    case "16m":
                        band = "16m";
                        break;
                    case "14m":
                        band = "14m";
                        break;
                    case "13m":
                        band = "13m";
                        break;
                    case "11m":
                        band = "11m";
                        break;

                } // comboboxrx2

                int register = -1;

                switch (band)
                {
                    case "160m": register = band_160m_register; setupForm.WaterfallLowRX2Threshold = WaterfallLowThreshold160m; break;
                    case "80m": register = band_80m_register; setupForm.WaterfallLowRX2Threshold = WaterfallLowThreshold80m; break;
                    case "60m": register = band_60m_register; setupForm.WaterfallLowRX2Threshold = WaterfallLowThreshold60m; break;
                    case "40m": register = band_40m_register; setupForm.WaterfallLowRX2Threshold = WaterfallLowThreshold40m; break;
                    case "30m": register = band_30m_register; setupForm.WaterfallLowRX2Threshold = WaterfallLowThreshold30m; break;
                    case "20m": register = band_20m_register; setupForm.WaterfallLowRX2Threshold = WaterfallLowThreshold20m; break;
                    case "17m": register = band_17m_register; setupForm.WaterfallLowRX2Threshold = WaterfallLowThreshold17m; break;
                    case "15m": register = band_15m_register; setupForm.WaterfallLowRX2Threshold = WaterfallLowThreshold15m; break;
                    case "12m": register = band_12m_register; setupForm.WaterfallLowRX2Threshold = WaterfallLowThreshold12m; break;
                    case "10m": register = band_10m_register; setupForm.WaterfallLowRX2Threshold = WaterfallLowThreshold10m; break;
                    case "6m": register = band_6m_register; setupForm.WaterfallLowRX2Threshold = WaterfallLowThreshold6m; break;
                    case "2m": register = band_2m_register; setupForm.WaterfallLowRX2Threshold = WaterfallLowThresholdXVTR; break;
                    case "GEN": register = band_gen_register; setupForm.WaterfallLowRX2Threshold = WaterfallLowThresholdGEN; break;
                    case "WWV": register = band_wwv_register; setupForm.WaterfallLowRX2Threshold = WaterfallLowThresholdWWV; break;
                    // ke9ns no RX2 SWL bands

                    //----------------
                    // ke9ns add: 
                    case "LMF": register = band_LMF_register; setupForm.WaterfallLowRX2Threshold = WaterfallLowThresholdLMF; break;
                    case "120m": register = band_120m_register; setupForm.WaterfallLowRX2Threshold = WaterfallLowThreshold120m; break;
                    case "90m": register = band_90m_register; setupForm.WaterfallLowRX2Threshold = WaterfallLowThreshold90m; break;
                    case "61m": register = band_61m_register; setupForm.WaterfallLowRX2Threshold = WaterfallLowThreshold61m; break;
                    case "49m": register = band_49m_register; setupForm.WaterfallLowRX2Threshold = WaterfallLowThreshold49m; break;
                    case "41m": register = band_41m_register; setupForm.WaterfallLowRX2Threshold = WaterfallLowThreshold41m; break;
                    case "31m": register = band_31m_register; setupForm.WaterfallLowRX2Threshold = WaterfallLowThreshold31m; break;
                    case "25m": register = band_25m_register; setupForm.WaterfallLowRX2Threshold = WaterfallLowThreshold25m; break;
                    case "22m": register = band_22m_register; setupForm.WaterfallLowRX2Threshold = WaterfallLowThreshold22m; break;
                    case "19m": register = band_19m_register; setupForm.WaterfallLowRX2Threshold = WaterfallLowThreshold19m; break;
                    case "16m": register = band_16m_register; setupForm.WaterfallLowRX2Threshold = WaterfallLowThreshold16m; break;
                    case "14m": register = band_14m_register; setupForm.WaterfallLowRX2Threshold = WaterfallLowThreshold14m; break;
                    case "13m": register = band_13m_register; setupForm.WaterfallLowRX2Threshold = WaterfallLowThreshold13m; break;
                    case "11m": register = band_11m_register; setupForm.WaterfallLowRX2Threshold = WaterfallLowThreshold11m; break;


                    case "VHF0": register = band_vhf0_register; setupForm.WaterfallLowRX2Threshold = WaterfallLowThresholdXVTR; break;
                    case "VHF1": register = band_vhf1_register; setupForm.WaterfallLowRX2Threshold = WaterfallLowThresholdXVTR; break;
                    case "VHF2": register = band_vhf2_register; setupForm.WaterfallLowRX2Threshold = WaterfallLowThresholdXVTR; break;
                    case "VHF3": register = band_vhf3_register; setupForm.WaterfallLowRX2Threshold = WaterfallLowThresholdXVTR; break;
                    case "VHF4": register = band_vhf4_register; setupForm.WaterfallLowRX2Threshold = WaterfallLowThresholdXVTR; break;
                    case "VHF5": register = band_vhf5_register; setupForm.WaterfallLowRX2Threshold = WaterfallLowThresholdXVTR; break;
                    case "VHF6": register = band_vhf6_register; setupForm.WaterfallLowRX2Threshold = WaterfallLowThresholdXVTR; break;
                    case "VHF7": register = band_vhf7_register; setupForm.WaterfallLowRX2Threshold = WaterfallLowThresholdXVTR; break;
                    case "VHF8": register = band_vhf8_register; setupForm.WaterfallLowRX2Threshold = WaterfallLowThresholdXVTR; break;
                    case "VHF9": register = band_vhf9_register; setupForm.WaterfallLowRX2Threshold = WaterfallLowThresholdXVTR; break;
                    case "VHF10": register = band_vhf10_register; setupForm.WaterfallLowRX2Threshold = WaterfallLowThresholdXVTR; break;
                    case "VHF11": register = band_vhf11_register; setupForm.WaterfallLowRX2Threshold = WaterfallLowThresholdXVTR; break;
                    case "VHF12": register = band_vhf12_register; setupForm.WaterfallLowRX2Threshold = WaterfallLowThresholdXVTR; break;
                    case "VHF13": register = band_vhf13_register; setupForm.WaterfallLowRX2Threshold = WaterfallLowThresholdXVTR; break;

                } // switch band


                if ((register < 3) && band.StartsWith("VHF"))
                {
                    int xvtr_index = Int32.Parse(band.Substring(3));

                    double start_freq = xvtrForm.GetBegin(xvtr_index);

                    for (int i = 0; i < 3 - register; i++)
                        DB.AddBandStack(band, "USB", "2600", start_freq + i * 0.0010);

                    UpdateBandStackRegisters();
                    register = 3;
                }


                last_band2 = band; // .209 string

                SetRX2BandButton(RX2Band); //.209

                Debug.WriteLine("RX2 BAND: " + RX2Band + " , " + iii2 + " , " + band);

                try
                {
                    iii2 = Convert.ToInt32((string)regBox12);
                    iii2--; // because regBox12 is + 1 for display to console.
                }
                catch
                {

                }


                if (DB.GetBandStack2(band, iii2, out mode, out filter, out freq))
                {
                    Debug.WriteLine("RX2 BAND1: " + RX2Band + " , " + iii2 + " , " + band + " , " + b + " ,freq:" + freq);

                    if (filter.Contains("@"))
                    {
                        filter = filter.Substring(0, (filter.Length) - 1); // ke9ns add for bandstack lockout
                    }

                    SetBand2(mode, filter, freq);
                    UpdateWaterfallLevelValues();
                }

                if (chkVFOBTX.Checked)
                {
                    chkVFOBTX_CheckedChanged(this, EventArgs.Empty); // .212 reupdate TX antenna
                }
                if (chkVFOATX.Checked)
                {
                    chkVFOATX_CheckedChanged(this, EventArgs.Empty); // .212
                }

                btnHidden.Focus();
            }// combo rx2 focus

            UpdateWaterfallLevelValues(); // ke9ns add allowing panafall requires this

            if (SpotForm != null) // ke9ns add .157
            {
                if (SpotControl.SP_Active > 2)
                {
                    SpotForm.processTCPMessage(); // upate the spotter that you changed bands
                }

            }
            autoadjust1 = true;

        } // combo rx2 index changed


        //bool done_console_basis = false;
        int dpi = 0;
        Size base_size = new Size(0, 0);
        bool dpi_resize_done = false;
        //bool set_min_size = false;


        //================================================================================================ke9ns MOD
        public void Console_Resize(object sender, System.EventArgs e)
        {

            //  if (FirstDown == true) return;



            if (setupForm != null && setupForm.checkBoxN1MM.Checked)
            {
                //   N1MM = false;
                N1MM_RESIZE = true;
            }

            if (setupForm != null && setupForm.chkVFOLargeWindow.Checked) //.228
            {
                grpVFOA.Width = 262 + 50;
                grpVFOB.Width = 262 + 50;
                grpVFOA.Location = new Point(110 - 50, 22);
                grpVFOB.Location = new Point(110 - 50, 22);

                txtVFOAFreq.Location = new Point(4, 11);
                txtVFOBFreq.Location = new Point(4, 11);

                txtVFOAMSD.Location = new Point(4, 11);
                txtVFOBMSD.Location = new Point(4, 11);

                panelVFOAHover.Width = 243 + 50;
                panelVFOBHover.Width = 243 + 50;

                txtVFOAFreq.Width = 253 + 50;
                txtVFOBFreq.Width = 253 + 50;

                txtVFOAMSD.Width = 253 + 50;
                txtVFOBMSD.Width = 253 + 50;

                txtVFOABand.Width = 220 + 50;
                txtVFOBBand.Width = 219 + 50;


            }
            else // normal size and location
            {
                grpVFOA.Width = 262;
                grpVFOB.Width = 262;
                grpVFOA.Location = new Point(110, 22);
                grpVFOB.Location = new Point(110, 22);

                txtVFOAFreq.Location = new Point(4, 11);
                txtVFOBFreq.Location = new Point(4, 11);

                txtVFOAMSD.Location = new Point(4, 11);
                txtVFOBMSD.Location = new Point(4, 11);

                panelVFOAHover.Width = 243;
                panelVFOBHover.Width = 243;



                txtVFOAFreq.Width = 253;
                txtVFOBFreq.Width = 253;

                txtVFOAMSD.Width = 253;
                txtVFOBMSD.Width = 253;

                txtVFOABand.Width = 220;
                txtVFOBBand.Width = 219;

            }

            if (this.WindowState == FormWindowState.Minimized)
            {
                N1MM_MINIMIZE = true;
                CHECKMIN = true;

                if (N1MM_ON == true) // ke9ns add
                {
                    //  if (mox)
                    return;
                }
                else
                {
                    N1MM_MINIMIZE = false;
                    return;
                }


            } // window is minimized
            else
            {
                N1MM_MINIMIZE = false;
                CHECKMIN = false;
            }

            if (dpi == 0) dpi = (int)picDisplay.CreateGraphics().DpiX;

            if (dpi > 96 && !dpi_resize_done)
            {
                if (base_size.Width == 0) base_size = this.AutoScaleBaseSize;

                if (this.AutoScaleBaseSize != base_size) dpi_resize_done = true;
                else return;
            }

            //   this.AutoScaleMode = AutoScaleMode.;  // ke9ns test


            /*if(!done_console_basis)
			{
				GrabConsoleSizeBasis();
				done_console_basis = true;
				/*if(dpi > 96)
				{
					ArrayList a = DB.GetVars("State");
					foreach(string s in a)
					{
						string[] vals = s.Split('/');
						string name = vals[0];
						string val = vals[1];
						
						switch(name)
						{
							case "console_width":
								this.Width = int.Parse(val);
								break;
							case "console_height":
								this.Height = int.Parse(val);
								break;
						}
					}						
				}
			}*/

            /*if(!set_min_size)
			{
				int W = console_basis_size.Width;
				int H;

				if(fwc_init && current_model == Model.FLEX5000 && FWCEEPROM.RX2OK)
					H = console_basis_size.Height - (panelRX2Filter.Height+8);
				else H = console_basis_size.Height;
				
				this.MinimumSize = new Size(W, H);
				set_min_size = true;
			}*/

            if (this.Width < console_basis_size.Width)
            {
                this.Width = console_basis_size.Width;
                return;
            }

            if (fwc_init && current_model == Model.FLEX5000 && FWCEEPROM.RX2OK) //ke9ns: for those with RX2 option
            {

                if (this.Height < console_basis_size.Height - (panelRX2Filter.Height + 8))
                    this.Height = console_basis_size.Height - (panelRX2Filter.Height + 8);
            }
            else if (this.Height < console_basis_size.Height)
            {
                this.Height = console_basis_size.Height;
                return;
            }

            int h_delta = this.Width - console_basis_size.Width;

            int v_delta = Math.Max(this.Height - console_basis_size.Height, 0);

            if (fwc_init && current_model == Model.FLEX5000 && FWCEEPROM.RX2OK) //ke9ns: for those with RX2 option
            {
                if (setupForm != null)
                {
                    if (setupForm.chkBoxTitle.Checked == true)
                    {
                        v_delta = Math.Max(this.Height - console_basis_size.Height + 25, 0); //ke9ns add: .160 when title bar is OFF, more room to move things down

                    }
                }
            }

            ResizeConsole(h_delta, v_delta);

            Display.Power = 1;
            //  Debug.WriteLine("RESIZE1");

            Display.Gradient(Display.SpectrumGridMax, Display.SpectrumGridMin); // ke9ns add: set new Gradient color scheme

            if (N1MM_RESIZE == true)
            {
                //    N1MM = true;
                N1MM_RESIZE = false;
            }

        } // control resize



        private int rx2_fixed_gain = 20;
        private int rx2_max_gain = 90;
        private void comboRX2AGC_SelectedIndexChanged(object sender, System.EventArgs e)
        {
            if (!fwc_init || current_model != Model.FLEX5000 || comboRX2AGC.SelectedIndex < 0) return;

            dsp.GetDSPRX(1, 0).RXAGCMode = (AGCMode)comboRX2AGC.SelectedIndex;

            switch ((AGCMode)comboRX2AGC.SelectedIndex)
            {
                case AGCMode.LONG:
                    toolTip1.SetToolTip(comboRX2AGC, "Automatic Gain Control Mode Setting:\n" +
                        "Long (Attack 2ms, Hang 750ms, Decay 200ms)");
                    //comboRX2AGC.BackColor = SystemColors.Window;
                    break;
                case AGCMode.SLOW:
                    toolTip1.SetToolTip(comboRX2AGC, "Automatic Gain Control Mode Setting:\n" +
                        "Slow (Attack 2ms, Hang 500ms, Decay 500ms)");
                    //comboRX2AGC.BackColor = SystemColors.Window;
                    break;
                case AGCMode.MED:
                    toolTip1.SetToolTip(comboRX2AGC, "Automatic Gain Control Mode Setting:\n" +
                        "Medium (Attack 2ms, Hang 250ms, Decay 250ms)");
                    //comboRX2AGC.BackColor = SystemColors.Window;
                    break;
                case AGCMode.FAST:
                    toolTip1.SetToolTip(comboRX2AGC, "Automatic Gain Control Mode Setting:\n" +
                        "Fast (Attack 2ms, Hang 100ms, Decay 100ms)");
                    //comboRX2AGC.BackColor = SystemColors.Window;
                    break;
                case AGCMode.CUSTOM:
                //  setupForm.CustomRXAGCEnabled = true; // ke9ns add (copy from AGC of RX1)
                //  toolTip1.SetToolTip(comboAGC, "Automatic Gain Control Mode Setting:\n"+
                //	"Custom - Set specifics in Setup Form -> DSP -> AGC/ALC");
                //comboRX2AGC.BackColor = SystemColors.Window;
                //	break;
                case AGCMode.FIXD:
                    setupForm.CustomRXAGCEnabled = false;
                    toolTip1.SetToolTip(comboAGC, "Automatic Gain Control Mode Setting:\n" +
                        "Fixed - Set gain with AGC-T control above");
                    //comboRX2AGC.BackColor = Color.Orange;
                    break;
            }

            // set RF control to Max or Fixed gain depending on mode
            switch ((AGCMode)comboRX2AGC.SelectedIndex)
            {
                case AGCMode.FIXD:
                    ptbRX2RF.Value = rx2_fixed_gain;
                    ptbRX2RF_Scroll(this, EventArgs.Empty);
                    break;

                default:
                    ptbRX2RF.Value = rx2_max_gain;
                    ptbRX2RF_Scroll(this, EventArgs.Empty);
                    break;
            }
        }

        private void chkVFOSync_CheckedChanged(object sender, System.EventArgs e)
        {
            if (chkVFOSync.Checked)
            {
                chkVFOSync.BackColor = button_selected_color;

                // ke9ns add

                if (RX2Enabled == true)
                {
                    if (chkVFOSplit.Checked == true)
                    {
                        saved_vfoa_sub_freq = VFOAFreq; // saved_vfoa_freq;
                        Debug.WriteLine("VFOSYNC");
                        UpdateVFOASub();
                    }
                }
                //
                txtVFOAFreq_LostFocus(this, EventArgs.Empty);


            }
            else
            {
                chkVFOSync.BackColor = SystemColors.Control;
            }

        } //  chkVFOSync_CheckedChanged

        private bool mute_rx1_on_vfob_tx = true;
        public bool MuteRX1OnVFOBTX
        {
            get { return mute_rx1_on_vfob_tx; }
            set
            {
                mute_rx1_on_vfob_tx = value;
                if (fwc_init && current_model == Model.FLEX5000 && FWCEEPROM.RX2OK && chkVFOBTX.Checked)
                {
                    FWC.SetFullDuplex(!value);
                    Audio.FullDuplex = !value;
                    if (!value)
                        FWC.SetQSE(false);
                }
            }
        }

        private bool mute_rx2_on_vfoa_tx = true;
        public bool MuteRX2OnVFOATX
        {
            get { return mute_rx2_on_vfoa_tx; }
            set
            {
                mute_rx2_on_vfoa_tx = value;
                if (chkVFOATX.Checked)
                    Audio.RX2AutoMuteTX = value;
            }
        }

        public int DSPBufDigTX
        {
            get { return dsp_buf_dig_tx; }
            set
            {
                dsp_buf_dig_tx = value;
                UpdateDSPBufTX();
            }
        }

        private void chkVFOATX_CheckedChanged(object sender, System.EventArgs e)
        {
            if (chkVFOATX.Focused && !chkVFOATX.Checked) chkVFOATX.Checked = true;

            if (chkVFOATX.Checked)
            {

                lblAntTX.ForeColor = Color.Red;
                lblAntTX2.ForeColor = Color.White; // .213

                if (chkVFOBTX.Checked) chkVFOBTX.Checked = false;

                swap_vfo_ab_tx = false;

                if (KWAutoInformation) BroadcastVFOChange("0");
                if (KWAutoInformation2) BroadcastVFOChange2("0"); // ke9ns add .214
                if (KWAutoInformation3) BroadcastVFOChange3("0");
                if (KWAutoInformation4) BroadcastVFOChange4("0");
                if (KWAutoInformation5) BroadcastVFOChange5("0");
                if (KWAutoInformation6) BroadcastVFOChange6("0");

                if (KWAutoInformation7) BroadcastVFOChange7("0"); // TCP/IP CAT

                chkVFOATX.BackColor = Color.Red;//button_selected_color;

                if (fwc_init && current_model == Model.FLEX5000 && FWCEEPROM.RX2OK && chkRX2.Checked) // ke9ns add .206
                {

                    if (fwcAntForm != null && fwcAntForm.chkTX2Active.Checked) // SO2R with VFOA TX so set AMP TX PTT line for VFOA RX1 and dont use RX2 PTT lines
                    {
                        if (FWCAmpRX2TX1 == false && FWCAmpTX1) FWC.SetAmpTX1(true);
                        else FWC.SetAmpTX1(false);

                        if (FWCAmpRX2TX2 == false && FWCAmpTX2) FWC.SetAmpTX2(true);
                        else FWC.SetAmpTX2(false);

                        if (FWCAmpRX2TX3 == false && FWCAmpTX3) FWC.SetAmpTX3(true);
                        else FWC.SetAmpTX3(false);

                        TXBand = rx1_band;      // ke9ns add .205


                        Debug.WriteLine("RX1 VFOATX and RX2 on SO2R " + FWCAmpRX2TX3 + " , " + FWCAmpTX3);
                    }
                    else // ke9ns: VFOA TX and no SO2R (normal op)
                    {
                        if (FWCAmpTX1) FWC.SetAmpTX1(true);
                        else FWC.SetAmpTX1(false);

                        if (FWCAmpTX2) FWC.SetAmpTX2(true);
                        else FWC.SetAmpTX2(false);

                        if (FWCAmpTX3) FWC.SetAmpTX3(true);
                        else FWC.SetAmpTX3(false);

                        Debug.WriteLine("RX1 VFOATX and RX2 ON , NO SO2R, Normal ");
                        TXBand = rx1_band;      // ke9ns add .205
                    }

                    SetTXAnt2(StringToBand(fwcAntForm.comboBand2.Text), fwcAntForm.StringToAnt(fwcAntForm.comboTXAnt2.Text)); //.212

                }
                else if (fwc_init && current_model == Model.FLEX5000) // SO2R OFF or no RX2 (below)
                {
                    if (FWCAmpTX1) FWC.SetAmpTX1(true);
                    else FWC.SetAmpTX1(false);

                    if (FWCAmpTX2) FWC.SetAmpTX2(true);
                    else FWC.SetAmpTX2(false);

                    if (FWCAmpTX3) FWC.SetAmpTX3(true);
                    else FWC.SetAmpTX3(false);
                    TXBand = rx1_band;      // ke9ns add .205

                    Debug.WriteLine("RX1 VFOATX and RX2 oFF Normal ");

                } // no RX2 available or no SO2R


                txtVFOBFreq_LostFocus(this, EventArgs.Empty); //.211
                txtVFOAFreq_LostFocus(this, EventArgs.Empty);

                if (chkVAC2.Checked && chkRX2.Checked)  // W4TME 
                {
                    ptbVACRXGain.Value = vac_rx_gain;
                    ptbVACRXGain_Scroll(this, EventArgs.Empty);

                    ptbVACTXGain.Value = vac_tx_gain;
                    ptbVACTXGain_Scroll(this, EventArgs.Empty);

                    comboVACSampleRate.Text = vac_sample_rate;

                    chkVACStereo.Checked = vac_stereo;
                }
            }
            else
            {
                lblAntTX2.ForeColor = Color.Red;
                lblAntTX.ForeColor = Color.White; // .213

                chkVFOATX.BackColor = SystemColors.Control;
            }
            btnHidden.Focus();
        }

        //ke9ns:  Sets or reads the VFO A TX/VFO B TX Buttons
        //  0 set VFO A to TX, 1 sets VFO B to TX.
        //  ZZSW transmits status if Kenwood AI enabled.
        private void BroadcastVFOChange(string ndx)
        {
            if (siolisten.SIO == null) return;
            string cmd = "ZZSW" + ndx + ";";
            try
            {
                siolisten.SIO.put(cmd);

            }
            catch { }
        } //BroadcastVFOChange

        private void BroadcastVFOChange2(string ndx) // ke9ns add .214
        {
            if (siolisten2.SIO2== null) return;

            string cmd = "ZZSW" + ndx + ";";
            try
            {
                siolisten2.SIO2.put(cmd); // ke9ns add: .180 port2
            }
            catch { }

        } //BroadcastVFOChange2

        private void BroadcastVFOChange3(string ndx) // ke9ns add .214
        {

            if (siolisten3.SIO3 == null) return;
            string cmd = "ZZSW" + ndx + ";";
            try
            {
                siolisten3.SIO3.put(cmd); // ke9ns add: .180 port2
            }
            catch { }

        } //BroadcastVFOChange3

        private void BroadcastVFOChange4(string ndx) // ke9ns add .214
        {
            if (siolisten4.SIO4 == null) return;
            string cmd = "ZZSW" + ndx + ";";
            try
            {
                siolisten4.SIO4.put(cmd); // ke9ns add: .180 port2
            }
            catch { }

        } //BroadcastVFOChange4


        private void BroadcastVFOChange5(string ndx) // ke9ns add .214
        {
            if (siolisten5.SIO5 == null) return;
            string cmd = "ZZSW" + ndx + ";";
            try
            {
                siolisten5.SIO5.put(cmd); // ke9ns add: .180 port2
            }
            catch { }

        } //BroadcastVFOChange5


        private void BroadcastVFOChange6(string ndx) // ke9ns add .214
        {
            if (siolisten6.SIO6 == null) return;

            string cmd = "ZZSW" + ndx + ";";
            try
            {
                siolisten6.SIO6.put(cmd); // ke9ns add: .180 port2
            }
            catch { }

        } //BroadcastVFOChange6



        private void BroadcastVFOChange7(string ndx) // ke9ns add .214
        {
           

            string cmd = "ZZSW" + ndx + ";";
            try
            {
                KWAI7 = true; //ke9ns: CATURL() should detect this
                CATURLFREQ = cmd;
            }
            catch { }

        } //BroadcastVFOChange7


        private void chkVFOBTX_CheckedChanged(object sender, System.EventArgs e)
        {
            if (chkVFOBTX.Focused && !chkVFOBTX.Checked) chkVFOBTX.Checked = true;

            if (chkVFOBTX.Checked)
            {
                lblAntTX2.ForeColor = Color.Red;
                lblAntTX.ForeColor = Color.White; // .213


                if (chkVFOATX.Checked) chkVFOATX.Checked = false;
                chkVFOBTX.BackColor = Color.Red;//button_selected_color;
                swap_vfo_ab_tx = true;
                if (KWAutoInformation) BroadcastVFOChange("1"); // broadcast on CAT
                if (KWAutoInformation2) BroadcastVFOChange2("1"); // broadcast on CAT .214
                if (KWAutoInformation3) BroadcastVFOChange3("1"); // broadcast on CAT
                if (KWAutoInformation4) BroadcastVFOChange4("1"); // broadcast on CAT
                if (KWAutoInformation5) BroadcastVFOChange5("1"); // broadcast on CAT
                if (KWAutoInformation6) BroadcastVFOChange6("1"); // broadcast on CAT

                if (KWAutoInformation7) BroadcastVFOChange7("1"); // broadcast on TCP/IP CAT



                txtVFOBFreq_LostFocus(this, EventArgs.Empty);

                if (fwc_init && current_model == Model.FLEX5000 && FWCEEPROM.RX2OK && chkRX2.Checked)
                {
                    if (fwcAntForm != null && fwcAntForm.chkTX2Active.Checked) // ke9ns: SO2R ON VFOB TX active so PTT AMP for RX2 transmit 2
                    {

                        if (FWCAmpRX2TX1 == true && FWCAmpTX1) FWC.SetAmpTX1(true);
                        else FWC.SetAmpTX1(false);

                        if (FWCAmpRX2TX2 == true && FWCAmpTX2) FWC.SetAmpTX2(true);
                        else FWC.SetAmpTX2(false);

                        if (FWCAmpRX2TX3 == true && FWCAmpTX3) FWC.SetAmpTX3(true);
                        else FWC.SetAmpTX3(false);


                        TXBand2 = rx2_band;      // ke9ns add .205

                        SetTXAnt2(StringToBand(fwcAntForm.comboBand2.Text), fwcAntForm.StringToAnt(fwcAntForm.comboTXAnt2.Text));

                        Debug.WriteLine("RX2 VFOBTX and SO2R " + FWCAmpRX2TX3 + " , " + FWCAmpTX3);
                    }
                    else // ke9ns: SO2R not active so normal op
                    {
                        if (FWCAmpTX1) FWC.SetAmpTX1(true);
                        else FWC.SetAmpTX1(false);

                        if (FWCAmpTX2) FWC.SetAmpTX2(true);
                        else FWC.SetAmpTX2(false);

                        if (FWCAmpTX3) FWC.SetAmpTX3(true);
                        else FWC.SetAmpTX3(false);

                        TXBand = rx1_band;      // ke9ns add .205

                        Debug.WriteLine("RX2 VFOBTX and SO2R OFF");

                    }


                    Audio.RX2AutoMuteTX = true;
                    FWC.SetFullDuplex(!mute_rx1_on_vfob_tx);
                    Audio.FullDuplex = !mute_rx1_on_vfob_tx;
                    if (!mute_rx1_on_vfob_tx && !mox) FWC.SetQSE(false);

                    Audio.TXDSPMode = rx2_dsp_mode;
                    dsp.GetDSPTX(0).CurrentDSPMode = rx2_dsp_mode;
                    if (fwc_init && (current_model == Model.FLEX5000 || current_model == Model.FLEX3000)) FWC.SetTXDSPMode(rx2_dsp_mode);
                    SetRX2Mode(rx2_dsp_mode);
                    Display.TXOnVFOB = true;
                    if (chkVFOSplit.Checked) chkVFOSplit.Checked = false;

                    if (chkVAC2.Checked && chkRX2.Checked)
                    {
                        ptbVACRXGain.Value = vac2_rx_gain;
                        ptbVACRXGain_Scroll(this, EventArgs.Empty);

                        ptbVACTXGain.Value = vac2_tx_gain;
                        ptbVACTXGain_Scroll(this, EventArgs.Empty);

                        comboVACSampleRate.Text = vac2_sample_rate;

                        chkVACStereo.Checked = vac2_stereo;
                    }
                }
                else if (fwc_init && current_model == Model.FLEX5000)
                {

                    if (FWCAmpTX1) FWC.SetAmpTX1(true);
                    else FWC.SetAmpTX1(false);

                    if (FWCAmpTX2) FWC.SetAmpTX2(true);
                    else FWC.SetAmpTX2(false);

                    if (FWCAmpTX3) FWC.SetAmpTX3(true);
                    else FWC.SetAmpTX3(false);

                    TXBand = rx1_band;      // ke9ns add .205

                    Debug.WriteLine("RX2 VFOBTX and RX2 OFF");
                }

                if (chkRX2.Checked == false && chkVFOBTX.Checked)    //in case of VU/XVTR-split error
                    chkVFOSplit.Checked = true;
            }
            else // button is unchecked
            {
                lblAntTX.ForeColor = Color.Red;
                lblAntTX2.ForeColor = Color.White; // .213

                chkVFOBTX.BackColor = SystemColors.Control;
                Display.TXOnVFOB = false;
                if (fwc_init && current_model == Model.FLEX5000 && FWCEEPROM.RX2OK && chkRX2.Checked)
                {

                    Audio.RX2AutoMuteTX = mute_rx2_on_vfoa_tx;
                    FWC.SetFullDuplex(false);
                    Audio.FullDuplex = false;

                    if (chkVAC2.Checked && chkRX2.Checked)
                    {
                        ptbVACRXGain.Value = vac_rx_gain;
                        ptbVACRXGain_Scroll(this, EventArgs.Empty);

                        ptbVACTXGain.Value = vac_tx_gain;
                        ptbVACTXGain_Scroll(this, EventArgs.Empty);

                        comboVACSampleRate.Text = vac_sample_rate;

                        chkVACStereo.Checked = vac_stereo;
                    }
                }

                if (chkRX2.Checked == false)
                    chkVFOSplit.Checked = false;
                Audio.TXDSPMode = rx1_dsp_mode;
                dsp.GetDSPTX(0).CurrentDSPMode = rx1_dsp_mode;
                if (fwc_init && (current_model == Model.FLEX5000 || current_model == Model.FLEX3000))
                    FWC.SetTXDSPMode(rx2_dsp_mode);
                SetRX1Mode(rx1_dsp_mode);
            }
            Audio.VFOBTX = chkVFOBTX.Checked;
            btnHidden.Focus();
        }

        private void toolStripMenuItemRX1FilterConfigure_Click(object sender, EventArgs e)
        {
            if (rx1_dsp_mode == DSPMode.DRM || rx1_dsp_mode == DSPMode.SPEC || rx1_dsp_mode == DSPMode.FM) return;

            if (filterRX1Form == null || filterRX1Form.IsDisposed)
                filterRX1Form = new FilterForm(this, rx1_filters, false);

            filterRX1Form.DSPMode = rx1_dsp_mode;
            filterRX1Form.CurrentFilter = rx1_filter;
            filterRX1Form.Show();
            filterRX1Form.Focus();
            filterRX1Form.WindowState = FormWindowState.Normal; // ke9ns add
        }

        private void toolStripMenuItemRX1FilterReset_Click(object sender, EventArgs e)
        {
            DialogResult dr = MessageBox.Show(
                "Are you sure you want to reset all RX1 custom filter settings to the default?",
                "Reset Filters?",
                MessageBoxButtons.YesNo,
                MessageBoxIcon.Question);

            if (dr == DialogResult.No) return;

            InitFilterPresets(rx1_filters);

            radFilter1.Text = rx1_filters[(int)rx1_dsp_mode].GetName(Filter.F1);
            radFilter2.Text = rx1_filters[(int)rx1_dsp_mode].GetName(Filter.F2);
            radFilter3.Text = rx1_filters[(int)rx1_dsp_mode].GetName(Filter.F3);
            radFilter4.Text = rx1_filters[(int)rx1_dsp_mode].GetName(Filter.F4);
            radFilter5.Text = rx1_filters[(int)rx1_dsp_mode].GetName(Filter.F5);
            radFilter6.Text = rx1_filters[(int)rx1_dsp_mode].GetName(Filter.F6);
            radFilter7.Text = rx1_filters[(int)rx1_dsp_mode].GetName(Filter.F7);
            radFilter8.Text = rx1_filters[(int)rx1_dsp_mode].GetName(Filter.F8);
            radFilter9.Text = rx1_filters[(int)rx1_dsp_mode].GetName(Filter.F9);
            radFilter10.Text = rx1_filters[(int)rx1_dsp_mode].GetName(Filter.F10);
            radFilterVar1.Text = rx1_filters[(int)rx1_dsp_mode].GetName(Filter.VAR1);
            radFilterVar2.Text = rx1_filters[(int)rx1_dsp_mode].GetName(Filter.VAR2);
            RX1Filter = rx1_filter;

            if (filterRX1Form != null && !filterRX1Form.IsDisposed)
            {
                filterRX1Form.DSPMode = rx1_dsp_mode;
            }
        }

        private void toolStripMenuItemRX2FilterConfigure_Click(object sender, EventArgs e)
        {
            if (rx2_dsp_mode == DSPMode.DRM || rx2_dsp_mode == DSPMode.SPEC) return;

            if (filterRX2Form == null || filterRX2Form.IsDisposed)
                filterRX2Form = new FilterForm(this, rx2_filters, true);

            filterRX2Form.DSPMode = rx2_dsp_mode;
            filterRX2Form.CurrentFilter = rx2_filter;
            filterRX2Form.Show();
            filterRX2Form.Focus();
            filterRX2Form.WindowState = FormWindowState.Normal; // ke9ns add
        }

#if (!NO_TNF)
        private Notch Context_Notch;
#endif
        private void toolStripNotchDelete_Click(Object sender, EventArgs e)
        {
#if (!NO_TNF)
            NotchList.RemoveNotch(Context_Notch);
            contextMenuStripNotch.Close();
            UpdateRX1Notches();
            UpdateRX1SubNotches();
            UpdateRX2Notches();
#endif
        }

        private void toolStripNotchRemember_Click(object sender, EventArgs e)
        {
#if (!NO_TNF)
            Context_Notch.Permanent = !toolStripNotchRemember.Checked;
            toolStripNotchRemember.Checked = !toolStripNotchRemember.Checked;
            contextMenuStripNotch.Close();
#endif
        }

        private void toolStripNotchNormal_Click(object sender, EventArgs e)
        {
#if (!NO_TNF)


            Context_Notch.Depth = 1;
            toolStripNotchNormal.Checked = true;
            toolStripNotchDeep.Checked = false;
            toolStripNotchVeryDeep.Checked = false;
            contextMenuStripNotch.Close();
            UpdateRX1Notches();
            UpdateRX1SubNotches();
            UpdateRX2Notches();
#endif
        }

        private void toolStripNotchDeep_Click(object sender, EventArgs e)
        {
#if (!NO_TNF)
            Context_Notch.Depth = 2;
            toolStripNotchNormal.Checked = false;
            toolStripNotchDeep.Checked = true;
            toolStripNotchVeryDeep.Checked = false;
            contextMenuStripNotch.Close();
            UpdateRX1Notches();
            UpdateRX1SubNotches();
            UpdateRX2Notches();
#endif
        }

        private void toolStripNotchVeryDeep_Click(object sender, EventArgs e)
        {
#if (!NO_TNF)
            Context_Notch.Depth = 3;
            toolStripNotchNormal.Checked = false;
            toolStripNotchDeep.Checked = false;
            toolStripNotchVeryDeep.Checked = true;
            contextMenuStripNotch.Close();
            UpdateRX1Notches();
            UpdateRX1SubNotches();
            UpdateRX2Notches();
#endif
        }

        private void toolStripMenuItemRX2FilterReset_Click(object sender, EventArgs e)
        {
            DialogResult dr = MessageBox.Show(
                "Are you sure you want to reset all RX2 custom filter settings to the default?",
                "Reset Filters?",
                MessageBoxButtons.YesNo,
                MessageBoxIcon.Question);

            if (dr == DialogResult.No) return;

            InitFilterPresets(rx2_filters);

            radRX2Filter1.Text = rx2_filters[(int)rx2_dsp_mode].GetName(Filter.F1);
            radRX2Filter2.Text = rx2_filters[(int)rx2_dsp_mode].GetName(Filter.F2);
            radRX2Filter3.Text = rx2_filters[(int)rx2_dsp_mode].GetName(Filter.F3);
            radRX2Filter4.Text = rx2_filters[(int)rx2_dsp_mode].GetName(Filter.F4);
            radRX2Filter5.Text = rx2_filters[(int)rx2_dsp_mode].GetName(Filter.F5);
            radRX2Filter6.Text = rx2_filters[(int)rx2_dsp_mode].GetName(Filter.F6);
            radRX2Filter7.Text = rx2_filters[(int)rx2_dsp_mode].GetName(Filter.F7);
            radRX2FilterVar1.Text = rx2_filters[(int)rx2_dsp_mode].GetName(Filter.VAR1);
            radRX2FilterVar2.Text = rx2_filters[(int)rx2_dsp_mode].GetName(Filter.VAR2);
            RX2Filter = rx2_filter;

            if (filterRX2Form != null && !filterRX2Form.IsDisposed)
            {
                filterRX2Form.DSPMode = rx2_dsp_mode;
            }
        }

        private static bool TDxButtonState = false;
        private static bool TDxCurrentVFO = false; //VFOA

        private void timer_navigate_Tick(object sender, System.EventArgs e)
        {

            if (TDxSensor == null) return;

            TDxInput.Vector3D t = TDxSensor.Translation;
            TDxInput.AngleAxis r = TDxSensor.Rotation;
            TDxDevice.Keyboard.IsKeyDown(1);
            double del;
            int val;

            if (TDxDevice.Keyboard.IsKeyDown(1)) //Button 1 assignment
            {
                TDxButtonState = true;
            }
            else if (TDxButtonState)
            {
                TDxButtonState = false;
                //click
                TDxCurrentVFO = !TDxCurrentVFO;
            }
            /* ke9ns
                        New control axes have been added to the SpaceNavigator support:

                Twist controls VFOA(or if in split, VFOB)

                Push forward/ backward zooms the panadapter

                 Push left / right pans the panadapter

                   Push up / down controls the filter width

            */
            if (spacenav_controlvfos) // setupForm VFO Control
            {
                del = Math.Exp(r.Angle / 10.0) - 1.0;
                if (del >= 0.1)
                {
                    del *= -Math.Sign(r.Y) / 1e6;
#if false
					if(current_click_tune_mode == ClickTuneMode.VFOB && scroll_vfob_on_split)
						VFOBFreq += del;
					else 
#endif
                    if (TDxCurrentVFO)
                        VFOBFreq += del;
                    else
                        VFOAFreq += del;
                }
            }
            if (spacenav_flypanadapter) // setupForm Panadapter Flight
            {
                if (Math.Abs(t.Z) > 1.0)
                {
                    val = ptbDisplayZoom.Value;
                    val += Convert.ToInt32(t.Z);
                    val = Math.Min(ptbDisplayZoom.Maximum, val);
                    val = Math.Max(ptbDisplayZoom.Minimum, val);
                    ptbDisplayZoom.Value = val;
                    ptbDisplayZoom_Scroll(this, EventArgs.Empty);
                    //btnDisplayPanCenter_Click(this, EventArgs.Empty);
                }

                if (Math.Abs(t.X) > 1.0)
                {
                    val = ptbDisplayPan.Value;
                    val += Convert.ToInt32(t.X);
                    val = Math.Min(ptbDisplayPan.Maximum, val);
                    val = Math.Max(ptbDisplayPan.Minimum, val);
                    ptbDisplayPan.Value = val;
                    CalcDisplayFreq();
                    //if(ptbDisplayPan.Focused) btnHidden.Focus();
                }

                if (Math.Abs(t.Y) > 1.0)
                {
                    val = ptbFilterWidth.Value;
                    val += Convert.ToInt32(t.Y);
                    val = Math.Min(ptbFilterWidth.Maximum, val);
                    val = Math.Max(ptbFilterWidth.Minimum, val);
                    ptbFilterWidth.Value = val;
                    ptbFilterWidth_Scroll(this.ptbFilterWidth, EventArgs.Empty);
                }
            }
        } // timer_navigate_tick

        public void PressKeyboardButton(Keys keyCode)
        {
            const int KEYEVENTF_EXTENDEDKEY = 0x1;
            const int KEYEVENTF_KEYUP = 0x2;

            Win32.keybd_event((byte)keyCode, 0x45, KEYEVENTF_EXTENDEDKEY, 0);
            Win32.keybd_event((byte)keyCode, 0x45, KEYEVENTF_EXTENDEDKEY | KEYEVENTF_KEYUP, 0);
        }

        private HiPerfTimer t9 = new HiPerfTimer();

        /*private void buttonTS1_Click(object sender, EventArgs e)
        {
            ptbRF.Value = 0;
            ptbRF_Scroll(this, EventArgs.Empty);
            Application.DoEvents();
            Thread.Sleep(1000);

            ptbRF.Value = 120;
            ptbRF_Scroll(this, EventArgs.Empty);
        }*/

        public string getVersion()
        {
            Assembly assembly = Assembly.GetExecutingAssembly();
            FileVersionInfo fvi = FileVersionInfo.GetVersionInfo(assembly.Location);
            //  string version = fvi.FileVersion.Substring(0, fvi.FileVersion.LastIndexOf(".")); // ke9ns mod
            string version = fvi.FileVersion.ToString();

            return version;
        }

        private void timer2_Tick(object sender, EventArgs e) // 200msec just calls this 1 time at start
        {
            timer2.Enabled = false;
            switch (dsp.GetDSPTX(0).CurrentDSPMode)
            {
                case DSPMode.CWL:
                case DSPMode.CWU:
                    Audio.MuteOutput = false;
                    if (mox)
                        USBHID.WriteI2C2Value(0x30, 0x25, 0xC0);
                    break;
                default:
                    USBHID.WriteI2C2Value(0x30, 0x25, 0xC0);
                    break;
            }
        }

        private void SetWBIRRX1Mu()
        {
            if (wbir_rx1_holdoff_active || calibrating) return;

            switch (current_model)
            {
                case Model.FLEX5000:
                case Model.FLEX3000:
                case Model.SDR1000:
                    switch (rx1_preamp_mode)
                    {
                        case PreampMode.OFF:
                        case PreampMode.LOW:
                        case PreampMode.MED:
                            dsp.GetDSPRX(0, 0).RXCorrectIQMu = 0.005;
                            dsp.GetDSPRX(0, 1).RXCorrectIQMu = 0.005;
                            break;
                        case PreampMode.HIGH:
                            dsp.GetDSPRX(0, 0).RXCorrectIQMu = 0.0005;
                            dsp.GetDSPRX(0, 1).RXCorrectIQMu = 0.0005;
                            break;
                    }
                    break;
                case Model.FLEX1500:
                    switch ((FLEX1500PreampMode)rx1_preamp_mode)
                    {
                        case FLEX1500PreampMode.MINUS_10:
                        case FLEX1500PreampMode.ZERO:
                        case FLEX1500PreampMode.PLUS_10:
                            dsp.GetDSPRX(0, 0).RXCorrectIQMu = 0.005;
                            dsp.GetDSPRX(0, 1).RXCorrectIQMu = 0.005;
                            break;
                        case FLEX1500PreampMode.PLUS_20:
                        case FLEX1500PreampMode.PLUS_30:
                            dsp.GetDSPRX(0, 0).RXCorrectIQMu = 0.0005;
                            dsp.GetDSPRX(0, 1).RXCorrectIQMu = 0.0005;
                            break;
                    }
                    break;
                default:
                    dsp.GetDSPRX(0, 0).RXCorrectIQMu = 0.005;
                    dsp.GetDSPRX(0, 1).RXCorrectIQMu = 0.005;
                    break;
            }
        }

        private void SetWBIRRX2Mu()
        {
            if (current_model != Model.FLEX5000 || !FWCEEPROM.RX2OK) return;
            if (wbir_rx2_holdoff_active || calibrating) return;

            switch (rx2_preamp_mode)
            {
                case PreampMode.OFF:
                case PreampMode.LOW:
                case PreampMode.MED:
                    dsp.GetDSPRX(0, 0).RXCorrectIQMu = 0.005;
                    break;
                case PreampMode.HIGH:
                    dsp.GetDSPRX(0, 0).RXCorrectIQMu = 0.0005;
                    break;
            }
        }

        private HiPerfTimer wbir_rx1_holdoff_timer = new HiPerfTimer();
        private bool wbir_rx1_holdoff_active = false;
        private void WBIRRX1Holdoff_Loop()
        {
            wbir_rx1_holdoff_active = true;

            while (true)
            {
                wbir_rx1_holdoff_timer.Stop();
                if (wbir_rx1_holdoff_timer.DurationMsec > 1000)
                    break;
                Thread.Sleep(100);
            }

            wbir_rx1_holdoff_active = false;
            SetWBIRRX1Mu();
        }

        private void WBIRRX1Holdoff() // ke9ns: ?? WBIR  RX1 holdOff
        {
            wbir_rx1_holdoff_timer.Start();
            if (!wbir_rx1_holdoff_active)
            {
                dsp.GetDSPRX(0, 0).RXCorrectIQMu = 0.0;
                dsp.GetDSPRX(0, 1).RXCorrectIQMu = 0.0;

                Thread t = new Thread(new ThreadStart(WBIRRX1Holdoff_Loop)); // above
                t.Name = "WBIRRX1Holdoff_Loop Thread";
                t.IsBackground = true;
                t.Priority = ThreadPriority.BelowNormal;
                t.Start();
            }
        }

        private HiPerfTimer wbir_rx2_holdoff_timer = new HiPerfTimer();
        private bool wbir_rx2_holdoff_active = false;
        private void WBIRRX2Holdoff_Loop()
        {
            if (calibrating) return;

            wbir_rx2_holdoff_active = true;

            while (true)
            {
                wbir_rx2_holdoff_timer.Stop();
                if (wbir_rx2_holdoff_timer.DurationMsec > 1000)
                    break;
                Thread.Sleep(100);
            }

            wbir_rx2_holdoff_active = false;
            SetWBIRRX2Mu();
        }

        private void WBIRRX2Holdoff()
        {
            if (calibrating) return;

            wbir_rx2_holdoff_timer.Start();
            if (!wbir_rx2_holdoff_active)
            {
                dsp.GetDSPRX(1, 0).RXCorrectIQMu = 0.0;

                Thread t = new Thread(new ThreadStart(WBIRRX2Holdoff_Loop));
                t.Name = "WBIRRX2Holdoff_Loop Thread";
                t.IsBackground = true;
                t.Priority = ThreadPriority.BelowNormal;
                t.Start();
            }
        }
        private void CallCal1500TXImageComb()
        {
            DialogResult dr = MessageBox.Show(new Form { TopMost = true }, "The RTG Transmit Image Calibration feature has been activated.  Run the calibration now?",
                "TX Image Cal?",
                MessageBoxButtons.YesNo,
                MessageBoxIcon.Question);

            if (dr == DialogResult.No) return;

            p = new Progress("Calibrate TX Image Comb");
            //p.Show();

            Thread t = new Thread(new ThreadStart(Cal1500TXImageComb));
            t.Name = "Cal 1500 TX Image Comb Thread";
            t.IsBackground = true;
            t.Priority = ThreadPriority.Normal;
            t.Start();
        }

        private void Cal1500TXImageComb()
        {
            float[] freq_list = { 1.868f, 3.768f, 5.341f, 7.176f, 10.158f, 14.188f, 18.120f, 21.333f, 24.936f, 28.410f, 50.102f };
            for (int i = 0; i < freq_list.Length; i++)
            {
                Invoke(new MethodInvoker(p.Show));
                Thread.Sleep(50);
                CalibrateTXImage(freq_list[i], p, true);

                if (p.Text == "")
                    break;

                Thread.Sleep(1000);
            }

            if (p.Text != "")
            {
                MessageBox.Show(new Form { TopMost = true }, "Transmit Image Calibration complete",
                    "TX Image Cal Complete",
                    MessageBoxButtons.OK,
                    MessageBoxIcon.Information);
            }
        }

        private void chkTNF_CheckedChanged(object sender, EventArgs e)
        {
            UpdateRX1Notches();
            UpdateRX1SubNotches();
            UpdateRX2Notches();
            Display.TNFActive = chkTNF.Checked;
        }

#if (!NO_TNF)
        private int default_notch_width = 100;
        //MAX_NOTCHES_IN_PASSBAND is declared in consoole.cs, dsp.cs, and sdr.c, [sdrexport.h]
        private const int MAX_NOTCHES_IN_PASSBAND = 18;     //used to be 9
        private const int MAX_NOTCHES_INITIALLY_IN_PASSBAND = 6;   //used to be 3
#endif
        private void btnTNFAdd_Click(object sender, EventArgs e)
        {
#if (!NO_TNF)
            // calculate the mid-point for the filter
            int low = dsp.GetDSPRX(0, 0).RXFilterLow;
            int high = dsp.GetDSPRX(0, 0).RXFilterHigh;
            int midpoint = (low + high) / 2;

            // offset for double sideband modes so the filter is visible
            switch (rx1_dsp_mode)
            {
                case DSPMode.DSB:
                case DSPMode.AM:
                case DSPMode.SAM:
                case DSPMode.FM:
                    midpoint += (high - low) / 4;
                    break;
            }

            if (midpoint < -9999 || midpoint > 9999)
                throw new Exception("TNF: The filter limits [" + low + "," + high + "] do not make sense");

            double vfo = VFOAFreq;
            if (chkRIT.Checked) vfo += (double)udRIT.Value * 1e-6; // check for RIT

            double rf_freq = vfo + midpoint * 1e-6;

            // if there's already another notch within 100Hz, then quit now
            if (NotchList.NotchNearFreq(rf_freq, 100))
                return;

            // if there's already 3+ filters within the RF window, quit now
            if (NotchList.NotchesInBW(VFOAFreq, low, high).Count >= MAX_NOTCHES_INITIALLY_IN_PASSBAND)
                return;

            if (setupForm.udTNFWidth.Value < 100) setupForm.udTNFWidth.Value = default_notch_width; // ke9ns add
            else default_notch_width = (int)setupForm.udTNFWidth.Value;

            NotchList.List.Add(new Notch(rf_freq, default_notch_width)); // ke9ns mod

            UpdateRX1Notches();
            UpdateRX1SubNotches();
            UpdateRX2Notches();
#endif
        } // btnTNFAdd_Click

        private void addNotch(int thread, int subrx, uint count, double freq, double bw)
        {
#if (!NO_TNF)
            //Debug.WriteLine("addNotch( " + thread + "," + subrx + "," + count + "," + freq + "," + bw);
            if (count < MAX_NOTCHES_IN_PASSBAND)
            {
                dsp.GetDSPRX(thread, subrx).SetNotchBW(count, bw);
                dsp.GetDSPRX(thread, subrx).SetNotchFreq(count, freq);
                dsp.GetDSPRX(thread, subrx).SetNotchOn(count, true);
            }
#endif
        }

        private void UpdateRX1Notches()
        {
#if (!NO_TNF)
            if (!chkTNF.Checked)
            {
                for (uint i = 0; i < MAX_NOTCHES_IN_PASSBAND; i++)
                    dsp.GetDSPRX(0, 0).SetNotchOn(i, false);
                return;
            }

            double vfo = VFOAFreq;
            if (chkRIT.Checked) vfo += (double)udRIT.Value * 1e-6;

            switch (rx1_dsp_mode)
            {
                case (DSPMode.CWL):
                    vfo += cw_pitch * 1e-6;
                    break;
                case (DSPMode.CWU):
                    vfo -= cw_pitch * 1e-6;
                    break;
            }

            int low = dsp.GetDSPRX(0, 0).RXFilterLow - 200;
            int high = dsp.GetDSPRX(0, 0).RXFilterHigh + 200;


            List<Notch> l = NotchList.NotchesInBW(vfo, low, high);
            if (l.Count == 0)
            {
                for (uint i = 0; i < MAX_NOTCHES_IN_PASSBAND; i++)
                    dsp.GetDSPRX(0, 0).SetNotchOn(i, false);
                return;
            }

            l.Sort();
            uint count = 0;

            // enable up to MAX_NOTCHES_IN_PASSBAND notches
            foreach (Notch n in l)
            {
                // translate RF to audio frequency
                double audio_freq = Math.Abs((n.Freq - vfo)) * 1e6; // now in Hz

                for (int x = 0; x < n.Depth; x++)
                {
                    if (audio_freq > 0)
                        addNotch(0, 0, count++, audio_freq, n.BW);
                }

                if (count >= MAX_NOTCHES_IN_PASSBAND) // don't enable more than 9 notches!
                    break;
            } // for loop

            // turn off unused notches
            if (count < MAX_NOTCHES_IN_PASSBAND)
            {
                for (uint i = count; i < MAX_NOTCHES_IN_PASSBAND; i++)
                    dsp.GetDSPRX(0, 0).SetNotchOn(i, false);
            }

            if (!chkPower.Checked)
                Display.DrawBackground();
#endif
        } // UpdateRX1Notches()

        private void UpdateRX1SubNotches()
        {
#if (!NO_TNF)
            if (!chkTNF.Checked || !chkEnableMultiRX.Checked)
            {
                for (uint i = 0; i < MAX_NOTCHES_IN_PASSBAND; i++)
                    dsp.GetDSPRX(0, 1).SetNotchOn(i, false);
                return;
            }

            double vfo = VFOBFreq;
            if (rx2_enabled) vfo = VFOASubFreq;
            if (chkRIT.Checked) vfo += (double)udRIT.Value * 1e-6;

            switch (rx1_dsp_mode)
            {
                case (DSPMode.CWL):
                    vfo += cw_pitch * 1e-6;
                    break;
                case (DSPMode.CWU):
                    vfo -= cw_pitch * 1e-6;
                    break;
            }

            int low = dsp.GetDSPRX(0, 1).RXFilterLow - 200;
            int high = dsp.GetDSPRX(0, 1).RXFilterHigh + 200;

            List<Notch> l = NotchList.NotchesInBW(vfo, low, high);
            if (l.Count == 0)
            {
                for (uint i = 0; i < MAX_NOTCHES_IN_PASSBAND; i++)
                    dsp.GetDSPRX(0, 1).SetNotchOn(i, false);
                return;
            }

            l.Sort();
            uint count = 0;

            // enable up to 3 notches
            foreach (Notch n in l)
            {
                // translate RF to audio frequency
                double audio_freq = (n.Freq - vfo) * 1e6; // now in Hz

                for (int x = 0; x < n.Depth; x++)
                {
                    if (audio_freq > 0)
                        addNotch(0, 1, count++, audio_freq, n.BW);
                }
                if (count >= MAX_NOTCHES_IN_PASSBAND) // don't enable more than 9 notches!
                    break;
            }

            // turn off unused notches
            if (count < MAX_NOTCHES_IN_PASSBAND)
            {
                for (uint i = count; i < MAX_NOTCHES_IN_PASSBAND; i++)
                    dsp.GetDSPRX(0, 1).SetNotchOn(i, false);
            }

            if (!chkPower.Checked)
                Display.DrawBackground();
#endif
        }

        private void UpdateRX2Notches()
        {
#if (!NO_TNF)
            if (!chkTNF.Checked || !rx2_enabled)
            {
                for (uint i = 0; i < MAX_NOTCHES_IN_PASSBAND; i++)
                    dsp.GetDSPRX(1, 0).SetNotchOn(i, false);
                return;
            }

            double vfo = VFOBFreq;
            //if (chkRIT.Checked) vfo += (double)udRIT.Value * 1e-6;

            switch (rx2_dsp_mode)
            {
                case (DSPMode.CWL):
                    vfo += cw_pitch * 1e-6;
                    break;
                case (DSPMode.CWU):
                    vfo -= cw_pitch * 1e-6;
                    break;
            }

            int low = dsp.GetDSPRX(1, 0).RXFilterLow - 200;
            int high = dsp.GetDSPRX(1, 0).RXFilterHigh + 200;

            List<Notch> l = NotchList.NotchesInBW(vfo, low, high);
            if (l.Count == 0)
            {
                for (uint i = 0; i < MAX_NOTCHES_IN_PASSBAND; i++)
                    dsp.GetDSPRX(1, 0).SetNotchOn(i, false);
                return;
            }

            l.Sort();
            uint count = 0;

            // enable up to 9 notches
            foreach (Notch n in l)
            {
                // translate RF to audio frequency
                double audio_freq = (n.Freq - vfo) * 1e6; // now in Hz

                for (int x = 0; x < n.Depth; x++)
                {
                    if (audio_freq > 0)
                        addNotch(1, 0, count++, audio_freq, n.BW);
                }
                if (count >= MAX_NOTCHES_IN_PASSBAND) // don't enable more than 9 notches!
                    break;

            }

            // turn off unused notches
            if (count < MAX_NOTCHES_IN_PASSBAND)
            {
                for (uint i = count; i < MAX_NOTCHES_IN_PASSBAND; i++)
                    dsp.GetDSPRX(1, 0).SetNotchOn(i, false);
            }

            if (!chkPower.Checked)
                Display.DrawBackground();
#endif
        }

        private void mnuESC_Click(object sender, EventArgs e)
        {
            if (current_model != Model.FLEX5000 || !FWCEEPROM.RX2OK) return;

            if (diversityForm == null || diversityForm.IsDisposed)
                diversityForm = new DiversityForm(this);

            diversityForm.Show();
            diversityForm.Focus();
            diversityForm.WindowState = FormWindowState.Normal; // ke9ns add




        } // ESC button


        private void ptbFMMic_Scroll(object sender, EventArgs e)
        {
            lblMicValFM.Text = ptbFMMic.Value.ToString();
            if (dsp.GetDSPTX(0).CurrentDSPMode == DSPMode.FM)
            {
                double gain_db = (double)ptbFMMic.Value;
                if (mic_boost) gain_db += 20.0;
                Audio.MicPreamp = Math.Pow(10.0, gain_db / 20.0); // convert to scalar
            }
            if (ptbFMMic.Focused) btnHidden.Focus();
        }

        private void chkFMCTCSS_CheckedChanged(object sender, EventArgs e)
        {
            CTCSSOn = chkFMCTCSS.Checked;

            if (chkFMCTCSS.Checked) chkFM1750.Checked = false; // ke9ns add .188
        }

        private void comboFMCTCSS_SelectedIndexChanged(object sender, EventArgs e)
        {
            CTCSSFreq = double.Parse(comboFMCTCSS.Text);
        }

        private void InitCTCSS()
        {
            comboFMCTCSS.Items.Clear();
            foreach (double d in CTCSS_array)
                comboFMCTCSS.Items.Add(d.ToString("f1"));
        }

        private void InitMemoryFrontPanel()
        {
            comboFMMemory.DataSource = MemoryList.List;
            comboFMMemory.DisplayMember = "Name";
            comboFMMemory.ValueMember = "Name";
        }

        private void radFMDeviation2kHz_CheckedChanged(object sender, EventArgs e)
        {
            if (radFMDeviation2kHz.Checked)
            {

                radRX2ModeFMN.Text = "2FM"; //.236
                radModeFMN.Text = "2FM";

                dsp.GetDSPTX(0).TXFMDeviation = 2500;
                dsp.GetDSPRX(0, 0).RXFMDeviation = 2500;

                dsp.GetDSPRX(1, 0).RXFMDeviation = 2500; //.236 add this for rx2


                if (RX1DSPMode == DSPMode.FM)
                {
                    UpdateRX1Filters(-4000, 4000);
                    UpdateDisplay();
                }
                if (RX2DSPMode == DSPMode.FM)
                {
                    UpdateRX2Filters(-4000, 4000);
                    UpdateDisplay();
                }
                if (dsp.GetDSPTX(0).CurrentDSPMode == DSPMode.FM)
                {
                    SetTXFilters(DSPMode.FM, -4000, 4000);
                }
            }
        }

        private void radFMDeviation5kHz_CheckedChanged(object sender, EventArgs e)
        {
            if (radFMDeviation5kHz.Checked)
            {
                radRX2ModeFMN.Text = "5FM"; //.236
                radModeFMN.Text = "5FM";

                dsp.GetDSPTX(0).TXFMDeviation = 5000;
                dsp.GetDSPRX(0, 0).RXFMDeviation = 5000;

                dsp.GetDSPRX(1, 0).RXFMDeviation = 5000; //.236 add this

                if (RX1DSPMode == DSPMode.FM)
                {
                    UpdateRX1Filters(-8000, 8000);
                    UpdateDisplay();
                }
                if (RX2DSPMode == DSPMode.FM)
                {
                    UpdateRX2Filters(-8000, 8000);
                    UpdateDisplay();
                }
                if (dsp.GetDSPTX(0).CurrentDSPMode == DSPMode.FM)
                {
                    SetTXFilters(DSPMode.FM, -8000, 8000);
                }
            }
        }

        //==================================================
        // ke9ns add (change to 17khz .218)
        public void FMDeviation10khz() // WFM
        {
            dsp.GetDSPTX(0).TXFMDeviation = FMDataDeviation;
            dsp.GetDSPRX(0, 0).RXFMDeviation = FMDataDeviation;

            dsp.GetDSPRX(1, 0).RXFMDeviation = FMDataDeviation; //.236 add this for rx2

            if (RX1DSPMode == DSPMode.FM)
            {
                UpdateRX1Filters(-FMDataLowHigh, FMDataLowHigh); // +/- 20khz
                UpdateDisplay();
            }
            if (RX2DSPMode == DSPMode.FM)
            {
                UpdateRX2Filters(-FMDataLowHigh, FMDataLowHigh);
                UpdateDisplay();
            }
            if (dsp.GetDSPTX(0).CurrentDSPMode == DSPMode.FM)
            {
                SetTXFilters(DSPMode.FM, -FMDataLowHigh, FMDataLowHigh);
            }

        } // FMDeviation10khz()



        private void udFMOffset_ValueChanged(object sender, EventArgs e)
        {
            fm_tx_offset_mhz = (double)udFMOffset.Value;
        }

        private void chkFMTXHigh_CheckedChanged(object sender, EventArgs e)
        {
            if (chkFMTXHigh.Checked)
            {
                chkFMTXSimplex.Checked = false;
                chkFMTXLow.Checked = false;

                chkFMTXRev.Enabled = true;
                chkFMTXRev.Checked = false;

                CurrentFMTXMode = FMTXMode.High;
            }
        }

        private void chkFMTXSimplex_CheckedChanged(object sender, EventArgs e)
        {
            if (chkFMTXSimplex.Checked)
            {
                chkFMTXHigh.Checked = false;
                chkFMTXLow.Checked = false;

                chkFMTXRev.Enabled = false;
                chkFMTXRev.Checked = false;

                CurrentFMTXMode = FMTXMode.Simplex;
            }
        }

        private void chkFMTXLow_CheckedChanged(object sender, EventArgs e)
        {
            if (chkFMTXLow.Checked)
            {
                chkFMTXSimplex.Checked = false;
                chkFMTXHigh.Checked = false;

                chkFMTXRev.Enabled = true;
                chkFMTXRev.Checked = false;

                CurrentFMTXMode = FMTXMode.Low;
            }
        }

        private void chkFMTXRev_CheckedChanged(object sender, EventArgs e)
        {
            if (chkFMTXRev.Checked)
            {
                switch (current_fm_tx_mode)
                {
                    case FMTXMode.Low:
                        VFOAFreq -= (fm_tx_offset_mhz);
                        break;
                    case FMTXMode.High:
                        VFOAFreq += (fm_tx_offset_mhz);
                        break;
                }
            }
            else
            {
                switch (current_fm_tx_mode)
                {
                    case FMTXMode.Low:
                        VFOAFreq += (fm_tx_offset_mhz);
                        break;
                    case FMTXMode.High:
                        VFOAFreq -= (fm_tx_offset_mhz);
                        break;
                }
            }
        }

        private void chkFMMode_Click(object sender, EventArgs e)
        {
            switch (current_fm_tx_mode)
            {
                case FMTXMode.High:
                    chkFMTXHigh.Checked = true;
                    break;

                case FMTXMode.Simplex:
                    chkFMTXSimplex.Checked = true;
                    break;

                case FMTXMode.Low:
                    chkFMTXLow.Checked = true;
                    break;
            }
        }

        private bool ctcss_on = false;
        public bool CTCSSOn
        {
            get { return ctcss_on; }
            set
            {
                ctcss_on = value;
                if (chkFMCTCSS.Checked != value) chkFMCTCSS.Checked = value;

                dsp.GetDSPTX(0).CTCSSFlag = chkFMCTCSS.Checked;
            }
        }

        private double ctcss_freq = 100.0;
        public double CTCSSFreq
        {
            get { return ctcss_freq; }
            set
            {
                ctcss_freq = value;
                if (comboFMCTCSS.Text != ctcss_freq.ToString("f1"))
                {
                    comboFMCTCSS.Text = ctcss_freq.ToString("f1");
                    comboFMCTCSS_SelectedIndexChanged(this, EventArgs.Empty);
                }

                dsp.GetDSPTX(0).CTCSSFreqHz = value;
            }
        }

        private void mnuMemory_Click(object sender, EventArgs e)
        {
            if (memoryForm == null || memoryForm.IsDisposed)
                memoryForm = new MemoryForm(this);
            memoryForm.Show();
            memoryForm.Focus();
            memoryForm.WindowState = FormWindowState.Normal; // ke9ns add
        }

        // ke9ns add .206 RX2
        public void RecallMemoryB(MemoryRecord record)
        {

            Debug.WriteLine("MEMORYRECALLB " + record.RXFreq + " , " + record.TXFreq);


            if (record.RXFreq < 0.009)
            {
                string memerror_message = "The VFO B RX Frequency value of " + record.RXFreq +
                    "  MHz is too low for the memory record modified or selected.  It must be a value greater than 0.009000 MHz.\r\n\r\n" +
                    "Manually change the VFO B RX Frequency value in the Memory record to correct this error.\r\n\r\n" +
                    "A default VFO B RX Frequency value of 10.000 MHz or the memory channel transmit frequency " +
                    "will be used by PowerSDR until the memory record with the invalid VFO B RX Frequency value is corrected.";
                string memerror_caption = "Data Entry Error - VFO B Frequency";
                MessageBox.Show(memerror_message, memerror_caption, MessageBoxButtons.OK, MessageBoxIcon.Exclamation, MessageBoxDefaultButton.Button1);

                record.RXFreq = 10.0;
            }

            if ((record.RXFreq != record.TXFreq) && (!record.Split))
            {
                string memerror_message = "The VFO B RX frequency of " + record.RXFreq +
                    " MHz does not match the transmit frequency of " + record.TXFreq +
                    " MHz and Split is not enabled for the memory record modified or selected.  This is an invalid configuration.\r\n\r\n" +
                    "The VFO B RX frequency will not be updated to the defined memory record value unless Split " +
                    " is enabled in the memory record or the RX and TX frequencies are changed to be the same frequency.\r\n\r\n" +
                    "The VFO B RX frequency will be set in PowerSDR to the Memory record transmit frequency of " + record.TXFreq + " MHz.";
                string memerror_caption = " Data Entry Error - VFO B RX/TX Frequency Mismatch";
                MessageBox.Show(memerror_message, memerror_caption, MessageBoxButtons.OK, MessageBoxIcon.Exclamation, MessageBoxDefaultButton.Button1);
            }

            RX2DSPMode = record.DSPMode;
            VFOBFreq = record.RXFreq;
            //  TuneStepIndex = TuneStepLookup(record.TuneStep);
            // VFOSplit = record.Split;


            if (record.DSPMode == DSPMode.FM)
            {
                CurrentFMTXMode = record.RPTR;
                if (record.Split)
                {
                    TXFreq = record.TXFreq;
                }

                if (record.RPTROffset > 50.0 || record.RPTROffset < 0)
                {
                    string memerror_message = "The Repeater Offset Value of " + record.RPTROffset +
                        " is out of range for the memory record modified or selected.  It must be a value between 0.000 and 50.000.\r\n\r\n" +
                        "Manually change the Repeater Offset value in the Memory record to correct this error.\r\n\r\n" +
                        "A default repeater offset value of 0.000 MHz will be used by PowerSDR until the memory record with the invalid repeater offset is corrected.";
                    string memerror_caption = "Data Entry Error - Repeater Offset";
                    MessageBox.Show(memerror_message, memerror_caption, MessageBoxButtons.OK, MessageBoxIcon.Exclamation, MessageBoxDefaultButton.Button1);

                    record.RPTROffset = 0.0;
                }
                FMTXOffsetMHz = record.RPTROffset;
                CTCSSOn = record.CTCSSOn;
                CTCSSFreq = record.CTCSSFreq;
                FMDeviation_Hz = record.Deviation;
            }
            else
            {
                TXFreq2 = record.TXFreq;

                RX2Filter = record.RXFilter;
                if (record.RXFilter == Filter.VAR1 || record.RXFilter == Filter.VAR2)
                    UpdateRX2Filters(record.RXFilterLow, record.RXFilterHigh);
            }



            if (record.Power > 100 || record.Power < 0)
            {
                string memerror_message = "The Power Value of " + record.Power +
                           " is out of range for the memory record modified or selected.  It must be a value between 0 and 100.\r\n\r\n" +
                           "Manually change the Power value in the Memory record to correct this error.\r\n\r\n" +
                           "A default Power value of 50 will be used by PowerSDR until the memory record with the invalid Power value is corrected.";
                string memerror_caption = "Data Entry Error - Power";
                MessageBox.Show(memerror_message, memerror_caption, MessageBoxButtons.OK, MessageBoxIcon.Exclamation, MessageBoxDefaultButton.Button1);

                record.Power = 50;
            }
            PWR = record.Power;
            RX2AGCMode = record.AGCMode;

            if (record.AGCT > 120 || record.AGCT < -20)
            {
                string memerror_message = "The AGC-T Value of " + record.AGCT +
                           " is out of range for the memory record modified or selected.  It must be a value between -20 and 120.\r\n\r\n" +
                           "Manually change the AGC-T value in the Memory record to correct this error.\r\n\r\n" +
                           "A default AGC-T value of 90 will be used by PowerSDR until the memory record with the invalid AGC-T value is corrected.";
                string memerror_caption = "Data Entry Error - AGC-T";
                MessageBox.Show(memerror_message, memerror_caption, MessageBoxButtons.OK, MessageBoxIcon.Exclamation, MessageBoxDefaultButton.Button1);

                record.AGCT = 90;
            }
            RF = record.AGCT;

        } // RecallMemoryB

        //================================================================================================
        // ke9ns 
        public void RecallMemory(MemoryRecord record)
        {
            if (record.RXFreq < 0.009)
            {
                string memerror_message = "The VFO A RX Frequency value of " + record.RXFreq +
                    "  MHz is too low for the memory record modified or selected.  It must be a value greater than 0.009000 MHz.\r\n\r\n" +
                    "Manually change the VFO A RX Frequency value in the Memory record to correct this error.\r\n\r\n" +
                    "A default VFO A RX Frequency value of 10.000 MHz or the memory channel transmit frequency " +
                    "will be used by PowerSDR until the memory record with the invalid VFO A RX Frequency value is corrected.";
                string memerror_caption = "Data Entry Error - VFO A Frequency";
                MessageBox.Show(memerror_message, memerror_caption, MessageBoxButtons.OK, MessageBoxIcon.Exclamation, MessageBoxDefaultButton.Button1);

                record.RXFreq = 10.0;
            }

            if ((record.RXFreq != record.TXFreq) && (!record.Split))
            {
                string memerror_message = "The VFO A RX frequency of " + record.RXFreq +
                    " MHz does not match the transmit frequency of " + record.TXFreq +
                    " MHz and Split is not enabled for the memory record modified or selected.  This is an invalid configuration.\r\n\r\n" +
                    "The VFO A RX frequency will not be updated to the defined memory record value unless Split " +
                    " is enabled in the memory record or the RX and TX frequencies are changed to be the same frequency.\r\n\r\n" +
                    "The VFO A RX frequency will be set in PowerSDR to the Memory record transmit frequency of " + record.TXFreq + " MHz.";
                string memerror_caption = " Data Entry Error - VFO A RX/TX Frequency Mismatch";
                MessageBox.Show(memerror_message, memerror_caption, MessageBoxButtons.OK, MessageBoxIcon.Exclamation, MessageBoxDefaultButton.Button1);
            }

            RX1DSPMode = record.DSPMode;
            VFOAFreq = record.RXFreq;
            TuneStepIndex = TuneStepLookup(record.TuneStep);
            VFOSplit = record.Split;

            if (record.DSPMode == DSPMode.FM)
            {
                CurrentFMTXMode = record.RPTR;
                if (record.Split)
                {
                    TXFreq = record.TXFreq;
                }

                if (record.RPTROffset > 50.0 || record.RPTROffset < 0)
                {
                    string memerror_message = "The Repeater Offset Value of " + record.RPTROffset +
                        " is out of range for the memory record modified or selected.  It must be a value between 0.000 and 50.000.\r\n\r\n" +
                        "Manually change the Repeater Offset value in the Memory record to correct this error.\r\n\r\n" +
                        "A default repeater offset value of 0.000 MHz will be used by PowerSDR until the memory record with the invalid repeater offset is corrected.";
                    string memerror_caption = "Data Entry Error - Repeater Offset";
                    MessageBox.Show(memerror_message, memerror_caption, MessageBoxButtons.OK, MessageBoxIcon.Exclamation, MessageBoxDefaultButton.Button1);

                    record.RPTROffset = 0.0;
                }
                FMTXOffsetMHz = record.RPTROffset;
                CTCSSOn = record.CTCSSOn;
                CTCSSFreq = record.CTCSSFreq;
                FMDeviation_Hz = record.Deviation;
            }
            else
            {
                TXFreq = record.TXFreq;
                RX1Filter = record.RXFilter;
                if (record.RXFilter == Filter.VAR1 || record.RXFilter == Filter.VAR2)
                    UpdateRX1Filters(record.RXFilterLow, record.RXFilterHigh);
            }

            if (record.Power > 100 || record.Power < 0)
            {
                string memerror_message = "The Power Value of " + record.Power +
                           " is out of range for the memory record modified or selected.  It must be a value between 0 and 100.\r\n\r\n" +
                           "Manually change the Power value in the Memory record to correct this error.\r\n\r\n" +
                           "A default Power value of 50 will be used by PowerSDR until the memory record with the invalid Power value is corrected.";
                string memerror_caption = "Data Entry Error - Power";
                MessageBox.Show(memerror_message, memerror_caption, MessageBoxButtons.OK, MessageBoxIcon.Exclamation, MessageBoxDefaultButton.Button1);

                record.Power = 50;
            }
            PWR = record.Power;
            RX1AGCMode = record.AGCMode;

            if (record.AGCT > 120 || record.AGCT < -20)
            {
                string memerror_message = "The AGC-T Value of " + record.AGCT +
                           " is out of range for the memory record modified or selected.  It must be a value between -20 and 120.\r\n\r\n" +
                           "Manually change the AGC-T value in the Memory record to correct this error.\r\n\r\n" +
                           "A default AGC-T value of 90 will be used by PowerSDR until the memory record with the invalid AGC-T value is corrected.";
                string memerror_caption = "Data Entry Error - AGC-T";
                MessageBox.Show(memerror_message, memerror_caption, MessageBoxButtons.OK, MessageBoxIcon.Exclamation, MessageBoxDefaultButton.Button1);

                record.AGCT = 90;
            }
            RF = record.AGCT;
        }

        private void comboFMMemory_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (comboFMMemory.Items.Count == 0 || comboFMMemory.SelectedItem == null) return;

            MemoryRecord recordToRestore = new MemoryRecord((MemoryRecord)comboFMMemory.SelectedItem);
            if (!initializing)
                RecallMemory(recordToRestore);
        }

        private void btnFMMemoryUp_Click(object sender, EventArgs e)
        {
            if (comboFMMemory.Items.Count == 0 || comboFMMemory.SelectedItem == null) return;
            comboFMMemory.SelectedIndex = (comboFMMemory.SelectedIndex + 1) % comboFMMemory.Items.Count;
        }

        private void btnFMMemoryDown_Click(object sender, EventArgs e)
        {
            if (comboFMMemory.Items.Count == 0 || comboFMMemory.SelectedItem == null) return;
            comboFMMemory.SelectedIndex = (comboFMMemory.SelectedIndex - 1 + comboFMMemory.Items.Count) % comboFMMemory.Items.Count;
        }


        //=================================================================================
        //ke9ns: come here when you select a memory from memory interface
        public void changeComboFMMemory(int index)
        {
            if (comboFMMemory.Items.Count == 0) return;

            if (index < 0 || index > comboFMMemory.Items.Count - 1) return;

            if (comboFMMemory.SelectedIndex != index)
            {
                comboFMMemory.SelectedIndex = index;
            }
            else // memory is already set in combobox, recall it
            {
                MemoryRecord recordToRestore = new MemoryRecord((MemoryRecord)comboFMMemory.SelectedItem); // ke9ns restore based on selected item from the FM panel rather than from the memoryform.

                RecallMemory(recordToRestore); // ke9ns actually pull up memory
            }
        } // changeComboFMMemory

        // ke9ns add .206 for mouse wheel click to send memory to VFOB instead of A
        public void changeComboFMMemoryB(int index)
        {
            Debug.WriteLine("comboFFMemory " + comboFMMemory.Items.Count);

            if (comboFMMemory.Items.Count == 0) return;


            if (index < 0 || index > comboFMMemory.Items.Count - 1) return;


            comboFMMemory.SelectedIndexChanged -= comboFMMemory_SelectedIndexChanged;
            comboFMMemory.SelectedIndex = index;
            comboFMMemory.SelectedIndexChanged += comboFMMemory_SelectedIndexChanged;

            MemoryRecord recordToRestore = new MemoryRecord((MemoryRecord)comboFMMemory.SelectedItem); // ke9ns restore based on selected item from the FM panel rather than from the memoryform.
            Debug.WriteLine("Recordtorestore " + recordToRestore);

            RecallMemoryB(recordToRestore); // ke9ns actually pull up memory

        } // changeComboFMMemoryB


        private void btnFMMemory_Click(object sender, EventArgs e)
        {
            if (memoryForm == null || memoryForm.IsDisposed)
                memoryForm = new MemoryForm(this);
            memoryForm.Show();
            memoryForm.Focus();
            memoryForm.WindowState = FormWindowState.Normal; // ke9ns add
        }

        private void timerNotchZoom_Tick(object sender, EventArgs e)
        {
#if (!NO_TNF)
            const int TOL = 10;

            timerNotchZoom.Enabled = false;
            if (notch_drag_max_delta_x < TOL && notch_drag_max_delta_y < TOL)
            {
                Display.TNFZoom = true;
                notch_zoom = true;
                Display.NotchZoomStartFreq = notch_drag_start.Freq;
            }
#endif
        }

        private void setupToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (setupForm == null || setupForm.IsDisposed)
                setupForm = new Setup(this);
            setupForm.Show();
            setupForm.Focus();
            setupForm.WindowState = FormWindowState.Normal; // ke9ns add
        }

        private void memoryToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (memoryForm == null || memoryForm.IsDisposed) memoryForm = new MemoryForm(this);
            memoryForm.Show();
            memoryForm.Focus();
            memoryForm.WindowState = FormWindowState.Normal; // ke9ns add
        }

        private void waveToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (WaveForm.IsDisposed)
                WaveForm = new WaveControl(this);
            WaveForm.Show();
            WaveForm.Focus();
            WaveForm.WindowState = FormWindowState.Normal; // ke9ns add

        }

        private void equalizerToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (eqForm == null || eqForm.IsDisposed)
                eqForm = new EQForm(this);
            eqForm.Show();
            eqForm.Focus();
            eqForm.WindowState = FormWindowState.Normal; // ke9ns add
        }

        private void xVTRsToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (xvtrForm == null || xvtrForm.IsDisposed)
                xvtrForm = new XVTRForm(this);

            xvtrForm.Show();
            xvtrForm.Focus();
            xvtrForm.WindowState = FormWindowState.Normal; // ke9ns add
        }

        private void cWXToolStripMenuItem_Click(object sender, EventArgs e) // CWX toolstrip 
        {
            if (setupForm == null || setupForm.IsDisposed)
            {
                setupForm = new Setup(this);
            }

            if ((setupForm != null) && (setupForm.chkKeyPoll.Checked == false))
            {
                if (rx1_dsp_mode == DSPMode.LSB) RX1DSPMode = DSPMode.CWL;
                else if (rx1_dsp_mode == DSPMode.USB) RX1DSPMode = DSPMode.CWU;


                if (rx1_dsp_mode != DSPMode.CWL && rx1_dsp_mode != DSPMode.CWU)
                {
                    RX1DSPMode = DSPMode.CWU;



                    //    MessageBox.Show(new Form { TopMost = true }, "The radio must be in CWL or CWU mode in order to open the " +
                    //       "CWX Control Form.",
                    //       "CWX Error: Wrong Mode",
                    //       MessageBoxButtons.OK,
                    //       MessageBoxIcon.Error);
                    //   return;
                }
            }
            //	cw_key_mode = true;
            if (cwxForm == null || cwxForm.IsDisposed)
            {
                Debug.WriteLine("CWX CREATE1");

                cwxForm = new CWX(this);
            }

            cwxForm.Show();
            cwxForm.Focus();
            cwxForm.WindowState = FormWindowState.Normal; // ke9ns add

        } // cWXToolStripMenuItem_Click

        private void uCBToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (ucbForm == null || ucbForm.IsDisposed)
                ucbForm = new UCBForm(this);
            ucbForm.Show();
            ucbForm.Focus();
            ucbForm.WindowState = FormWindowState.Normal; // ke9ns add
        }


        //=========================================================================
        // ke9ns opens up the correct audio mixer board for your flex radio type
        //       this allows you to choose the input and output (assume VAC1 & 2 off)
        //==========================================================================
        private void mixerToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (fwc_init || hid_init)
            {
                switch (current_model)
                {
                    case Model.FLEX5000:
                        if (fwcMixForm == null || fwcMixForm.IsDisposed)
                            fwcMixForm = new FWCMixForm(this);
                        fwcMixForm.Show();
                        fwcMixForm.Focus();
                        fwcMixForm.WindowState = FormWindowState.Normal; // ke9ns add
                        break;
                    case Model.FLEX3000:
                        if (flex3000MixerForm == null || flex3000MixerForm.IsDisposed)
                            flex3000MixerForm = new FLEX3000MixerForm(this);
                        flex3000MixerForm.Show();
                        flex3000MixerForm.Focus();
                        flex3000MixerForm.WindowState = FormWindowState.Normal; // ke9ns add
                        break;
                    case Model.FLEX1500:
                        if (flex1500MixerForm == null || flex1500MixerForm.IsDisposed)
                            flex1500MixerForm = new FLEX1500MixerForm(this);
                        flex1500MixerForm.Show();
                        flex1500MixerForm.Focus();
                        flex1500MixerForm.WindowState = FormWindowState.Normal; // ke9ns add
                        break;
                }
            }
        }

        private void antennaToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (fwc_init && current_model == Model.FLEX5000)
            {
                if (fwcAntForm == null || fwcAntForm.IsDisposed)
                    fwcAntForm = new FWCAntForm(this);
                fwcAntForm.Show();
                fwcAntForm.Focus();
                fwcAntForm.WindowState = FormWindowState.Normal; // ke9ns add
            }
            else if (hid_init && current_model == Model.FLEX1500)
            {
                if (hidAntForm == null || hidAntForm.IsDisposed)
                    hidAntForm = new HIDAntForm(this);
                hidAntForm.Show();
                hidAntForm.Focus();
                hidAntForm.WindowState = FormWindowState.Normal; // ke9ns add
            }
        }

        private void relaysToolStripMenuItem_Click(object sender, EventArgs e)
        {
            //if(fwc_init && current_model == Model.FLEX5000)
            {
                if (flex5000RelayForm == null || flex5000RelayForm.IsDisposed)
                    flex5000RelayForm = new FLEX5000RelayForm(this);
                flex5000RelayForm.Show();
                flex5000RelayForm.Focus();
                flex5000RelayForm.WindowState = FormWindowState.Normal; // ke9ns add
            }
        }

        private void aTUToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (fwc_init && current_model == Model.FLEX5000)
            {
                if (fwcAtuForm == null || fwcAtuForm.IsDisposed)
                    fwcAtuForm = new FWCATUForm(this);
                fwcAtuForm.Show();
                fwcAtuForm.Focus();
            }
            else if (fwc_init && current_model == Model.FLEX3000)
            {
                if (flex3000ATUForm == null || flex3000ATUForm.IsDisposed)
                    flex3000ATUForm = new FLEX3000ATUForm(this);
                flex3000ATUForm.Show();
                flex3000ATUForm.Focus();
            }
        }

        private void flexControlToolStripMenuItem_Click(object sender, EventArgs e)
        {
            switch (current_flexcontrol_mode)
            {
                case FlexControlMode.Basic:
                    if (flexControlBasicForm == null || flexControlBasicForm.IsDisposed)
                        flexControlBasicForm = new FlexControlBasicForm(this);
                    flexControlBasicForm.Show();
                    flexControlBasicForm.Focus();
                    //  flexControlBasicForm.WindowState = FormWindowState.Normal; // ke9ns add
                    break;
                case FlexControlMode.Advanced:
                    if (flexControlAdvancedForm == null || flexControlAdvancedForm.IsDisposed)
                        flexControlAdvancedForm = new FlexControlAdvancedForm(this);
                    flexControlAdvancedForm.Show();
                    flexControlAdvancedForm.Focus();
                    //   flexControlAdvancedForm.WindowState = FormWindowState.Normal; // ke9ns add
                    break;
            }
        }

        public void eSCToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (current_model != Model.FLEX5000 || !FWCEEPROM.RX2OK) return;


            if (setupForm != null && setupForm.chkBoxESC.Checked == true)
            {
                btnReset_Click(this, EventArgs.Empty);

                panelTSRadar.Enabled = true;
                panelTSRadar.Visible = true;


            }
            else
            {

                btnReset_Click(this, EventArgs.Empty);

                panelTSRadar.Enabled = false;
                panelTSRadar.Visible = false;

                if (diversityForm == null || diversityForm.IsDisposed)
                    diversityForm = new DiversityForm(this);

                diversityForm.Show();
                diversityForm.Focus();
                diversityForm.WindowState = FormWindowState.Normal; // ke9ns add

            }


        } // eSCToolStripMenuItem_Click


        private void reportBugToolStripMenuItem_Click(object sender, EventArgs e)
        {
            Thread t = new Thread(new ThreadStart(LaunchBugLink));
            t.Name = "Launch Helpdesk Link Thread";  //W4TME
            t.IsBackground = true;
            t.Priority = ThreadPriority.Normal;
            t.Start();
        }

        private void remoteProfilesToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (File.Exists(Application.StartupPath + "\\command.xml"))
            {
                if (ProfileForm == null || ProfileForm.IsDisposed)
                    ProfileForm = new RemoteProfiles(this);
                ProfileForm.Show();
                ProfileForm.Focus();
                ProfileForm.WindowState = FormWindowState.Normal; // ke9ns add
            }
            else
                MessageBox.Show(new Form { TopMost = true }, "You must create at least one remote profile first", "No Profiles Available", MessageBoxButtons.OK);
        }

        private void aboutToolStripMenuItem_Click(object sender, EventArgs e)
        {
            // launch about form here
            if (aboutForm == null || aboutForm.IsDisposed)
                aboutForm = new AboutForm();
            aboutForm.ShowDialog();
            aboutForm.Focus();
        }

        private void herosToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if ((fwc_init && (current_model == Model.FLEX5000 || current_model == Model.FLEX3000)) ||
                            (hid_init && current_model == Model.FLEX1500))
            {
                if (preSelForm == null || preSelForm.IsDisposed) preSelForm = new PreSelForm(this);

                preSelForm.Show();
                preSelForm.Focus();
                preSelForm.WindowState = FormWindowState.Normal; // ke9ns add
            }
        }

        private void UpdateTXProfile(int ndx)
        {
            int cnt = CATTXProfileCount;
            int current = comboTXProfile.SelectedIndex;
            if (ndx != 0 && cnt > 0)
                comboTXProfile.SelectedIndex = 0;
            else if (ndx == 0 && cnt > 0)
                comboTXProfile.SelectedIndex = 1;

            comboTXProfile.SelectedIndex = ndx;
        }

        public bool RX1IsIn60m()
        {
            double freq = VFOAFreq;
            return (freq >= 5.25 && freq <= 5.45); // (freq >= 5.1 && freq <= 5.5);
        }

        public bool RX1IsOn60mChannel(Channel c)
        {
            double freq = VFOAFreq - ModeFreqOffset(rx1_dsp_mode);
            freq = Math.Round(freq, 6);

            return (c.Freq == freq);
        }

        public bool RX1IsOn60mChannel()
        {
            double freq = VFOAFreq - ModeFreqOffset(rx1_dsp_mode);
            freq = Math.Round(freq, 6);

            foreach (Channel c in Display.Channels60m)
            {
                if (c.Freq == freq)
                    return true;
            }

            return false; // nothing matched, return false
        }

        public bool RX2IsIn60m()
        {
            if (!fwc_init || current_model != Model.FLEX5000 || !FWCEEPROM.RX2OK) return false;

            double freq = VFOBFreq;
            return (freq >= 5.25 && freq <= 5.45); //(freq >= 5.1 && freq <= 5.5)
        }

        public bool RX2IsOn60mChannel(Channel c)
        {
            double freq = VFOBFreq - ModeFreqOffset(rx2_dsp_mode);
            freq = Math.Round(freq, 6);

            return (c.Freq == freq);
        }

        public bool RX2IsOn60mChannel()
        {
            if (!fwc_init || current_model != Model.FLEX5000 || !FWCEEPROM.RX2OK) return false;

            double freq = VFOBFreq - ModeFreqOffset(rx2_dsp_mode);
            freq = Math.Round(freq, 6);

            foreach (Channel c in Display.Channels60m)
            {
                if (c.Freq == freq)
                    return true;
            }

            return false; // nothing matched, return false
        }




        private double ModeFreqOffset(DSPMode mode)
        {
            switch (mode)
            {
                case DSPMode.LSB:
                case DSPMode.DIGL:

                    if (VFOAFreq < 25.0) return (1500 * 1e-6);
                    else return 0;


                case DSPMode.USB:
                case DSPMode.DRM:
                case DSPMode.DIGU:
                    if (VFOAFreq < 25.0) return (-1500 * 1e-6);
                    else return 0;

                case DSPMode.DSB:
                case DSPMode.CWL:
                case DSPMode.CWU:
                case DSPMode.FM:
                case DSPMode.AM:
                case DSPMode.SAM:
                    return 0;

                default: return 0;
            }
        }

        private void radBandVHF3_CheckedChanged(object sender, EventArgs e)
        {

        }

        private void Console_Load(object sender, EventArgs e)
        {
            //   using System.Runtime.InteropServices;
            //  using System.Drawing.Text;



        }

        private void panelFilter_Paint(object sender, PaintEventArgs e)
        {

        }




        //=======================================================================
        // ke9ns add to move meter up/down
        private void picRX2Meter_MouseUp(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                // meterCombo = false;
                // CurrentMeterTX1Mode = MeterTXMode.ALC; // go back to another TX meter

                if (setupForm == null || setupForm.IsDisposed)
                    setupForm = new Setup(this);

                setupForm.Show();
                setupForm.Focus();
                setupForm.WindowState = FormWindowState.Normal; // ke9ns add

                setupForm.tcSetup.SelectedIndex = 6; // select appearance tab;
                setupForm.tcAppearance.SelectedIndex = 2; // select  tab meter


            } // right click
            else
            {
                if (setupForm != null)
                {
                    Debug.WriteLine("RX3 " + setupForm.chk2ndMeter.Checked);

                    if (setupForm.chk2ndMeter.Checked == true)
                    {
                        setupForm.chk2ndMeter.Checked = false;
                        // hide RX2 button panel .211
                        //  panelBandGNRX2.Visible = false;
                        //  panelBandHFRX2.Visible = false;
                        //   panelBandVHFRX2.Visible = false;
                    }
                    else
                    {
                        setupForm.chk2ndMeter.Checked = true;
                        // expose RX2 button panel .211
                        //  panelBandGNRX2.Visible = true;
                        // panelBandHFRX2.Visible = true;
                        //  panelBandVHFRX2.Visible = true;
                    }

                }

            }



        } // picRX2Meter_MouseUp


        //============================================================================
        //============================================================================ 
        // ke9ns add Clicking on RX1 meter will cycle through 3 meters and 
        // update setup form
        //============================================================================ 
        //============================================================================ 

        private void picMultiMeterDigital_MouseUp(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((me.Button == System.Windows.Forms.MouseButtons.Right))
            {


                if (setupForm == null || setupForm.IsDisposed)
                    setupForm = new Setup(this);

                setupForm.Show();
                setupForm.Focus();
                setupForm.WindowState = FormWindowState.Normal; // ke9ns add

                setupForm.tcSetup.SelectedIndex = 6; // select appearance tab;
                setupForm.tcAppearance.SelectedIndex = 2; // select  tab meter



            } // right click
            else
            {

                switch (current_meter_display_mode)
                {

                    case MultiMeterDisplayMode.Bar:   // if BAR switch to EDGE
                        meterLMB = false;
                        meterDMB = false;

                        lblMultiSMeter.Visible = false; // turn off labels since we are switching off Bar meter
                        lblRX2Meter.Visible = false;

                        if (setupForm != null)
                        {
                            setupForm.chkBoxLMB.Checked = false;
                            setupForm.chkBoxDMB.Checked = false;
                        }

                        current_meter_display_mode = MultiMeterDisplayMode.Edge; // switch to analog
                        CurrentMeterDisplayMode = current_meter_display_mode;
                        setupForm.MTRSet = "Edge";  // comboMeterType update
                        EdgeMeterBackgroundColor = edge_meter_background_color;

                        break;

                    case MultiMeterDisplayMode.Edge: // if Edge switch to Analog
                        meterLMB = false;
                        meterDMB = false;

                        if (setupForm != null)
                        {
                            setupForm.chkBoxLMB.Checked = false;
                            setupForm.chkBoxDMB.Checked = false;
                        }

                        current_meter_display_mode = MultiMeterDisplayMode.Analog; // switch to analog
                        CurrentMeterDisplayMode = current_meter_display_mode;
                        setupForm.MTRSet = "Analog";  // comboMeterType update
                        AnalogMeterBackgroundColor = analog_meter_background_color;

                        break;

                    case MultiMeterDisplayMode.Analog: // if Analog switch from Standard Analog -> light -> dark -> to TR7 meter

                        if ((meterDMB == false) && (meterLMB == false)) // Standard Analog background
                        {
                            meterLMB = true;
                            meterDMB = false;
                            if (setupForm != null)
                            {
                                setupForm.chkBoxLMB.Checked = true;
                                setupForm.chkBoxDMB.Checked = false;
                            }

                            CurrentMeterDisplayMode = current_meter_display_mode;
                            AnalogMeterBackgroundColor = analog_meter_background_color;
                        }
                        else if (meterLMB == true) // light background Analog
                        {
                            meterLMB = false;
                            meterDMB = true;
                            if (setupForm != null)
                            {
                                setupForm.chkBoxDMB.Checked = true;
                                setupForm.chkBoxLMB.Checked = false;

                            }
                            CurrentMeterDisplayMode = current_meter_display_mode;
                            AnalogMeterBackgroundColor = analog_meter_background_color;
                        }
                        else if (meterDMB == true) // dark background Analog
                        {
                            meterLMB = false;
                            meterDMB = false;

                            if (setupForm != null)
                            {
                                setupForm.chkBoxDMB.Checked = false;
                                setupForm.chkBoxLMB.Checked = false;
                            }

                            CurrentMeterDisplayMode = current_meter_display_mode;
                            setupForm.MTRSet = "AnalogTR7";
                            AnalogMeterBackgroundColor = analog_meter_background_color;
                        }

                        break; // Analog

                    case MultiMeterDisplayMode.Original: // if TR7 switch to BAR

                        current_meter_display_mode = MultiMeterDisplayMode.Bar;
                        CurrentMeterDisplayMode = current_meter_display_mode;
                        setupForm.MTRSet = "Bar";
                        EdgeMeterBackgroundColor = edge_meter_background_color;

                        lblMultiSMeter.Visible = true; // turn on text labels for BAR meter

                        if (meterCombo != true) //MeterTXMode.Combo)
                        {
                            lblRX2Meter.Visible = true;
                        }

                        break; // Original

                } // switch (current_meter_display_mode)     check which meter you current display and change to the next one


                UpdateDisplay(); // ke9ns add

                btnHidden.Focus();


            } // left mouse click


        } // picMultiMeterDigital_MouseUp





        //=========================================================================

        private void radBand160_CheckedChanged(object sender, EventArgs e)
        {

        }

        private void picDisplay_Click(object sender, EventArgs e)
        {

        }

        //============================================================================ 
        //============================================================================ 
        // ke9ns add turn waterfall from color to grayscale
        // this saves display time and remote internet bandwidth
        //============================================================================ 
        //============================================================================ 
        private void GrayMenuItem_Click(object sender, EventArgs e) // ke9ns ADD  // this selects color or gray scale waterfalls
        {

            if (Display.GrayScale == 1) // do if currently GRAY waterfall
            {
                Display.GrayScale = 0;                // change to  RGB
                this.GrayMenuItem.Text = "GrayWtr";
                GrayMenuItem.BackColor = Color.DarkBlue; //.243

            }
            else  // do if currently Color waterfall
            {
                Display.GrayScale = 1;                 // change to Gray
                this.GrayMenuItem.Text = "ColorWtr";
                GrayMenuItem.BackColor = Color.Gray; //.243
            }

            //  this.GrayMenuItem.ForeColor = System.Drawing.SystemColors.ControlLightLight;

        } //graymenuitem

        // ke9ns add to check for right click to toggle panadapter fill or no fill
        private void GrayMenuItem_MouseDown(object sender, MouseEventArgs e)
        {

            MouseEventArgs me = (MouseEventArgs)e;

            if (me.Button == System.Windows.Forms.MouseButtons.Right) // right mouse click
            {
                if ((setupForm != null)) // make sure form is running
                {
                    if (setupForm.chkDisplayPanFill.Checked == true && setupForm.chkBoxPanFillColor.Checked == true)
                    {
                        setupForm.chkDisplayPanFill.Checked = false; // turn off fill if both fill and gradient were both on

                        //   GrayMenuItem.Font = new Font("Swis721 BdOul BT", 9.0f, FontStyle.Regular); //.243  Ex

                        //    GrayMenuItem.Font.FontFamily = Font.FontFamily.Swis721 BdOul BT"; // Swis721 Blk BT



                    }
                    else if (setupForm.chkDisplayPanFill.Checked == true) //.243
                    {
                        setupForm.chkBoxPanFillColor.Checked = true; // turn on gradient becuase fill was already ON
                                                                     //   GrayMenuItem.Font = new Font("Swis721 Blk BT", 9.0f, FontStyle.Regular); //.243  Ex

                    }
                    else
                    {
                        setupForm.chkDisplayPanFill.Checked = true; // turn fill on
                        setupForm.chkBoxPanFillColor.Checked = false; // turn gradient off
                                                                      //  GrayMenuItem.Font = new Font("Swis721 Blk BT", 9.0f, FontStyle.Regular); //.243  Ex

                    }

                }

            } // right click


        } //  GrayMenuItem_MouseDown


        //============================================================================ 
        //============================================================================ 
        // ke9ns add clicking on PA temp or volts turns on/off this reading
        // PA reading from the flex take a long time so this is a toggle
        //============================================================================ 
        //============================================================================ 
        private void labelTS4_Click(object sender, EventArgs e) // ke9ns add
        {
            if (PAON == 0)
            {
                PAON = 1;
            }
            else
            {
                PAON = 0;
            }



        } //  click on AMPS



        //============================================================================ 
        // ke9ns add 
        private void labelTS3_Click(object sender, EventArgs e) // ke9ns add
        {

            if (PAON == 0)
            {
                PAON = 1;
            }
            else if (PAON == 1)
            {
                PAON = 2;
            }
            else
            {
                PAON = 0;
            }

        } // click on temp


        //============================================================================ 
        //============================================================================ 
        // ke9ns add CALLSIGN menu field allow WaveForm to get text from here
        //============================================================================ 
        //============================================================================ 
        public static string callsign = "CallSign";

        public string Callsign            // wave.cs gets call sign from here
        {
            get { return callsign; }
            set
            {
                // Callsign = setupForm.txtGenCustomTitle.Text;
                callsign = value;

            } // set
        } // tx id

        public static string lastcallsign = " hhh ";

        public string LastCall            // wave.cs gets call sign from here
        {
            get { return lastcallsign; }
            set
            {
                lastcallsign = value;

            } // set
        } // tx id



        //=================================================================================================
        // ke9ns add   Check for left or right mouse click
        //=================================================================================================
        private void callsignTextBox_MouseDown(object sender, MouseEventArgs e)
        {

            MouseEventArgs me = (MouseEventArgs)e;

            callsignTextBox.ShortcutsEnabled = false; // added to eliminate the contextmenu from popping up

            if (me.Button == System.Windows.Forms.MouseButtons.Right) // right mouse click
            {

                string filePath = AppDataPath + "ke9ns8.dat";


                if (!File.Exists(filePath))
                {
                    Debug.WriteLine("problem no ke9ns dat file found ");
                    return;
                }

                string argument = @"/select, " + filePath;

                System.Diagnostics.Process.Start("explorer.exe", argument);

            }

            if (me.Button == System.Windows.Forms.MouseButtons.Left) // left mouse click
            {
                WaveForm.CreatePlay = true;   // create wave file            
            }

        } // callsigntextbox mouse down

        //============================================================================ 
        //============================================================================ 
        // ke9ns add: change callsign TX waterfall ID text here
        //============================================================================ 
        //============================================================================ 
        private void callsignTextBox_TextChanged_1(object sender, EventArgs e) // ke9ns add
        {
            // Debug.WriteLine("change   ");
            // Process.Start(@"c:\test")

            callsignTextBox.BackColor = Color.LemonChiffon; //to show your editing this callsign field
            callsign = callsignTextBox.Text;
            menuStrip1.Invalidate();
            menuStrip1.Update();

        }


        private static byte callsignfocus = 0; // ke9ns used to keep focus on text entry and not flex keyboard shortcuts

        private void callsignTextBox_MouseEnter(object sender, EventArgs e)// ke9ns add
        {

            //  Debug.WriteLine("Enter  ");

            callsign = callsignTextBox.Text;
            callsignTextBox.BackColor = Color.LemonChiffon;  // to show your editing this callsign field
            callsignfocus = 1;

            callsignTextBox.Focus();


        }

        private void callsignTextBox_MouseLeave(object sender, EventArgs e)// ke9ns add
        {
            // Debug.WriteLine("leaveM   ");
            WaveForm.CreatePlay = true;   // create wave file
            btnHidden.Focus();

            callsignfocus = 0; // ke9ns 
        }

        //============================================================================ 
        //============================================================================ 
        // ke9ns add:  call waveform.createBoxTS to create new wave file first.
        //============================================================================ 
        //============================================================================ 
        private void callsignTextBox_Leave(object sender, EventArgs e)// ke9ns add
        {
            //   Debug.WriteLine("leave   ");
            WaveForm.CreatePlay = true;   // create wave file
                                          // "bright" variable controls brightness of txwaterID
        } // callsignTextBox_Leave



        //============================================================================ 
        //============================================================================ 
        // ke9ns add update TX Waterfall ID status from here
        // jump here from either a TXIDMenu click or from WaveForm TXIDBoxTS update
        //============================================================================ 
        //============================================================================ 
        private static byte vac1 = 0;
        public static int Txfh = 0;
        private void TXIDMenuItem_CheckedChanged(object sender, EventArgs e)
        {

            if ((TXIDMenuItem.Checked) && (chkPower.Checked))
            {

                if (comboDisplayMode.Focused)
                    btnHidden.Focus();

                if (chkVAC1.Checked)
                {
                    vac1 = 1;
                    chkVAC1.Checked = false;
                }
                chkMOX.Checked = true;     // key radio 
                WaveForm.TXIDPlay = true;

                Debug.WriteLine("WATERID START");
            }
            else
            {
                this.TXIDMenuItem.Text = "TX WaterID";

                //  Thread.Sleep(300);

                WaveForm.TXIDPlay = false;

                if (WIDEWATERID == false)
                {
                    if (Txfh > 0) TXFilterHigh = Txfh;         // put back original filter size
                }

                if (vac1 == 1)
                {
                    vac1 = 0;
                    Thread.Sleep(100);
                    chkVAC1.Checked = true;

                    //  await Task.Delay(3000);
                }
                //  Debug.WriteLine("wating...........");


                // Task.Delay(200);

                Debug.WriteLine("WATERID OVER and OUT");

                chkMOX.Checked = false;


            }
        } // TXIDMenuItem_CheckedChanged


        //=================================================================================
        //=================================================================================
        //=================================================================================
        // ke9ns add
        public Color Border = Color.DarkGreen;  // color of line around box
        public float BorderThk = 2.2f;   // line thickness around box
        public float BorderOff = (2.2f / 2.0f); // ke9ns offset from edge of box

        public Color BackGround = Color.FromArgb(46, 46, 46); // ke9ns add

        //=================================================================================
        // ke9ns add to draw curved colored line around groupbox
        private void panelDateTime_Paint(object sender, PaintEventArgs p4)
        {
            PanelTS box = (PanelTS)sender;

            //  p4.Graphics.TextRenderingHint = TextRenderingHint.ClearTypeGridFit;
            //   p4.Graphics.CompositingMode = CompositingMode.SourceOver;
            //   p4.Graphics.CompositingQuality = CompositingQuality.HighQuality;
            p4.Graphics.InterpolationMode = InterpolationMode.HighQualityBicubic;
            p4.Graphics.SmoothingMode = SmoothingMode.HighQuality;
            p4.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;

            GraphicsPath gPath = CreatePath(1, 1, box.Width - BorderThk, box.Height - BorderThk, 8, true, true, true, true); //

            p4.Graphics.FillPath(new SolidBrush(BackGround), gPath);

            if (txtTimer.ForeColor == Color.Red)
            {
                p4.Graphics.DrawPath(new Pen(Color.Yellow, BorderThk), gPath); // ke9ns take color from setup Ring VFO color

            }
            else
            {
                p4.Graphics.DrawPath(new Pen(ring_vfo_color, BorderThk), gPath); // ke9ns take color from setup Ring VFO color
            }



        } //panelDateTime_Paint

        //=================================================================================
        // ke9ns add to draw curved colored line around groupbox
        private void grpVFOBetween_Paint(object sender, PaintEventArgs p8)
        {
            PanelTS box = (PanelTS)sender;

            //  p8.Graphics.TextRenderingHint = TextRenderingHint.ClearTypeGridFit;
            //  p8.Graphics.CompositingMode = CompositingMode.SourceOver;
            //  p8.Graphics.CompositingQuality = CompositingQuality.HighQuality;
            p8.Graphics.InterpolationMode = InterpolationMode.HighQualityBicubic;
            p8.Graphics.SmoothingMode = SmoothingMode.HighQuality;
            p8.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;


            GraphicsPath gPath = CreatePath(1, 1, box.Width - BorderThk, box.Height - BorderThk, 8, true, true, true, true); //

            p8.Graphics.FillPath(new SolidBrush(BackGround), gPath);


            if (txtTimer.ForeColor == Color.Red)
            {
                p8.Graphics.DrawPath(new Pen(Color.Yellow, BorderThk), gPath); // ke9ns take color from setup Ring VFO color

            }
            else
            {
                p8.Graphics.DrawPath(new Pen(ring_vfo_color, BorderThk), gPath); // ke9ns take color from setup Ring VFO color
            }

        } // grpVFOBetween_Paint

        //=================================================================================
        // ke9ns add to draw curved colored line around groupbox
        private void panelAntenna_Paint(object sender, PaintEventArgs p5)
        {

            PanelTS box = (PanelTS)sender; // this is the box we are currently repainting

            //  p5.Graphics.InterpolationMode = InterpolationMode.HighQualityBicubic;
            //  p5.Graphics.SmoothingMode = SmoothingMode.HighQuality;
            //  p5.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;

            //  p5.Graphics.TextRenderingHint = TextRenderingHint.ClearTypeGridFit;
            //  p5.Graphics.CompositingMode = CompositingMode.SourceOver;
            //  p5.Graphics.CompositingQuality = CompositingQuality.HighQuality;
            p5.Graphics.InterpolationMode = InterpolationMode.HighQualityBicubic;
            p5.Graphics.SmoothingMode = SmoothingMode.HighQuality;
            p5.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;

            GraphicsPath gPath = CreatePath(1, 1, box.Width - BorderThk, box.Height - BorderThk, 8, true, true, true, true); //

            p5.Graphics.FillPath(new SolidBrush(BackGround), gPath);
            p5.Graphics.DrawPath(new Pen(ring_vfo_color, BorderThk), gPath); // ke9ns take color from setup Ring VFO color


            int HS = (int)(((float)box.Height / 2.0F) - ((float)box.Height) * 0.2F);
            int HF = (int)(((float)box.Height / 2.0F) * 0.8F);


            if (chkMOX.Checked == true) p5.Graphics.DrawImage(ant3, new Rectangle(7, HS, 20, HF));
            else p5.Graphics.DrawImage(ant2, new Rectangle(7, HS, 20, HF));



        } // panelAntenna_Paint

        //=================================================================================
        // ke9ns add to draw curved colored line around groupbox
        private void panelRing_Paint(object sender, PaintEventArgs p2)
        {
            // ke9ns refer to:  public static void SetBackgroundImage(Control c)  in skin.cs


            PanelTS box = (PanelTS)sender; // this is the box we are currently repainting

            //   p2.Graphics.InterpolationMode = InterpolationMode.HighQualityBicubic;
            //   p2.Graphics.SmoothingMode = SmoothingMode.HighQuality;
            //   p2.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;

            //   p2.Graphics.TextRenderingHint = TextRenderingHint.ClearTypeGridFit;
            //   p2.Graphics.CompositingMode = CompositingMode.SourceOver;
            //   p2.Graphics.CompositingQuality = CompositingQuality.HighQuality;
            p2.Graphics.InterpolationMode = InterpolationMode.HighQualityBicubic;
            p2.Graphics.SmoothingMode = SmoothingMode.HighQuality;
            p2.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;

            GraphicsPath gPath = CreatePath(1, 1, box.Width - BorderThk, box.Height - BorderThk, 8, true, true, true, true); //

            p2.Graphics.FillPath(new SolidBrush(BackGround), gPath);
            p2.Graphics.DrawPath(new Pen(ring_vfo_color, BorderThk), gPath); // ke9ns take color from setup Ring VFO color



        } // panelRing_Paint

        //=================================================================================
        // ke9ns add to draw curved colored line around groupbox
        private void panelRX1Ring_Paint(object sender, PaintEventArgs p2)
        {
            // ke9ns refer to:  public static void SetBackgroundImage(Control c)  in skin.cs


            PanelTS box = (PanelTS)sender; // this is the box we are currently repainting

            p2.Graphics.InterpolationMode = InterpolationMode.HighQualityBicubic;
            p2.Graphics.SmoothingMode = SmoothingMode.HighQuality;
            p2.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;

            GraphicsPath gPath = CreatePath(1, 1, box.Width - BorderThk, box.Height - BorderThk, 8, true, true, true, true); //

            p2.Graphics.FillPath(new SolidBrush(BackGround), gPath);
            p2.Graphics.DrawPath(new Pen(ring_vfo_color, BorderThk), gPath); // ke9ns take color from setup Ring VFO color

            p2.Graphics.DrawString("RX1 - VFOA", box.Font, Brushes.White, 8, 2);

        } // panelRX1Ring_Paint

        private void panelRX2Ring_Paint(object sender, PaintEventArgs p2)
        {
            // ke9ns refer to:  public static void SetBackgroundImage(Control c)  in skin.cs
            // ke9ns: SetBackgroundImage is how button images get placed over buttons

            PanelTS box = (PanelTS)sender; // this is the box we are currently repainting

            p2.Graphics.InterpolationMode = InterpolationMode.HighQualityBicubic;
            p2.Graphics.SmoothingMode = SmoothingMode.HighQuality;
            p2.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;

            GraphicsPath gPath = CreatePath(1, 1, box.Width - BorderThk, box.Height - BorderThk, 8, true, true, true, true); //

            p2.Graphics.FillPath(new SolidBrush(BackGround), gPath);
            p2.Graphics.DrawPath(new Pen(ring_vfo_color, BorderThk), gPath); // ke9ns take color from setup Ring VFO color

            p2.Graphics.DrawString("RX2 - VFOB", box.Font, Brushes.White, 8, 2);

        } // panelRX2Ring_Paint

        //=================================================================================
        // ke9ns add to draw curved colored line around groupbox
        private void panelOptions_Paint(object sender, PaintEventArgs p3)
        {

            PanelTS box = (PanelTS)sender;
            //  p3.Graphics.InterpolationMode = InterpolationMode.HighQualityBicubic;
            //  p3.Graphics.SmoothingMode = SmoothingMode.HighQuality;
            //  p3.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;

            //   p3.Graphics.TextRenderingHint = TextRenderingHint.ClearTypeGridFit;
            //   p3.Graphics.CompositingMode = CompositingMode.SourceOver;
            //   p3.Graphics.CompositingQuality = CompositingQuality.HighQuality;
            p3.Graphics.InterpolationMode = InterpolationMode.HighQualityBicubic;
            p3.Graphics.SmoothingMode = SmoothingMode.HighQuality;
            p3.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;

            GraphicsPath gPath = CreatePath(1, 1, box.Width - BorderThk, box.Height - BorderThk, 8, true, true, true, true); //

            p3.Graphics.FillPath(new SolidBrush(BackGround), gPath);
            p3.Graphics.DrawPath(new Pen(ring_vfo_color, BorderThk), gPath); // ke9ns take color from setup Ring VFO color


        } // panelOptions



        //=================================================================================
        // ke9ns add to draw curved colored line around groupbox
        private void panelTSBandStack_Paint(object sender, PaintEventArgs p1)
        {
            PanelTS box = (PanelTS)sender;

            //   p1.Graphics.TextRenderingHint = TextRenderingHint.ClearTypeGridFit;
            //  p1.Graphics.CompositingMode = CompositingMode.SourceOver;
            //   p1.Graphics.CompositingQuality = CompositingQuality.HighQuality;
            p1.Graphics.InterpolationMode = InterpolationMode.HighQualityBicubic;
            p1.Graphics.SmoothingMode = SmoothingMode.HighQuality;
            p1.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;

            GraphicsPath gPath = CreatePath(1, 1, box.Width - BorderThk, box.Height - BorderThk, 8, true, true, true, true); //

            p1.Graphics.FillPath(new SolidBrush(BackGround), gPath);
            p1.Graphics.DrawPath(new Pen(ring_vfo_color, BorderThk), gPath); // ke9ns take color from setup Ring VFO color

            p1.Graphics.DrawString("BandStack VFO A & B", box.Font, Brushes.White, 8, 0);

        } // panelTSBandStack_Paint

        private void panelTSRadar_Paint(object sender, PaintEventArgs p1) //.246
        {
            PanelTS box = (PanelTS)sender;

            //   p1.Graphics.TextRenderingHint = TextRenderingHint.ClearTypeGridFit;
            //  p1.Graphics.CompositingMode = CompositingMode.SourceOver;
            //   p1.Graphics.CompositingQuality = CompositingQuality.HighQuality;
            p1.Graphics.InterpolationMode = InterpolationMode.HighQualityBicubic;
            p1.Graphics.SmoothingMode = SmoothingMode.HighQuality;
            p1.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;

            GraphicsPath gPath = CreatePath(1, 1, box.Width - BorderThk, box.Height - BorderThk, 8, true, true, true, true); //

            p1.Graphics.FillPath(new SolidBrush(BackGround), gPath);
            p1.Graphics.DrawPath(new Pen(ring_vfo_color, BorderThk), gPath); // ke9ns take color from setup Ring VFO color

            p1.Graphics.DrawString("RX1-RX2 Diversity ESC", box.Font, Brushes.White, 8, 0);

            // picRadar.Invalidate();

        } // panelTSRadar_Paint


        public PowerMaster pm; // .212

        //=================================================================================
        // ke9ns add to draw curved colored line around groupbox
        private void grpVFOA_Paint(object sender, PaintEventArgs p9)  // ke9ns ADD
        {

            //   Debug.WriteLine("z layer for VFOA1 " + grpVFOA.Parent.Controls.GetChildIndex(grpVFOA));  //7
            //   Debug.WriteLine("z layer for VFOA2 " + grpVFOA.Parent.Controls.GetChildIndex(VFODialA));  //46
            //   Debug.WriteLine("z layer for VFOA3 " + grpVFOA.Parent.Controls.GetChildIndex(VFODialAA));  //2;
            //   VFODialAA.Parent.Controls.SetChildIndex(VFODialAA, 45);


            if ((setupForm != null))
            {
                if ((setupForm.chkVFOOpenFont.Checked == true)) vfoopenfont = true;
                else vfoopenfont = false;


                if ((setupForm.chkVFOBoldFont.Checked == true)) VFOBoldFont = true;
                else VFOBoldFont = false;


            }


            PanelTS box = (PanelTS)sender;
            //  p9.Graphics.InterpolationMode = InterpolationMode.HighQualityBicubic;
            //  p9.Graphics.SmoothingMode = SmoothingMode.HighQuality;
            //  p9.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;

            //  p9.Graphics.TextRenderingHint = TextRenderingHint.ClearTypeGridFit;
            //   p9.Graphics.CompositingMode = CompositingMode.SourceOver;
            //   p9.Graphics.CompositingQuality = CompositingQuality.HighQuality;
            p9.Graphics.InterpolationMode = InterpolationMode.HighQualityBicubic;
            p9.Graphics.SmoothingMode = SmoothingMode.HighQuality;
            p9.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;

            GraphicsPath gPath = CreatePath(1, 1, box.Width - BorderThk, box.Height - BorderThk, 8, true, true, true, true); //

            p9.Graphics.FillPath(new SolidBrush(VFOBackgroundColor), gPath); // VFOBackgroundColor

            if ((MOX) && (chkVFOATX.Checked == true))
            {
                p9.Graphics.DrawPath(new Pen(Color.Red, BorderThk), gPath); // ke9ns take color from setup Ring VFO color

            }
            else
            {
                p9.Graphics.DrawPath(new Pen(ring_vfo_color, BorderThk), gPath); // ke9ns take color from setup Ring VFO color
            }

            p9.Graphics.DrawString("VFO A", box.Font, Brushes.White, 8, 0);
            //  p.Graphics.DrawImage(vfoa, new Rectangle(-8,-9, 50, 40));




        } // grpVFOA_Paint

        float rotA = 0;  // ke9ns add angle of dial for vfoA
        float rotB = 0; // ke9ns add angle of dial for vfoB

        float ROTValue = 3.585f; // ke9ns: starting value (need to linearize it below)


        public bool dialcheckA = false;  // ke9ns add: true = update dial because vfo freq changed
        Graphics gA;

        public float XX = 0.0f;

        //===================================================================
        // ke9ns: add  THREAD old fashioned dial rotation behind the digital values
        private void DIALA()
        {
            do
            {
                Thread.Sleep(10);

                if (dialcheckA == true)
                {

                    dialcheckA = false;
                    Bitmap rotatedBmp = new Bitmap(300, 300);   //create a new empty bitmap to hold rotated image

                    rotA = (float)((VFOAFreq % 1.0) * 1000.0); // vfoafreq in mhz

                    // ke9ns: below is to linearize my photo of an old dial that had no defined center.

                    if (rotA == 0)
                    {
                        rotA = 1000f;
                        ROTValue = 3.585f;
                    }
                    else if (rotA <= 50) ROTValue = 3.860f;
                    else if (rotA <= 100) ROTValue = 3.730f;
                    else if (rotA <= 150) ROTValue = 3.690f;
                    else if (rotA <= 200) ROTValue = 3.660f;
                    else if (rotA <= 250) ROTValue = 3.630f;
                    else if (rotA <= 300) ROTValue = 3.595f;
                    else if (rotA <= 350) ROTValue = 3.595f;
                    else if (rotA <= 400) ROTValue = 3.575f;
                    else if (rotA <= 450) ROTValue = 3.565f;
                    else if (rotA <= 500) ROTValue = 3.555f;
                    else if (rotA <= 550) ROTValue = 3.560f;
                    else if (rotA <= 600) ROTValue = 3.550f;
                    else if (rotA <= 650) ROTValue = 3.550f;
                    else if (rotA <= 700) ROTValue = 3.555f;
                    else if (rotA <= 750) ROTValue = 3.560f;
                    else if (rotA <= 800) ROTValue = 3.565f;
                    else if (rotA <= 850) ROTValue = 3.570f;
                    else if (rotA <= 900) ROTValue = 3.575f;
                    else if (rotA <= 950) ROTValue = 3.580f;
                    else if (rotA <= 1000) ROTValue = 3.585f;


                    rotA = rotA / ROTValue;  // ke9ns: .188 new dial  was 2.77777F  1000 khz per revolution = 360 deg rotation or 0 to 359 = 0 to 999 khz
                    rotA = 360 - rotA; // ke9ns: original dial

                    rotatedBmp.SetResolution(72, 72); //  rotatedBmp.SetResolution(dial.HorizontalResolution, dial.VerticalResolution); // 300 x  300
                    gA = Graphics.FromImage(rotatedBmp);   //make a graphics object from the Empty bitmap area
                    gA.SmoothingMode = SmoothingMode.HighQuality;
                    gA.TranslateTransform(150, 150); //Put the rotation point in the center of the bitmap area
                    gA.RotateTransform(rotA); //rotate the bitmap area (not the dial image)
                    gA.TranslateTransform(-150F, -150F);//move the 0,0 point back to the upper left corner
                    gA.DrawImage(dial, new PointF(0, 0));      //drop dial image onto graphics object that has already been rotated
                    gA = Graphics.FromImage(rotatedBmp);   //make a graphics object from the Empty bitmap area

                    gA.DrawLine(new Pen(Color.Red, 2.0F), (float)dial.Width / 2.0F, 50, (float)dial.Width / 2.0F, 80); // ke9ns: .188 new dial was 30,150

                    VFODialA.Image = rotatedBmp;


                } // if (dialcheckA == true)

            } while (vfodial == true);
        } // DIALA


        Graphics gB;
        public bool dialcheckB = false;  // ke9ns add
        //===================================================================
        // ke9ns add  THREAD old fashioned dial rotation behind the digital values
        private void DIALB()
        {
            do
            {
                Thread.Sleep(10);

                if (dialcheckB == true)
                {
                    dialcheckB = false;

                    Bitmap rotatedBmpB = new Bitmap(300, 300);   //create a new empty bitmap to hold rotated image

                    rotB = (float)((VFOBFreq % 1.0) * 1000.0); // vfobfreq in mhz

                    if (rotB == 0)
                    {
                        rotB = 1000f;
                        ROTValue = 3.585f;
                    }
                    else if (rotB <= 50) ROTValue = 3.860f;
                    else if (rotB <= 100) ROTValue = 3.730f;
                    else if (rotB <= 150) ROTValue = 3.690f;
                    else if (rotB <= 200) ROTValue = 3.660f;
                    else if (rotB <= 250) ROTValue = 3.630f;
                    else if (rotB <= 300) ROTValue = 3.595f;
                    else if (rotB <= 350) ROTValue = 3.595f;
                    else if (rotB <= 400) ROTValue = 3.575f;
                    else if (rotB <= 450) ROTValue = 3.565f;
                    else if (rotB <= 500) ROTValue = 3.555f;
                    else if (rotB <= 550) ROTValue = 3.560f;
                    else if (rotB <= 600) ROTValue = 3.550f;
                    else if (rotB <= 650) ROTValue = 3.550f;
                    else if (rotB <= 700) ROTValue = 3.555f;
                    else if (rotB <= 750) ROTValue = 3.560f;
                    else if (rotB <= 800) ROTValue = 3.565f;
                    else if (rotB <= 850) ROTValue = 3.570f;
                    else if (rotB <= 900) ROTValue = 3.575f;
                    else if (rotB <= 950) ROTValue = 3.580f;
                    else if (rotB <= 1000) ROTValue = 3.585f;


                    rotB = rotB / ROTValue; // ke9ns: .188 new dial  //  rotB = rotB / 2.777777F; // ke9ns 1000 khz per revolution = 360 deg rotation or 0 to 359 = 0 to 999 khz
                    rotB = 360 - rotB;

                    rotatedBmpB.SetResolution(dial1.HorizontalResolution, dial1.VerticalResolution);
                    gB = Graphics.FromImage(rotatedBmpB);   //make a graphics object from the empty bitmap
                    gB.SmoothingMode = SmoothingMode.HighQuality;
                    gB.TranslateTransform(150, 150);   //Put the rotation point in the center of the bitmap area
                    gB.RotateTransform(rotB);  //rotate the empty bitmap area
                    gB.TranslateTransform(-150, -150);  //move 0,0 back to upper left corner
                    gB.DrawImage(dial1, new PointF(0, 0));   //drop your image into previously rotated bitmap
                    gB = Graphics.FromImage(rotatedBmpB);   //take this new image and put it back into a bitmap

                    gB.DrawLine(new Pen(Color.Red, 2.0F), dial1.Width / 2F, 50, dial1.Width / 2F, 80); // ke9ns:  .188 new dial

                    VFODialB.Image = rotatedBmpB;

                }

            } while (vfodial == true);

        } // DIALB




        private void grpVFOA_MouseHover(object sender, EventArgs e)
        {
            grpVFOA.Invalidate();

        }

        //=================================================================================
        // ke9ns add to draw curved colored line around groupbox
        private void grpVFOB_Paint(object sender, PaintEventArgs p7)
        {
            if ((setupForm != null))
            {
                if ((setupForm.chkVFOOpenFont.Checked == true)) vfoopenfont = true;
                else vfoopenfont = false;

                if ((setupForm.chkVFOBoldFont.Checked == true)) VFOBoldFont = true;
                else VFOBoldFont = false;


            }

            PanelTS box = (PanelTS)sender;
            //   p7.Graphics.InterpolationMode = InterpolationMode.HighQualityBicubic;
            //  p7.Graphics.SmoothingMode = SmoothingMode.HighQuality;
            //  p7.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;

            //  p7.Graphics.TextRenderingHint = TextRenderingHint.ClearTypeGridFit;
            //  p7.Graphics.CompositingMode = CompositingMode.SourceOver;
            //   p7.Graphics.CompositingQuality = CompositingQuality.HighQuality;
            p7.Graphics.InterpolationMode = InterpolationMode.HighQualityBicubic;
            p7.Graphics.SmoothingMode = SmoothingMode.HighQuality;
            p7.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;

            GraphicsPath gPath = CreatePath(1, 1, box.Width - BorderThk, box.Height - BorderThk, 8, true, true, true, true); //

            p7.Graphics.FillPath(new SolidBrush(VFOBackgroundColor), gPath); // VFOBackgroundColor

            if ((MOX) && (chkVFOBTX.Checked == true))
            {
                p7.Graphics.DrawPath(new Pen(Color.Red, BorderThk), gPath); // ke9ns take color from setup Ring VFO color

            }
            else
            {
                p7.Graphics.DrawPath(new Pen(ring_vfo_color, BorderThk), gPath); // ke9ns take color from setup Ring VFO color
            }

            p7.Graphics.DrawString("VFO B", box.Font, Brushes.White, 8, 0);

        } //grpVFOB_Paint

        private void grpVFOB_MouseHover(object sender, EventArgs e)
        {
            grpVFOB.Invalidate();
        }


        Color Border1 = Color.DarkGreen;

        //=================================================================================
        // ke9ns add to draw curved colored line around groupbox
        private void grpMultimeter_Paint(object sender, PaintEventArgs p11)
        {

            PanelTS box = (PanelTS)sender;

            // p11.Graphics.TextRenderingHint = TextRenderingHint.ClearTypeGridFit;
            //  p11.Graphics.CompositingMode = CompositingMode.SourceOver;
            //  p11.Graphics.CompositingQuality = CompositingQuality.HighQuality;
            p11.Graphics.InterpolationMode = InterpolationMode.HighQualityBicubic;
            p11.Graphics.SmoothingMode = SmoothingMode.HighQuality;
            p11.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;

            GraphicsPath gPath = CreatePath(1, 1, box.Width - BorderThk, box.Height - BorderThk, 4, true, true, true, true); //



            if (MeterMenu == true) // show RX and TX meter menu items
            {
                txtMultiText.Location = new Point(2, 37);
                picMultiMeterDigital.Location = new Point(2, 65);

                txtRX2Meter.Location = new Point(2, 37);
                picRX2Meter.Location = new Point(2, 65);

                picRX3Meter.Location = new Point(3, 36);


                grpMultimeter.Height = 147;
                grpRX2Meter.Height = 147;
            }
            else // ke9ns add: false = hide RX and TX meter select menus
            {

                txtMultiText.Location = new Point(2, 2);
                picMultiMeterDigital.Location = new Point(2, 30);


                txtRX2Meter.Location = new Point(2, 2);
                picRX2Meter.Location = new Point(2, 30);
                picRX3Meter.Location = new Point(3, 2);


                grpMultimeter.Height = 113;
                grpRX2Meter.Height = 113;

            }


            if (meterLMB == true) // ke9ns v1 (light colored meter)
            {
                LinearGradientBrush P = new LinearGradientBrush(box.ClientRectangle, Color.FromArgb(218, 218, 189), Color.FromArgb(243, 244, 211), LinearGradientMode.Horizontal);

                p11.Graphics.FillPath(P, gPath); // new SolidBrush(Color.FromArgb(0xff,0xff,0xe4))

                if (MeterMenu == true)
                {
                    p11.Graphics.DrawString("RX1 Meter          TX Meter", box.Font, Brushes.Black, 8, 2);
                    comboMeterRXMode.Visible = true;
                    comboMeterTXMode.Visible = true;
                }
                else
                {
                    comboMeterRXMode.Visible = false;
                    comboMeterTXMode.Visible = false;

                }

                txtMultiText.ForeColor = Color.Black;
                txtMultiText.BackColor = Color.FromArgb(0xff, 0xff, 0xe4);

            }
            else if (meterDMB == true)  // ke9ns (dark colored meter)
            {
                LinearGradientBrush Pp = new LinearGradientBrush(box.ClientRectangle, Color.FromArgb(64, 64, 55), Color.FromArgb(139, 139, 125), LinearGradientMode.Horizontal);

                p11.Graphics.FillPath(Pp, gPath); // new SolidBrush(Color.FromArgb(146, 146, 140))

                if (MeterMenu == true)
                {
                    p11.Graphics.DrawString("RX1 Meter          TX Meter", box.Font, Brushes.White, 8, 2);
                    comboMeterRXMode.Visible = true;
                    comboMeterTXMode.Visible = true;
                }
                else
                {
                    comboMeterRXMode.Visible = false;
                    comboMeterTXMode.Visible = false;

                }

                txtMultiText.ForeColor = Color.Black;
                txtMultiText.BackColor = Color.FromArgb(139, 139, 125);

            }
            else
            {

                p11.Graphics.FillPath(new SolidBrush(AnalogMeterBackgroundColor), gPath);

                if (MeterMenu == true)
                {
                    p11.Graphics.DrawString("RX1 Meter          TX Meter", box.Font, Brushes.White, 8, 2);
                    comboMeterRXMode.Visible = true;
                    comboMeterTXMode.Visible = true;

                }
                else
                {
                    comboMeterRXMode.Visible = false;
                    comboMeterTXMode.Visible = false;

                }

                txtMultiText.ForeColor = MeterDigitalTextColor;
                txtMultiText.BackColor = MeterDigitalBackgroundColor;
            }

            p11.Graphics.DrawPath(new Pen(ring_vfo_color, BorderThk), gPath); // ke9ns take color from setup Ring VFO color

            if (metermenu != 0) // ke9ns update console posisions
            {
                metermenu = metermenu & ~1;

                Console_Resize(this, EventArgs.Empty);
            }



        } // grpMultimeter_Paint

        //=================================================================================
        // ke9ns add to draw curved colored line around groupbox
        private void grpRX2Meter_Paint(object sender, PaintEventArgs p10)
        {
            PanelTS box = (PanelTS)sender;
            //  p10.Graphics.InterpolationMode = InterpolationMode.HighQualityBicubic;
            //   p10.Graphics.SmoothingMode = SmoothingMode.HighQuality;
            //  p10.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;

            //  p10.Graphics.TextRenderingHint = TextRenderingHint.ClearTypeGridFit;
            //  p10.Graphics.CompositingMode = CompositingMode.SourceOver;
            //  p10.Graphics.CompositingQuality = CompositingQuality.HighQuality;
            p10.Graphics.InterpolationMode = InterpolationMode.HighQualityBicubic;
            p10.Graphics.SmoothingMode = SmoothingMode.HighQuality;
            p10.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;

            GraphicsPath gPath = CreatePath(1, 1, box.Width - BorderThk, box.Height - BorderThk, 4, true, true, true, true); //



            if (MeterMenu == true) // show RX and TX meter menu items
            {
                txtMultiText.Location = new Point(2, 37);
                picMultiMeterDigital.Location = new Point(2, 65);

                txtRX2Meter.Location = new Point(2, 37);
                picRX2Meter.Location = new Point(2, 65);

                picRX3Meter.Location = new Point(3, 36);


                grpMultimeter.Height = 147;
                grpRX2Meter.Height = 147;
            }
            else // ke9ns add: false = hide RX and TX meter select menus
            {

                txtMultiText.Location = new Point(2, 2);
                picMultiMeterDigital.Location = new Point(2, 30);


                txtRX2Meter.Location = new Point(2, 2);
                picRX2Meter.Location = new Point(2, 30);
                picRX3Meter.Location = new Point(3, 2);


                grpMultimeter.Height = 113;
                grpRX2Meter.Height = 113;

            }


            if (meterLMB == true)
            {
                LinearGradientBrush P = new LinearGradientBrush(box.ClientRectangle, Color.FromArgb(218, 218, 189), Color.FromArgb(243, 244, 211), LinearGradientMode.Horizontal);

                p10.Graphics.FillPath(P, gPath); // color of the light meter background  new SolidBrush(Color.FromArgb(0xff, 0xff, 0xe4))

                if (MeterMenu == true)
                {

                    if (FWCEEPROM.RX2OK)  // if no 2nd receiver then make the 2nd meter visable
                    {
                        p10.Graphics.DrawString("RX2 Meter          TX Meter(2nd)", box.Font, Brushes.Black, 8, 2);
                    }
                    else
                    {
                        p10.Graphics.DrawString("TX Meter(2nd)", box.Font, Brushes.Black, 88, 2);
                    }
                    comboRX2MeterMode.Visible = true;
                    comboMeterTX1Mode.Visible = true;
                }
                else
                {
                    comboRX2MeterMode.Visible = false;
                    comboMeterTX1Mode.Visible = false;


                }

                //  grpRX2Meter.Text = "------------------------ TX Meter (2nd)";

                txtRX2Meter.ForeColor = Color.Black;
                txtRX2Meter.BackColor = Color.FromArgb(0xff, 0xff, 0xe4);
            }
            else if (meterDMB == true)
            {
                LinearGradientBrush P = new LinearGradientBrush(box.ClientRectangle, Color.FromArgb(64, 64, 55), Color.FromArgb(139, 139, 125), LinearGradientMode.Horizontal);

                p10.Graphics.FillPath(P, gPath); // color of the dark meter background new SolidBrush(Color.FromArgb(146,146,140))


                if (MeterMenu == true)
                {

                    if (FWCEEPROM.RX2OK)  // if no 2nd receiver then make the 2nd meter visable
                    {
                        p10.Graphics.DrawString("RX2 Meter          TX Meter(2nd)", box.Font, Brushes.White, 8, 2);
                    }
                    else
                    {
                        p10.Graphics.DrawString("TX Meter(2nd)", box.Font, Brushes.White, 88, 2);
                    }
                    comboRX2MeterMode.Visible = true;
                    comboMeterTX1Mode.Visible = true;
                }
                else
                {
                    comboRX2MeterMode.Visible = false;
                    comboMeterTX1Mode.Visible = false;

                }


                txtRX2Meter.ForeColor = Color.Black;
                //  txtRX2Meter.BackColor = Color.FromArgb(146, 146, 140);
                txtRX2Meter.BackColor = Color.FromArgb(139, 139, 125);
            }
            else
            {
                p10.Graphics.FillPath(new SolidBrush(AnalogMeterBackgroundColor), gPath);

                if (MeterMenu == true)
                {

                    if (FWCEEPROM.RX2OK)  // if no 2nd receiver then make the 2nd meter visable
                    {
                        p10.Graphics.DrawString("RX2 Meter          TX Meter(2nd)", box.Font, Brushes.White, 8, 2);
                    }
                    else
                    {
                        p10.Graphics.DrawString("TX Meter(2nd)", box.Font, Brushes.White, 88, 2);
                    }
                    comboRX2MeterMode.Visible = true;
                    comboMeterTX1Mode.Visible = true;
                }
                else
                {
                    comboRX2MeterMode.Visible = false;
                    comboMeterTX1Mode.Visible = false;

                }


                txtRX2Meter.ForeColor = MeterDigitalTextColor;
                txtRX2Meter.BackColor = MeterDigitalBackgroundColor;
            }

            p10.Graphics.DrawPath(new Pen(ring_vfo_color, BorderThk), gPath); // ke9ns take color from setup Ring VFO color

            if (metermenu != 0) // ke9ns update console posisions
            {
                metermenu = metermenu & ~2;

                Console_Resize(this, EventArgs.Empty);
            }



        } //  grpRX2Meter_Paint


        //=======================================================================================================
        //=======================================================================================================
        //  grpVFOA.Paint += PaintBorderlessGroupBox;
        // ke9ns add draw rounded box around groupbox (but prefer to use the grpVFOA_PAINT event instead of this)
        private void PaintBorderlessGroupBox(object sender, PaintEventArgs p6)
        {
            GroupBoxTS box = (GroupBoxTS)sender;

            GraphicsPath gPath = CreatePath(0, 0, box.Width - 1, box.Height - 1, 4, true, true, true, true); //

            p6.Graphics.Clear(Color.Transparent);  // box.Parent.BackColor

            //   p6.Graphics.InterpolationMode = InterpolationMode.HighQualityBicubic;
            //   p6.Graphics.SmoothingMode = SmoothingMode.HighQuality;
            //   p6.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;

            //   p6.Graphics.TextRenderingHint = TextRenderingHint.ClearTypeGridFit;
            //   p6.Graphics.CompositingMode = CompositingMode.SourceOver;
            //   p6.Graphics.CompositingQuality = CompositingQuality.HighQuality;
            p6.Graphics.InterpolationMode = InterpolationMode.HighQualityBicubic;
            p6.Graphics.SmoothingMode = SmoothingMode.HighQuality;
            p6.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;


            p6.Graphics.FillPath(new SolidBrush(Color.Transparent), gPath);
            p6.Graphics.DrawPath(new Pen(Color.Green, 2.2f), gPath);

            p6.Graphics.DrawString(box.Text, box.Font, Brushes.White, 8, 0);

        } // PaintBorderlessGroupBox






        //  ToolTip tt = new ToolTip();
        private void TXIDMenuItem_MouseHover(object sender, EventArgs e)
        {
            //  tt.Show("Click 'LIVE ...", this.menuStrip1, 10000);

        }

        public bool QuickRec2 = false; // .252 true = quick record rx2

        //=======================================================================
        // ke9ns add  PLAY button opens folder 
        //=======================================================================
        private void ckQuickRec_MouseDown(object sender, MouseEventArgs e)
        {

            MouseEventArgs me = (MouseEventArgs)e;

            if (me.Button == System.Windows.Forms.MouseButtons.Middle) //.252 record rx2
            {
                if ((checkBoxID.Checked == true)) // ke9ns add (Rec/Play ID box checked) allow tx on play directly so you dont need to mox and play
                {

                    if ((ckQuickRec.Checked)) // if enabled (recording)
                    {
                        oldmode = RX1DSPMode;
                        if ((oldmode == DSPMode.FM) || (oldmode == DSPMode.AM) || (oldmode == DSPMode.SAM) || (oldmode == DSPMode.DSB)) RX1DSPMode = DSPMode.USB; // record only in SSB mode

                        if (chkVAC1.Checked)
                        {
                            vac1 = 1;
                            //  chkVAC1.Checked = false; // ke9ns mod  .122 bypass this to allow PC mic to be used to record voice keyer audio recordings.
                        }

                        chkMOX.Checked = true;     // key radio 
                        QuickRec2 = true; // .252
                        WaveForm.QuickRec = true;
                        ckQuickPlay.Enabled = true;
                        ckQuickRec.BackColor = button_selected_color;
                        temp_PWR = PWR; // ptbPWR.Value; // record current drive settings
                        PWR = 0; // ptbPWR.Value = 0; // turn drive off for recording


                    }
                    else
                    {
                        QuickRec2 = false; // .252
                        WaveForm.QuickRec = false;
                        chkMOX.Checked = false;     // unkey radio
                        ckQuickRec.BackColor = SystemColors.Control;//k6jca 1/13/08
                                                                    //ptbPWR.Value
                        PWR = temp_PWR; // turn drive level back up to prior setting

                        if (oldmode != DSPMode.FIRST)
                        {
                            RX1DSPMode = oldmode;
                            oldmode = DSPMode.FIRST;
                        }

                        if (vac1 == 1)
                        {
                            vac1 = 0;
                            Thread.Sleep(100);
                            chkVAC1.Checked = true;
                        }

                    }

                    ckQuickPlay.Enabled = !ckQuickRec.Checked;
                }

                //--------------------------------------------------
                else // ke9ns original way to doing quickaudio
                {
                    if (ckQuickRec.Checked == false && QuickRec2 == false) // actual REC button on console screen pressed (RED)
                    {

                        QuickRec2 = true; // .252
                        WaveForm.QuickRec = true;
                        ckQuickPlay.Enabled = true;
                        ckQuickRec.BackColor = Color.Red; // button_selected_color; // RED
                        
                        ckQuickRec.Text = "RX2";


                       

                    }
                    else
                    {

                        QuickRec2 = false; // .252
                        WaveForm.QuickRec = false;
                        ckQuickRec.BackColor = SystemColors.Control;//k6jca 1/13/08
                        ckQuickRec.Text = "  ";

                    }

                    ckQuickPlay.Enabled = !ckQuickRec.Checked;
                }



            }
            else if (me.Button == System.Windows.Forms.MouseButtons.Right)
            {
                /*
                                if (WaveForm.IsDisposed)
                                    WaveForm = new WaveControl(this);
                                WaveForm.Show();
                                WaveForm.Focus();

                            */

                string filePath = AppDataPath + "ke9ns8.dat";
                string filePath1 = AppDataPath + "QuickAudio\\";


                if (WaveForm.chkQuickAudioFolder.Checked == false) // ke9ns do below if standard quickqudio
                {
                    if (!File.Exists(filePath))
                    {
                        Debug.WriteLine("problem no ke9ns dat file found");
                        return;
                    }

                    string argument = @"/select, " + filePath;
                    //   Debug.WriteLine("filepath " + argument);

                    System.Diagnostics.Process.Start("explorer.exe", argument);
                }
                else // do below if subfolder sequential quickaudio
                {


                    if (!Directory.Exists(filePath1))
                    {
                        // create PowerSDR audio folder if it does not exist
                        //  Directory.CreateDirectory(wave_folder);
                        Debug.WriteLine("problem no ke9ns dat file found");
                        return;

                    }
                    string argument = @"/select, " + filePath1;

                    //   Debug.WriteLine("filepath1 " + argument);

                    System.Diagnostics.Process.Start("explorer.exe", argument);

                } // 



            } // right mouse button click


        } // ckQuickRec_MouseDown



        //============================================================================ 
        //============================================================================ 
        // ke9ns add: Click here to 1 time autoadjust waterfall level
        //============================================================================ 
        //============================================================================ 

        public bool waterpanClick = false; // RX1 true = a click and not auto mode
        public bool waterpanClick2 = false; //RX2 true = a click and not auto mode
        public bool waterpanClick3 = false; //RX2 true = a click and not auto mode

        public void autoBrightBox_Click(object sender, EventArgs e)
        {


            if (Display.continuum == 0)
            {
                waterpanClick = true;
                waterpanClick2 = true;
                waterpanClick3 = true;
                Display.AutoBright = 1; // adjust RX or TX

                AGCTUPDATE = true;
            }
            else // in continuum mode so restart
            {
                Display.K14 = 0; // click to restart continuum 
            }

            btnHidden.Focus();


        } // autoBrightBox_Click


        //============================================================================ 
        //============================================================================ 
        // ke9ns add Scanner function
        //============================================================================ 
        //============================================================================ 
        private void ScanMenuItem_Click(object sender, EventArgs e)
        {
            if (ScanForm == null || ScanForm.IsDisposed)
                ScanForm = new ScanControl(this);
            ScanForm.Show();
            ScanForm.Focus();
            ScanForm.WindowState = FormWindowState.Normal; // ke9ns add

        }  //  ScanMenuItem_Click



        //===============================================================================================
        // ke9ns add GENERAL SWL BANDS here

        private void radBandGEN0_Click(object sender, EventArgs e)
        {
            SaveBandA();
            if (last_band.Equals("LMF"))
            {
                if ((Control.ModifierKeys & Keys.Shift) == Keys.Shift)
                    band_LMF_index = (band_LMF_index - 1 + band_LMF_register) % band_LMF_register;
                else
                    band_LMF_index = (band_LMF_index + 1) % band_LMF_register;
            }
            last_band = "LMF";

            string filter, mode;
            double freq;
            if (DB.GetBandStack(last_band, band_LMF_index, out mode, out filter, out freq))
            {
                if (filter.Contains("@")) filter = filter.Substring(0, (filter.Length) - 1); // ke9ns add for bandstack lockout

                SetBand(mode, filter, freq);
            }
            UpdateWaterfallLevelValues();

        } // MF or AM band in USA

        private void radBandGEN1_Click(object sender, EventArgs e)
        {
            SaveBandA();

            if (last_band.Equals("120M"))
            {
                if ((Control.ModifierKeys & Keys.Shift) == Keys.Shift)
                {
                    band_120m_index = (band_120m_index - 1 + band_120m_register) % band_120m_register;
                }
                else
                {
                    band_120m_index = (band_120m_index + 1) % band_120m_register; // ke9ns get the remainder as an index for the next bandstack
                }
            }
            last_band = "120M";

            string filter, mode;
            double freq;
            if (DB.GetBandStack(last_band, band_120m_index, out mode, out filter, out freq))
            {
                if (filter.Contains("@")) filter = filter.Substring(0, (filter.Length) - 1); // ke9ns add for bandstack lockout

                SetBand(mode, filter, freq);
            }
            UpdateWaterfallLevelValues();
        } // 120m

        private void radBandGEN2_Click(object sender, EventArgs e)
        {
            SaveBandA();
            if (last_band.Equals("90M"))
            {
                if ((Control.ModifierKeys & Keys.Shift) == Keys.Shift)
                    band_90m_index = (band_90m_index - 1 + band_90m_register) % band_90m_register;
                else
                    band_90m_index = (band_90m_index + 1) % band_90m_register;
            }
            last_band = "90M";

            string filter, mode;
            double freq;
            if (DB.GetBandStack(last_band, band_90m_index, out mode, out filter, out freq))
            {
                if (filter.Contains("@")) filter = filter.Substring(0, (filter.Length) - 1); // ke9ns add for bandstack lockout

                SetBand(mode, filter, freq);
            }
            UpdateWaterfallLevelValues();
        } // 90m

        private void radBandGEN3_Click(object sender, EventArgs e)
        {
            SaveBandA();
            if (last_band.Equals("61M"))
            {
                if ((Control.ModifierKeys & Keys.Shift) == Keys.Shift)
                    band_61m_index = (band_61m_index - 1 + band_61m_register) % band_61m_register;
                else
                    band_61m_index = (band_61m_index + 1) % band_61m_register;
            }
            last_band = "61M";

            string filter, mode;
            double freq;
            if (DB.GetBandStack(last_band, band_61m_index, out mode, out filter, out freq))
            {
                if (filter.Contains("@")) filter = filter.Substring(0, (filter.Length) - 1); // ke9ns add for bandstack lockout

                SetBand(mode, filter, freq);
            }
            UpdateWaterfallLevelValues();
        } // 60m

        private void radBandGEN4_Click(object sender, EventArgs e)
        {

            SaveBandA();
            if (last_band.Equals("49M"))
            {
                if ((Control.ModifierKeys & Keys.Shift) == Keys.Shift)
                    band_49m_index = (band_49m_index - 1 + band_49m_register) % band_49m_register;
                else
                    band_49m_index = (band_49m_index + 1) % band_49m_register;
            }
            last_band = "49M";


            string filter, mode;
            double freq;
            if (DB.GetBandStack(last_band, band_49m_index, out mode, out filter, out freq))
            {
                if (filter.Contains("@")) filter = filter.Substring(0, (filter.Length) - 1); // ke9ns add for bandstack lockout

                SetBand(mode, filter, freq);
            }
            UpdateWaterfallLevelValues();

        } // 49m


        private void radBandGEN5_Click(object sender, EventArgs e)
        {
            // since there is no TX calibration for outside of ham bands you must use the closest ham band (60m in this case)
            // SetTXBand()
            SaveBandA();
            if (last_band.Equals("41M"))
            {
                if ((Control.ModifierKeys & Keys.Shift) == Keys.Shift)
                    band_41m_index = (band_41m_index - 1 + band_41m_register) % band_41m_register;
                else
                    band_41m_index = (band_41m_index + 1) % band_41m_register;
            }
            last_band = "41M";


            string filter, mode;
            double freq;
            if (DB.GetBandStack(last_band, band_41m_index, out mode, out filter, out freq))
            {
                if (filter.Contains("@")) filter = filter.Substring(0, (filter.Length) - 1); // ke9ns add for bandstack lockout

                SetBand(mode, filter, freq);
            }
            UpdateWaterfallLevelValues();


        } // 41m

        private void radBandGEN6_Click(object sender, EventArgs e)
        {
            SaveBandA();
            if (last_band.Equals("31M"))
            {
                if ((Control.ModifierKeys & Keys.Shift) == Keys.Shift)
                    band_31m_index = (band_31m_index - 1 + band_31m_register) % band_31m_register;
                else
                    band_31m_index = (band_31m_index + 1) % band_31m_register;
            }
            last_band = "31M";

            string filter, mode;
            double freq;
            if (DB.GetBandStack(last_band, band_31m_index, out mode, out filter, out freq))
            {
                if (filter.Contains("@")) filter = filter.Substring(0, (filter.Length) - 1); // ke9ns add for bandstack lockout

                SetBand(mode, filter, freq);
            }
            UpdateWaterfallLevelValues();
        } //31m

        private void radBandGEN7_CheckedChanged(object sender, EventArgs e)
        {
            SaveBandA();
            if (last_band.Equals("25M"))
            {
                if ((Control.ModifierKeys & Keys.Shift) == Keys.Shift)
                    band_25m_index = (band_25m_index - 1 + band_25m_register) % band_25m_register;
                else
                    band_25m_index = (band_25m_index + 1) % band_25m_register;
            }
            last_band = "25M";

            string filter, mode;
            double freq;
            if (DB.GetBandStack(last_band, band_25m_index, out mode, out filter, out freq))
            {
                if (filter.Contains("@")) filter = filter.Substring(0, (filter.Length) - 1); // ke9ns add for bandstack lockout

                SetBand(mode, filter, freq);
            }
            UpdateWaterfallLevelValues();
        } // 25m

        private void radBandGEN8_Click(object sender, EventArgs e)
        {
            SaveBandA();
            if (last_band.Equals("22M"))
            {
                if ((Control.ModifierKeys & Keys.Shift) == Keys.Shift)
                    band_22m_index = (band_22m_index - 1 + band_22m_register) % band_22m_register;
                else
                    band_22m_index = (band_22m_index + 1) % band_22m_register;
            }
            last_band = "22M";

            string filter, mode;
            double freq;
            if (DB.GetBandStack(last_band, band_22m_index, out mode, out filter, out freq))
            {
                if (filter.Contains("@")) filter = filter.Substring(0, (filter.Length) - 1); // ke9ns add for bandstack lockout

                SetBand(mode, filter, freq);
            }
            UpdateWaterfallLevelValues();
        } // 22m

        private void radBandGEN9_Click(object sender, EventArgs e)
        {
            SaveBandA();
            if (last_band.Equals("19M"))
            {
                if ((Control.ModifierKeys & Keys.Shift) == Keys.Shift)
                    band_19m_index = (band_19m_index - 1 + band_19m_register) % band_19m_register;
                else
                    band_19m_index = (band_19m_index + 1) % band_19m_register;
            }
            last_band = "19M";

            string filter, mode;
            double freq;
            if (DB.GetBandStack(last_band, band_19m_index, out mode, out filter, out freq))
            {
                if (filter.Contains("@")) filter = filter.Substring(0, (filter.Length) - 1); // ke9ns add for bandstack lockout

                SetBand(mode, filter, freq);
            }
            UpdateWaterfallLevelValues();
        } // 19m

        private void radBandGEN10_Click(object sender, EventArgs e)
        {
            SaveBandA();
            if (last_band.Equals("16M"))
            {
                if ((Control.ModifierKeys & Keys.Shift) == Keys.Shift)
                    band_16m_index = (band_16m_index - 1 + band_16m_register) % band_16m_register;
                else
                    band_16m_index = (band_16m_index + 1) % band_16m_register;
            }
            last_band = "16M";

            string filter, mode;
            double freq;
            if (DB.GetBandStack(last_band, band_16m_index, out mode, out filter, out freq))
            {
                if (filter.Contains("@")) filter = filter.Substring(0, (filter.Length) - 1); // ke9ns add for bandstack lockout

                SetBand(mode, filter, freq);
            }
            UpdateWaterfallLevelValues();
        } //16m

        private void radBandGEN11_Click(object sender, EventArgs e)
        {
            SaveBandA();
            if (last_band.Equals("14M"))
            {
                if ((Control.ModifierKeys & Keys.Shift) == Keys.Shift)
                    band_14m_index = (band_14m_index - 1 + band_14m_register) % band_14m_register;
                else
                    band_14m_index = (band_14m_index + 1) % band_14m_register;
            }
            last_band = "14M";

            string filter, mode;
            double freq;
            if (DB.GetBandStack(last_band, band_14m_index, out mode, out filter, out freq))
            {
                if (filter.Contains("@")) filter = filter.Substring(0, (filter.Length) - 1); // ke9ns add for bandstack lockout

                SetBand(mode, filter, freq);
            }
            UpdateWaterfallLevelValues();
        } // 14m

        private void radBandGEN12_Click(object sender, EventArgs e)
        {
            SaveBandA();
            if (last_band.Equals("13M"))
            {
                if ((Control.ModifierKeys & Keys.Shift) == Keys.Shift)
                    band_13m_index = (band_13m_index - 1 + band_13m_register) % band_13m_register;
                else
                    band_13m_index = (band_13m_index + 1) % band_13m_register;
            }
            last_band = "13M";

            string filter, mode;
            double freq;
            if (DB.GetBandStack(last_band, band_13m_index, out mode, out filter, out freq))
            {
                if (filter.Contains("@")) filter = filter.Substring(0, (filter.Length) - 1); // ke9ns add for bandstack lockout

                SetBand(mode, filter, freq);
            }
            UpdateWaterfallLevelValues();
        } // 13m 

        private void radBandGEN13_Click(object sender, EventArgs e)
        {
            SaveBandA();
            if (last_band.Equals("11M"))
            {
                if ((Control.ModifierKeys & Keys.Shift) == Keys.Shift)
                    band_11m_index = (band_11m_index - 1 + band_11m_register) % band_11m_register;
                else
                    band_11m_index = (band_11m_index + 1) % band_11m_register;
            }
            last_band = "11M";

            string filter, mode;
            double freq;
            if (DB.GetBandStack(last_band, band_11m_index, out mode, out filter, out freq))
            {
                if (filter.Contains("@")) filter = filter.Substring(0, (filter.Length) - 1); // ke9ns add for bandstack lockout

                SetBand(mode, filter, freq);
            }
            UpdateWaterfallLevelValues();

        } // 11m


        //==========================================================================
        // ke9ns add RIGHT CLICK to add bandstack to list
        private void radBand160_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;


            if ((regBand == 1) && (me.Button == System.Windows.Forms.MouseButtons.Right)) // regband is 1 when control key held down
            {
                if (band_160m_register < 10)
                    DB.AddBandStack("160M", rx1_dsp_mode.ToString(), rx1_filter.ToString(), Math.Round(VFOAFreq, 6)); // take current band, DSP mode, filter, and freq
                UpdateBandStackRegisters();
                UpdateBandButtonColors();

            } // right click



        } //  radBand160_MouseDown

        private void radBand80_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((regBand == 1) && (me.Button == System.Windows.Forms.MouseButtons.Right))
            {
                if (band_80m_register < 10)
                    DB.AddBandStack("80M", rx1_dsp_mode.ToString(), rx1_filter.ToString(), Math.Round(VFOAFreq, 6)); // take current band, DSP mode, filter, and freq
                UpdateBandStackRegisters();
                UpdateBandButtonColors();
            } // right click

        }//  radBand80_MouseDown

        private void radBand60_MouseDown(object sender, MouseEventArgs e)
        {
            // channelized

        }

        private void radBand40_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((regBand == 1) && (me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                if (band_40m_register < 10)
                    DB.AddBandStack("40M", rx1_dsp_mode.ToString(), rx1_filter.ToString(), Math.Round(VFOAFreq, 6)); // take current band, DSP mode, filter, and freq

                UpdateBandStackRegisters();
                UpdateBandButtonColors();

            } // right click

        }

        private void radBand30_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((regBand == 1) && (me.Button == System.Windows.Forms.MouseButtons.Right))
            {
                if (band_30m_register < 10)
                    DB.AddBandStack("30M", rx1_dsp_mode.ToString(), rx1_filter.ToString(), Math.Round(VFOAFreq, 6)); // take current band, DSP mode, filter, and freq
                UpdateBandStackRegisters();
                UpdateBandButtonColors();
            } // right click

        }

        private void radBand20_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((regBand == 1) && (me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                if (band_20m_register < 10)
                    DB.AddBandStack("20M", rx1_dsp_mode.ToString(), rx1_filter.ToString(), Math.Round(VFOAFreq, 6)); // take current band, DSP mode, filter, and freq
                UpdateBandStackRegisters();
                UpdateBandButtonColors();
            } // right click

        }

        private void radBand17_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((regBand == 1) && (me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                if (band_17m_register < 10)
                    DB.AddBandStack("17M", rx1_dsp_mode.ToString(), rx1_filter.ToString(), Math.Round(VFOAFreq, 6)); // take current band, DSP mode, filter, and freq
                UpdateBandStackRegisters();
                UpdateBandButtonColors();
            } // right click
        }

        private void radBand15_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((regBand == 1) && (me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                if (band_15m_register < 10)
                    DB.AddBandStack("15M", rx1_dsp_mode.ToString(), rx1_filter.ToString(), Math.Round(VFOAFreq, 6)); // take current band, DSP mode, filter, and freq
                UpdateBandStackRegisters();
                UpdateBandButtonColors();

            } // right click
        }

        private void radBand12_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((regBand == 1) && (me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                if (band_12m_register < 10)
                    DB.AddBandStack("12M", rx1_dsp_mode.ToString(), rx1_filter.ToString(), Math.Round(VFOAFreq, 6)); // take current band, DSP mode, filter, and freq
                UpdateBandStackRegisters();
                UpdateBandButtonColors();

            } // right click
        }

        private void radBand10_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((regBand == 1) && (me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                if (band_10m_register < 10)
                    DB.AddBandStack("10M", rx1_dsp_mode.ToString(), rx1_filter.ToString(), Math.Round(VFOAFreq, 6)); // take current band, DSP mode, filter, and freq
                UpdateBandStackRegisters();
                UpdateBandButtonColors();

            } // right click
        }

        private void radBand6_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((regBand == 1) && (me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                if (band_6m_register < 10)
                    DB.AddBandStack("6M", rx1_dsp_mode.ToString(), rx1_filter.ToString(), Math.Round(VFOAFreq, 6)); // take current band, DSP mode, filter, and freq
                UpdateBandStackRegisters();
                UpdateBandButtonColors();

            } // right click
        }

        private void radBandGN0_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((regBand == 1) && (me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                if (band_LMF_register < 10)
                    DB.AddBandStack("LMF", rx1_dsp_mode.ToString(), rx1_filter.ToString(), Math.Round(VFOAFreq, 6)); // take current band, DSP mode, filter, and freq
                UpdateBandStackRegisters();
                UpdateBandButtonColors();

            } // right click
        }

        private void radBandGN1_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((regBand == 1) && (me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                if (band_120m_register < 10)
                    DB.AddBandStack("120M", rx1_dsp_mode.ToString(), rx1_filter.ToString(), Math.Round(VFOAFreq, 6)); // take current band, DSP mode, filter, and freq
                UpdateBandStackRegisters();
                UpdateBandButtonColors();

            } // right click
        }

        private void radBandGN2_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((regBand == 1) && (me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                if (band_90m_register < 10)
                    DB.AddBandStack("90M", rx1_dsp_mode.ToString(), rx1_filter.ToString(), Math.Round(VFOAFreq, 6)); // take current band, DSP mode, filter, and freq
                UpdateBandStackRegisters();
                UpdateBandButtonColors();

            } // right click
        }

        private void radBandGN3_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((regBand == 1) && (me.Button == System.Windows.Forms.MouseButtons.Right))
            {
                if (band_61m_register < 10)
                    DB.AddBandStack("61M", rx1_dsp_mode.ToString(), rx1_filter.ToString(), Math.Round(VFOAFreq, 6)); // take current band, DSP mode, filter, and freq
                UpdateBandStackRegisters();
                UpdateBandButtonColors();

            } // right click
        }

        private void radBandGN4_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((regBand == 1) && (me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                if (band_49m_register < 10)
                    DB.AddBandStack("49M", rx1_dsp_mode.ToString(), rx1_filter.ToString(), Math.Round(VFOAFreq, 6)); // take current band, DSP mode, filter, and freq
                if (band_160m_register < 10)
                    UpdateBandStackRegisters();
                UpdateBandButtonColors();

            } // right click
        }

        private void radBandGN5_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((regBand == 1) && (me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                if (band_41m_register < 10)
                    DB.AddBandStack("41M", rx1_dsp_mode.ToString(), rx1_filter.ToString(), Math.Round(VFOAFreq, 6)); // take current band, DSP mode, filter, and freq
                UpdateBandStackRegisters();
                UpdateBandButtonColors();

            } // right click
        }

        private void radBandGN6_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((regBand == 1) && (me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                if (band_31m_register < 10)
                    DB.AddBandStack("31M", rx1_dsp_mode.ToString(), rx1_filter.ToString(), Math.Round(VFOAFreq, 6)); // take current band, DSP mode, filter, and freq
                UpdateBandStackRegisters();
                UpdateBandButtonColors();

            } // right click
        }

        private void radBandGN7_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((regBand == 1) && (me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                if (band_25m_register < 10)
                    DB.AddBandStack("25M", rx1_dsp_mode.ToString(), rx1_filter.ToString(), Math.Round(VFOAFreq, 6)); // take current band, DSP mode, filter, and freq
                UpdateBandStackRegisters();
                UpdateBandButtonColors();

            } // right click
        }

        private void radBandGN8_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((regBand == 1) && (me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                if (band_22m_register < 10)
                    DB.AddBandStack("22M", rx1_dsp_mode.ToString(), rx1_filter.ToString(), Math.Round(VFOAFreq, 6)); // take current band, DSP mode, filter, and freq
                UpdateBandStackRegisters();
                UpdateBandButtonColors();

            } // right click
        }

        private void radBandGN9_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((regBand == 1) && (me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                if (band_19m_register < 10)
                    DB.AddBandStack("19M", rx1_dsp_mode.ToString(), rx1_filter.ToString(), Math.Round(VFOAFreq, 6)); // take current band, DSP mode, filter, and freq
                UpdateBandStackRegisters();
                UpdateBandButtonColors();

            } // right click
        }

        private void radBandGN10_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((regBand == 1) && (me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                if (band_16m_register < 10)
                    DB.AddBandStack("16M", rx1_dsp_mode.ToString(), rx1_filter.ToString(), Math.Round(VFOAFreq, 6)); // take current band, DSP mode, filter, and freq
                UpdateBandStackRegisters();
                UpdateBandButtonColors();

            } // right click
        }

        private void radBandGN11_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((regBand == 1) && (me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                if (band_14m_register < 10)
                    DB.AddBandStack("14M", rx1_dsp_mode.ToString(), rx1_filter.ToString(), Math.Round(VFOAFreq, 6)); // take current band, DSP mode, filter, and freq
                UpdateBandStackRegisters();
                UpdateBandButtonColors();

            } // right click
        }

        private void radBandGN12_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((regBand == 1) && (me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                if (band_13m_register < 10)
                    DB.AddBandStack("13M", rx1_dsp_mode.ToString(), rx1_filter.ToString(), Math.Round(VFOAFreq, 6)); // take current band, DSP mode, filter, and freq
                UpdateBandStackRegisters();
                UpdateBandButtonColors();

            } // right click
        }

        private void radBandGN13_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((regBand == 1) && (me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                if (band_11m_register < 10)
                    DB.AddBandStack("11M", rx1_dsp_mode.ToString(), rx1_filter.ToString(), Math.Round(VFOAFreq, 6)); // take current band, DSP mode, filter, and freq
                UpdateBandStackRegisters();
                UpdateBandButtonColors();

            } // right click
        }

        private void radBandVHF0_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((regBand == 1) && (me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                if (band_vhf0_register < 10)
                    DB.AddBandStack("VHF0", rx1_dsp_mode.ToString(), rx1_filter.ToString(), Math.Round(VFOAFreq, 6)); // take current band, DSP mode, filter, and freq
                UpdateBandStackRegisters();
                UpdateBandButtonColors();

            } // right click
        }

        private void radBandVHF1_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((regBand == 1) && (me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                if (band_vhf1_register < 10)
                    DB.AddBandStack("VHF1", rx1_dsp_mode.ToString(), rx1_filter.ToString(), Math.Round(VFOAFreq, 6)); // take current band, DSP mode, filter, and freq
                UpdateBandStackRegisters();
                UpdateBandButtonColors();

            } // right click
        }

        private void radBandVHF2_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((regBand == 1) && (me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                if (band_vhf2_register < 10)
                    DB.AddBandStack("VHF2", rx1_dsp_mode.ToString(), rx1_filter.ToString(), Math.Round(VFOAFreq, 6)); // take current band, DSP mode, filter, and freq
                UpdateBandStackRegisters();
                UpdateBandButtonColors();

            } // right click
        }


        private void radBandVHF3_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((regBand == 1) && (me.Button == System.Windows.Forms.MouseButtons.Right))
            {
                if (band_vhf3_register < 10)
                    DB.AddBandStack("VHF3", rx1_dsp_mode.ToString(), rx1_filter.ToString(), Math.Round(VFOAFreq, 6)); // take current band, DSP mode, filter, and freq
                UpdateBandStackRegisters();
                UpdateBandButtonColors();

            } // right click
        }


        private void radBandVHF4_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((regBand == 1) && (me.Button == System.Windows.Forms.MouseButtons.Right))
            {
                if (band_vhf4_register < 10)
                    DB.AddBandStack("VHF4", rx1_dsp_mode.ToString(), rx1_filter.ToString(), Math.Round(VFOAFreq, 6)); // take current band, DSP mode, filter, and freq
                UpdateBandStackRegisters();
                UpdateBandButtonColors();

            } // right click
        }

        private void radBandVHF5_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((regBand == 1) && (me.Button == System.Windows.Forms.MouseButtons.Right))
            {
                if (band_vhf5_register < 10)
                    DB.AddBandStack("VHF5", rx1_dsp_mode.ToString(), rx1_filter.ToString(), Math.Round(VFOAFreq, 6)); // take current band, DSP mode, filter, and freq
                UpdateBandStackRegisters();
                UpdateBandButtonColors();

            } // right click
        }



        private void radBandVHF6_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((regBand == 1) && (me.Button == System.Windows.Forms.MouseButtons.Right))
            {
                if (band_vhf6_register < 10)
                    DB.AddBandStack("VHF6", rx1_dsp_mode.ToString(), rx1_filter.ToString(), Math.Round(VFOAFreq, 6)); // take current band, DSP mode, filter, and freq
                UpdateBandStackRegisters();
                UpdateBandButtonColors();

            } // right click
        }


        private void radBandVHF7_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((regBand == 1) && (me.Button == System.Windows.Forms.MouseButtons.Right))
            {
                if (band_vhf7_register < 10)
                    DB.AddBandStack("VHF7", rx1_dsp_mode.ToString(), rx1_filter.ToString(), Math.Round(VFOAFreq, 6)); // take current band, DSP mode, filter, and freq
                UpdateBandStackRegisters();
                UpdateBandButtonColors();

            } // right click
        }


        private void radBandVHF8_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((regBand == 1) && (me.Button == System.Windows.Forms.MouseButtons.Right))
            {
                if (band_vhf8_register < 10)
                    DB.AddBandStack("VHF8", rx1_dsp_mode.ToString(), rx1_filter.ToString(), Math.Round(VFOAFreq, 6)); // take current band, DSP mode, filter, and freq
                UpdateBandStackRegisters();
                UpdateBandButtonColors();

            } // right click
        }


        private void radBandVHF9_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((regBand == 1) && (me.Button == System.Windows.Forms.MouseButtons.Right))
            {
                if (band_vhf9_register < 10)
                    DB.AddBandStack("VHF9", rx1_dsp_mode.ToString(), rx1_filter.ToString(), Math.Round(VFOAFreq, 6)); // take current band, DSP mode, filter, and freq
                UpdateBandStackRegisters();
                UpdateBandButtonColors();

            } // right click
        }


        private void radBandVHF10_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((regBand == 1) && (me.Button == System.Windows.Forms.MouseButtons.Right))
            {
                if (band_vhf10_register < 10)
                    DB.AddBandStack("VHF10", rx1_dsp_mode.ToString(), rx1_filter.ToString(), Math.Round(VFOAFreq, 6)); // take current band, DSP mode, filter, and freq
                UpdateBandStackRegisters();
                UpdateBandButtonColors();

            } // right click
        }


        private void radBandVHF11_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((regBand == 1) && (me.Button == System.Windows.Forms.MouseButtons.Right))
            {
                if (band_vhf11_register < 10)
                    DB.AddBandStack("VHF11", rx1_dsp_mode.ToString(), rx1_filter.ToString(), Math.Round(VFOAFreq, 6)); // take current band, DSP mode, filter, and freq
                UpdateBandStackRegisters();
                UpdateBandButtonColors();

            } // right click
        }

        private void radBandVHF12_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((regBand == 1) && (me.Button == System.Windows.Forms.MouseButtons.Right))
            {
                if (band_vhf12_register < 10)
                    DB.AddBandStack("VHF12", rx1_dsp_mode.ToString(), rx1_filter.ToString(), Math.Round(VFOAFreq, 6)); // take current band, DSP mode, filter, and freq
                UpdateBandStackRegisters();
                UpdateBandButtonColors();

            } // right click
        }


        private void radBandVHF13_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((regBand == 1) && (me.Button == System.Windows.Forms.MouseButtons.Right))
            {
                if (band_vhf13_register < 10)
                    DB.AddBandStack("VHF13", rx1_dsp_mode.ToString(), rx1_filter.ToString(), Math.Round(VFOAFreq, 6)); // take current band, DSP mode, filter, and freq
                UpdateBandStackRegisters();
                UpdateBandButtonColors();

            } // right click
        }


        //====================================================================================================
        // ke9ns
        public bool SWLFORM
        {
            get
            {
                return false;
            }
            set
            {

                if (SwlForm == null || SwlForm.IsDisposed) SwlForm = new SwlControl(this); // ke9ns add communicate with swl list controls

                SwlForm.Show();
                SwlForm.Focus();

                SwlForm.WindowState = FormWindowState.Normal; // ke9ns add


                // = value;
            }
        }


        //====================================================================================================
        //====================================================================================================
        // ke9ns add 
        private void spotterMenu_Click(object sender, EventArgs e)
        {

            Debug.WriteLine("SPOTTER CLICK " + SpotForm);

            if (SpotForm == null || SpotForm.IsDisposed)
            {
                Debug.WriteLine("SPOTTER needs to be started now");
                SpotForm = new SpotControl(this);
            }

            SpotForm.Refresh();
            SpotForm.Show();
            SpotForm.Focus();

            SpotForm.WindowState = FormWindowState.Normal; // ke9ns add



        } //  spotterMenu_Click

        //====================================================================================================
        // ke9ns add  clicking the MAP button on the main console screen
        private void trackMenuItem1_Click(object sender, EventArgs e)
        {

            if (SpotForm == null || SpotForm.IsDisposed)
            {
                Debug.WriteLine("SpotControl instance created by Map button");
                SpotForm = new SpotControl(this);
            }

            if (SpotForm.chkFLayerON.Checked)
            {
                SpotForm.chkFLayerON.Checked = false;

            }
            else if (SpotForm.chkDLayerON.Checked)
            {
                SpotForm.chkDLayerON.Checked = false;

            }
            else if (SpotForm.chkLightningMap.Checked) //.240
            {
                SpotForm.chkLightningMap.Checked = false;
            }
            else if (SpotForm.chkCloudOn.Checked) //.241
            {
                SpotForm.chkCloudOn.Checked = false;
            }
            else
            {
                SpotForm.btnTrack_Click(this, EventArgs.Empty); // virtually clicking the track button on the spotter screen
            }

            if (SpotForm.chkMapOn.Checked) //.243
            {
                MapMenuItem.Text = "Spotter Map";
                MapMenuItem.BackColor = Color.DarkBlue;

            }
            else
            {
                MapMenuItem.Text = "Maps";
                MapMenuItem.BackColor = Color.Transparent;
            }


        } // trackMenuItem1_Click


        // ke9ns add for pulling up World Map (right click on the MAP button)
        private void MapMenuItem_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((me.Button == System.Windows.Forms.MouseButtons.Right)) //.239
            {

                if (SpotForm == null || SpotForm.IsDisposed)
                {
                    Debug.WriteLine("SpotControl instance created by Map button");
                    SpotForm = new SpotControl(this);
                }
                // this is the left click
                //  SpotForm.btnTrack_Click(this, EventArgs.Empty); // virtually clicking the track button on the spotter screen

                if (SpotForm.chkFLayerON.Checked == true)
                {
                    SpotForm.chkCloudOn.Checked = false;
                    SpotForm.chkFLayerON.Checked = false;
                    SpotForm.chkLightningMap.Checked = false;
                    SpotForm.chkDLayerON.Checked = true;
                    MapMenuItem.Text = "D-Layer map"; //.243
                    MapMenuItem.BackColor = Color.DarkGreen;

                }
                else if (SpotForm.chkDLayerON.Checked == true)
                {
                    SpotForm.chkCloudOn.Checked = false;
                    SpotForm.chkDLayerON.Checked = false;
                    SpotForm.chkFLayerON.Checked = false;
                    SpotForm.chkLightningMap.Checked = true;
                    MapMenuItem.Text = "Lightning map"; //.243
                    MapMenuItem.BackColor = Color.DarkRed;
                }
                else if (SpotForm.chkLightningMap.Checked == true)
                {

                    SpotForm.chkLightningMap.Checked = false;
                    SpotForm.chkFLayerON.Checked = false;
                    SpotForm.chkDLayerON.Checked = false;
                    SpotForm.chkCloudOn.Checked = true;
                    MapMenuItem.Text = "Cloud map";  //.243
                    MapMenuItem.BackColor = Color.DarkGray;
                }
                else if (SpotForm.chkCloudOn.Checked == true)
                {
                    SpotForm.chkCloudOn.Checked = false;
                    SpotForm.chkLightningMap.Checked = false;
                    SpotForm.chkDLayerON.Checked = false;
                    SpotForm.chkFLayerON.Checked = true;
                    MapMenuItem.Text = "F-Layer map"; //.243
                    MapMenuItem.BackColor = Color.DarkOrange;

                }
                else
                {
                    SpotForm.chkFLayerON.Checked = true; //.240
                    MapMenuItem.Text = "F-Layer map"; //.243
                    MapMenuItem.BackColor = Color.DarkOrange;
                }



            } //  if ((me.Button == System.Windows.Forms.MouseButtons.Right))
            else if ((me.Button == System.Windows.Forms.MouseButtons.Middle)) // .239
            {

                if (helpbox1Form == null || helpbox1Form.IsDisposed) helpbox1Form = new helpbox1(this);

                helpbox1Form.Show();
                helpbox1Form.Focus();
                helpbox1Form.WindowState = FormWindowState.Normal; // ke9ns add

            } // right click



        } // MapMenuItem_MouseDown(


        // ke9ns add if you put your mouse over map button
        private void trackMenuItem1_MouseEnter(object sender, EventArgs e)
        {
            HELPMAP = true;

        }

        private void trackMenuItem1_MouseLeave(object sender, EventArgs e)
        {
            HELPMAP = false;

        }






        //===================================================================================
        // ke9ns add setup DX spider cluster by right clicking
        public void spotterMenu_MouseDown(object sender, MouseEventArgs e)
        {

            /*
            MouseEventArgs me = (MouseEventArgs)e;


            if (me.Button == System.Windows.Forms.MouseButtons.Right)
            {
                if (SpotForm == null || SpotForm.IsDisposed)
                   SpotForm = new SpotControl(this);

                    SpotForm.Show();
                   SpotForm.Focus();

            }

    */
        } //spotterMenu_MouseDown


        //=================================================================================================
        // ke9ns add right click to open VAC panel directly
        private void chkVAC1_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                if (setupForm == null || setupForm.IsDisposed)
                    setupForm = new Setup(this);

                setupForm.Show();
                setupForm.Focus();
                setupForm.WindowState = FormWindowState.Normal; // ke9ns add

                setupForm.tcSetup.SelectedIndex = 1; // select audio tab;
                setupForm.tcAudio.SelectedIndex = 1; // select vac1 tab
                setupForm.chkAudioIQtoVAC.Focus();


            } // right click
        }

        //=================================================================================================
        // ke9ns add right click to open VAC panel directly
        private void chkVAC2_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((me.Button == System.Windows.Forms.MouseButtons.Right))
            {
                if (setupForm == null || setupForm.IsDisposed)
                    setupForm = new Setup(this);
                setupForm.Show();
                setupForm.Focus();
                setupForm.WindowState = FormWindowState.Normal; // ke9ns add

                setupForm.tcSetup.SelectedIndex = 1; // select audio tab;
                setupForm.tcAudio.SelectedIndex = 2; // select vac2 tab
                setupForm.chkVAC2DirectIQ.Focus();



            } // right click
        } // chkVAC2_MouseDown


        // ke9ns add
        private void comboTXProfile_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                if (setupForm == null || setupForm.IsDisposed)
                    setupForm = new Setup(this);

                setupForm.Show();
                setupForm.Focus();
                setupForm.WindowState = FormWindowState.Normal; // ke9ns add

                setupForm.tcSetup.SelectedIndex = 4; // select audio tab;

                //   setupForm.tcAudio.SelectedIndex = 1; // select vac1 tab
                //    setupForm.chkAudioIQtoVAC.Focus();

            } // right click
        } // comboTXProfile_MouseDown

        // ke9ns add
        private void lblAntRX1_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                if (fwc_init && current_model == Model.FLEX5000)
                {
                    if (fwcAntForm == null || fwcAntForm.IsDisposed)
                        fwcAntForm = new FWCAntForm(this);
                    fwcAntForm.Show();
                    fwcAntForm.Focus();
                    fwcAntForm.WindowState = FormWindowState.Normal; // ke9ns add
                }
                else if (hid_init && current_model == Model.FLEX1500)
                {
                    if (hidAntForm == null || hidAntForm.IsDisposed)
                        hidAntForm = new HIDAntForm(this);
                    hidAntForm.Show();
                    hidAntForm.Focus();
                    hidAntForm.WindowState = FormWindowState.Normal; // ke9ns add
                }

            } // right click
        }

        // ke9ns add
        private void lblAntTX_Click(object sender, EventArgs e)
        {
            if (fwc_init && current_model == Model.FLEX5000)
            {
                if (fwcAntForm == null || fwcAntForm.IsDisposed)
                    fwcAntForm = new FWCAntForm(this);
                fwcAntForm.Show();
                fwcAntForm.Focus();
                fwcAntForm.WindowState = FormWindowState.Normal; // ke9ns add
            }
            else if (hid_init && current_model == Model.FLEX1500)
            {
                if (hidAntForm == null || hidAntForm.IsDisposed)
                    hidAntForm = new HIDAntForm(this);
                hidAntForm.Show();
                hidAntForm.Focus();
                hidAntForm.WindowState = FormWindowState.Normal; // ke9ns add
            }
        }

        // ke9ns add
        private void lblAntRX1_Click(object sender, EventArgs e)
        {
            if (fwc_init && current_model == Model.FLEX5000)
            {
                if (fwcAntForm == null || fwcAntForm.IsDisposed)
                    fwcAntForm = new FWCAntForm(this);
                fwcAntForm.Show();
                fwcAntForm.Focus();
                fwcAntForm.WindowState = FormWindowState.Normal; // ke9ns add
            }
            else if (hid_init && current_model == Model.FLEX1500)
            {
                if (hidAntForm == null || hidAntForm.IsDisposed)
                    hidAntForm = new HIDAntForm(this);
                hidAntForm.Show();
                hidAntForm.Focus();
                hidAntForm.WindowState = FormWindowState.Normal; // ke9ns add
            }
        }

        // ke9ns add
        private void lblAntRX2_Click(object sender, EventArgs e)
        {
            if (fwc_init && current_model == Model.FLEX5000)
            {
                if (fwcAntForm == null || fwcAntForm.IsDisposed)
                    fwcAntForm = new FWCAntForm(this);
                fwcAntForm.Show();
                fwcAntForm.Focus();
                fwcAntForm.WindowState = FormWindowState.Normal; // ke9ns add
            }
            else if (hid_init && current_model == Model.FLEX1500)
            {
                if (hidAntForm == null || hidAntForm.IsDisposed)
                    hidAntForm = new HIDAntForm(this);
                hidAntForm.Show();
                hidAntForm.Focus();
                hidAntForm.WindowState = FormWindowState.Normal; // ke9ns add
            }
        }

        // ke9ns add (right click )
        private void chkRXEQ_MouseDown(object sender, MouseEventArgs e)
        {

            MouseEventArgs me = (MouseEventArgs)e;

            if ((me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                if (eqForm == null || eqForm.IsDisposed)
                    eqForm = new EQForm(this);
                eqForm.Show();
                eqForm.Focus();
                eqForm.WindowState = FormWindowState.Normal; // ke9ns add


            } // right click
        }

        // ke9ns add (right click )
        private void chkTXEQ_MouseDown(object sender, MouseEventArgs e)
        {

            MouseEventArgs me = (MouseEventArgs)e;

            if ((me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                if (eqForm == null || eqForm.IsDisposed)
                    eqForm = new EQForm(this);
                eqForm.Show();
                eqForm.Focus();
                eqForm.WindowState = FormWindowState.Normal; // ke9ns add
                                                             //   setupForm.tcSetup.SelectedIndex = 4; // select audio tab;

                //   setupForm.tcAudio.SelectedIndex = 1; // select vac1 tab
                //    setupForm.chkAudioIQtoVAC.Focus();


            } // right click

        }

        private void comboVACSampleRate_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                if (setupForm == null || setupForm.IsDisposed)
                    setupForm = new Setup(this);

                setupForm.Show();
                setupForm.Focus();
                setupForm.WindowState = FormWindowState.Normal; // ke9ns add

                setupForm.tcSetup.SelectedIndex = 1; // select audio tab;
                setupForm.tcAudio.SelectedIndex = 1; // select vac1 tab
                setupForm.chkAudioIQtoVAC.Focus();


            } // right click
        }

        //ke9ns add
        private void comboFMTXProfile_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                if (setupForm == null || setupForm.IsDisposed)
                    setupForm = new Setup(this);

                setupForm.Show();
                setupForm.Focus();
                setupForm.WindowState = FormWindowState.Normal; // ke9ns add

                setupForm.tcSetup.SelectedIndex = 4; // select audio tab;

                //   setupForm.tcAudio.SelectedIndex = 1; // select vac1 tab
                //    setupForm.chkAudioIQtoVAC.Focus();

            } // right click
        }

        // ke9ns add
        private void ptbMic_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                if (setupForm == null || setupForm.IsDisposed)
                    setupForm = new Setup(this);

                setupForm.Show();
                setupForm.Focus();
                setupForm.WindowState = FormWindowState.Normal; // ke9ns add

            } // right click
        }


        // ke9ns add
        private void ptbDX_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                if (setupForm == null || setupForm.IsDisposed)
                    setupForm = new Setup(this);

                setupForm.Show();
                setupForm.Focus();
                setupForm.WindowState = FormWindowState.Normal; // ke9ns add

            } // right click
        }

        // ke9ns add
        private void ptbCPDR_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                if (setupForm == null || setupForm.IsDisposed)
                    setupForm = new Setup(this);

                setupForm.Show();
                setupForm.Focus();
                setupForm.WindowState = FormWindowState.Normal; // ke9ns add

            } // right click
        }


        // ke9ns add
        private void ptbVOX_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                if (setupForm == null || setupForm.IsDisposed)
                    setupForm = new Setup(this);

                setupForm.Show();
                setupForm.Focus();
                setupForm.WindowState = FormWindowState.Normal; // ke9ns add

            } // right click
        }

        // ke9ns add
        private void chkNB_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                if (setupForm == null || setupForm.IsDisposed)
                    setupForm = new Setup(this);

                setupForm.Show();
                setupForm.Focus();
                setupForm.WindowState = FormWindowState.Normal; // ke9ns add

                setupForm.tcSetup.SelectedIndex = 3; // select dsp tab;
                setupForm.tcDSP.SelectedIndex = 0; // select Options tab

            } // right click
        }

        // ke9ns add
        private void chkDSPNB2_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                if (setupForm == null || setupForm.IsDisposed)
                    setupForm = new Setup(this);

                setupForm.Show();
                setupForm.Focus();
                setupForm.WindowState = FormWindowState.Normal; // ke9ns add

                setupForm.tcSetup.SelectedIndex = 3; // select dsp tab;
                setupForm.tcDSP.SelectedIndex = 0; // select Options tab

            } // right click
        }


        // ke9ns add
        private void chkANF_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                if (setupForm == null || setupForm.IsDisposed)
                    setupForm = new Setup(this);

                setupForm.Show();
                setupForm.Focus();
                setupForm.WindowState = FormWindowState.Normal; // ke9ns add

                setupForm.tcSetup.SelectedIndex = 3; // select dsp tab;
                setupForm.tcDSP.SelectedIndex = 0; // select Options tab

            } // right click
        }


        // ke9ns add
        private void chkNR_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                if (setupForm == null || setupForm.IsDisposed)
                    setupForm = new Setup(this);

                setupForm.Show();
                setupForm.Focus();
                setupForm.WindowState = FormWindowState.Normal; // ke9ns add

                setupForm.tcSetup.SelectedIndex = 3; // select dsp tab;
                setupForm.tcDSP.SelectedIndex = 0; // select Options tab

            } // right click
        }

        // ke9ns add
        private void chkRX2NR_MouseDown(object sender, MouseEventArgs e)
        {

            MouseEventArgs me = (MouseEventArgs)e;

            if ((me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                if (setupForm == null || setupForm.IsDisposed)
                    setupForm = new Setup(this);

                setupForm.Show();
                setupForm.Focus();
                setupForm.WindowState = FormWindowState.Normal; // ke9ns add

                setupForm.tcSetup.SelectedIndex = 3; // select dsp tab;
                setupForm.tcDSP.SelectedIndex = 0; // select Options tab

            } // right click
        }

        private void chkRX2ANF_MouseDown(object sender, MouseEventArgs e)
        {

            MouseEventArgs me = (MouseEventArgs)e;

            if ((me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                if (setupForm == null || setupForm.IsDisposed)
                    setupForm = new Setup(this);

                setupForm.Show();
                setupForm.Focus();
                setupForm.WindowState = FormWindowState.Normal; // ke9ns add

                setupForm.tcSetup.SelectedIndex = 3; // select dsp tab;
                setupForm.tcDSP.SelectedIndex = 0; // select Options tab

            } // right click
        }

        private void chkRX2NB_MouseDown(object sender, MouseEventArgs e)
        {

            MouseEventArgs me = (MouseEventArgs)e;

            if ((me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                if (setupForm == null || setupForm.IsDisposed)
                    setupForm = new Setup(this);

                setupForm.Show();
                setupForm.Focus();
                setupForm.WindowState = FormWindowState.Normal; // ke9ns add

                setupForm.tcSetup.SelectedIndex = 3; // select dsp tab;
                setupForm.tcDSP.SelectedIndex = 0; // select Options tab

            } // right click
        }

        private void chkRX2NB2_MouseDown(object sender, MouseEventArgs e)
        {

            MouseEventArgs me = (MouseEventArgs)e;

            if ((me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                if (setupForm == null || setupForm.IsDisposed)
                    setupForm = new Setup(this);

                setupForm.Show();
                setupForm.Focus();
                setupForm.WindowState = FormWindowState.Normal; // ke9ns add

                setupForm.tcSetup.SelectedIndex = 3; // select dsp tab;
                setupForm.tcDSP.SelectedIndex = 0; // select Options tab

            } // right click
        }

        // ke9ns add
        private void btnTNFAdd_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                if (setupForm == null || setupForm.IsDisposed)
                    setupForm = new Setup(this);

                setupForm.Show();
                setupForm.Focus();
                setupForm.WindowState = FormWindowState.Normal; // ke9ns add

                setupForm.tcSetup.SelectedIndex = 3; // select dsp tab;
                setupForm.tcDSP.SelectedIndex = 0; // select Options tab

            } // right click
        }

        // ke9ns add
        private void chkTNF_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                if (setupForm == null || setupForm.IsDisposed)
                    setupForm = new Setup(this);

                setupForm.Show();
                setupForm.Focus();
                setupForm.WindowState = FormWindowState.Normal; // ke9ns add

                setupForm.tcSetup.SelectedIndex = 3; // select dsp tab;
                setupForm.tcDSP.SelectedIndex = 0; // select Options tab

            } // right click
        }


        // ke9ns add to go directly to gray line color section
        private void btnDisplayPanCenter_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((me.Button == System.Windows.Forms.MouseButtons.Middle))
            {

                if (current_model == Model.FLEX5000 && FWCEEPROM.RX2OK && chkRX2.Checked)  //.220 corrected
                {

                    CalcDisplayFreq(); // .225 add

                    //double edge_alias = 7200.0;
                    //double if_freq = 11025.0;

                    CTUN1_HZ = 0; // reset CTUN to center

                    double spur_tune_width = 200e6 / Math.Pow(2, 16);
                    if (fwc_init && (current_model == Model.FLEX5000 || current_model == Model.FLEX3000))
                        spur_tune_width = 500e6 / Math.Pow(2, 16);

                    int width = Display.RXDisplayHigh2 - Display.RXDisplayLow2;

                    int max_pan_width = (int)(sample_rate1 - 2 * spur_tune_width - width);
                    if (max_pan_width == 0)
                    {
                        ptbDisplayPan2.Value = (ptbDisplayPan2.Maximum - ptbDisplayPan2.Minimum) / 2;
                        ptbDisplayPan2_Scroll(btnDisplayPanCenter, EventArgs.Empty);
                        return;
                    }

                    int low = -width / 2; // target -- if width is centered at 0, low will be half the width below 0
                    int abs_low = (int)(-(double)sample_rate1 * 0.5 - if_freq * 1e6 + spur_tune_width);
                    int offset = low - abs_low;

                    int new_val = (int)((double)offset * (double)ptbDisplayPan2.Maximum / (double)max_pan_width);
                    ptbDisplayPan2.Value = Math.Min(Math.Max(ptbDisplayPan2.Minimum, new_val), ptbDisplayPan2.Maximum);
                    ptbDisplayPan2_Scroll(btnDisplayPanCenter, EventArgs.Empty);


                }
                else if (me.Button == System.Windows.Forms.MouseButtons.Right)
                {

                    if (setupForm == null || setupForm.IsDisposed)
                        setupForm = new Setup(this);

                    setupForm.Show();
                    setupForm.Focus();
                    setupForm.WindowState = FormWindowState.Normal; // ke9ns add

                    setupForm.tcSetup.SelectedIndex = 6; // select appearance tab;
                    setupForm.tcAppearance.SelectedIndex = 1; // select  tab
                }
            } // right click
            else if (me.Button == System.Windows.Forms.MouseButtons.Right)
            {

                if (setupForm == null || setupForm.IsDisposed)
                    setupForm = new Setup(this);

                setupForm.Show();
                setupForm.Focus();
                setupForm.WindowState = FormWindowState.Normal; // ke9ns add

                setupForm.tcSetup.SelectedIndex = 6; // select appearance tab;
                setupForm.tcAppearance.SelectedIndex = 1; // select  tab
            }

        } // btnDisplayPanCenter_MouseDown

        private void chkTUN_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                if (setupForm == null || setupForm.IsDisposed)
                    setupForm = new Setup(this);

                if (setupForm.chkBoxPulser.Checked == false)
                {
                    setupForm.chkBoxPulser.Checked = true;
                    chkFWCATU.Enabled = false;

                }
                else
                {
                    setupForm.chkBoxPulser.Checked = false;
                    chkFWCATU.Enabled = true;
                }



            } // right click
            else if ((me.Button == System.Windows.Forms.MouseButtons.Middle))
            {
                if (setupForm == null || setupForm.IsDisposed)
                    setupForm = new Setup(this);

                setupForm.Show();
                setupForm.Focus();
                setupForm.WindowState = FormWindowState.Normal; // ke9ns add

                setupForm.tcSetup.SelectedIndex = 4; // select transmit tab;


            }

        } // chkTUN_MouseDown(

        //==================================================================================================
        // ke9ns add for auto adjusting panadapter min level (keep the base line signal on the screen)
        private void autoBrightBox_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            autoBrightBox.ShortcutsEnabled = false; // added to eliminate the contextmenu from popping up

            if ((me.Button == System.Windows.Forms.MouseButtons.Right))
            {
                autoBrightBox.ForeColor = Color.LightPink;

                if (Display.continuum == 0)
                {
                    waterpanClick = true;
                    waterpanClick2 = true;
                    waterpanClick3 = true;

                    Display.AutoBright = 2; // adjust RX  panadapter level

                    AGCTUPDATE = true;
                }
                else // in continuum mode so restart
                {
                    //   Display.K14 = 0; // click to restart continuum 
                }

                btnHidden.Focus();


            } // right click
            else
            {
                autoBrightBox.ForeColor = Color.LightSkyBlue;
            }


        } // autobrightbox_mousedown

        private void chkEnableMultiRX_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                if (rx2_enabled)
                {
                    VFOASubFreq = VFOAFreq; // ke9ns add start with sub on top of vfoA
                    UpdateVFOASub();

                }
                else
                {
                    VFOBFreq = VFOAFreq; // ke9ns add  start with B synced to A
                }


            } // right click

        } // chkEnableMultiRX_MouseDown


        // ke9ns add right click over ZOOM label goes directly to setup->display
        public bool AutoPanScale = false;  // ke9ns add true = readjust the pan scale for small signals, false = go back to large scale pan
        public int AutoPanScaleMin = -140; // ke9ns
        public int AutoPanScaleMax = -20; // ke9ns
        public int AutoPanScaleStep = 10; // ke9ns

        public bool ZZOOM = false; // ke9ns to allow TNFZOOM feature without TNF ON

        private void lblDisplayZoom_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;
            if ((me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                if (ZZOOM == false)
                {
                    Display.NotchZoomStartFreq = VFOAFreq; // in mhz
                    Display.TNFZoom = true;
                    ZZOOM = true;
                }
                else
                {
                    Display.TNFZoom = false;
                    ZZOOM = false;
                }

                Debug.WriteLine("TNFZOOM");


                /*
                   if (setupForm == null || setupForm.IsDisposed)
                       setupForm = new Setup(this);

                   setupForm.Show();
                   setupForm.Focus();
                   setupForm.WindowState = FormWindowState.Normal; // ke9ns add

                   setupForm.tcSetup.SelectedIndex = 2; // select Display tab;
                 */

            } // right click
            else // ke9ns left click to adjust pan scale 
            {
                if (Display.continuum == 0)
                {
                    if (AutoPanScale == true)
                    {
                        lblDisplayZoom1.Image = global::PowerSDR.Properties.Resources.ZoomGray;  // lblDisplayZoom.ForeColor = Color.White; // ke9ns turn back to white when viewing standard scale signals

                        AutoPanScale = false;
                        Display.AutoBright = 4; // adjust RX pan scale to standard signals
                    }
                    else
                    {
                        lblDisplayZoom1.Image = global::PowerSDR.Properties.Resources.zoomRed;  // lblDisplayZoom.ForeColor = Color.Red; // ke9ns turn ZOOM text red to indicate your viewing small scale
                        AutoPanScale = true;
                        AutoPanScaleMin = Display.SpectrumGridMin; // ke9ns store original value so you can go back when you toggle to standard signals again
                        AutoPanScaleMax = Display.SpectrumGridMax;
                        AutoPanScaleStep = Display.SpectrumGridStep;

                        Display.AutoBright = 3; // adjust RX pan scale to small signals

                    }


                    Debug.WriteLine("AutoPanScale = " + AutoPanScale);
                }

            }
        }

        //===================================================================
        // ke9ns add  VAC system PC volume control
        private void ptbVAC_Scroll(object sender, EventArgs e)
        {

        }

        //===========================================================================================
        // ke9ns add allow 2nd meter function for TX function
        private void comboMeterTX1Mode_SelectedIndexChanged(object sender, EventArgs e)
        {
            MeterTXMode mode = MeterTXMode.FIRST;
            if (comboMeterTX1Mode.Items.Count == 0 || comboMeterTX1Mode.SelectedIndex < 0)
            {
                //current_meter_tx_mode = MeterTXMode.FIRST;
            }
            else
            {
                meterCombo = false;

                switch (comboMeterTX1Mode.Text)
                {
                    case "Fwd Pwr":
                        mode = MeterTXMode.FORWARD_POWER;
                        break;
                    case "Ref Pwr":
                        mode = MeterTXMode.REVERSE_POWER;
                        break;
                    case "Mic":
                        mode = MeterTXMode.MIC;
                        break;
                    case "EQ":
                        mode = MeterTXMode.EQ;
                        break;
                    case "Leveler":
                        mode = MeterTXMode.LEVELER;
                        break;
                    case "Lev Gain":
                        mode = MeterTXMode.LVL_G;
                        break;
                    case "CPDR":
                        mode = MeterTXMode.CPDR;
                        break;
                    case "ALC":
                        mode = MeterTXMode.ALC;
                        break;
                    case "ALC Comp":
                        mode = MeterTXMode.ALC_G;
                        break;
                    case "SWR":
                        mode = MeterTXMode.SWR;
                        break;
                    case "Combo":
                        meterCombo = true;
                        mode = MeterTXMode.Combo;
                        break;

                    case "Off":
                        mode = MeterTXMode.OFF;
                        break;

                } // switch (comboMeterTX1Mode.Text)


                if (mode == MeterTXMode.Combo)
                {
                    picRX3Meter.Visible = true;
                    picRX3Meter.Enabled = true;

                }
                else
                {
                    picRX3Meter.Visible = false;
                    picRX3Meter.Enabled = false;

                }

                //  if (chkTUN.Checked)
                //  {
                //      tune_meter_tx_mode = mode;
                //     if (setupForm != null) setupForm.TuneMeterTXMode = mode;
                //  }

                current_meter_tx1_mode = mode;

            }

            //---------------------------
            // ke9ns add
            bool mox2 = false; // ke9ns add  false = rx    true = 2nd tx meter active

            if ((setupForm != null) && (setupForm.chkRX2AutoMuteRX2OnVFOATX.Checked == false) || (TXMeter2 == false) || ((TXMeter2 == true) && (!MOX))) // ke9ns do RX2 if in duplex mode and not in special 2nd TX meter mode
            {
                if ((!FWCEEPROM.RX2OK) || (FWCEEPROM.RX2OK && chkRX2.Checked == false)) mox2 = true; // ke9ns keep meter set for the TX type you wanted all the time
                else mox2 = false; // receiving on RX2 or dont want 2nd tX meter

            }
            else
            {
                mox2 = true; // transmitting and want 2nd tx meter to function
            }

            if (mox2)
            {
                switch (mode)
                {
                    case MeterTXMode.FIRST:
                        lblRX2Meter.Text = "";
                        break;
                    case MeterTXMode.MIC:
                    case MeterTXMode.EQ:
                    case MeterTXMode.LEVELER:
                    case MeterTXMode.CPDR:
                    case MeterTXMode.ALC:
                        lblRX2Meter.Text = "-20    -10     -5      0   1   2   3";
                        break;
                    case MeterTXMode.FORWARD_POWER:
                    case MeterTXMode.REVERSE_POWER:
                        if (pa_present ||
                            (fwc_init && (current_model == Model.FLEX5000 || current_model == Model.FLEX3000)) ||
                            (hid_init && current_model == Model.FLEX1500))
                            lblRX2Meter.Text = "1      5     10    50   100  120+";
                        else
                            lblRX2Meter.Text = "0      0.1     0.2     0.5        1.0";
                        break;
                    case MeterTXMode.SWR:
                        lblRX2Meter.Text = "1      1.5   2     3     5    10";
                        lblRX2Meter.Text = "0             10              20";
                        break;
                    case MeterTXMode.OFF:
                        lblRX2Meter.Text = "";
                        break;
                    case MeterTXMode.LVL_G:
                    case MeterTXMode.ALC_G:
                        lblRX2Meter.Text = "0       5       10      15      20";
                        break;
                }
                ResetRX2MeterPeak();

            } // mox

            if (meterCombo == true) picRX3Meter.Invalidate(); // ke9ns12 add
            else picRX2Meter.Invalidate(); // ke9ns12 add

            // picRX2Meter.Invalidate();

            if (comboMeterTX1Mode.Focused) btnHidden.Focus();


        } //comboMeterTX1Mode_SelectedIndexChanged

        //===================================================================================
        // ke9ns add allow you to play sequential quickaudio by right clicking
        private void ckQuickPlay_MouseDown(object sender, MouseEventArgs e)
        {
            //   ckQuickPlay.ContextMenu = null;
            //   ckQuickPlay.ContextMenuStrip = null;


            MouseEventArgs me = (MouseEventArgs)e;


            if (me.Button == System.Windows.Forms.MouseButtons.Right)
            {
                if (WaveForm.chkQuickAudioFolder.Checked == true)
                {
                    string filePath = AppDataPath + "QuickAudio\\";

                    if (!Directory.Exists(filePath))
                    {
                        // create PowerSDR audio folder if it does not exist
                        //  Directory.CreateDirectory(wave_folder);
                        Debug.WriteLine("problem no ke9ns dat file found");
                        return;
                    }

                    openFileDialog1.InitialDirectory = String.Empty;
                    openFileDialog1.ShowHelp = true; // ke9ns .169 added to prevent freeze lag
                    openFileDialog1.Title = "Select your QuickAudio File, or Cancel to select the last recorded";

                    openFileDialog1.InitialDirectory = filePath; // ke9ns  file to quickplay subfolder but could also be wave_folder;



                    Debug.WriteLine("right  click ");


                    DialogResult result = openFileDialog1.ShowDialog();

                    if (result == DialogResult.OK) // Test result.
                    {
                        Debug.WriteLine("file selected1 " + result);
                        Debug.WriteLine("file selected2 " + openFileDialog1.FileName);

                        WaveControl.QPFILE = openFileDialog1.FileName; // pass file name to wave file
                    }
                    else
                    {
                        Debug.WriteLine("nothing selected");
                        WaveControl.QPFILE = null;
                    }

                    Debug.WriteLine("file selected " + result);

                } // sequential quickaudio

            } // right mouse button click
            else if (me.Button == System.Windows.Forms.MouseButtons.Left)
            {
                Debug.WriteLine("left click ");

            }


        } // ckQuickPlay_MouseDown











        //============================================================================ 
        //============================================================================ 
        // ke9ns add Click here to start/stop TX Waterfall ID
        //============================================================================ 
        //============================================================================ 
        private void TXIDMenuItem_MouseDown(object sender, MouseEventArgs e)  // also called by txtTimer_mouse
        {

            if ((!TXIDMenuItem.Checked) && (callsignTextBox.BackColor == Color.MediumSpringGreen) && (chkPower.Checked)) // cant transmit unless you have a valid callsign waterfall id wave file and Radio is ON
            {

                // WaveOptions.RECPLAY1 = true; // force wave into POST
                WaveForm.RECPLAY = true;

                Txfh = TXFilterHigh;         // save original filter size

                if (WIDEWATERID == false)
                {
                    TXFilterHigh = 2600;         // reduce size for text waterfall ID
                }

                if (chkVAC1.Checked)
                {
                    vac1 = 1;
                    chkVAC1.Checked = false;
                }

                TXIDMenuItem.Text = "Creating";   // transmit will  be displayed in the wave.cs form

                menuStrip1.Invalidate();
                menuStrip1.Update();

                TXIDMenuItem.Checked = true;

                Debug.WriteLine("WATERFALL ON======================");
            }
            else
            {
                Debug.WriteLine("WATERFALL OFF======================");
                WaveForm.TXIDPlay = false; // tell wave.cs not to create or send waterfall id
                this.TXIDMenuItem.Text = "TX WaterID";

                TXIDMenuItem.Checked = false;

                if (WIDEWATERID == false)
                {
                    if (Txfh > 0) TXFilterHigh = Txfh;         // put back original filter size
                }

                if (vac1 == 1)
                {
                    vac1 = 0;
                    Thread.Sleep(100);
                    chkVAC1.Checked = true;

                    // Task.Delay(200);
                }

                chkMOX.Checked = false;

            } // was checked when clicked


        } // mousedown on TXID menu item


        //============================================================================ 
        //============================================================================ 
        // ke9ns add turn on/off peak values (bottom right side of panadapter window)
        //============================================================================ 
        //============================================================================ 
        private static int peak1 = 0;
        private void txtDisplayPeakOffset_TextChanged(object sender, EventArgs e) // ke9ns ADD toggle on/off this display
        {

            if (peak1 == 1) peak1 = 0;
            else peak1 = 1;
            btnHidden.Focus();
        }

        private void txtDisplayPeakFreq_TextChanged(object sender, EventArgs e)
        {
            if (peak1 == 1) peak1 = 0;
            else peak1 = 1;
            btnHidden.Focus();
        }



        // ke9ns add
        public static int bslock = 0;

        public static int BandStackLock
        {
            get { return bslock; }
            set
            {
                bslock = value;

            }
        }
        public static int bslock2 = 0; // .209

        public static int BandStackLock2
        {
            get { return bslock2; }
            set
            {
                bslock2 = value;

            }
        }


        //=====================================================================
        // ke9ns add 10 minute Timer

        private int chkBoxTimer1 = 0;  // ke9ns    2= timer ID starting at the next 10min mark and every 10min, 1= timerID starting on the next minute and every 10 min, 3=OFF
                                       //  setupForm.chkBox30min.Checked == true  // ke9ns true = 30min (instead of 10)
        private bool chkBoxTimer2 = false; // ke9ns true = Waterfall ID
        private bool chkBoxTimer3 = false; // ke9ns true = Voice ID  IDTIMER.wav
        private bool chkBoxTimer4 = false; // ke9ns true = CW Audio ID IDTIMERCW.wav

        private bool voice = false; // ke9ns add true = voice ID was selected, dont reset until to toggle through all choices again

        [DllImport("user32.dll", CharSet = CharSet.Auto, CallingConvention = CallingConvention.Winapi)]
        internal static extern IntPtr GetFocus();


        //Import the FindWindow API to find our window
        [DllImport("User32.dll", EntryPoint = "FindWindow")]
        private static extern IntPtr FindWindowNative(string className, string windowName);

        [DllImport("user32.dll")]
        private static extern IntPtr GetForegroundWindow();


        //Import the SetForeground API to activate it
        [DllImport("User32.dll", EntryPoint = "SetForegroundWindow")]
        private static extern IntPtr SetForegroundWindowNative(IntPtr hWnd);

        // ke9ns add to allow mute of PC volume
        private const int APPCOMMAND_VOLUME_MUTE = 0x80000;
        private const int WM_APPCOMMAND = 0x319;
        [DllImport("User32.dll")]
        public static extern IntPtr SendMessageW(IntPtr hWnd, int Msg, IntPtr wParam, IntPtr lParam);


        public IntPtr FindWindow(string className, string windowName)
        {
            return FindWindowNative(className, windowName);
        }

        public IntPtr SetForegroundWindow(IntPtr hWnd)
        {
            return SetForegroundWindowNative(hWnd);
        }


        private string GetFocusControl()
        {
            Control focusControl = null;
            IntPtr focusHandle = GetFocus();
            if (focusHandle != IntPtr.Zero) focusControl = Control.FromHandle(focusHandle);
            if (focusControl.Name.ToString().Length == 0) return focusControl.Parent.Parent.Name.ToString();
            else return focusControl.Name.ToString();
        }

        public void Activate(string title)
        {
            //Find the window, using the Window Title
            IntPtr hWnd = this.FindWindow(null, title);


            if (hWnd.ToInt32() > 0) //If found
            {
                this.SetForegroundWindow(hWnd); //Activate it
            }
        }


        public void shownames()
        {
            Process[] processlist = Process.GetProcesses();

            foreach (Process process in processlist)
            {
                if (!String.IsNullOrEmpty(process.MainWindowTitle))
                {
                    Debug.WriteLine("Process: {0} ID: {1} Window title: {2}", process.ProcessName, process.Id, process.MainWindowTitle);

                }
            }
        }
        public bool MouseIsOverControl(Control c)
        {
            return c.ClientRectangle.Contains(c.PointToClient(Control.MousePosition));
        }
        private void txtTimer_KeyDown(object sender, KeyEventArgs e)
        {


            /*   if (e.KeyCode == Keys.F1)
               {
                   if (helpboxForm == null || helpboxForm.IsDisposed) helpboxForm = new helpbox(this);

                   helpboxForm.Show();
                   helpboxForm.Focus();
                   helpboxForm.WindowState = FormWindowState.Normal; // ke9ns add

                   helpboxForm.richTextBox1.Text = "Testing";
               }
            */

        } // txtTimer_KeyDown


        //===============================================================================
        // ke9ns add called by setup.cs program when TOT box checked on or off (Time out timer)
        public bool tot_onoff = false; // ke9ns add  ON or OFF
        public bool TOT_TRIP = false; // ke9ns add TOT exceeded wait to clear popup to return to false

        public bool TOT_ONOFF
        {
            get
            {
                return tot_onoff;
            }

            set
            {

                tot_onoff = value;

                if (tot_onoff == true)
                {
                    Debug.WriteLine("TOT ON");
                    if (TOTBOXForm == null) TOTBOXForm = new TOTBOX(this);

                    Thread t5 = new Thread(new ThreadStart(TOTTIMER)); // ke9ns start TIME-OUT TIMER HERE
                    t5.Name = "Time-Out Timer Thread";
                    t5.IsBackground = true;
                    t5.Priority = ThreadPriority.BelowNormal;
                    t5.Start();
                }
                else
                {
                    tot_onoff = false; // ke9ns turn normal operation back on
                    TOT_TRIP = false; // ke9ns turn normal operation back on
                    if (setupForm != null) setupForm.textBoxTOT.Text = "OFF";
                }

            }


        } // TOT_ONOFF




        Stopwatch TOTTIME = new Stopwatch();  // ke9ns add (timeout timer)

        public bool TOT_TX = false; // ke9ns add
        public bool TOT_RXONLY = false; // ke9ns add

        //=====================================================================
        // ke9ns add THREAD
        private void TOTTIMER()
        {

            while ((tot_onoff == true)) // exit thread if TOT turned OFF
            {
                Thread.Sleep(100);            // 

                if (mox)
                {
                    if (TOT_TX == false) // if TX active start timer 1 time
                    {
                        TOT_TX = true;
                        TOTTIME.Restart(); // timer on now


                    } // if (TOT_TX == false)

                } // if (mox)
                else
                {

                    if (TOT_TRIP == false)
                    {
                        if (setupForm != null) setupForm.textBoxTOT.Text = "Ready";
                        TOTTIME.Reset(); // dont clear this if you have tripped the timer OUT
                        TOT_TX = false;
                    }

                } // in RX mode here


                try
                {
                    if (TOT_TX == true)
                    {
                        if (TOTTIME.ElapsedMilliseconds > ((long)setupForm.udTOT.Value * 1000)) // 
                        {
                            TOT_TRIP = true;

                            TOTTIME.Reset();

                            if (TOTBOXForm == null) TOTBOXForm = new TOTBOX(this);

                            TOTBOXForm.Show();
                            TOTBOXForm.Focus();
                            TOTBOXForm.WindowState = FormWindowState.Normal; // ke9ns POP UP Window for TOT

                            MOX = false;

                            RXOnly = true; // kill transmit

                            if (setupForm != null) setupForm.textBoxTOT.Text = "TIME-OUT";

                        } // if (TOTTIME.ElapsedMilliseconds > (setupForm.udTOT.Value * 1000))
                        else if (TOT_TRIP == false)
                        {

                            long temp1 = (long)setupForm.udTOT.Value - ((long)TOTTIME.ElapsedMilliseconds / 1000);

                            if (setupForm != null) setupForm.textBoxTOT.Text = temp1.ToString();

                        }

                    }



                }
                catch (Exception)
                {

                    setupForm.textBoxTOT.Text = "problem";
                }


            } //   while ((tot_onoff == true))

            TOTTIME.Stop();
            setupForm.textBoxTOT.Text = "OFF";

        } // TOTTIMER THREAD






        // ke9ns add
        private void txtTimer_MouseUp(object sender, MouseEventArgs e)
        {
            txtTimer.ShortcutsEnabled = false;

            if (e.Button == MouseButtons.Left) // ke9ns Start Stop 10 min timer
            {

                if (chkBoxTimer1 == 0)
                {
                    chkBoxTimer1 = 1; // timer on  1= timerID starting on the next minute and every 10 min
                    txtTimer.ForeColor = Color.AntiqueWhite;

                    if (chkBoxTimer2 == true)
                    {
                        if (setupForm != null && setupForm.chkBox30min.Checked == true)
                            txtTimer.Text = "wfID Timer: 30min";
                        else
                            txtTimer.Text = "wfID Timer: 10min";

                    }
                    else if (chkBoxTimer3 == true)
                    {
                        if (setupForm != null && setupForm.chkBox30min.Checked == true)
                            txtTimer.Text = "voID Timer: 30min";
                        else
                            txtTimer.Text = "voID Timer: 10min";

                    }
                    else if (chkBoxTimer4 == true)
                    {
                        if (setupForm != null && setupForm.chkBox30min.Checked == true)
                            txtTimer.Text = "cwID Timer: 30min";
                        else
                            txtTimer.Text = "cwID Timer: 10min";

                    }
                    else
                    {
                        if (setupForm != null && setupForm.chkBox30min.Checked == true)
                            txtTimer.Text = "  ID Timer: 30min";
                        else
                            txtTimer.Text = "  ID Timer: 10min";

                    }

                    if (setupForm != null && setupForm.chkBox30min.Checked == true)
                        DurationCount = 30;
                    else
                        DurationCount = 10;

                    txtTimer.Select(12, 2);
                    txtTimer.SelectionColor = Color.LawnGreen;
                    txtTimer.Select(0, 0);

                    Thread t = new Thread(new ThreadStart(IDTIMER));
                    t.Name = "10min ID timer Thread";
                    t.IsBackground = true;
                    t.Priority = ThreadPriority.BelowNormal;
                    t.Start();

                } //  if (chkBoxTimer1 == 0)

                else if (chkBoxTimer1 == 1)
                {
                    chkBoxTimer1 = 2; // timer on  2= timer ID starting at the next 10min mark and every 10min
                    txtTimer.ForeColor = Color.AntiqueWhite;

                    if (setupForm != null && setupForm.chkBox30min.Checked == true)
                        DurationCount = (30 - (UTCNEW % 30)); // find the time remaining until the next 10min interval
                    else
                        DurationCount = (10 - (UTCNEW % 10)); // find the time remaining until the next 10min interval



                    if (chkBoxTimer2 == true)
                    {
                        txtTimer.Text = "wfID Timer: " + DurationCount.ToString() + "minI";
                    }
                    else if (chkBoxTimer3 == true)
                    {
                        txtTimer.Text = "voID Timer: " + DurationCount.ToString() + "minI";
                    }
                    else if (chkBoxTimer4 == true)
                    {
                        txtTimer.Text = "cwID Timer: " + DurationCount.ToString() + "minI";
                    }
                    else
                    {
                        txtTimer.Text = "  ID Timer: " + DurationCount.ToString() + "minI";
                    }


                    txtTimer.Select(12, DurationCount.ToString().Length);
                    txtTimer.SelectionColor = Color.LawnGreen;
                    txtTimer.Select(0, 0);



                } //
                else
                {
                    chkBoxTimer1 = 0; // timer off

                    if (chkBoxTimer2 == true)
                    {

                        txtTimer.ForeColor = Color.AntiqueWhite;
                        txtTimer.Text = "wfID Timer: OFF";

                    }
                    else if (chkBoxTimer3 == true)
                    {

                        txtTimer.ForeColor = Color.AntiqueWhite;
                        txtTimer.Text = "voID Timer: OFF";

                    }
                    else if (chkBoxTimer4 == true)
                    {

                        txtTimer.ForeColor = Color.AntiqueWhite;
                        txtTimer.Text = "cwID Timer: OFF";

                    }
                    else
                    {

                        txtTimer.ForeColor = Color.AntiqueWhite;
                        txtTimer.Text = "  ID Timer: OFF";

                    }
                    txtTimer.Select(12, 3);
                    txtTimer.SelectionColor = Color.Red;
                    txtTimer.Select(0, 0);

                    if (setupForm != null && setupForm.chkBox30min.Checked == true)
                        DurationCount = 30;
                    else
                        DurationCount = 10;

                } //  if (chkBoxTimer1 == true)

                btnHidden.Focus();


            } // left mouse button
            else if (e.Button == MouseButtons.Right) // ke9ns  toggle wf = waterfall ID transmission
            {

                if (chkBoxTimer1 == 0) // id timer is off
                {


                    if (chkBoxTimer2 == true) // if doing waterfall ID
                    {
                        voice = false;

                        chkBoxTimer2 = false; // 
                        chkBoxTimer3 = false; //
                        chkBoxTimer4 = false; // 

                        txtTimer.ForeColor = Color.AntiqueWhite;
                        txtTimer.Text = "  ID Timer: OFF";


                    }
                    else if ((chkBoxTimer3 == false) && (voice == false))
                    {
                        WaveForm.RECPLAY = true; // ke9ns also sets waveoptions.recplay1 which sets POST

                        voice = true;

                        chkBoxTimer3 = true; // 
                        chkBoxTimer2 = false; // 
                        chkBoxTimer4 = false; // 


                        txtTimer.ForeColor = Color.AntiqueWhite;
                        txtTimer.Text = "voID Timer: OFF";

                    }
                    else if (chkBoxTimer4 == false)
                    {
                        WaveForm.RECPLAY = true; // ke9ns also sets waveoptions.recplay1 which sets POST


                        chkBoxTimer4 = true; // 
                        chkBoxTimer2 = false; // 
                        chkBoxTimer3 = false; // 


                        txtTimer.ForeColor = Color.AntiqueWhite;
                        txtTimer.Text = "cwID Timer: OFF";

                    }
                    else // if chkBoxTime3 was already True then switch to waterfall ID
                    {

                        chkBoxTimer2 = true; // 
                        chkBoxTimer3 = false; // 
                        chkBoxTimer4 = false; // 


                        txtTimer.ForeColor = Color.AntiqueWhite;
                        txtTimer.Text = "wfID Timer: OFF";

                    }

                    txtTimer.Select(12, 3);
                    txtTimer.SelectionColor = Color.Red;
                    txtTimer.Select(0, 0);

                }
                else // if timer running then do below
                {


                    if (chkBoxTimer2 == true)
                    {
                        voice = false;
                        chkBoxTimer2 = false; // 
                        chkBoxTimer3 = false; // 
                        chkBoxTimer4 = false; // 


                        txtTimer.ForeColor = Color.AntiqueWhite;

                        if (chkBoxTimer1 == 1) txtTimer.Text = "  ID Timer: " + DurationCount.ToString() + "min";
                        else txtTimer.Text = "  ID Timer: " + DurationCount.ToString() + "minI";


                    }
                    else if ((chkBoxTimer3 == false) && (voice == false))
                    {
                        WaveForm.RECPLAY = true; // ke9ns also sets waveoptions.recplay1 which sets POST

                        voice = true;
                        chkBoxTimer3 = true; // 
                        chkBoxTimer2 = false; // 
                        chkBoxTimer4 = false; // 


                        txtTimer.ForeColor = Color.AntiqueWhite;
                        if (chkBoxTimer1 == 1) txtTimer.Text = "voID Timer: " + DurationCount.ToString() + "min";
                        else txtTimer.Text = "voID Timer: " + DurationCount.ToString() + "minI";

                    }
                    else if (chkBoxTimer4 == false)
                    {
                        WaveForm.RECPLAY = true; // ke9ns also sets waveoptions.recplay1 which sets POST

                        chkBoxTimer4 = true; // 
                        chkBoxTimer2 = false; // 
                        chkBoxTimer3 = false; // 


                        txtTimer.ForeColor = Color.AntiqueWhite;
                        if (chkBoxTimer1 == 1) txtTimer.Text = "cwID Timer: " + DurationCount.ToString() + "min";
                        else txtTimer.Text = "cwID Timer: " + DurationCount.ToString() + "minI";

                    }
                    else // if chkBoxTime3 was already True then switch to waterfall ID
                    {

                        chkBoxTimer2 = true; // 
                        chkBoxTimer3 = false; // 

                        chkBoxTimer4 = false; // 

                        txtTimer.ForeColor = Color.AntiqueWhite;
                        if (chkBoxTimer1 == 1) txtTimer.Text = "wfID Timer: " + DurationCount.ToString() + "min";
                        else txtTimer.Text = "wfID Timer: " + DurationCount.ToString() + "minI";
                    }


                    if (DurationCount > 9) txtTimer.Select(12, 2);
                    else txtTimer.Select(12, 1);


                    txtTimer.SelectionColor = Color.LawnGreen;
                    txtTimer.Select(0, 0);


                } // timer1 running

            } // right mouse button



        } // txtTimer_MouseUp


        //=====================================================================
        // ke9ns add 10 minute Timer


        private void txtTimer_MouseDown(object sender, MouseEventArgs e)
        {

            txtTimer.ShortcutsEnabled = false;


        } //  txtTimer_MouseDown


        //=====================================================================
        // ke9ns add 
        /*     private void IDSQLEVEL()
             {

                 if (IDSQL < -100)
                 {

                     if (sql_data <= (float)(IDSQL - 10))
                     {
                         IDSQUELCH = true; // nobody talking so your OK to transmit ID
                     }
                     else
                     {
                         IDSQUELCH = false; // talking, so wait
                     }

                 }
                 else
                 {
                     IDSQUELCH = true; // noise floor too high to determine, so just transmit ID
                 }


             } // IDSQLEVEL()
     */

        //==================================================================
        DateTime UTCD;
        String FD;
        int UTCNEW = 0;  // used to check the time to sync onto the nearest minute
        int LASTUTC = 0;
        int DurationCount = 0;              // ID occurs every 10 min


        Stopwatch IDTIME = new Stopwatch();  // 10min timer

        public bool TIMETOID = false;   // true = 10min up and time to id  (wave plays IDTIMER.wav file)
        public bool TIMETOID1 = false;   // true = 10min up and time to id (wave.cs plays IDTIMERCW.wave file)


        public bool IDSQUELCH = false; // true =ok to ID using audio or waterfall (signal is low so nobody talking)


        //  public bool TIMETOID1 = false;   // true = get noise floor level from display
        //  public int IDSQL = 0; // noise floor level from display

        //=====================================================================
        // ke9ns add THREAD
        private void IDTIMER()
        {

            UTCD = DateTime.SpecifyKind(DateTime.UtcNow, DateTimeKind.Utc);
            FD = UTCD.ToString("HHmm");
            LASTUTC = UTCNEW = Convert.ToInt16(FD);

            IDTIME.Reset();
            //  DurationCount = 10;  // this should be 10 for 10min per ID

            bool flag1 = false; // ring flash
            bool flag2 = false; // ring flash
            bool temp1 = false; // checkkBoxID

            IDSQUELCH = true; // this will be controlled by signal levels compared to the noise floor

            while (chkBoxTimer1 > 0)
            {
                Thread.Sleep(100);            // 

                UTCD = DateTime.SpecifyKind(DateTime.UtcNow, DateTimeKind.Utc);
                FD = UTCD.ToString("HHmm");
                UTCNEW = Convert.ToInt16(FD);


                try
                {

                    if ((UTCNEW != LASTUTC)) // check 1 time per minute
                    {
                        LASTUTC = UTCNEW;

                        if (DurationCount > 0) // check 10 min
                        {


                            DurationCount--;

                            if (chkBoxTimer1 == 2) // start timer on any 10min increment of the hour
                            {

                                if (chkBoxTimer2 == true)
                                {
                                    txtTimer.Text = "wfID Timer: " + DurationCount.ToString() + "minI";
                                }
                                else if (chkBoxTimer3 == true)
                                {
                                    txtTimer.Text = "voID Timer: " + DurationCount.ToString() + "minI";
                                }
                                else if (chkBoxTimer4 == true)
                                {
                                    txtTimer.Text = "cwID Timer: " + DurationCount.ToString() + "minI";
                                }
                                else
                                {
                                    txtTimer.Text = "  ID Timer: " + DurationCount.ToString() + "minI";
                                }
                            }
                            else  // start 10min timer on the next minute
                            {

                                if (chkBoxTimer2 == true)
                                {
                                    txtTimer.Text = "wfID Timer: " + DurationCount.ToString() + "min";
                                }
                                else if (chkBoxTimer3 == true)
                                {
                                    txtTimer.Text = "voID Timer: " + DurationCount.ToString() + "min";
                                }
                                else if (chkBoxTimer4 == true)
                                {
                                    txtTimer.Text = "cwID Timer: " + DurationCount.ToString() + "min";
                                }
                                else
                                {
                                    txtTimer.Text = "  ID Timer: " + DurationCount.ToString() + "min";
                                }
                            }

                            if (DurationCount > 9) txtTimer.Select(12, 2);
                            else txtTimer.Select(12, 1);

                            txtTimer.SelectionColor = Color.LawnGreen;
                            txtTimer.Select(0, 0);

                        } //  if (DurationCount > 0)

                        if (DurationCount == 0) // TIME TO ID
                        {
                            txtTimer.Text = " >> TIME TO ID << ";
                            txtTimer.ForeColor = Color.Red;
                            panelDateTime.Invalidate();
                            grpVFOBetween.Invalidate();

                            flag1 = true;


                            if (chkBoxTimer2 == true)
                            {

                                if ((chkPower.Checked))
                                {
                                    TIMETOID = true; // let wave: chkQuickPlay_CheckedChanged know you want to play IDTIMER.WAV file only
                                    if (IDSQUELCH == true)
                                    {
                                        TXIDMenuItem_MouseDown(this, new MouseEventArgs(MouseButtons.Left, 1, 0, 0, 1)); // transmit TX Waterfall ID (only if its Green)
                                        TIMETOID = false;
                                    }
                                }
                            }
                            else if (chkBoxTimer3 == true)
                            {
                                temp1 = checkBoxID.Checked;

                                string filePath = AppDataPath + "QuickAudio\\";

                                if (WaveForm.chkQuickAudioFolder.Checked == false) WaveForm.chkQuickAudioFolder.Checked = true;

                                if (WaveForm.chkQuickAudioFolder.Checked == true)  // ke9ns add
                                {

                                    if (Directory.Exists(filePath)) // need to see the quickaudio folder
                                    {

                                        if (File.Exists(filePath + "IDTIMER.wav"))
                                        {

                                            if ((chkPower.Checked)) // ke9ns add allow tx on play directly so you dont need to mox and play
                                            {
                                                TIMETOID = true; // let wave: chkQuickPlay_CheckedChanged know you want to play IDTIMER.WAV file only

                                                checkBoxID.Checked = true;
                                                ckQuickPlay.Checked = true;
                                                chkMOX.Checked = true;     // key radio 
                                                WaveForm.QuickPlay = true;
                                                //   ckQuickPlay.BackColor = button_selected_color;
                                                // TIMETOID = false; this is set false by chkQuickPlay_CheckedChanged
                                            }


                                        } //  if (File.Exists(filePath + "\\IDTIMER.wav"))
                                        else
                                        {
                                            MessageBox.Show(new Form { TopMost = true }, "No IDTIMER.wav file found in folder: " + filePath + "\n" +
                                               "Select the [Rec/Play ID] checkbox option, then hit the REC button to record your own Audio File\n" +
                                               "Then Hit the REC button again, to end the recording, then Right Click on the PLAY Button\n" +
                                               "And rename the newest file created to: IDTIMER.wav", "IDTIMER.WAV");

                                        }

                                    } // if (!Directory.Exists(filePath)) 

                                } //  if (WaveForm.chkQuickAudioFolder.Checked == true) 
                            } // if (chkBoxTimer3 == true)
                            else if (chkBoxTimer4 == true)
                            {
                                temp1 = checkBoxID.Checked;

                                string filePath = AppDataPath + "QuickAudio\\";

                                if (WaveForm.chkQuickAudioFolder.Checked == false) WaveForm.chkQuickAudioFolder.Checked = true;

                                if (WaveForm.chkQuickAudioFolder.Checked == true)  // ke9ns add
                                {

                                    if (Directory.Exists(filePath)) // need to see the quickaudio folder
                                    {

                                        if (File.Exists(filePath + "IDTIMERCW.wav"))
                                        {

                                            if ((chkPower.Checked)) // ke9ns add allow tx on play directly so you dont need to mox and play
                                            {
                                                TIMETOID1 = true; // let wave: chkQuickPlay_CheckedChanged know you want to play IDTIMER.WAV file only

                                                checkBoxID.Checked = true;
                                                ckQuickPlay.Checked = true;
                                                chkMOX.Checked = true;     // key radio 
                                                WaveForm.QuickPlay = true;

                                            }


                                        } //  if (File.Exists(filePath + "\\IDTIMER.wav"))

                                        else
                                        {
                                            MessageBox.Show(new Form { TopMost = true }, "No IDTIMERCW.wav file found in folder: " + filePath + "\n" +
                                               "Select the [Rec/Play ID] checkbox option in CW mode, then hit the REC button to record your own CW or CWX recording.\n" +
                                               "Then Hit the REC button again, to end the recording, then Right Click on the PLAY Button\n" +
                                               "And rename the newest file created to: IDTIMERCW.wav", "IDTIMERCW.WAV");

                                        }

                                    } // if (!Directory.Exists(filePath)) 

                                } //  if (WaveForm.chkQuickAudioFolder.Checked == true) 

                            } // if (chkBoxTimer4 == true)
                            else
                            {
                                //   SystemSounds.Exclamation.Play(); // play sound on PC 
                                //   AutoClosingMessageBox.Show(">>>>TIME to ID your STATION<<<<\n>>>>TIME to ID your STATION<<<<\n>>>>TIME to ID your STATION<<<<", ">>>>TIME to ID<<<<", 5000);
                                //  MessageBox.Show(new Form { TopMost = true }, ">>>>TIME to ID your STATION<<<<\n>>>>TIME to ID your STATION<<<<","TIME-TO-ID");

                                // example of a threaded message box (new Thread(new ThreadStart(TXBW))).Start(); // just a warning message

                                TIMETOID = true;

                                if (IDBOXForm == null) IDBOXForm = new IDBOX(this);

                                IDBOXForm.Show();
                                IDBOXForm.Focus();
                                IDBOXForm.WindowState = FormWindowState.Normal; // ke9ns add

                            }


                            IDTIME.Restart(); // timer restart

                        } // Durationcount == 0

                    } //   if ((UTCNEW != LASTUTC))
                    else if (DurationCount == 0)  // flash TIME TO ID  (outside of the last minute)
                    {
                        int warntime = 8000;

                        if (chkBoxTimer2 == true) warntime = 8000; // if transmitting waterfall ID, then shorten the ID warning time


                        if (IDTIME.ElapsedMilliseconds < warntime) // 5 seconds
                        {

                            /*
                            if ((TIMETOID == true) && (IDSQUELCH == true) && (chkPower.Checked)) // check if squelch prevented Audio or waterfall ID, then try here
                            {
                                if ((chkBoxTimer2 == true))
                                {
   
                                    TXIDMenuItem_MouseDown(this, new MouseEventArgs(MouseButtons.Left, 1, 0, 0, 1)); // transmit TX Waterfall ID (only if its Green)
                                    TIMETOID = false;
                                    
                                }
                                else if ((chkBoxTimer3 == true))
                                {
                                    checkBoxID.Checked = true;
                                    ckQuickPlay.Checked = true;
                                    chkMOX.Checked = true;     // key radio 
                                    WaveForm.QuickPlay = true;

                                }


                            } //if (TIMETOID == true)
                            */

                            if ((IDTIME.ElapsedMilliseconds % 1000) < 500)
                            {
                                flag2 = false;
                                if (flag1 == false)
                                {
                                    txtTimer.ForeColor = Color.Red;
                                    panelDateTime.Invalidate();
                                    grpVFOBetween.Invalidate();

                                    flag1 = true;
                                }

                            }
                            else
                            {
                                flag1 = false;
                                if (flag2 == false)
                                {
                                    txtTimer.ForeColor = Color.Black;
                                    panelDateTime.Invalidate();
                                    grpVFOBetween.Invalidate();

                                    flag2 = true;
                                }
                            }

                        }

                        else // reset over again
                        {
                            if (setupForm != null && setupForm.chkBox30min.Checked == true)
                                DurationCount = 30;
                            else
                                DurationCount = 10;


                            flag1 = false;
                            flag2 = false;
                            txtTimer.ForeColor = Color.AntiqueWhite;

                            panelDateTime.Invalidate();


                            if (setupForm != null && setupForm.chkBox30min.Checked == true)
                            {
                                if (chkBoxTimer2 == true)
                                {
                                    if (chkBoxTimer1 == 1) txtTimer.Text = "wfID Timer: 30min";
                                    else txtTimer.Text = "wfID Timer: 30minI";
                                }
                                else if (chkBoxTimer3 == true)
                                {
                                    if (chkBoxTimer1 == 1) txtTimer.Text = "voID Timer: 30min";
                                    else txtTimer.Text = "voID Timer: 30minI";
                                }
                                else if (chkBoxTimer4 == true)
                                {
                                    if (chkBoxTimer1 == 1) txtTimer.Text = "cwID Timer: 30min";
                                    else txtTimer.Text = "cwID Timer: 30minI";
                                }
                                else
                                {
                                    if (chkBoxTimer1 == 1) txtTimer.Text = "  ID Timer: 30min";
                                    else txtTimer.Text = "  ID Timer: 30minI";
                                }
                            }
                            else
                            {
                                if (chkBoxTimer2 == true)
                                {
                                    if (chkBoxTimer1 == 1) txtTimer.Text = "wfID Timer: 10min";
                                    else txtTimer.Text = "wfID Timer: 10minI";
                                }
                                else if (chkBoxTimer3 == true)
                                {
                                    if (chkBoxTimer1 == 1) txtTimer.Text = "voID Timer: 10min";
                                    else txtTimer.Text = "voID Timer: 10minI";
                                }
                                else if (chkBoxTimer4 == true)
                                {
                                    if (chkBoxTimer1 == 1) txtTimer.Text = "cwID Timer: 10min";
                                    else txtTimer.Text = "cwID Timer: 10minI";
                                }
                                else
                                {
                                    if (chkBoxTimer1 == 1) txtTimer.Text = "  ID Timer: 10min";
                                    else txtTimer.Text = "  ID Timer: 10minI";
                                }
                            }
                            txtTimer.Select(12, 2);
                            txtTimer.SelectionColor = Color.LawnGreen;
                            txtTimer.Select(0, 0);
                            IDTIME.Stop();
                        }

                        if (chkBoxTimer3 == true)
                        {
                            if (!mox) checkBoxID.Checked = false; // was temp1;
                        }

                    } // Durationcount == 0
                }
                catch (Exception)
                {

                    txtTimer.Text = "  ID Timer: Flt";
                }


            } //  while (chkBoxTimer1 == true)

            //  TIMETOID1 = false; // turn off noise floor measurement

        } // IDTIMER THREAD


        //=====================================================================
        // ke9ns add
        private void txtNOAA_MouseDown(object sender, MouseEventArgs e)
        {

            if (noaaON == 0)
            {
                LOCALWEATHER = false;
                noaaON = 1; // turn on space weather
                btnHidden.Focus();
            }
            else if (noaaON == 1)
            {
                LOCALWEATHER = true;
                noaaON = 3; // turn on space weather
                btnHidden.Focus();
            }
            else
            {

                LOCALWEATHER = false;

                noaaON = 0; // shut down thread
                suncounter = 2;
                RadioBlackout = GeoBlackout = " ";

                txtNOAA.ForeColor = Color.AliceBlue;
                txtNOAA2.ForeColor = Color.AliceBlue;

                txtNOAA.Text = "Space WX: OFF";
                txtNOAA2.Text = "Click On";
            }

            int h_delta = this.Width - console_basis_size.Width;
            int v_delta = Math.Max(this.Height - console_basis_size.Height, 0);

            ResizeConsole(h_delta, v_delta);

            //  Console_Resize(this, e); // ke9ns add used to move panelVFO over when panelTS1 local weather is activated or deactivated

            txtNOAA.SelectAll();
            txtNOAA.SelectionAlignment = HorizontalAlignment.Center;

            txtNOAA2.SelectAll();
            txtNOAA2.SelectionAlignment = HorizontalAlignment.Center;

            txtNOAA.Select(0, 0);
            txtNOAA2.Select(0, 0);


        } // txtNOAA_Mousedown

        //========================================================================
        //========================================================================
        // ke9ns add

        private void checkBoxID_CheckedChanged(object sender, EventArgs e)
        {
            if (checkBoxID.Checked == true)
            {
                WaveForm.RECPLAY = true; // ke9ns also sets waveoptions.recplay1 which sets POST
            }

            btnHidden.Focus();


        } //checkBoxID_CheckedChanged


        // ke9ns add: from "The General" from Stackoverflow
        private static unsafe void ConvertImage(string fromPath, string toPath, Color source, Color targetColor, double threshold)
        {
            var thresh = threshold * threshold;
            var target = targetColor.ToArgb();

            using (var bmp = new Bitmap(fromPath))
            {
                // lock the array for direct access
                var data = bmp.LockBits(new Rectangle(0, 0, bmp.Width, bmp.Height), ImageLockMode.ReadWrite, PixelFormat.Format32bppPArgb);
                // Convert the source to rgb
                int sR = source.R, sG = source.G, sB = source.B;
                // store the max length so we don't have to recalculate it
                var length = (int*)data.Scan0 + bmp.Height * bmp.Width;

                for (var p = (int*)data.Scan0; p < length; p++)
                {

                    // get the rgb Distance
                    var r = ((*p >> 16) & 255) - sR;
                    var g = ((*p >> 8) & 255) - sG;
                    var b = ((*p >> 0) & 255) - sB;

                    // compare it against the threshold
                    if (r * r + g * g + b * b > thresh)
                        continue;
                    // poke the target color in
                    *p = target;
                }

                // unlock the bitmap
                bmp.UnlockBits(data);
                bmp.Save(toPath);
            }
        }


        // ke9ns add below

        public static int suncounter = 2; // for space weather
        public static byte noaaON = 0; // for space weather 1=space weather, 2=local weather, 3=both
        public static int SFI = 0;       // for Space weather
        public static int SN = 0;        // for Space weather
        public static int Aindex = 0;    // for Space weather
        public static int Kindex = 0;    // for Space weather
        public static string RadioBlackout = " ";    // R scale
        public static string GeoBlackout = " ";      // G scale
        public static string RadiationBlackout = " "; // S scale .231
        public static int EISN = 0;                    // Estimated International Sunspot Number
        public static int Last_EISN = 0; // ke9ns: .197
        public static int SSNE = 0;                   // Effecitve sunpot number
        public static int Last_SSNE = 0; // ke9ns: .197
        private string serverPath;       // for Space weather NOAA
        private string serverPath1;       // for Space weather SIDC
        private string serverPath2;       // for Space weather  NWRA


        public static string localheight; // ke9ns local height (Feet)
        public static string localheightm; // meters
        public static string localcurrtemp; // current local temperature F
        public static string localcurrtempC;
        public static string localcurrhum; // current local humidity %
        public static string localcurrfor; // current local forcast
        public static string localcurrbar; // current local press (merc)
        public static string localcurrwind; // current local wind (knots)
        public static string localcurrwindM;
        public static string localcurrwinddir; // current local wind (knots)
        public static string localcurrwinddirS;




        public bool OpenWeather = false; //ke9ns add: true= outside USA
        public void NOAA()
        {
            Debug.WriteLine("NOAA THREAD HERE");
            if (SpotForm == null || SpotForm.IsDisposed)
            {
                Debug.WriteLine("SpotControl instance created here in NOAA routine");
                SpotForm = new SpotControl(this);
            }

            OpenWeather = false;


            Debug.WriteLine("IR Cloud map from  Wisc.edu");

            try
            {
                using (WebClient client = new WebClient()) //.241
                {
                    client.DownloadFileAsync(new Uri("http://tropic.ssec.wisc.edu/real-time/mosaic/images/moseir.jpg"), AppDataPath + "IRCloudE.jpg");
                }


            }
            catch (Exception g)
            {
                Debug.WriteLine("Unable to get IR Cloud from Wisc: E" + g);

            }

            try
            {
                using (WebClient client = new WebClient()) //.241
                {
                    client.DownloadFileAsync(new Uri("http://tropic.ssec.wisc.edu/real-time/mosaic/images/mossir.jpg"), AppDataPath + "IRCloudS.jpg");
                }


            }
            catch (Exception g)
            {
                Debug.WriteLine("Unable to get IR Cloud from Wisc: S " + g);

            }
            try
            {
                using (WebClient client = new WebClient()) //.241
                {
                    client.DownloadFileAsync(new Uri("http://tropic.ssec.wisc.edu/real-time/mosaic/images/moswir.jpg"), AppDataPath + "IRCloudW.jpg");
                }

            }
            catch (Exception g)
            {
                Debug.WriteLine("Unable to get IR Cloud from Wisc: W " + g);

            }



            Debug.WriteLine("Lightning map from Blitzortung ");

            try
            {
                using (WebClient client = new WebClient()) //.240
                {
                    //  client.DownloadFileAsync(new Uri("https://www.blitzortung.org/en/canvas.png"), AppDataPath + "Canvas.png");
                    client.DownloadFileAsync(new Uri("https://www.blitzortung.org/en/Images/image_b_earth.png"), AppDataPath + "Canvas.png");

                }

            }
            catch (Exception g)
            {
                Debug.WriteLine("Unable to get Lightning from Blitzortung: " + g);

            }



            Debug.WriteLine("NOAA DRAP D-Layer absorption image capture");

            try
            {
                using (WebClient client = new WebClient()) //.234
                {
                    client.DownloadFileAsync(new Uri("https://services.swpc.noaa.gov/images/drap_global.png"), AppDataPath + "DRAP.png");
                }


            }
            catch (Exception g)
            {
                Debug.WriteLine("Unable to get DRAP image from noaa: " + g);

            }

            Debug.WriteLine("SWS F-Layer reflection image capture");
            try
            {
                using (WebClient client = new WebClient()) //.234
                {
                    client.DownloadFileAsync(new Uri("https://www.sws.bom.gov.au/Images/HF%20Systems/Global%20HF/Ionospheric%20Map/WorldIMap0.gif"), AppDataPath + "FRAP.gif");

                }


            }
            catch (Exception g)
            {
                Debug.WriteLine("Unable to get DRAP image from noaa: " + g);

            }



            string currweth1 = httpFile.Weather(); // get local weather data if in USA
            var xdoc = new XDocument();

            try
            {
                xdoc = XDocument.Parse(currweth1, LoadOptions.None);
            }
            catch (Exception g)
            {
                Debug.WriteLine("Xdocument parse: " + g);

                Debug.WriteLine("SWITCH TO OPENWEATHER: ");

                OpenWeather = true;

            }

            if (OpenWeather == false)
            {
                //  if (((int)SpotForm.udDisplayLat.Value > 24) && ((int)SpotForm.udDisplayLat.Value < 51))
                //   if (((int)SpotForm.udDisplayLong.Value > -140) && ((int)SpotForm.udDisplayLong.Value < -69))
                //   {


                Debug.WriteLine("USE NOAA weather (your in the USA)=========");


                Debug.WriteLine("GOOD LAT AND LONG weather data4=========");
                Debug.WriteLine(" ");

                // Debug.WriteLine(xdoc);


                try
                {
                    localcurrfor = xdoc.Descendants("wordedForecast").Descendants("text").ElementAt(0).Value; // get todays forcast in text
                    localweatherupdate = true; // tell screen to update with new weather data

                }
                catch (Exception h)
                {
                    Debug.WriteLine("weather for bad: " + h);

                }

                try
                {
                    localcurrwind = xdoc.Descendants("data").Skip(1).Descendants("wind-speed").Skip(1).Descendants("value").ElementAt(0).Value; // KNOTS
                    localcurrwindM = ((int)(Convert.ToDouble(localcurrwind) * 1.152)).ToString();  // mph = knots * 1.152

                }
                catch (Exception h)
                {
                    Debug.WriteLine("weather for wind: " + h);
                }

                try
                {
                    localcurrwinddir = xdoc.Descendants("data").Skip(1).Descendants("direction").Descendants("value").ElementAt(0).Value;

                    int temp11 = Convert.ToInt32(localcurrwinddir);

                    if ((temp11 >= 350) || (temp11 < 10)) localcurrwinddirS = "N";
                    else if ((temp11 >= 10) && (temp11 < 80)) localcurrwinddirS = "NE";
                    else if ((temp11 >= 80) && (temp11 < 100)) localcurrwinddirS = "E";
                    else if ((temp11 >= 100) && (temp11 < 170)) localcurrwinddirS = "SE";
                    else if ((temp11 >= 170) && (temp11 < 190)) localcurrwinddirS = "S";
                    else if ((temp11 >= 190) && (temp11 < 260)) localcurrwinddirS = "SW";
                    else if ((temp11 >= 260) && (temp11 < 280)) localcurrwinddirS = "W";
                    else if ((temp11 >= 280) && (temp11 < 350)) localcurrwinddirS = "NW";
                    else localcurrwinddirS = "--";

                    if (temp11 < 0 || temp11 > 360) localcurrwinddir = "--";


                }
                catch (Exception h)
                {
                    Debug.WriteLine("weather for wind dir: " + h);
                    localcurrwinddir = "--";
                    localcurrwinddirS = "--";
                }

                try
                {
                    localcurrbar = xdoc.Descendants("data").Skip(1).Descendants("pressure").Descendants("value").ElementAt(0).Value;
                }
                catch (Exception h)
                {
                    Debug.WriteLine("weather for press" + h);
                }

                try
                {
                    localcurrhum = xdoc.Descendants("data").Skip(1).Descendants("humidity").Descendants("value").ElementAt(0).Value;
                }
                catch (Exception h)
                {
                    Debug.WriteLine("weather for humidity" + h);
                }

                try
                {
                    localcurrtemp = xdoc.Descendants("data").Skip(1).Descendants("temperature").Descendants("value").ElementAt(0).Value;
                    localcurrtempC = ((int)((Convert.ToDouble(localcurrtemp) - 32.0) * 5 / 9)).ToString(); // C = (F-32)*5/9
                }
                catch (Exception h)
                {
                    Debug.WriteLine("weather for temp" + h);
                }

                try
                {
                    localheight = xdoc.Descendants("location").Descendants("height").ElementAt(0).Value; // feet
                    localheightm = ((int)((Convert.ToDouble(localheight) * 0.3048))).ToString(); // meters
                }
                catch (Exception h)
                {
                    Debug.WriteLine("weather for height" + h);
                }

                //  } // long
                //  else OpenWeather = true;
            } // lat   //  else OpenWeather = true;
            else  // ke9ns: // if (OpenWeather == true)   for outside of the USA use openweather
            {

                Debug.WriteLine("OPENWEATHER");

                string currweth = httpFile.WeatherOpen(); // get local weather data if in USA
                string currheight = httpFile.WeatherOpen1();// get height

                //   Debug.WriteLine(" " + currweth);
                Debug.WriteLine("OPENWEATHER1");

                try
                {
                    int temp = currweth.IndexOf("name");
                    int temp1 = currweth.IndexOf("cod");
                    if (temp1 > 0)
                    {
                        localcurrfor = currweth.Substring(temp + 7, temp1 - (temp + 7) - 3);// get todays forcast in text

                        localcurrfor += ":\n";
                        Debug.WriteLine("localcurrfor " + temp + " , " + temp1 + " , " + localcurrfor);

                        localweatherupdate = true; // tell screen to update with new weather data
                    }
                    else
                    {
                        // no name available

                        Debug.WriteLine("NO NAME AVAILABLE");

                    }


                }
                catch (Exception h)
                {
                    Debug.WriteLine("openbweather for bad: " + h);
                }

                try
                {
                    int temp = currweth.IndexOf("description");
                    int temp1 = currweth.IndexOf("icon");
                    localcurrfor += currweth.Substring(temp + 14, temp1 - (temp + 14) - 3);// get todays forcast in text

                    Debug.WriteLine("localcurrfor " + temp + " , " + temp1 + " , " + localcurrfor);

                    localweatherupdate = true; // tell screen to update with new weather data

                }
                catch (Exception h)
                {
                    Debug.WriteLine("openbweather for bad: " + h);
                }

                try
                {
                    int temp = currweth.IndexOf("speed");
                    int temp1 = currweth.IndexOf("deg");
                    localcurrwind = currweth.Substring(temp + 7, temp1 - (temp + 7) - 2);
                    Debug.WriteLine("localcurrwind " + temp + " , " + temp1 + " , " + localcurrwind);

                    localcurrwindM = ((int)(Convert.ToDouble(localcurrwind) * 0.54)).ToString();  // kph = knots * .54

                }
                catch (Exception h)
                {
                    Debug.WriteLine("openweather for wind: " + h);
                }

                try
                {

                    int temp = currweth.IndexOf("deg");
                    int temp1 = 0;

                    int temp9 = currweth.IndexOf(",", temp);
                    int temp10 = currweth.IndexOf("}", temp);

                    if (temp10 < temp9) temp1 = temp10;
                    else temp1 = temp9;

                    localcurrwinddir = currweth.Substring(temp + 5, temp1 - (temp + 5));
                    Debug.WriteLine("localcurrwinddir " + temp + " , " + temp1 + " , " + localcurrwinddir);


                    int temp11 = Convert.ToInt32(localcurrwinddir);

                    if ((temp11 >= 350) || (temp11 < 10)) localcurrwinddirS = "N";
                    else if ((temp11 >= 10) && (temp11 < 80)) localcurrwinddirS = "NE";
                    else if ((temp11 >= 80) && (temp11 < 100)) localcurrwinddirS = "E";
                    else if ((temp11 >= 100) && (temp11 < 170)) localcurrwinddirS = "SE";
                    else if ((temp11 >= 170) && (temp11 < 190)) localcurrwinddirS = "S";
                    else if ((temp11 >= 190) && (temp11 < 260)) localcurrwinddirS = "SW";
                    else if ((temp11 >= 260) && (temp11 < 280)) localcurrwinddirS = "W";
                    else if ((temp11 >= 280) && (temp11 < 350)) localcurrwinddirS = "NW";
                    else localcurrwinddirS = "--";

                    if (temp11 < 0 || temp11 > 360) localcurrwinddir = "--";


                }
                catch (Exception h)
                {
                    Debug.WriteLine("weather for wind dir: " + h);
                    localcurrwinddir = "--";
                    localcurrwinddirS = "--";
                }

                try
                {
                    int temp = currweth.IndexOf("pressure");
                    int temp1 = currweth.IndexOf("humidity", temp);

                    localcurrbar = currweth.Substring(temp + 10, temp1 - (temp + 10) - 2); // in mBar (not inHg)
                    Debug.WriteLine("localcurrbar " + temp + " , " + temp1 + " , " + localcurrbar);

                }
                catch (Exception h)
                {
                    Debug.WriteLine("weather for press" + h);
                }

                try
                {
                    int temp = currweth.IndexOf("humidity");
                    int temp1 = 0;

                    int temp11 = currweth.IndexOf(",", temp);
                    int temp10 = currweth.IndexOf("}", temp);

                    if (temp10 < temp11) temp1 = temp10;
                    else temp1 = temp11;


                    localcurrhum = currweth.Substring(temp + 10, temp1 - (temp + 10));
                    Debug.WriteLine("localcurrhum " + temp + " , " + temp1 + " , " + localcurrhum);


                }
                catch (Exception h)
                {
                    Debug.WriteLine("weather for humidity" + h);
                }

                try
                {
                    int temp = currweth.IndexOf("temp");
                    int temp1 = currweth.IndexOf("feels_like", temp);

                    localcurrtempC = currweth.Substring(temp + 6, temp1 - (temp + 6) - 3);
                    Debug.WriteLine("localcurrtempC " + temp + " , " + temp1 + " , " + localcurrtempC);


                    localcurrtemp = ((int)((Convert.ToDouble(localcurrtempC) * 9.0 / 5.0) + 32.0)).ToString();

                    //  localcurrtempC = ((int)((Convert.ToDouble(localcurrtemp) - 32.0) * 5 / 9)).ToString(); // C = (F-32)*5/9


                }
                catch (Exception h)
                {
                    Debug.WriteLine("weather for temp" + h);
                }

                try
                {
                    int temp = currheight.IndexOf("height");
                    int temp1 = 0;

                    int temp11 = currheight.IndexOf("]", temp);
                    int temp10 = currheight.IndexOf("}", temp);

                    if (temp10 < temp11) temp1 = temp10;
                    else temp1 = temp11;

                    localheightm = currheight.Substring(temp + 8, temp1 - (temp + 8));

                    Debug.WriteLine("1localheight " + temp + " , " + temp1);

                    if (Convert.ToDouble(localheightm) < 0.0)
                    {
                        localheightm = "0";
                        localheight = "0";
                    }
                    else
                    {
                        localheight = ((int)(Convert.ToDouble(localheightm) * 3.28)).ToString(); // feet
                    }


                    // localheightm = ((int)((Convert.ToDouble(localheight) * 0.3048))).ToString(); // meters


                }
                catch (Exception h)
                {
                    Debug.WriteLine("weather for height" + h);
                }

            } // if (OpenWeather == true)


            //  Debug.WriteLine("Weather data: " + localheight + "feet,  " + localcurrtemp + "F, " + localcurrhum + "%hum, " + localcurrwind + "knots, " + localcurrbar + "inHg, " + localcurrfor);


            //--------------------------------------------------------------------------------

            Debug.WriteLine("GET NOAA=========");

            suncounter = 1;
            serverPath1 = "https://services.swpc.noaa.gov/text/wwv.txt"; // this gets SF, A, K and storm data,    SIDC gets SS,  nwra gets Effective sun spot number "https://spawx.nwra.com/spawx/env_latest.html";

            try
            {
                ServicePointManager.Expect100Continue = true;
                ServicePointManager.SecurityProtocol = SecurityProtocolType.Tls12;
                // Use SecurityProtocolType.Ssl3 if needed for compatibility reasons

                HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(serverPath1);
                HttpWebResponse webResponse = (HttpWebResponse)webRequest.GetResponse();

                Stream responseStream1 = webResponse.GetResponseStream();
                StreamReader streamReader1 = new StreamReader(responseStream1);

                string noaa = streamReader1.ReadToEnd();

                responseStream1.Close();
                streamReader1.Close();

                Debug.WriteLine("GOT  NOAA=========");


                /*  ftp site turned off on Dec 9th, 2017
                       serverPath = "ftp://ftp.swpc.noaa.gov/pub/latest/wwv.txt"; 

                        FtpWebRequest request = (FtpWebRequest)WebRequest.Create(serverPath);

                        //  textBox1.Text += "Attempt to download Space Weather \r\n";

                        request.KeepAlive = true;
                        request.UsePassive = true;
                        request.UseBinary = true;

                        request.Method = WebRequestMethods.Ftp.DownloadFile;
                        string username = "anonymous";
                        string password = "guest";
                        request.Credentials = new NetworkCredential(username, password);

                        string noaa = null;

                        try
                        {
                            FtpWebResponse response = (FtpWebResponse)request.GetResponse();

                            Stream responseStream = response.GetResponseStream();
                            StreamReader reader = new StreamReader(responseStream);
                            noaa = reader.ReadToEnd();

                            reader.Close();
                            response.Close();
                            //   Debug.WriteLine("noaa=== " + noaa);

                            //   textBox1.Text += "NOAA Download complete \r\n";


                */



                //--------------------------------------------------------------------
                if (noaa.Contains("Solar flux ")) // 
                {

                    int ind = noaa.IndexOf("Solar flux ") + 11;

                    try
                    {
                        SFI = (int)(Convert.ToDouble(noaa.Substring(ind, 3)));
                        Debug.WriteLine("SFI " + SFI);
                    }
                    catch (Exception)
                    {
                        SFI = 0;
                    }


                } // SFI

                if (noaa.Contains("A-index ")) // 
                {

                    int ind = noaa.IndexOf("A-index ") + 8;

                    try
                    {
                        Aindex = (int)(Convert.ToDouble(noaa.Substring(ind, 2)));
                        Debug.WriteLine("Aindex " + Aindex);
                    }
                    catch (Exception)
                    {
                        Aindex = 0;
                    }


                } // Aindex

                if (noaa.Contains("K-index ") && noaa.Contains(" was ")) // 
                {

                    int ind = noaa.IndexOf(" was ") + 5;

                    try
                    {
                        Kindex = (int)(Convert.ToDouble(noaa.Substring(ind, 2)));
                        Debug.WriteLine("Kindex " + Aindex);
                    }
                    catch (Exception)
                    {
                        Kindex = 0;
                    }


                } // Kindex


                if (noaa.Contains("Radio blackouts reaching the ")) // 
                {

                    int ind = noaa.IndexOf("Radio blackouts reaching the ") + 29;

                    try
                    {
                        RadioBlackout = noaa.Substring(ind, 2);
                        Debug.WriteLine("Radio Blackout " + RadioBlackout);
                    }
                    catch (Exception)
                    {
                        RadioBlackout = " ";
                    }


                } // radio blackouts
                else
                {
                    RadioBlackout = " ";
                }

                if (noaa.Contains("level occurred") && noaa.Contains("Geomagnetic storms reaching the ")) // 
                {

                    int ind = noaa.IndexOf("Geomagnetic storms reaching the ") + 32;

                    try
                    {
                        GeoBlackout = noaa.Substring(ind, 2);
                        Debug.WriteLine("Geomagnetic storms" + GeoBlackout);
                    }
                    catch (Exception)
                    {
                        GeoBlackout = " ";
                    }


                } //geo storms
                else
                {
                    GeoBlackout = " ";
                }

                if (RadioBlackout != " ")
                {
                    RadioBlackout = RadioBlackout + GeoBlackout;
                    Debug.WriteLine("radio-geo " + RadioBlackout);

                }
                else
                {
                    RadioBlackout = GeoBlackout;
                    Debug.WriteLine("geo " + RadioBlackout);
                }

            } // try
            catch (Exception ex)
            {
                Debug.WriteLine("1noaa fault=== " + ex);

                noaaON = 0; // failure to get data
            }

            Debug.WriteLine("endof NOAA thread");


            //--------------------------------------------------------------------------
            //--------------------------------------------------------------------------
            //--------------------------------------------------------------------------
            //--------------------------------------------------------------------------
            // ke9ns get Estimated International Sunspot Number (EISN)


            Debug.WriteLine("GET SIDC=========");

            suncounter = 1;
            serverPath1 = "http://www.sidc.be/silso/DATA/EISN/EISN_current.txt";

            try
            {

                HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(serverPath1);
                HttpWebResponse webResponse = (HttpWebResponse)webRequest.GetResponse();

                Stream responseStream1 = webResponse.GetResponseStream();
                StreamReader streamReader1 = new StreamReader(responseStream1);

                string eisn = streamReader1.ReadToEnd();

                responseStream1.Close();
                streamReader1.Close();


                Debug.WriteLine("GET SIDC1=========");
                //  Debug.WriteLine("GET SIDC1=========" + eisn);

                int len = eisn.Length;

                //   Debug.WriteLine("GET SIDC2=========" + len);

                string sub1 = eisn.Substring(len - 18, 3); // get Sunspot value from end of file (newest data)

                //   Debug.WriteLine("GET SIDC3=========" + sub1);

                try
                {
                    EISN = Convert.ToInt16(sub1);
                    if (Last_EISN != EISN) // .197
                    {
                        last_MHZ = 0;
                        SpotControl.Map_Last = SpotControl.Map_Last | 2;    // force update of world map
                    }
                }
                catch (Exception)
                {
                    EISN = 0;
                    Debug.WriteLine("Failed to detect EISN# from text file");

                }

            }
            catch (Exception)
            {
                Debug.WriteLine("Could not get SIDC EISN#");
            }

            //    Debug.WriteLine("endof SIDC thread");

            //--------------------------------------------------------------------------
            //--------------------------------------------------------------------------
            //--------------------------------------------------------------------------
            //--------------------------------------------------------------------------
            // ke9ns get Effective SSN from NWRA


            Debug.WriteLine("GET NWRA=========");


            serverPath2 = "https://spawx.nwra.com/spawx/env_latest.html";

            try
            {
                ServicePointManager.Expect100Continue = true;
                ServicePointManager.SecurityProtocol = SecurityProtocolType.Tls12;
                // Use SecurityProtocolType.Ssl3 if needed for compatibility reasons

                HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(serverPath2);
                HttpWebResponse webResponse = (HttpWebResponse)webRequest.GetResponse();

                Stream responseStream1 = webResponse.GetResponseStream();
                StreamReader streamReader1 = new StreamReader(responseStream1);

                string ssne = streamReader1.ReadToEnd();

                responseStream1.Close();
                streamReader1.Close();

                Debug.WriteLine("GET SSNe=========");

                //   Debug.WriteLine("GET SSNe=========" + ssne);

                //  int len = ssne.Length;

                if (ssne.Contains("NWRA SSNe:") == true) // example:  NWRA SSNe:    24.5    26.7    27.4    23.2    26.0     7.1     9.1
                {
                    int len = ssne.IndexOf("NWRA SSNe:");  // location of first char in this string


                    string sub1 = ssne.Substring(len + 59, 5); // get newest effective ssn#

                    //   Debug.WriteLine("GET SSNe3=========" + sub1);

                    try
                    {
                        SSNE = Convert.ToInt16(sub1);
                        if (SSNE == -999) SSNE = 0;

                        if (Last_SSNE != SSNE) // .197
                        {
                            last_MHZ = 0;
                            SpotControl.Map_Last = SpotControl.Map_Last | 2;    // force update of world map
                        }
                    }
                    catch (Exception)
                    {
                        SSNE = 0;
                        Debug.WriteLine("Failed to detect EISN# from text file");

                    }

                } // contains NWRA SSNe:
            }
            catch (Exception)
            {
                Debug.WriteLine("Could not get NWRA SSNe#");
            }

            //   Debug.WriteLine("endof NWRA thread");

        } // NOAA thread to get space weather



        //=============================================================================================
        private void radBandWWV_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((regBand == 1) && (me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                if (band_wwv_register < 9)
                {
                    DB.AddBandStack("WWV", "SAM", "F5", 25.000000); // take current band, DSP mode, filter, and freq
                    DB.AddBandText(25.000000, 25.000000, "WWV", false);

                    UpdateBandStackRegisters();
                    UpdateBandButtonColors();
                }
            } // right click
        }

        private void autoBrightBox_MouseUp(object sender, MouseEventArgs e)
        {
            autoBrightBox.ForeColor = Color.White;
        }



        //============================================================================
        // ke9ns add to determine if you want the peak db numbers to appear in the lower right of the pan display area
        private void txtDisplayPeakPower_TextChanged(object sender, EventArgs e)
        {
            if (peak1 == 1) peak1 = 0;
            else peak1 = 1;
            btnHidden.Focus();
        }

        private void lblCPUMeter_Click(object sender, EventArgs e)
        {

        }

        private void txtVFOAMSD_TextChanged(object sender, EventArgs e)
        {

        }




        //============================================================================================
        // ke9ns add everything below as part of PowerMate add one
        //================================================================================================
        // Button Push event handler
        //================================================================================================
        public void OnButtonEvent(HidDevice.PowerMate.ButtonState bs, int value, int value1, int value2)
        {

            switch (bs)   // 2 cases UP or DOwn
            {
                case HidDevice.PowerMate.ButtonState.Down:
                    {
                        Debug.WriteLine(" down");
                        if (RIT == true)
                        {
                            RITValue = 0; // reset RIT back to zero if you hit the KNOB
                        }
                        else
                        {
                            if (setupForm.chkKnobVFO.Checked == true)
                            {
                                if (setupForm.chkKnobVFOB.Checked) setupForm.chkKnobVFOB.Checked = false;
                                else setupForm.chkKnobVFOB.Checked = true;
                            }
                            else
                            {
                                if (setupForm.chkBoxIND.Checked == true) // ke9ns (check if Alt tune step ON for powermat knob)
                                {

                                    if (setupForm.tune_step_index4 != setupForm.tune_step_index3)
                                    {
                                        setupForm.tune_step_index4 = setupForm.tune_step_index3; // ke9ns temp storage
                                    }
                                    else
                                    {
                                        setupForm.tune_step_index4 = setupForm.tune_step_index2; // ke9ns 
                                    }


                                    setupForm.txtWheelTune2.Text = tune_step_list[setupForm.tune_step_index2].Name;
                                    setupForm.txtWheelTune3.Text = tune_step_list[setupForm.tune_step_index3].Name;



                                    /*  
                                       if (setupForm.tune_step_index2 >= 6) // ke9ns if 
                                       {
                                           setupForm.tune_step_index2 = 3 % tune_step_list.Count;

                                           setupForm.txtWheelTune2.Text = tune_step_list[setupForm.tune_step_index2].Name;
                                       }
                                       else
                                       {
                                           setupForm.ChangeTuneStepUp2();
                                       }
                                     */

                                }
                                else // cycle through the mouse tune steps
                                {
                                    if (tune_step_index >= 6)
                                    {
                                        tune_step_index = 3 % tune_step_list.Count;
                                        txtWheelTune.Text = tune_step_list[tune_step_index].Name;
                                    }
                                    else
                                    {
                                        ChangeTuneStepUp();
                                    }

                                    grpVFOBetween.Invalidate();

                                }
                            }
                        }
                    }
                    break;

                case HidDevice.PowerMate.ButtonState.Up:
                    {
                        Debug.WriteLine("up");

                    }
                    break;
            } // switch


        } // onbutton



        //================================================================================================
        //   LED brightness event handler (slider)
        //================================================================================================

        public void OnSliderBrightness(object sender, EventArgs e)
        {
            TrackBar slider = sender as TrackBar;

            if (slider != null)
            {
                //  LEDV = (int)slider.Value;
                this.powerMate.LedBrightness = (byte)slider.Value; // get slider bar value to set LED


                Trace.WriteLine(slider.Value.ToString());
            }

        }

        public static int CTUN3 = 0;      // ke9ns add keep rundisplay() thread from updating pan and water too soon in CTUn mode
        public static bool CTUN = false;  // ke9ns add CTUN feature ON/OFF
        public static long CTUN1_HZ = 0;  // ke9ns add used in Calcdisplayfreq() to keep display from moving and allow vfoa bandpass to move across display
        public double tempVFOAFreq = 0.0; //  ke9ns add hold new vfo freq seperate from real vfoafreq to sync up display movement
        public static int UPDATEOFF = 0;  // ke9ns add pan & waterfall delay while CTUN is on and your sliding across the display

        //============================================================================
        // ke9ns add: To turn on/off CTUN feature
        //  CTUN=0 normal, 1=main bandpass moves (just like the sub does across the display)
        private void lblDisplayPan_MouseDown(object sender, MouseEventArgs e)
        {
            if (CTUN == false)
            {
                //  CTUN1_HZ = 0;
                CTUN = true;

                lblDisplayPan1.Image = global::PowerSDR.Properties.Resources.PanRed;  // lblDisplayPan.ForeColor = Color.Red;
            }
            else
            {
                //  CTUN1_HZ = 0;
                CTUN = false;
                lblDisplayPan1.Image = global::PowerSDR.Properties.Resources.panGray;  // lblDisplayPan.ForeColor = Color.White;

            }

        } // pan text from console window


        // ke9ns add  make sure to turn off CTUN if not in water, or pan or panfall modes
        private bool CTUN1
        {
            get
            {
                return CTUN;
            }
            set
            {
                CTUN = value;
                if (CTUN == true) lblDisplayPan1.Image = global::PowerSDR.Properties.Resources.PanRed; //lblDisplayPan.ForeColor = Color.Red;
                else lblDisplayPan1.Image = global::PowerSDR.Properties.Resources.panGray;  // lblDisplayPan.ForeColor = Color.White;

            }


        } // CTUN1

        //================================================================================================
        // ke9ns add  PowerMate Griffin Knob rotation value event handler
        //================================================================================================
        public void OnRotateEvent(int value1)
        {
            // Trace.WriteLine("ROTATE "+ value1);

            if (((lastvalue < 0) && (value1 > 0)) || ((lastvalue > 0) && (value1 < 0))) // if knob changes directions, reset speed counter
            {
                speed = 0;
                lastvalue = value1;
                return;
            }

            lastvalue = value1;

            if (speed < (int)setupForm.udSpeedPM.Value)
            {
                speed++;
                return; // wait until you turn knob in 1 direction far enough to exceed speed rating you set in setup.cs
            }
            else speed = 0; // you turned knob far enough so reset speed counter

            if (setupForm != null && setupForm.chkKnobVFOB.Checked == false) //.249
            {
                if (CTUN == false) // ke9ns: CTUN is where the Screen stays put and the bandpass window moves (when TRUE).
                {
                    //---------------------------------------------
                    if (value1 < 0)
                    {
                        if (RIT == true)
                        {
                            RITValue = RITValue - 1;
                        }
                        else
                        {
                            if (setupForm.chkBoxIND.Checked == true)
                            {
                                int num_steps = -1;
                                if (vfo_char_width == 0) GetVFOCharWidth();
                                int step = CurrentTuneStepHz2;  // ke9ns add
                                VFOAFreq = SnapTune(VFOAFreq, step, num_steps);
                            }
                            else
                            {
                                if (setupForm != null)
                                {
                                    if (setupForm.chkBoxWheelRev.Checked == true) Console_MouseWheel(this, new MouseEventArgs(MouseButtons.None, 0, 0, 0, 120)); // reverse it here, I will reverse it later also
                                    else Console_MouseWheel(this, new MouseEventArgs(MouseButtons.None, 0, 0, 0, -120));
                                }

                            }
                        }
                    }
                    else // value >= 0
                    {
                        if (RIT == true)
                        {
                            RITValue = RITValue + 1;
                        }
                        else
                        {
                            if (setupForm.chkBoxIND.Checked == true) // alt tune step value
                            {
                                int num_steps = 1;

                                if (vfo_char_width == 0) GetVFOCharWidth();

                                int step = CurrentTuneStepHz2;  // ke9ns add

                                VFOAFreq = SnapTune(VFOAFreq, step, num_steps);

                            }
                            else
                            {
                                if (setupForm != null)
                                {
                                    if (setupForm.chkBoxWheelRev.Checked == true) Console_MouseWheel(this, new MouseEventArgs(MouseButtons.None, 0, 0, 0, -120));
                                    else Console_MouseWheel(this, new MouseEventArgs(MouseButtons.None, 0, 0, 0, 120));
                                }

                                //  Console_MouseWheel(this, new MouseEventArgs(MouseButtons.None, 0, 0, 0, 120));
                            }
                        }
                    }
                } // CTUN false
                else // CTUN true
                {

                    if ((Display.CurrentDisplayMode == DisplayMode.PANADAPTER) || (Display.CurrentDisplayMode == DisplayMode.PANAFALL) || (Display.CurrentDisplayMode == DisplayMode.PANASCOPE) || (Display.CurrentDisplayMode == DisplayMode.WATERFALL))
                    {
                        UPDATEOFF = 2; // 2 ke9ns let system know not to update screen for a little while pan
                    }

                    if (value1 < 0)
                    {
                        CTUN1_HZ = CTUN1_HZ - CurrentTuneStepHz;// ke9ns add allow bandpass window to scroll across display instead of display freq scroll under bandpass.
                        tempVFOAFreq = VFOAFreq - (double)CurrentTuneStepHz / 1e6; // vfoafreq in mhz
                        CalcDisplayFreq(); // ke9ns keep display from moving
                    }
                    else if (value1 > 0) // value >= 0
                    {

                        //  commands.ZZAU("01"); // .178
                        //  setupForm.parser.Get("ZZAU01;");

                        CTUN1_HZ = CTUN1_HZ + CurrentTuneStepHz;// ke9ns add allow bandpass window to scroll across display instead of display freq scroll under bandpass.
                        tempVFOAFreq = VFOAFreq + (double)CurrentTuneStepHz / 1e6;
                        CalcDisplayFreq(); // ke9ns keep display from moving
                    }

                    //   Debug.WriteLine("CTUN="+ CTUN1_HZ);


                } // CTUN true

            } //   if (setupForm.chkKnobVFOB.Checked == false)
            else // VFOB
            {
                //.249 ke9ns have not made a CTUN for VFOB yet.

                if (CTUN == false) // ke9ns: CTUN is where the Screen stays put and the bandpass window moves (when TRUE).
                {
                    //---------------------------------------------
                    if (value1 < 0)
                    {
                        if (RIT == true)
                        {
                            RITValue = RITValue - 1;
                        }
                        else
                        {
                            if (setupForm.chkBoxIND.Checked == true)
                            {
                                int num_steps = -1;
                                if (vfo_char_width == 0) GetVFOCharWidth();
                                int step = CurrentTuneStepHz2;  // ke9ns add
                                VFOBFreq = SnapTune(VFOBFreq, step, num_steps);
                            }
                            else
                            {

                                int step = CurrentTuneStepHz;
                                int num_steps = -1;
                                if (vfo_char_width == 0) GetVFOCharWidth();
                                VFOBFreq = SnapTune(VFOBFreq, step, num_steps);
                            }
                        }
                    }
                    else // value >= 0
                    {
                        if (RIT == true)
                        {
                            RITValue = RITValue + 1;
                        }
                        else
                        {
                            if (setupForm.chkBoxIND.Checked == true) // alt tune step value
                            {
                                int num_steps = 1;
                                if (vfo_char_width == 0) GetVFOCharWidth();
                                int step = CurrentTuneStepHz2;  // ke9ns add
                                VFOBFreq = SnapTune(VFOBFreq, step, num_steps);

                            }
                            else
                            {
                                int step = CurrentTuneStepHz;
                                int num_steps = 1;
                                if (vfo_char_width == 0) GetVFOCharWidth();
                                VFOBFreq = SnapTune(VFOBFreq, step, num_steps);


                            }
                        }
                    }
                } // CTUN false
                else // CTUN true
                {

                    if ((Display.CurrentDisplayMode == DisplayMode.PANADAPTER) || (Display.CurrentDisplayMode == DisplayMode.PANAFALL) || (Display.CurrentDisplayMode == DisplayMode.PANASCOPE) || (Display.CurrentDisplayMode == DisplayMode.WATERFALL))
                    {
                        UPDATEOFF = 2; // 2 ke9ns let system know not to update screen for a little while pan
                    }

                    if (value1 < 0)
                    {
                        CTUN1_HZ = CTUN1_HZ - CurrentTuneStepHz;// ke9ns add allow bandpass window to scroll across display instead of display freq scroll under bandpass.
                        tempVFOAFreq = VFOAFreq - (double)CurrentTuneStepHz / 1e6; // vfoafreq in mhz
                        CalcDisplayFreq(); // ke9ns keep display from moving
                    }
                    else if (value1 > 0) // value >= 0
                    {

                        //  commands.ZZAU("01"); // .178
                        //  setupForm.parser.Get("ZZAU01;");

                        CTUN1_HZ = CTUN1_HZ + CurrentTuneStepHz;// ke9ns add allow bandpass window to scroll across display instead of display freq scroll under bandpass.
                        tempVFOAFreq = VFOAFreq + (double)CurrentTuneStepHz / 1e6;
                        CalcDisplayFreq(); // ke9ns keep display from moving
                    }

                    //   Debug.WriteLine("CTUN="+ CTUN1_HZ);


                } // CTUN true


            } //   if (setupForm.chkKnobVFOB.Checked == true



        } //onrotateevent

        //================================================================================================
        // rotation value to screen invoked from above
        //================================================================================================

        void SetRotateLabel()
        {
            //  this.rotationLabel.Text = currentRotationalValue.ToString();

        }
        //================================================================================================
        // rotation value to screen invoked from above
        //================================================================================================

        void SetSENDLabel()
        {

        }





        //=========================================================================================
        //=========================================================================================
        // ke9ns add to allow TX filter on main console SSB panel
        private void udTXFilterHigh_ValueChanged(object sender, EventArgs e)
        {
            if (setupForm != null) setupForm.udTXFilterHigh.Value = udTXFilterHigh.Value;

            btnHidden.Focus();
        }

        // ke9ns add
        private void udTXFilterLow_ValueChanged(object sender, EventArgs e)
        {
            if (setupForm != null) setupForm.udTXFilterLow.Value = udTXFilterLow.Value;

            btnHidden.Focus();

        }





        //=========================================================================================
        //=========================================================================================
        // ke9ns add send hygain rotor command to DDUtil via the CAT port setup in PowerSDR
        public string spotDDUtil_Rotor // called from SPOT.cs routine when clicking on DX SPOT
        {

            set
            {
                if (ROTOREnabled == false) return; // if rotor is not connected then dont check

                try
                {
                    Debug.WriteLine("CAT ROTOR1:");
                    siolisten1.SIO1.put(value);   // this is the DDUtil PORT found in setup and SIOListenerIII.cs
                }
                catch { }

            }

        } // 

        // ke9ns add
        public string RotorAngle = "NA";  // ke9ns add
        public bool RotorAngleRdy = false; // ke9ns add

        public string spotDDUtil_Rotor1 // called from SPOT.cs routine when clicking on DX SPOT
        {

            get
            {

                // CATTester cat = new CATTester(this);

                string answer = "N-A";

                if (ROTOREnabled == false) return answer; // if rotor is not connected then dont check

                try
                {
                    siolisten1.SIO1.put1("AI1;");  // parser.Get1("AI1;");
                    Stopwatch rotor = new Stopwatch();

                    rotor.Restart();

                    for (; ; )
                    {
                        if ((rotor.ElapsedMilliseconds > 200) || (RotorAngleRdy == true)) break;
                    }



                    rotor.Stop();

                    //  Debug.WriteLine("ROTORANGLE :" + RotorAngle + ", "+ RotorAngleRdy);
                    RotorAngleRdy = false;
                }
                catch { }

                answer = RotorAngle;

                return answer;
            }

        } // 

        double sPrev = 0.0;
        double sPrev2 = 0.0;


        //================================================================================================
        //================================================================================================
        // ke9ns add to detect single Frequecy tones in a data stream  (audio.cs routine uses for wwv)
        // spotform.GoertzelCoef to get Coeff value 
        //  BEACON: GoertzelCoef(600.0, console.SampleRate1);  // comes up with the Coeff values for the freq and sample rate used
        //  WWV: GoertzelCoef(100.0, console.SampleRate1);  // comes up with the Coeff values for the freq and sample rate used

        public int Goertzel(float[] samples, int start, int end)
        {

            sPrev = 0.0;
            sPrev2 = 0.0;

            for (int i = start; i < end; i++)   // feedback
            {
                double s = samples[i] + SpotForm.Coeff * sPrev - sPrev2; // 
                sPrev2 = sPrev;
                sPrev = s;

            } // for loop

            double power = (sPrev2 * sPrev2) + (sPrev * sPrev) - ((SpotForm.Coeff * sPrev) * sPrev2);  // feedforward

            return (int)power; // magnitude of frequency in question within the stream


        } //  Goertzel


        //----------------------------------------------------------------------
        public int Goertzel2(float[] samples, int start, int end)
        {
            sPrev = 0.0;
            sPrev2 = 0.0;

            for (int i = start; i < end; i++)   // feedback
            {
                double s = samples[i] + SpotForm.Coeff2 * sPrev - sPrev2; // 
                sPrev2 = sPrev;
                sPrev = s;
            }

            double power = (sPrev2 * sPrev2) + (sPrev * sPrev) - ((SpotForm.Coeff2 * sPrev) * sPrev2);  // feedforward

            return (int)power; // magnitude of frequency in question within the stream
        } //  Goertzel



        /*
            public double goertzel(List<double> sngData, long N, float frequency, int samplerate)
            {
                double skn, skn1, skn2;
                skn = skn1 = skn2 = 0;
                samplerate = this.sampleRate;
                frequency = this.freq;

                double c = 2 * pi * frequency / samplerate;
                double cosan = Math.Cos(c);

                for (int i = 0; i < N; i++)
                {
                    skn2 = skn1;
                    skn1 = skn;
                    skn = 2 * cosan * skn1 - skn2 + sngData[i];
                }

                return skn - Math.Exp(-c) * skn1;
            }
    */
        //==================================================================================
        //==================================================================================
        // ke9ns for precision mSec timer (not used at this time)
        // ke9ns add  This timer runs at the periodic rate, repeatedly and  jmps to "TimerPeriodicEventCallback" when the timer is reached
        private void setup_timer(int cwxwpm)
        {

            if (timerID != 0) // if timer is running, kill it to start over
            {
                timeKillEvent(timerID);
            }

            // (delay, resolution, proc, user, mode)
            timerID = timeSetEvent(cwxwpm, 1, timeProcPeriodic, 0, (int)TimerMode.Periodic); //  jmps to "TimerPeriodicEventCallback" when the timer is reached


            if (timerID == 0)
            {
                Debug.Fail("1Timer creation failed.");
            }

        } // setup_timer

        //==================================================================================
        //==================================================================================
        private int timerID1;



        private TimeProc timeProcPeriodic1;

        // ke9ns for precision mSec timer for TUNE Pulser
        // ke9ns add  This timer is a one shot timer for the duty cycle of the tone jmps to "TimerPeriodicEventCallback1" when the timer is reached 
        private void setup_timer1(int cwxwpm)
        {

            if (timerID1 != 0)
            {
                timeKillEvent(timerID1);
            }

            // (delay, resolution, proc, user, mode)
            timerID1 = timeSetEvent(cwxwpm, 1, timeProcPeriodic1, 0, (int)TimerMode.OneShot); //  jmps to "TimerPeriodicEventCallback1" when the timer is reached


            if (timerID1 == 0)
            {

                Debug.Fail("2Timer creation failed.");
            }

        } // setup_timer1






        //=========================================================================================
        //=========================================================================================
        // rn3kk 
        public void startHttpServer(int port)
        {
            httpServer.start(port);
        }

        //=========================================================================================
        //=========================================================================================
        // rn3kk 
        public void stopHttpServer()
        {
            httpServer.stop();
        }

        //=========================================================================================
        //=========================================================================================
        // rn3kk add method for set VFOAFreq
        public void setVFOAFreqByPixel(int pixel)
        {
            Debug.WriteLine("Receive pixel: " + pixel.ToString());
            Debug.WriteLine("Panoram width: " + picDisplay.Width.ToString());
            float x = PixelToHz(pixel);
            Debug.WriteLine("Offset x:=" + x.ToString());

            double rf_freq = VFOAFreq + (double)x * 0.0000010;

            if (rx1_dsp_mode == DSPMode.CWL)
                rf_freq += (double)cw_pitch * 0.0000010;
            else if (rx1_dsp_mode == DSPMode.CWU)
                rf_freq -= (double)cw_pitch * 0.0000010;

            long f = (long)(rf_freq * 1e6);
            int mult = CurrentTuneStepHz;
            if (f % mult > mult / 2) f += (mult - f % mult);
            else f -= f % mult;
            rf_freq = (double)f * 1e-6;
            VFOAFreq = rf_freq;
        }








        //=========================================================================================
        //=========================================================================================
        // rn3kk add method for change if mousewheell on web
        public void wheelEventOnWeb(bool direction)
        {
            if (direction)
            {
                VFOAFreq += CurrentTuneStepMHz;
            }
            else
            {
                VFOAFreq -= CurrentTuneStepMHz;
            }
        }

        // rn3kk add
        public string getVFOAFreqString()
        {
            return txtVFOAFreq.Text;
        }



        // rn3kk add
        public string getVFOBFreqString()
        {
            return txtVFOBFreq.Text;
        }

        //========================================================================
        // ke9ns add

        bool lastHF = false;
        bool lastVHF = false;
        bool lastGN = false;
        bool lastHFRX2 = false; // .203
        bool lastVHFRX2 = false;
        bool lastGNRX2 = false;

        private void panelBandHF_VisibleChanged(object sender, EventArgs e)
        {
            if (panelBandHF.Visible != lastHF)
            {
                panelBandHF.Invalidate();
                lastHF = panelBandHF.Visible;
            }


        }

        private void panelBandVHF_VisibleChanged(object sender, EventArgs e)
        {
            if (panelBandVHF.Visible != lastVHF)
            {
                panelBandVHF.Invalidate();
                lastVHF = panelBandVHF.Visible;
            }
        }

        private void panelBandGN_VisibleChanged(object sender, EventArgs e)
        {
            if (panelBandGN.Visible != lastGN)
            {
                panelBandGN.Invalidate();
                lastGN = panelBandGN.Visible;
            }
        }

        // ke9ns add .203
        private void panelBandHFRX2_VisibleChanged(object sender, EventArgs e)
        {
            if (panelBandHFRX2.Visible != lastHFRX2)
            {
                panelBandHFRX2.Invalidate();
                lastHFRX2 = panelBandHFRX2.Visible;
            }


        }

        private void panelBandVHFRX2_VisibleChanged(object sender, EventArgs e)
        {
            if (panelBandVHFRX2.Visible != lastVHFRX2)
            {
                panelBandVHFRX2.Invalidate();
                lastVHFRX2 = panelBandVHFRX2.Visible;
            }
        }

        private void panelBandGNRX2_VisibleChanged(object sender, EventArgs e)
        {
            if (panelBandGNRX2.Visible != lastGNRX2)
            {
                panelBandGNRX2.Invalidate();
                lastGNRX2 = panelBandGNRX2.Visible;
            }
        }


        //===============================================================================
        // ke9ns add bandstack from main console screen
        private void textBox1_MouseDown(object sender, MouseEventArgs e)
        {
            textBox1.ShortcutsEnabled = false; // added to eliminate the contextmenu from popping up

        }

        //===============================================================================
        // ke9ns add bandstack from main console screen
        private void textBox1_MouseUp(object sender, MouseEventArgs e)
        {

            textBox1.ShortcutsEnabled = false;


            if (e.Button == MouseButtons.Left)
            {
                try
                {
                    int ii = textBox1.GetCharIndexFromPosition(e.Location);

                    StackForm.xxx = (ii / StackForm.BSLength); //find row 

                    if (StackForm.xxx >= band_stacks[StackForm.nnn]) return; // if you click past the last index freq, then do nothing.

                    Debug.WriteLine("xxx " + StackForm.xxx + " , " + ii);

                    textBox1.SelectionStart = (StackForm.xxx * StackForm.BSLength);
                    textBox1.SelectionLength = StackForm.BSLength;

                    Debug.WriteLine("index at start of click " + iii);

                    if (filter2[iii] == "") // check if current index locked
                    {
                        StackForm.yyy = 1;
                        SaveBandA(); // put away last freq you were on before moving
                        Debug.WriteLine("OPEN SO SAVE");
                    }
                    else
                    {
                        Debug.WriteLine("LOCKED SO DONT SAVE " + iii + " says " + filter2[iii]);
                    }

                    iii = StackForm.xxx; // update new position in bandstack for checking if its locked

                    Debug.WriteLine("index after click " + iii);

                    StackForm.yyy = 0;

                    StackForm.updateindex();

                    SetBand(StackForm.mode1[StackForm.xxx], StackForm.filter1[StackForm.xxx], StackForm.freq1[StackForm.xxx]);

                    UpdateWaterfallLevelValues();
                }
                catch
                {
                    Debug.WriteLine("Failed to determine index or cannot save bandstack because its locked");

                    if (StackForm.yyy == 1)
                    {
                        StackForm.updateindex();

                        SetBand(StackForm.mode1[StackForm.xxx], StackForm.filter1[StackForm.xxx], StackForm.freq1[StackForm.xxx]);

                        UpdateWaterfallLevelValues();
                    }

                }

            } // LEFT CLICK MOUSE

            else if (e.Button == MouseButtons.Right) // ke9ns right click = lock or unlock bandstank memory
            {

                try
                {

                    int ii = textBox1.GetCharIndexFromPosition(e.Location);

                    Debug.WriteLine("BOX POS " + ii);

                    StackForm.xxx = (ii / StackForm.BSLength); //find row 

                    if (StackForm.xxx >= band_stacks[StackForm.nnn]) return; // if you click past the last index freq, then do nothing.


                    if (StackForm.filter1[StackForm.xxx].Contains("@"))
                    {
                        StackForm.filter1[StackForm.xxx] = StackForm.filter1[StackForm.xxx].Substring(0, (StackForm.filter1[StackForm.xxx].Length) - 1); // toggle LOCK OFF
                    }
                    else
                    {
                        StackForm.filter1[StackForm.xxx] = StackForm.filter1[StackForm.xxx] + "@"; // toggle LOCK ON
                    }


                    DB.SaveBandStack(last_band, StackForm.xxx, StackForm.mode1[StackForm.xxx], StackForm.filter1[StackForm.xxx], StackForm.freq1[StackForm.xxx]);


                    StackForm.bandstackupdate(); // update bandstack screen

                    //  StackForm.updateindex();

                }
                catch
                {
                    Debug.WriteLine("Bad location1");

                }

            } // RIGHT CLICK MOUSE



        } // textBox1_MouseUp


        //===============================================================================
        // ke9ns add bandstack from main console screen  .209
        private void textBox2_MouseDown(object sender, MouseEventArgs e)
        {
            textBox2.ShortcutsEnabled = false; // added to eliminate the contextmenu from popping up

        }

        //===============================================================================
        // ke9ns add bandstack from main console screen .209
        private void textBox2_MouseUp(object sender, MouseEventArgs e)
        {
            textBox2.ShortcutsEnabled = false;

            if (e.Button == MouseButtons.Right) // ke9ns right click = lock or unlock bandstank memory
            {
                //  this does not take you to the freq you right clicked on
                try
                {

                    int ii = textBox2.GetCharIndexFromPosition(e.Location);

                    Debug.WriteLine("BOX POS " + ii);

                    StackForm.xxx2 = (ii / StackForm.BSLength); //find row 

                    if (StackForm.xxx2 >= band_stacks[StackForm.nnn2]) return; // if you click past the last index freq, then do nothing.

                    if (StackForm.filter12[StackForm.xxx2].Contains("@"))
                    {
                        StackForm.filter12[StackForm.xxx2] = StackForm.filter12[StackForm.xxx2].Substring(0, (StackForm.filter12[StackForm.xxx2].Length) - 1); // toggle LOCK OFF
                    }
                    else
                    {
                        StackForm.filter12[StackForm.xxx2] = StackForm.filter12[StackForm.xxx2] + "@"; // toggle LOCK ON
                    }

                    DB.SaveBandStack2(last_band2, StackForm.xxx2, StackForm.mode12[StackForm.xxx2], StackForm.filter12[StackForm.xxx2], StackForm.freq12[StackForm.xxx2]);

                    StackForm.bandstackupdate(); // update bandstack screen

                }
                catch
                {
                    Debug.WriteLine("Bad location2");

                }

            } // RIGHT CLICK MOUSE
            else if (e.Button == MouseButtons.Left) // ke9ns Middle erases bandstack entries 1 at a time
            {

                try
                {
                    int ii = textBox2.GetCharIndexFromPosition(e.Location);

                    StackForm.xxx2 = (ii / StackForm.BSLength); //find row 

                    if (StackForm.xxx2 >= band_stacks[StackForm.nnn2]) return; // if you click past the last index freq, then do nothing.

                    Debug.WriteLine("xxx2 " + StackForm.xxx2 + " , " + ii);

                    textBox2.SelectionStart = (StackForm.xxx2 * StackForm.BSLength);
                    textBox2.SelectionLength = StackForm.BSLength;

                    Debug.WriteLine("index at start of click " + iii2);

                    if (filter22[iii2] == "") // check if current index locked
                    {
                        StackForm.yyy2 = 1;
                        SaveBandB(); // put away last freq you were on before moving
                        Debug.WriteLine("OPEN SO SAVE");
                    }
                    else
                    {
                        Debug.WriteLine("LOCKED SO DONT SAVE " + iii2 + " says " + filter22[iii2]);
                    }

                    iii = StackForm.xxx2; // update new position in bandstack for checking if its locked

                    Debug.WriteLine("index after click " + iii2);

                    StackForm.yyy2 = 0;

                    StackForm.updateindex2();

                    SetBand2(StackForm.mode12[StackForm.xxx2], StackForm.filter12[StackForm.xxx2], StackForm.freq12[StackForm.xxx2]);

                    UpdateWaterfallLevelValues();
                }
                catch
                {
                    Debug.WriteLine("Failed to determine index or cannot save bandstack because its locked");

                    if (StackForm.yyy2 == 1)
                    {
                        StackForm.updateindex2();

                        SetBand2(StackForm.mode12[StackForm.xxx2], StackForm.filter12[StackForm.xxx2], StackForm.freq12[StackForm.xxx2]);

                        UpdateWaterfallLevelValues();
                    }

                }

                btnHidden.Focus();

            } // MIDDLE CLICK MOUSE

        } //textBox2_MouseUp .209



        //=====================================================================
        // ke9ns add to move bandstack embedded screen (toggles OFF/ON
        void BandStackMove()
        {

            if (panelTSBandStack.Enabled == false)
            {

                buttonbs.BackColor = Color.Green; // ke9ns ad .211 active

                chkBoxBS.Checked = true;

                buttonAdd.Enabled = true;
                buttonSort.Enabled = true;
                buttonDel.Enabled = true;

                buttonAdd.Visible = true;
                buttonSort.Visible = true;

                buttonDel.Visible = true;
                panelTSBandStack.Enabled = true;
                panelTSBandStack.Visible = true;


                if ((MeterTop == true) && (this.Size.Width >= 1200)) // ke9ns add: .153 bandstack on upper right side
                {

                    panelDisplay.Parent.Controls.Remove(panelTSBandStack); // ke9ns add: remove bandstack from display are
                    this.Controls.Add(panelTSBandStack);

                    panelTSBandStack.Size = new Size(168, 250); // .228 was 163
                    panelTSBandStack.Anchor = AnchorStyles.Top | AnchorStyles.Left;
                    panelTSBandStack.Location = new Point(556, 6);


                }
                else // bandstack panel in panadapter area
                {

                    if (panelTSBandStack.Parent.Controls == this.Controls) // ke9ns: if bandstack was moved to console screen, put it back under panelDisplay
                    {
                        this.Controls.Remove(panelTSBandStack);

                        panelTSBandStack.Location = new Point(556, 6);
                        panelTSBandStack.Size = new Size(168, 222); // .228 was 158
                        panelTSBandStack.Anchor = AnchorStyles.Left | AnchorStyles.Bottom;

                        this.panelDisplay.Controls.Add(this.panelTSBandStack);
                        this.panelTSBandStack.ResumeLayout(false);
                        this.panelTSBandStack.PerformLayout();


                    } //  if (panelTSBandStack.Parent.Controls == this.Controls)



                    //  picDisplay.Width = panelDisplay.Width - panelTSBandStack.Width - 18; // reduce the size the panadapter display when Bandstack turned on

                } // metertop = false

                if (Display.WMS == 1) // ke9ns force a redraw of the waterfall as we shrink or expand the panafall display area
                {
                    Display.WMS = 0;
                }
                else
                {
                    Display.WMS = 1;
                }

                picDisplay.Invalidate();
                panelDisplay.Invalidate();


                if (Display.WMS == 1)  // ke9ns force a redraw of the waterfall as we shrink or expand the panafall display area
                {
                    Display.WMS = 0;
                }
                else
                {
                    Display.WMS = 1;
                }

                Console_Resize(this, EventArgs.Empty);


            } //   if (panelTSBandStack.Enabled == false)
            else
            {

                buttonbs.BackColor = Color.Black; // ke9ns ad .211 active

                chkBoxBS.Checked = false;

                buttonAdd.Enabled = false;
                buttonSort.Enabled = false;
                buttonDel.Enabled = false;

                buttonAdd.Visible = false;
                buttonSort.Visible = false;
                buttonDel.Visible = false;


                panelTSBandStack.Enabled = false;
                panelTSBandStack.Visible = false;


                picDisplay.Width = panelDisplay.Width - 18; // 9 pixels on each size

                if (Display.WMS == 1)  // ke9ns force a redraw of the waterfall as we shrink or expand the panafall display area
                {
                    Display.WMS = 0;
                }
                else
                {
                    Display.WMS = 1;
                }

                picDisplay.Invalidate();
                panelDisplay.Invalidate();

                if (Display.WMS == 1)   // ke9ns force a redraw of the waterfall as we shrink or expand the panafall display area
                {
                    Display.WMS = 0;
                }
                else
                {
                    Display.WMS = 1;
                }

                Console_Resize(this, EventArgs.Empty);

            }

        } // BandStackMove

        //=============================================================================
        // ke9ns add to allow bandstack panel to open/close
        private void regBox_MouseUp(object sender, MouseEventArgs e)
        {

            regBox.ShortcutsEnabled = false;
            regBox1.ShortcutsEnabled = false;

            if (StackForm == null || StackForm.IsDisposed) StackForm = new StackControl(this);

            if (e.Button == MouseButtons.Right) // ke9ns 
            {

                StackForm.Show();
                StackForm.Focus();
                StackForm.WindowState = FormWindowState.Normal; // ke9ns add

            }
            else if (e.Button == MouseButtons.Left) // ke9ns 
            {

                BandStackMove(); // toggle on/off

            } // right click


        } // regBox_Mouseup

        //=============================================================================
        // ke9ns add
        private void regBox1_MouseDown(object sender, MouseEventArgs e)
        {
            regBox.ShortcutsEnabled = false;
            regBox1.ShortcutsEnabled = false;

        } // regBox1_MouseDown





        //=============================================================================
        // ke9ns add call DB routine and delete the current freq listed in the current bandstack
        public void PurgeBandStack(int xxx, string mode, string filter, string freq)
        {

            DB.PurgeBandStack(xxx, last_band, mode, filter, freq); // call database and delete 1 bandstack entry for the current freq


        } //  PurgeBandStack (this routine is called from stack.cs)

        public void PurgeBandStack2(int xxx, string mode, string filter, string freq)
        {

            DB.PurgeBandStack(xxx, last_band2, mode, filter, freq); // call database and delete 1 bandstack entry for the current freq


        } //  PurgeBandStack (this routine is called from stack.cs)




        //=============================================================================
        // ke9ns add call DB routine and SORT the current freq listed in the current bandstack
        public void SortBandStack(int g, string mode, string filter, double freq)
        {

            DB.SortBandStack(last_band, g, mode, filter, freq);  // call database and sort bandstack entries 

        }
        public void SortBandStack2(int g, string mode, string filter, double freq) // .209
        {

            DB.SortBandStack2(last_band2, g, mode, filter, freq);  // call database and sort bandstack entries 

        }

        //=============================================================================
        // ke9ns add call DB routine and SORT the current freq listed in the current bandstack
        public void BandStackUpdate()
        {
            UpdateBandStackRegisters();  // recheck the remaining bandstack entries 

            SetRX1BandButton(RX1Band);   // update the remaining bandstack entries

            if (FWCEEPROM.RX2OK) SetRX2BandButton(RX2Band); //.209

            UpdateWaterfallLevelValues();

        } // 


        //============================================================================
        //============================================================================
        //============================================================================
        // ke9ns add improve tooltip







        //============================================================================
        //============================================================================
        //============================================================================
        // ke9ns add to allow extra control of group panels (ie rounded edges)
        public static GraphicsPath CreatePath(float x, float y, float width, float height,
                                          float radius, bool RoundTopLeft, bool RoundTopRight, bool RoundBottomRight, bool RoundBottomLeft)
        {
            float xw = x + width;
            float yh = y + height;
            float xwr = xw - radius;
            float yhr = yh - radius;
            float xr = x + radius;
            float yr = y + radius;
            float r2 = radius * 2;
            float xwr2 = xw - r2;
            float yhr2 = yh - r2;

            GraphicsPath p = new GraphicsPath();
            p.StartFigure();

            //Top Left Corner

            if (RoundTopLeft)
            {
                p.AddArc(x, y, r2, r2, 180, 90);
            }
            else
            {
                p.AddLine(x, yr, x, y);
                p.AddLine(x, y, xr, y);

            }

            //Top Edge
            p.AddLine(xr, y, xwr, y);

            //Top Right Corner

            if (RoundTopRight)
            {
                p.AddArc(xwr2, y, r2, r2, 270, 90);
            }
            else
            {
                p.AddLine(xwr, y, xw, y);
                p.AddLine(xw, y, xw, yr);
            }


            //Right Edge
            p.AddLine(xw, yr, xw, yhr);

            //Bottom Right Corner

            if (RoundBottomRight)
            {
                p.AddArc(xwr2, yhr2, r2, r2, 0, 90);
            }
            else
            {
                p.AddLine(xw, yhr, xw, yh);
                p.AddLine(xw, yh, xwr, yh);
            }


            //Bottom Edge
            p.AddLine(xwr, yh, xr, yh);

            //Bottom Left Corner           

            if (RoundBottomLeft)
            {
                p.AddArc(x, yhr2, r2, r2, 90, 90);
            }
            else
            {
                p.AddLine(xr, yh, x, yh);
                p.AddLine(x, yh, x, yhr);
            }

            //Left Edge
            p.AddLine(x, yhr, x, yr);

            p.CloseFigure();

            return p;

        } // CreatePath(float x, float y, float width, float height,  float radius, bool RoundTopLeft, bool RoundTopRight, bool RoundBottomRight, bool RoundBottomLeft)









        //==================================================================
        // ke9ns add: so all richtextbox items can still use the mouse wheel to change freq. when the mouse is over the time,cpu,spaceweather, temp, volts panel
        private void labelTS4_MouseWheel(object sender, System.Windows.Forms.MouseEventArgs e) // this is the volts panel
        {

            Console_MouseWheel(this, new MouseEventArgs(MouseButtons.None, 0, 0, 0, e.Delta));


        } // labelTS4_MouseWheel



        //===============================================================================================================
        // ke9ns add: Click on CQCQ calling button (play CQCQ.wav file audio)

        public bool CQCQCALL = false; // ke9ns add true = wave plays CQCQ.wav file

        private void btnTrack_Click(object sender, EventArgs e)
        {

            string filePath = AppDataPath + "QuickAudio\\";

            if (WaveForm.chkQuickAudioFolder.Checked == false) WaveForm.chkQuickAudioFolder.Checked = true;

            if (WaveForm.chkQuickAudioFolder.Checked == true)  // ke9ns add
            {
                if (Directory.Exists(filePath))    // need to see the quickaudio folder
                {
                    if (File.Exists(filePath + "CQCQ.wav"))
                    {
                        if ((chkPower.Checked))     // ke9ns add allow tx on play directly so you dont need to mox and play
                        {

                            if ((WaveForm.QuickPlay == false) && (CQCQReplayON == false)) // starts to play CQCQ audio now
                            {

                                if (chkVAC1.Checked) // turn OFF VAC while transmitting (override it)
                                {
                                    vac1 = 1;
                                    chkVAC1.Checked = false;
                                }

                                CQCQCALL = true;                // let wave: chkQuickPlay_CheckedChanged know you want to play CQCQ.WAV file only
                                checkBoxID.Checked = true;     // REC/PLAY ID box
                                ckQuickPlay.Checked = true;     //  PLAY button (which keys the radio because checkboxID = true

                                if (udCQCQRepeat.Value > 0) // if you entered a repeater timer value, the start thread
                                {
                                    if (CQCQReplayON == false) // ke9ns make sure thread is not already running
                                    {
                                        CQCQReplayON = true;
                                        Thread t9 = new Thread(new ThreadStart(CQCQReplayThread));
                                        t9.Name = "CQCQ Replay Thread";
                                        t9.IsBackground = true;
                                        t9.Priority = ThreadPriority.BelowNormal;
                                        t9.Start();
                                    }

                                }


                                buttonCQ1.Image = global::PowerSDR.Properties.Resources.widered4;  //  buttonCQ.BackColor = Color.Red;



                            }
                            else // if you click the CQCQ button before the audio is finished playing, stop the recording now.
                            {

                                buttonCQ1.Image = global::PowerSDR.Properties.Resources.wideblue4; //   buttonCQ.BackColor = Color.Blue;


                                checkBoxID.Checked = false;     // REC/PLAY ID box

                                CQCQReplayON = false;

                                WaveForm.QuickPlay = false;
                                chkMOX.Checked = false;     // unkey radio
                                ckQuickPlay.BackColor = SystemColors.Control;//k6jca 1/13/08
                                CQCQCALL = false;

                                if (vac1 == 1)
                                {
                                    vac1 = 0;
                                    Thread.Sleep(100);
                                    //   chkVAC1.Checked = true;
                                }

                                checkBoxID.Checked = false;     // REC/PLAY ID box

                            }

                        } // chkpower

                    } //  if (File.Exists(filePath + "\\CQCQ.wav"))
                    else
                    {
                        MessageBox.Show(new Form() { TopMost = true }, "Console: Could not Find file CQCQ.wav in QuickAudio folder");
                    }

                } // if (!Directory.Exists(filePath)) 
                else
                {
                    MessageBox.Show(new Form() { TopMost = true }, "Console: Could not find QuickAudio Folder");
                }

            } //  if (WaveForm.chkQuickAudioFolder.Checked == true) 

            //  btnHidden.Focus();

        } // CQCQ btnTrack_Click


        //=======================================================================
        // ke9ns add: CQCQ Replay thread

        public bool CQCQReplayON = false;
        public bool CQCQReplayPTT = false;

        public void CQCQReplayThread()
        {
            int replayCount = 0;

            Stopwatch CQReplay = new Stopwatch();
            CQReplay.Reset();

            Debug.WriteLine("===========Start CQCQ timer thread");
            for (; ; )
            {
                Thread.Sleep(50);

                if (CQCQReplayON == false) break;

                if (udCQCQRepeat.Value == 0) break;

                if (WaveForm.QuickPlay == true) // playing
                {

                    buttonCQ1.Image = global::PowerSDR.Properties.Resources.widered4;  // buttonCQ.BackColor = Color.Red;



                    if (CQReplay.ElapsedMilliseconds > 0) CQReplay.Reset();

                    if ((CQCQReplayPTT == false && chkMOX.Checked == false) || (CQCQReplayPTT == true)) // ke9ns check pollPTT
                    {
                        Debug.WriteLine("Audio Playing.. BREAK BREAK");

                        break; // ke9ns if you hit the PTT while play audio, then break
                    }

                }
                else //  if (WaveForm.QuickPlay == false)  CQCQ playback done so start timer
                {

                    buttonCQ1.Image = global::PowerSDR.Properties.Resources.wideorg4;  //   buttonCQ.BackColor = Color.Orange;


                    if ((CQCQReplayPTT == true)) // ke9ns check pollPTT
                    {
                        Debug.WriteLine("WAITING..PTT... BREAK BREAK BREAK");
                        break; // ke9ns if you hit the PTT while play audio, then break
                    }
                    if ((CQReplay.ElapsedMilliseconds > 150) && (chkMOX.Checked == true)) // ke9ns check pollPTT
                    {
                        Debug.WriteLine("WAITING..MOX TRUE.. BREAK BREAK BREAK");
                        break; // ke9ns if you hit the PTT while play audio, then break
                    }

                    if ((CQReplay.ElapsedMilliseconds > 550) && chkPower.Checked == false)
                    {
                        Debug.WriteLine("CHKPOWER BREAK BREAK BREAK=====");
                        break;
                    }

                    if (CQReplay.ElapsedMilliseconds == 0) CQReplay.Start(); // do 1 time per playback

                    if (CQReplay.ElapsedMilliseconds >= ((long)udCQCQRepeat.Value * 1000))
                    {
                        if (CQCQReplayON == true)
                        {
                            if (++replayCount < 8) // max count
                            {
                                // REPEAT PLAY NOW
                                if (chkVAC1.Checked) // turn OFF VAC while transmitting (override it)
                                {
                                    vac1 = 1;
                                    chkVAC1.Checked = false;
                                }

                                CQCQCALL = true;                // let wave: chkQuickPlay_CheckedChanged know you want to play CQCQ.WAV file only
                                checkBoxID.Checked = true;     // REC/PLAY ID box
                                ckQuickPlay.Checked = true;     //  PLAY button (which keys the radio because checkboxID = true
                            }
                            else
                            {
                                Debug.WriteLine("8 times... BREAK BREAK BREAK=====");
                                break; // end after 8 times
                            }
                        }

                    } //  if (CQReplay.ElapsedMilliseconds >= ((long)udCQCQRepeat.Value * 1000))

                }


            } // for loop forever


            //...........................................................
            // breaks come here and turn off audio playback
            checkBoxID.Checked = false;     // REC/PLAY ID box


            buttonCQ1.Image = global::PowerSDR.Properties.Resources.wideblue4;  //   buttonCQ.BackColor = Color.Blue;


            Debug.WriteLine("DONE BREAK BREAK BREAK=====");

            CQReplay.Stop();

            WaveForm.QuickPlay = false; // kill any audio playback

            // pollPTT will check for PTT release to end this timer

            ckQuickPlay.BackColor = SystemColors.Control;//k6jca 1/13/08
            CQCQCALL = false;

            if (vac1 == 1)
            {
                vac1 = 0;
                Thread.Sleep(100);
                chkVAC1.Checked = true;
            }

            checkBoxID.Checked = false;     // REC/PLAY ID box


        } // CQCQReplayThread()


        public bool CALLCALL = false; // ke9ns add true = wave plays CALL.wav file

        //=======================================================================
        // ke9ns add  REPLY button This button is used when trying to make a contact with a station
        private void buttonCall_Click(object sender, EventArgs e)
        {
            string filePath = AppDataPath + "QuickAudio\\";

            if (WaveForm.chkQuickAudioFolder.Checked == false) WaveForm.chkQuickAudioFolder.Checked = true;

            if (WaveForm.chkQuickAudioFolder.Checked == true)  // ke9ns add
            {
                if (Directory.Exists(filePath)) // need to see the quickaudio folder
                {
                    if (File.Exists(filePath + "CALL.wav"))
                    {
                        if ((chkPower.Checked)) // ke9ns add: allow tx on play directly so you dont need to mox and play
                        {
                            if (WaveForm.QuickPlay == false)
                            {
                                if (chkVAC1.Checked)
                                {
                                    vac1 = 1;
                                    chkVAC1.Checked = false;
                                }

                                CALLCALL = true;      // let wave: chkQuickPlay_CheckedChanged know you want to play CALL.WAV file only
                                checkBoxID.Checked = true;
                                ckQuickPlay.Checked = true;



                                buttonCall1.Image = global::PowerSDR.Properties.Resources.widered3;   //  buttonCall.BackColor = Color.Red;

                            }
                            else // turn off
                            {
                                //  buttonCall.BackColor = Color.Blue;

                                WaveForm.QuickPlay = false;
                                chkMOX.Checked = false;     // unkey radio
                                ckQuickPlay.BackColor = SystemColors.Control;//k6jca 1/13/08
                                CALLCALL = false;

                                if (vac1 == 1)
                                {
                                    vac1 = 0;
                                    Thread.Sleep(100);
                                    chkVAC1.Checked = true;
                                }
                                checkBoxID.Checked = false;
                            }

                        } // chkpower

                    } //  if (File.Exists(filePath + "\\CALL.wav"))
                    else
                    {
                        MessageBox.Show(new Form() { TopMost = true }, "Console: Could not Find file CALL.wav in QuickAudio folder");

                    }

                } // if (!Directory.Exists(filePath)) 
                else
                {
                    MessageBox.Show(new Form() { TopMost = true }, "Console: Could not find QuickAudio Folder");
                }

            } //  if (WaveForm.chkQuickAudioFolder.Checked == true) 


        } // CALL REPLY buttonCall_Click


        //=======================================================================================================
        //=======================================================================================================
        // ke9ns add (for magnifier)

        Bitmap bitmap1;

        public Bitmap bitmap2;  //something Display.cs can display

        private void MagnifyImage() // get mouse position from mousemove routine above and put in DX_X and _Y
        {

            bitmap1 = new Bitmap(picDisplay.Width, picDisplay.Height); // ke9ns set bitmap size to size of picDisplay since it gets resized with your screen
            picDisplay.DrawToBitmap(bitmap1, picDisplay.ClientRectangle); // ke9ns grab picDisplay and convert to bitmap

            bitmap2 = bitmap1.Clone(new Rectangle(DX_X - 25, DX_Y - 25, 50, 50), PixelFormat.Format32bppRgb); // get small window of bitmap

            // g.DrawImage(bitmap2, DX_X - 50, DX_Y - 50, 100,100);

        } // getImage()




        //=========================================================
        // ke9ns 
        public bool CW_POLL()
        {
            bool dot, dash, rca_ptt, mic_ptt;

            if ((cwxForm != null) && (cwxForm.stopPoll == true))
            {
                FWC.ReadPTT(out dot, out dash, out rca_ptt, out mic_ptt);

                if ((dot == true) || (dash == true)) return true;
            }

            return false;
        }


        public bool keydot = false;  // ke9ns add

        public bool CWP = false; // ke9ns add allows CWX panel usage while in SSB mode



        //==================================================================================================
        public bool KEYON = false;

        public void CWINUSBMODE()
        {
            if (KEYON == true)
            {
                switch (Audio.TXDSPMode)
                {
                    case DSPMode.USB:
                    case DSPMode.CWU:
                    case DSPMode.DIGU:
                        Audio.SineFreq1 = cw_pitch;
                        DttSP.SetTXFilter(1, cw_pitch - 100, cw_pitch + 100);
                        Audio.TXInputSignal = Audio.SignalSource.SINE;
                        Audio.SourceScale = 1.0;
                        break;
                    case DSPMode.LSB:
                    case DSPMode.CWL:
                    case DSPMode.DIGL:
                        Audio.SineFreq1 = cw_pitch;
                        DttSP.SetTXFilter(1, -cw_pitch - 100, -cw_pitch + 100);
                        Audio.TXInputSignal = Audio.SignalSource.SINE;
                        Audio.SourceScale = 1.0;
                        break;
                    case DSPMode.DSB:
                        Audio.SineFreq1 = cw_pitch;
                        DttSP.SetTXFilter(1, cw_pitch - 100, cw_pitch + 100);
                        Audio.TXInputSignal = Audio.SignalSource.SINE;
                        Audio.SourceScale = 1.0;
                        break;
                    case DSPMode.AM:
                    case DSPMode.SAM:
                    case DSPMode.FM:
                        Audio.SineFreq1 = cw_pitch;
                        DttSP.SetTXFilter(1, cw_pitch - 100, cw_pitch + 100);
                        Audio.TXInputSignal = Audio.SignalSource.SINE;
                        Audio.SourceScale = 1.0;
                        break;
                }

                DttSP.SetMode(1, 0, DSPMode.DIGU);

                // ensure radio believes we are in CW for tx freq limits
                if (fwc_init && (current_model == Model.FLEX5000 || current_model == Model.FLEX3000))
                {
                    switch (Audio.TXDSPMode)
                    {
                        case DSPMode.CWL:
                        case DSPMode.LSB:
                        case DSPMode.DIGL:
                            FWC.SetTXDSPMode(DSPMode.CWL);

                            break;
                        default:
                            FWC.SetTXDSPMode(DSPMode.CWU);
                            break;
                    }
                }

                chkMOX.Checked = true;

                current_ptt_mode = PTTMode.MANUAL;

                switch (Audio.TXDSPMode)
                {
                    case DSPMode.CWL:
                    case DSPMode.CWU:
                        Audio.TXDSPMode = DSPMode.DIGU;
                        break;
                    default:
                        break;

                }


                if (chkMUT.Checked == false) // ke9ns add prevent MUT from malfunctioning
                {
                    Audio.MonitorVolume = (ptbAF.Value / 100.0) / 10;  // ke9ns add cut volume during a tune

                }
                else
                {
                    if (chkBoxMuteSpk.Checked == false) // ke9ns add
                    {
                        Audio.MonitorVolume = 0.0; // if muted

                    }
                    else
                    {
                        //  Debug.WriteLine("check...");

                    }
                }



            } // CW bug being used
            else // when you unkey the bug then put back everything
            {
                Audio.TXInputSignal = Audio.SignalSource.RADIO;


                chkMOX.Checked = false;



                DSPMode mode = dsp.GetDSPTX(0).CurrentDSPMode;

                if (fwc_init && (current_model == Model.FLEX5000 || current_model == Model.FLEX3000))
                    FWC.SetTXDSPMode(mode);

                DttSP.SetMode(1, 0, mode);
                switch (mode)
                {
                    case DSPMode.AM:
                    case DSPMode.SAM:
                    case DSPMode.FM:
                        Audio.SineFreq1 = cw_pitch;
                        break;
                    case DSPMode.CWL:
                    case DSPMode.CWU:
                        Audio.TXDSPMode = mode;
                        break;

                    default:
                        Audio.SineFreq1 = cw_pitch; // ke9ns add default
                        break;


                }

                DttSP.SetTXFilter(1, dsp.GetDSPTX(0).TXFilterLow, dsp.GetDSPTX(0).TXFilterHigh);

                if (tune_meter_tx_mode != old_tune_meter_tx_mode)
                    CurrentMeterTXMode = old_tune_meter_tx_mode;

                if (chkNoiseGate.Checked)
                    dsp.GetDSPTX(0).TXSquelchOn = true;

                if (chkMUT.Checked == false) // ke9ns add prevent MUT from malfunctioning
                {
                    Audio.MonitorVolume = ptbAF.Value / 100.0; // ke9ns add to bring volume back up when done
                }


            } // cw bug released

        } // CWINUSEMODE()


        //==============================================================================================
        // ke9ns add
        public bool WideWaterID = false; // ke9ns add allows for wider TX water ID

        public bool WIDEWATERID
        {
            get
            {
                if (setupForm != null) return setupForm.chkTXWtrID.Checked;
                else return WideWaterID;
            }
            set { WideWaterID = value; }
        }


        //====================================================================================================
        // ke9ns add works auto closing messagebox
        sealed public class AutoClosingMessageBox
        {
            System.Threading.Timer _timeoutTimer;
            string _caption;

            AutoClosingMessageBox(string text, string caption, int timeout)
            {
                _caption = caption;




                _timeoutTimer = new System.Threading.Timer(OnTimerElapsed, null, timeout, System.Threading.Timeout.Infinite);

                using (_timeoutTimer)
                {
                    MessageBox.Show(text, caption, MessageBoxButtons.OK, MessageBoxIcon.Information, MessageBoxDefaultButton.Button1, MessageBoxOptions.DefaultDesktopOnly);
                    //  MessageBox.Show(text);

                }

            }

            //========================================================================================

            public static void Show(string text, string caption, int timeout)
            {
                new AutoClosingMessageBox(text, caption, timeout);
            }


            void OnTimerElapsed(object state) // ke9ns used for auto closing messagebox
            {
                IntPtr mbWnd = FindWindow("#32770", _caption); // lpClassName is #32770 for MessageBox

                if (mbWnd != IntPtr.Zero) SendMessage(mbWnd, WM_CLOSE, IntPtr.Zero, IntPtr.Zero);

                _timeoutTimer.Dispose();
            }

            const int WM_CLOSE = 0x0010;
            [System.Runtime.InteropServices.DllImport("user32.dll", SetLastError = true)]
            static extern IntPtr FindWindow(string lpClassName, string lpWindowName);

            [System.Runtime.InteropServices.DllImport("user32.dll", CharSet = System.Runtime.InteropServices.CharSet.Auto)]
            static extern IntPtr SendMessage(IntPtr hWnd, UInt32 Msg, IntPtr wParam, IntPtr lParam);

        } // AutoClosingMessageBox




        //====================================================================================================
        // ke9ns add works auto closing RichTextBox
        sealed public class AutoClosingMessageBox1
        {
            System.Threading.Timer _timeoutTimer;
            string _caption;

            AutoClosingMessageBox1(string text, string caption, int timeout)
            {
                _caption = caption;

                _timeoutTimer = new System.Threading.Timer(OnTimerElapsed, null, timeout, System.Threading.Timeout.Infinite);

                using (_timeoutTimer)
                {
                    // open richtextbox here instead

                    //  MessageBox.Show(text, caption, MessageBoxButtons.OK, MessageBoxIcon.Information, MessageBoxDefaultButton.Button1, MessageBoxOptions.DefaultDesktopOnly);
                    //  MessageBox.Show(text);

                }

            }

            //========================================================================================

            public static void Show(string text, string caption, int timeout)
            {
                new AutoClosingMessageBox1(text, caption, timeout);
            }


            void OnTimerElapsed(object state) // ke9ns used for auto closing messagebox
            {
                IntPtr mbWnd = FindWindow("#32770", _caption); // lpClassName is #32770 for MessageBox

                if (mbWnd != IntPtr.Zero) SendMessage(mbWnd, WM_CLOSE, IntPtr.Zero, IntPtr.Zero);

                _timeoutTimer.Dispose();
            }

            const int WM_CLOSE = 0x0010;
            [System.Runtime.InteropServices.DllImport("user32.dll", SetLastError = true)]
            static extern IntPtr FindWindow(string lpClassName, string lpWindowName);

            [System.Runtime.InteropServices.DllImport("user32.dll", CharSet = System.Runtime.InteropServices.CharSet.Auto)]
            static extern IntPtr SendMessage(IntPtr hWnd, UInt32 Msg, IntPtr wParam, IntPtr lParam);

        } // AutoClosingMessageBox1


        //======================================================================================================
        // ke9ns add to allow JPEG compression
        private ImageCodecInfo GetEncoder(ImageFormat format)
        {
            ImageCodecInfo[] codecs = ImageCodecInfo.GetImageDecoders();
            foreach (ImageCodecInfo codec in codecs)
            {
                if (codec.FormatID == format.Guid)
                {
                    return codec;
                }
            }
            return null;
        }


        //=========================================================================================
        // ke9ns add
        public bool URLPresent = false; // ke9ns add true=imagerequest for simple HTTPserver (this is used in setup->general->user interface to show if someone is looking at your http server address)

        public bool URLPRESENT
        {
            get
            {
                return URLPresent;
            }

            set
            {
                URLPresent = value;

                if (setupForm != null)
                {
                    if (value == true) setupForm.groupBox2.Text = "HttpServer: Active";
                    else setupForm.groupBox2.Text = "HttpServer";
                }

                //  URLPresent = false; // reset

            }


        } // URLPRESENT


        Bitmap bitmap; // ke9ns add
                       //   Bitmap bitmapA; // ke9ns add



        byte[] picDisplayOutput; // ke9ns add
        MemoryStream memstream; // ke9ns add

        // ke9ns add
        private void comboCWTXProfile_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                if (setupForm == null || setupForm.IsDisposed)
                    setupForm = new Setup(this);

                setupForm.Show();
                setupForm.Focus();
                setupForm.WindowState = FormWindowState.Normal; // ke9ns add

                setupForm.tcSetup.SelectedIndex = 4; // select audio tab;

                //   setupForm.tcAudio.SelectedIndex = 1; // select vac1 tab
                //    setupForm.chkAudioIQtoVAC.Focus();

            } // right click
        } //comboCWTXProfile_mousedown

        // ke9ns add
        private void comboDigTXProfile_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                if (setupForm == null || setupForm.IsDisposed)
                    setupForm = new Setup(this);

                setupForm.Show();
                setupForm.Focus();
                setupForm.WindowState = FormWindowState.Normal; // ke9ns add

                setupForm.tcSetup.SelectedIndex = 4; // select audio tab;

                //   setupForm.tcAudio.SelectedIndex = 1; // select vac1 tab
                //    setupForm.chkAudioIQtoVAC.Focus();

            } // right click
        } // comboDigTXProfile






        //======================================================================================================
        // ke9ns add  used by HTTP routine to send graphic image of either PAN or full console window to internet
        public byte[] getImage()
        {

            if ((setupForm != null) && (setupForm.checkBoxHTTP1.Checked == true)) // full console below
            {

                Graphics myGraphics = this.CreateGraphics();
                Size s = this.Size;
                // Size s1 = new Size(s.Width / 2, s.Height / 2);
                // Rectangle compressionRectangle = new Rectangle(0, 0,s1.Width,s1.Height);
                // myGraphics.DrawImage(bitmap, compressionRectangle);

                bitmap = new Bitmap(s.Width, s.Height, myGraphics); // bitmap of the exact size of the console window

                Graphics memGraph = Graphics.FromImage(bitmap);

                memGraph.CopyFromScreen(this.Location.X, this.Location.Y, 0, 0, s);


                using (memstream = new MemoryStream())
                {
                    ImageCodecInfo jpgEncoder = GetEncoder(ImageFormat.Jpeg);
                    System.Drawing.Imaging.Encoder myEncoder = System.Drawing.Imaging.Encoder.Quality;
                    EncoderParameters myEncoderParameters = new EncoderParameters(1);

                    EncoderParameter myEncoderParameter = new EncoderParameter(myEncoder, 40L);  // ke9ns 40% quality  (reduction to reduce byte size since this is the entire console screen)

                    myEncoderParameters.Param[0] = myEncoderParameter;
                    bitmap.Save(memstream, jpgEncoder, myEncoderParameters);
                    picDisplayOutput = memstream.ToArray();
                }


            }
            else // just display (not console) below
            {

                bitmap = new Bitmap(picDisplay.Width, picDisplay.Height); // ke9ns set bitmap size to size of picDisplay since it gets resized with your screen
                picDisplay.DrawToBitmap(bitmap, picDisplay.ClientRectangle); // ke9ns grab picDisplay and convert to bitmap

                using (memstream = new MemoryStream())
                {
                    bitmap.Save(memstream, ImageFormat.Jpeg);
                    picDisplayOutput = memstream.ToArray();
                }

            }

            return picDisplayOutput;  // return byte array of jpeg


        } // getImage()

        byte[] audioOutput; // ke9ns add
        public float[] HTTPAudio_data = new float[16384];          // ke9ns add    used to get out_l_ptr1 audio stream in 2048 pieces at a time

        public bool HTTPAudio = false;
        public bool HTTPAudio_ON = false;

        string HTTP_Audio;
        string HTTP_Audio1;
        //======================================================================================================
        // ke9ns add  used by HTTP routine to send graphic image of either PAN or full console window to internet
        public byte[] getAudio()
        {
            /*
                        if (HTTPAudio == false)
                        {
                          //  Audio.wave_file_writer.Stop();
                            string temp = "test";
                            string wave_folder = Environment.GetFolderPath(Environment.SpecialFolder.MyMusic) + "\\PowerSDR";

                            temp = wave_folder + "\\" + temp;

                            HTTP_Audio = temp + ".wav";  // ke9ns this is the file created
                            HTTP_Audio1 = temp + ".mp3";  // ke9ns this is the file created

                            Audio.wave_file_writer = new WaveFileWriter(BlockSize1, 2, SampleRate1, HTTP_Audio);  // open up new test.wav file in PowerSDR folder

                        } //  if (HTTPAudio == false)
            */
            HTTPAudio = true; // activate audio stream



            using (var reader = new WaveFileReader(HTTP_Audio))    // Open a reader for test.wav file
            {
                IWaveProvider stream32 = new Wave16ToFloatProvider(reader); // interface to convert wav file to floating stream


                using (var converted = new LameMP3FileWriter(HTTP_Audio1, reader.WaveFormat, LAMEPreset.VBR_90)) // open test.wav and convert to mp3 and save in test.mp3
                {
                    //  reader.CopyTo(converted);  // create MP3 file


                    int bytesRead;
                    do
                    {
                        bytesRead = stream32.Read(audioOutput, 0, audioOutput.Length);
                        converted.Write(audioOutput, 0, bytesRead);


                    } while (bytesRead != 0 && converted.Length < reader.Length);

                }
            }

            /*
                      using (WaveFileReader reader = new WaveFileReader(HTTP_Audio))
                      {

                          IWaveProvider stream32 = new Wave16ToFloatProvider(reader);

                          using (WaveFileWriter converted = new WaveFileWriter(temp.wav, stream32.WaveFormat))
                          {
                              byte[] buffer = new byte[8192];
                              int bytesRead;
                              do
                              {
                                  bytesRead = stream32.Read(buffer, 0, buffer.Length);
                                  converted.Write(buffer, 0, bytesRead);
                              } while (bytesRead != 0 && converted.Length < reader.Length);
                          }
                      }
          */


            return audioOutput;  // return byte array of audio


        } // getAudio()

        /*
                    var waveIn = new WaveInEvent();
                    waveIn.DeviceNumber = deviceID;
                    waveIn.WaveFormat = Program.WAVEFORMAT;
                    waveIn.BufferMilliseconds = 50;
                    waveIn.DataAvailable += OnDataAvailable;

                    var udpSender = new UdpClient();
                            udpSender.JoinMulticastGroup(Program.MulticastIP);

                    waveIn.StartRecording();

                    private void OnDataAvailable(object sender, WaveInEventArgs e)
                {
                    udpSender.Send(e.Buffer, e.BytesRecorded, Program.EndPoint);
                }
        */

        //=========================================================================================
        //=========================================================================================
        // ke9ns add allows Http server to talk with Setup through Console
        //       
        public static int m_port = 0;   // ke9ns add port# 
        public static bool m_terminated = true;

        // ke9ns add  called by setup() when Basic HTTP activated 
        public bool HttpServer
        {

            set
            {
                httpFile.HttpServer1();
            }

        } //HttpServer


        //=========================================================================================
        //=========================================================================================
        // ke9ns add allows Http server to talk with Setup through Console
        public int HTTP_PORT
        {
            get
            {
                return (int)setupForm.udHttpPort.Value;
            }

        } // HTTP_PORT

        //=========================================================================================
        //=========================================================================================
        // ke9ns add allows Http server to talk with Setup through Console
        public int HTTP_REFRESH
        {
            get
            {
                return (int)setupForm.udHttpRefresh.Value;
            }

        } // HTTP_REFRESH

        //=========================================================================================
        //=========================================================================================
        // ke9ns add allows Http server to talk with Setup through Console
        public string HTTP_USER
        {
            get
            {
                return setupForm.txtHttpUser.Text;
            }

        } // HTTP_PORT


        //=========================================================================================
        //=========================================================================================
        // ke9ns add allows Http server to talk with Setup through Console
        public string HTTP_PASS
        {
            get
            {
                return setupForm.txtHttpPass.Text;
            }

        } // HTTP_PORT




        private void SWLMenuItem_Click(object sender, EventArgs e)
        {
            if (SpotForm != null)
            {

                if (SpotControl.SP1_Active == 0)
                {
                    if (SpotControl.SP3_Active == 1)
                    {
                        SpotControl.SP1_Active = 1; // make sure SWL is actually turned ON
                        SWLFORM = true; // open up SWL search window

                        if (SpotControl.SP_Active == 0)
                        {
                            spotterMenu.BackColor = Color.Yellow;
                            spotterMenu.Text = "SWL Spot";
                        }
                    }

                }
                else
                {

                    if (SwlForm != null)
                    {
                        SwlForm.Close();
                    }

                    SpotControl.SP1_Active = 0; // turn off SWL spotter

                    // SpotControl.statusBoxSWL.ForeColor = Color.Red;
                    //  SpotControl.statusBoxSWL.Text = "Off";


                    if (SpotControl.SP_Active == 0)
                    {
                        spotterMenu.BackColor = Color.Red;
                        spotterMenu.Text = "Spotter";
                    }

                }


            } //  if (SpotForm != null)


        } // SWLMenuItem_Click

        // ke9ns add
        private void panelTS1_MouseClick(object sender, MouseEventArgs e)
        {
            localweather = false;
            localweatherblock = true;
            localweatherupdate = false;
            noaaON = 1;
            panelTS1.Visible = false;
            panelTS1.Enabled = false;
            panelTS1.Invalidate();

            int h_delta = this.Width - console_basis_size.Width;
            int v_delta = Math.Max(this.Height - console_basis_size.Height, 0);
            ResizeConsole(h_delta, v_delta);


        } // panelTS1_MouseClic

        public void TurnOffVOA()
        {
            if (SpotForm != null) // ke9ns add .198
            {
                Debug.WriteLine("0SPOT TURNED OFF " + SpotForm.checkBoxMUF.Checked + " , " + SpotForm.VOARUN + " , " + SpotForm.VOARUN + " , " + SpotControl.SP5_Active + " , " + SpotForm.mapon);

                SpotForm.checkBoxMUF.CheckedChanged -= SpotForm.checkBoxMUF_CheckedChanged;
                SpotForm.checkBoxMUF.Checked = false;
                SpotControl.Map_Last = SpotControl.Map_Last | 2;    // force update of world map


                SpotControl.SP5_Active = 0;                     // turn off tracking



                Debug.WriteLine("1SPOT TURNED OFF- " + SpotForm.checkBoxMUF.Checked + " , " + SpotForm.VOARUN + " , " + SpotForm.VOARUN + " , " + SpotControl.SP5_Active + " , " + SpotForm.mapon);

            } //  if (SpotForm != null) 




        } // TurnOffVOA()


        // ke9ns add
        public void chkPower_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;


            if ((me.Button == System.Windows.Forms.MouseButtons.Right)) // 
            {
                if (chkPower.Checked) //.254
                {
                    chkPower.Checked = false; //
                    Thread.Sleep(800);
                   
                }

                setupForm.ApplyOptions(); // ke9ns add .193a (wait until save is updated before closing everything

                if (SpotForm != null) // ke9ns add .198
                {
                    Debug.WriteLine("SPOT TURNED OFF " + SpotForm.checkBoxMUF.Checked + " , " + SpotForm.VOARUN + " , " + SpotForm.VOARUN + " , " + SpotControl.SP5_Active + " , " + SpotForm.mapon);

                    SpotForm.checkBoxMUF.CheckedChanged -= SpotForm.checkBoxMUF_CheckedChanged;
                    SpotForm.checkBoxMUF.Checked = false;
                    SpotControl.Map_Last = SpotControl.Map_Last | 2;    // force update of world map


                    SpotControl.SP5_Active = 0;                     // turn off tracking


                    Debug.WriteLine("SPOT TURNED OFF- " + SpotForm.checkBoxMUF.Checked + " , " + SpotForm.VOARUN + " , " + SpotForm.VOARUN + " , " + SpotControl.SP5_Active + " , " + SpotForm.mapon);

                } //  if (SpotForm != null) 

                chkPower.Checked = false; // ke9ns add .193a
                this.Close();

                /*   if (System.Windows.Forms.Application.MessageLoop)
                   {
                       // WinForms app
                       System.Windows.Forms.Application.Exit();
                   }
                   else
                   {
                       // Console app
                       System.Environment.Exit(1);
                   }

   */
            } // right click

        } // chkPower_MouseDown



        IPEndPoint RemoteEndPoint; // ke9ns add


        //=============================================================================
        // ke9ns add Camera Screen Shot JPEG Save in QuickScreen folder

        private void ScreenCap_MouseDown(object sender, MouseEventArgs e)
        {
            ScreenCap1.Visible = true;
            ScreenCap1.Enabled = true;

            ScreenCap.Visible = false;


            MouseEventArgs me = (MouseEventArgs)e;

            if ((me.Button == System.Windows.Forms.MouseButtons.Right)) // 
            {
                string filePath = AppDataPath + "QuickScreen";


                if (!Directory.Exists(filePath))
                {
                    Debug.WriteLine("problem QuickScreen folder not found. Create a file first: " + filePath);
                    //    return;
                }

                System.Diagnostics.Process.Start("explorer.exe", filePath); // open folder

            } // right click
            else
            {
                Screen_Save(); // left click performs a screen display capture and save as JPEG
            }

            btnHidden.Focus();
        } // ScreenCap_MouseDown


        //======================================================================================================
        // ke9ns add  screen save
        public void Screen_Save()
        {

            string temp = "__" + RX1DSPMode.ToString() + "_";   // DSP mode
            temp += VFOAFreq.ToString("f6" ) + "MHz_";    // Freq
            temp += DateTime.Now.ToString();                     // Date and time
            temp = temp.Replace("/", "-");
            temp = temp.Replace(":", "_");

            System.IO.Directory.CreateDirectory(AppDataPath + "QuickScreen");                   // create sub directory if it does not exist
            string file_name = AppDataPath + "QuickScreen" + "\\SDRScreenSave" + temp + ".jpg"; // place to save jpeg screen shots


            if ((setupForm != null) && (setupForm.checkBoxHTTP1.Checked == true)) // full console below
            {

                Graphics myGraphics = this.CreateGraphics(); // graphics control for the full PSDR console
                Size s = this.Size;                          // current size of the PSDR console

                bitmap = new Bitmap(s.Width, s.Height, myGraphics);                                 // create bitmap the exact size of the full console screen
                Graphics memGraph = Graphics.FromImage(bitmap);                                     // make graphic the size of the PSDR console
                memGraph.CopyFromScreen(this.Location.X, this.Location.Y, 0, 0, s);                 // copy the full console screen to memGraph

                ImageCodecInfo jpgEncoder = GetEncoder(ImageFormat.Jpeg);                           // create JPEG format
                System.Drawing.Imaging.Encoder myEncoder = System.Drawing.Imaging.Encoder.Quality;  // create JPEG encoder
                EncoderParameters myEncoderParameters = new EncoderParameters(1);                   // parameters
                EncoderParameter myEncoderParameter = new EncoderParameter(myEncoder, 99L);         // 99% quality  (reduction to reduce byte size since this is the entire console screen)
                myEncoderParameters.Param[0] = myEncoderParameter;                                  // set paramaters

                bitmap.Save(file_name, jpgEncoder, myEncoderParameters);                            // save FILE as JPEG using Parameters

            }
            else // just display (not console) below
            {

                bitmap = new Bitmap(picDisplay.Width, picDisplay.Height);                           // set bitmap size to size of picDisplay since it gets resized with your screen
                picDisplay.DrawToBitmap(bitmap, picDisplay.ClientRectangle);                        // Draw picDisplay to bitmap

                bitmap.Save(file_name, ImageFormat.Jpeg);                                           // Save File as JPEG (as a Full RES JPEG, no compression)


            } // Just Display area



        } //  Screen_Save()



        //==========================================================================
        // ke9ns add  to send spectrum data to n1mm+ program (but requires PowerSDR to not be minimized)
        public bool N1MM // called when setup.cs checkboxn1mm is changed
        {
            get
            {
                return true;
            }
            set
            {
                if (value == true)
                {
                    N1MM_ON = true;
                    Thread t8 = new Thread(new ThreadStart(N1MM_SPECTRUM));
                    t8.Name = "N1MM_SPECTRUM display";
                    t8.IsBackground = true;
                    t8.Priority = ThreadPriority.Highest;
                    t8.Start();

                }
                else
                {
                    N1MM_ON = false; // shut down thread

                }
            }



        } //  N1MM

        private void ScreenCap_MouseUp(object sender, MouseEventArgs e)
        {
            ScreenCap.Visible = true;
            ScreenCap1.Visible = false;

        }

        // ke9ns add
        private void txtVFOABand_MouseUp(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((me.Button == System.Windows.Forms.MouseButtons.Right))
            {
                if (SpotForm.chkBoxBandText.Checked == true) SpotForm.chkBoxBandText.Checked = false;
                else SpotForm.chkBoxBandText.Checked = true;
            }


        } // txtVFOABand_MouseUp

        // ke9ns add
        private void txtVFOBBand_MouseUp(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((me.Button == System.Windows.Forms.MouseButtons.Right))
            {
                if (SpotForm.chkBoxBandText.Checked == true) SpotForm.chkBoxBandText.Checked = false;
                else SpotForm.chkBoxBandText.Checked = true;
            }
        }


        private bool SplitUp = false;
        //===============================================================================
        // ke9ns add to allow a 5khz split (1khz on cw)
        private void chkVFOSplit_MouseDown(object sender, MouseEventArgs e)
        {

            MouseEventArgs me = (MouseEventArgs)e;

            if ((me.Button == System.Windows.Forms.MouseButtons.Right))
            {
                if (RX2Enabled == true) return; // dont allow if 2nd RX is ON

                if (setupForm == null || setupForm.IsDisposed) setupForm = new Setup(this);

                if (chkVFOSync.Checked == true)
                {
                    chkVFOSync.Checked = false; // turn off 
                }

                if (SplitUp == false)
                {
                    SplitUp = true;
                    if ((RX1DSPMode == DSPMode.CWL) || (RX1DSPMode == DSPMode.CWU))
                        VFOBFreq = VFOAFreq + .001; // in mhz
                    else
                        VFOBFreq = VFOAFreq + .005; // in mhz
                }
                else
                {
                    SplitUp = false;
                    if ((RX1DSPMode == DSPMode.CWL) || (RX1DSPMode == DSPMode.CWU))
                        VFOBFreq = VFOAFreq - .001; // in mhz
                    else
                        VFOBFreq = VFOAFreq - .005; // in mhz
                }

                txtVFOAFreq_LostFocus(this, EventArgs.Empty);

                chkVFOSplit.Checked = true; // activate split (TX on vfoB)

                if (setupForm.chkBoxSplitListen.Checked == true)
                {
                    VFOASubFreq = VFOAFreq; // ke9ns add start with sub on top of vfoA
                    UpdateVFOASub();

                    chkEnableMultiRX.Checked = true; // activate the multiRX (sub receiver to listen in on the TX freq)
                }

            } // right click
        } //chkVFOSplit_MouseDown


        bool n1mm_rx2 = false;
        public bool N1MM_RX2 // .219
        {
            get
            {
                if (setupForm != null) n1mm_rx2 = setupForm.checkBoxRX2.Checked;

                return n1mm_rx2;
            }
            set
            {
                n1mm_rx2 = value;
                if (setupForm != null) setupForm.checkBoxRX2.Checked = n1mm_rx2;

            }

        } //  N1MM_RX2



        // ke9ns n1mm



        //=========================================================================================
        /*
         
     <?xml version="1.0" encoding="utf-8"?>
     <Spectrum>
     <Name>N1MM SDR1</Name>
     <LowScopeFrequency>14000</LowScopeFrequency>
     <HighScopeFrequency>14055</HighScopeFrequency>
     <ScalingFactor>0.3125</ScalingFactor>
     <DataCount>475</DataCount>
     <SpectrumData>0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0, 
     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0, 
     0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,19,25,0,0,0,0,0,0,0,4,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0, 
     1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0, 
     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15,0,0,0,0,0,38,50,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0, 
     0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 
     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0
     </SpectrumData>
     </Spectrum>
          
         */


        Socket server; // ke9ns add


        public bool N1MM_ON = false; // ke9ns add setupform turns this ON
        public int N1MM_Sample = 0; // ke9ns add  current number of samples in the pan (W)
        public int N1MM_Floor = -130; // ke9ns add  current lowest dBm value on the pan
        public int N1MM_Low = 0; // ke9ns add in khz found in display.cs
        public int N1MM_High = 0; // ke9ns add in khz found in display.cs
        public int N1MM_OFFSET = 0; // ke9ns: n1mm takes only khz upper/lower limits, so need to pad data since the Pan is not on perfect khz Low/high ends

        public double N1MM_Low1 = 0;
        public double N1MM_High1 = 0;
        public bool N1MM_MINIMIZE = false; // ke9ns add console minimized or not
        public bool N1MM_RESIZE = false; // ke9ns add

        public int[] N1MM_Data = new int[6000]; // ke9ns add



        // StringBuilder N1MM_Data_String = new StringBuilder();
        string N1MM_Data_String;


        public int N1MM_SPEED = 140; // ke9ns add: frames / sec  140msec = 7 fps
        //=========================================================================================
        // ke9ns add thread  (N1MM+ uses connectionless UDP that is unreliable)

        public void N1MM_SPECTRUM()
        {
            Debug.WriteLine("N1MM START");

            if (SpotForm == null || SpotForm.IsDisposed) SpotForm = new SpotControl(this);

            RemoteEndPoint = new IPEndPoint(IPAddress.Parse("127.0.0.1"), (int)setupForm.udN1MMport.Value);  // standard n1mm port is 13064
            server = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);


            //    IPEndPoint RemoteEndPoint = new IPEndPoint(IPAddress.Parse("127.0.0.1"), 13064);
            //    Socket server = new Socket(AddressFamily.InterNetwork,SocketType.Dgram, ProtocolType.Udp);
            //  string welcome = "Hello, are you there?";

            // this should be the bandpass, so LOW = VFOA - lowrxbandpass, HIGH = VFOA + highrxbandpass

            while (N1MM_ON == true)
            {
                if ((setupForm != null) && (setupForm.udN1MMfps.Value > 0) && (setupForm.udN1MMfps.Value < 8))
                {
                    N1MM_SPEED = 1000 / (int)setupForm.udN1MMfps.Value;
                }

                //  Debug.WriteLine("N1MM GO");


                Thread.Sleep(N1MM_SPEED); // translates into 7 frames per second

                //  Debug.WriteLine("Floor " + N1MM_Floor);
                //  if ((!mox) && (chkPower.Checked == true) && (N1MM_MINIMIZE == false) && (N1MM_RESIZE == false)) // DO if in Rec mode && 
                // ke9ns .183 will now work while minimized
                if ((!mox) && (chkPower.Checked == true) && (N1MM_Floor > -140 && N1MM_Floor < -60)) // DO if in Rec mode && 
                {
                    //   Debug.WriteLine("N1MM GO-----");

                    N1MM_Data_String = "";

                    int y = 0;


                    //   Debug.WriteLine("samples " + N1MM_Sample);

                    int yy = 0;



                    yy = N1MM_Floor * (-1);

                    N1MM_Floor = 0; // reset

                    int sampleCut = 1;



                    if (N1MM_Sample > 1024) sampleCut = 2; // if too much data, then cut in half

                    int qq = N1MM_Sample / sampleCut; // cut the number of samples in half

                    if (sampleCut == 1) qq = qq - 1;

                    //  Debug.WriteLine("1samples " + qq);

                    //  Debug.WriteLine("CUT " + sampleCut);

                    for (int i = 0; i < (N1MM_Sample - 1); i = i + sampleCut) // -1 for sampleCut of 2
                    {
                        y = (yy + N1MM_Data[i]) * 3; // 140

                        N1MM_Data_String = N1MM_Data_String + y.ToString();

                        if (i < (N1MM_Sample - (sampleCut + 1)))  // 3 = sampleCut of 2   2=sampleCut of 1
                        {
                            N1MM_Data_String = N1MM_Data_String + ",";
                        }


                    } // for samples

                    float scalef = (float)setupForm.udN1MMscale.Value;

                    //  if ((N1MM_MINIMIZE == true) && chkDisplayAVG.Checked) scalef = scalef / 2; // cut scale by half because I dont avg the display when minimized

                    //  Debug.WriteLine("N1MM GO-----" + N1MM_Low + " , "+ N1MM_High);

                    string welcome = "<?xml version=\"1.0\" encoding=\"utf - 8\"?>\n" +
                         "<Spectrum>\n" +
                         "<Name>" +
                      SpotControl.callB.ToString() +     //  SpotForm.callBox.Text.ToString() +  // "KE9NS" +
                        "</Name>\n" +

                        "<LowScopeFrequency>" +
                        N1MM_Low.ToString() + // "14000" +  // low freq
                        "</LowScopeFrequency>\n" +

                        "<HighScopeFrequency>" +
                        N1MM_High.ToString() + // "14055" +  // high freq
                        "</HighScopeFrequency>\n" +

                        "<ScalingFactor>" +
                        scalef.ToString() + // "0.3125" + // scale factor
                        "</ScalingFactor>\n" +

                        "<DataCount>" +
                        qq.ToString() +     // N1MM_Sample.ToString() +   //"475" +
                        "</DataCount>\n" +

                         "<SpectrumData>" +

                         N1MM_Data_String +

                         // SAME DATA FRAME
                         //  "0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,\n" +
                         // "0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,\n" +
                         //  "0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,19,25,0,0,0,0,0,0,0,4,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,\n" +
                         //  "1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,\n" +
                         //  "0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15,0,0,0,0,0,38,50,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,\n" +
                         //  "0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n" +
                         //  "0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0\n" +

                         "</SpectrumData>\n" +
                         "</Spectrum>\n";

                    //   Debug.WriteLine("N1MM DATA");
                    //  Debug.WriteLine(welcome);

                    byte[] data = Encoding.ASCII.GetBytes(welcome);

                    server.SendTo(data, data.Length, SocketFlags.None, RemoteEndPoint); // SEND TO N1MM+ PROGRAM VIA 127.0.0.1 IP

                } // !mox
                else
                {
                    Debug.WriteLine("N1MM NOT GO");
                }

            } // while N1MM_ON == true

            Debug.WriteLine("N1MM STOP");


            server.Close(); // shut down N1MM

        } // N1MM_SPECTRUM()

        //==============================================================================================
        // ke9ns add
        private void comboDisplayMode_MouseUp(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((me.Button == System.Windows.Forms.MouseButtons.Right))
            {
                //  Debug.WriteLine("DISPLAY MODE RIGHT CLICK ");

                if (comboDisplayMode.Text == "Continuum")
                {
                    if (CONT_RUN == false)
                    {
                        Debug.WriteLine("CONT false ");

                        CONT_dbm.Clear();

                        CONT_Curr = 0; // reset
                        CONT_Last = 0;
                        CONT_RUN = true; // start recording continuum data
                    }
                    else
                    {
                        Debug.WriteLine("CONT true ");

                        CONT_RUN = false; // stop recording continuum data
                        CONT_Last = CONT_Curr;
                        CONT_Logger_Write();
                        CONT_Curr = 0; // reset
                        CONT_Last = 0;
                        CONT_dbm.Clear();
                    }
                } // if in continuum mode only
                else
                {
                    Debug.WriteLine("not in CONT mode " + comboDisplayMode.Text);
                }

            } // right click button pushed




        } //  comboDisplayMode_MouseUp

        //===============================================================================
        // ke9ns add (record Continuum into CSV)


        public int CONT_Curr = 0; // current index

        public int CONT_Last = 0;


        // ke9ns add for IIC solid-state AMP PTT ON/OFF control (remote)
        // this way I can remotely tune up antenna (verifying SWR using LP-500 remote) before PTT AMP
        private void checkBoxIICPTT_CheckedChanged(object sender, EventArgs e)
        {
            if (checkBoxIICPTT.Checked == true)
            {
                checkBoxIICPTT.Text = "Amp  PTT";
            }
            else
            {
                checkBoxIICPTT.Text = "Amp  ̶P̶T̶T̶"; // strike through characters
            }

            IIC_AMPCONTROL(AMPBAND, AMPBAND1); //  call routine to update the IIC bus


        } // checkBoxIICPTT_CheckedChanged

        private void checkBoxIICON_CheckedChanged(object sender, EventArgs e)
        {
            if (setupForm != null) setupForm.chkBoxIICON.Checked = checkBoxIICON.Checked;

            if (checkBoxIICON.Checked == true)
            {
                checkBoxIICON.Text = "Amp ON";
            }
            else
            {
                checkBoxIICON.Text = "Amp OFF";
            }

            IIC_AMPCONTROL(AMPBAND, AMPBAND1); //  call routine to update the IIC bus

        }

        // ke9ns add right click to go directly to setup->transmitter
        private void chkVOX_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                if (setupForm == null || setupForm.IsDisposed)
                    setupForm = new Setup(this);

                setupForm.Show();
                setupForm.Focus();
                setupForm.WindowState = FormWindowState.Normal; // ke9ns add

                setupForm.tcSetup.SelectedIndex = 4; // select transmit tab;



            } // right click
        }



        // ke9ns add: go to wave
        private void buttonCQ_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                if (WaveForm.IsDisposed)
                    WaveForm = new WaveControl(this);
                WaveForm.Show();
                WaveForm.Focus();
                WaveForm.WindowState = FormWindowState.Normal; // ke9ns add


                //   if (setupForm == null || setupForm.IsDisposed)
                //      setupForm = new Setup(this);

                //  setupForm.Show();
                //  setupForm.Focus();
                //  setupForm.WindowState = FormWindowState.Normal; // ke9ns add

                //   setupForm.tcSetup.SelectedIndex = 4; // select audio tab;


            } // right click
        }

        // ke9ns add: go to wave
        private void buttonCall_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                if (WaveForm.IsDisposed)
                    WaveForm = new WaveControl(this);
                WaveForm.Show();
                WaveForm.Focus();
                WaveForm.WindowState = FormWindowState.Normal; // ke9ns add


                //   if (setupForm == null || setupForm.IsDisposed)
                //      setupForm = new Setup(this);

                //  setupForm.Show();
                //  setupForm.Focus();
                //  setupForm.WindowState = FormWindowState.Normal; // ke9ns add

                //   setupForm.tcSetup.SelectedIndex = 4; // select audio tab;


            } // right click
        }

        bool PSDRFocusNow = false;
        bool PSDRAct = false;
        IntPtr myHandle;

        //=================================================================================
        // ke9ns add: allows moving mouse back onto Console screen, to refocus PowerSDR to accept keyboard strokes
        // this way you do not need to click on PowerSDR to refocus if you click on some other PowerSDR sub-form or other PC program
        private void Console_MouseEnter(object sender, EventArgs e)
        {
            if (setupForm != null)
            {
                if (setupForm.chkBoxAutoFocus.Checked == true)  // check if feature is active
                {
                    if (this.ContainsFocus) return; // if PowerSDR already has focus, then do nothing.



                    PSDRFocusNow = false;
                    PSDRAct = false;

                    // check ALL PSDR sub-forms and see if any are currently in FOCUS
                    // If sub-form has focus (TRUE) then do not auto focus the CONSOLE screen when moving mouse back to CONSOLE, 
                    // unless the "Always on TOP" box is checked for the sub-form... then refocus the Console screen,
                    // because the sub-form will remain on top of the Console, and the keyboard will still focus on the Console
                    // IF the "Always on Top" box is unchecked, dont refocus on Console, because the sub-form would disappear behind the console
                    // Note: not all sub-forms have a "always on top" box


                    if (flexControlBasicForm != null) if (flexControlBasicForm.ContainsFocus) PSDRFocusNow = true;
                    if (flexControlAdvancedForm != null) if (flexControlAdvancedForm.ContainsFocus) PSDRFocusNow = true;
                    if (setupForm != null)
                    {
                        if (setupForm.chkAlwaysOnTop1.Checked == false) // 
                        {
                            if (setupForm.ContainsFocus) PSDRFocusNow = true; // if setupform has focus, but does not have "always on top" checked, then dont give focus to PowerSDR
                        }
                        //  else if (setupForm.ContainsFocus) PSDRAct = true; //
                    }
                    if (SwlForm != null)
                    {
                        if (SwlForm.chkAlwaysOnTop.Checked == false) // 
                        {
                            if (SwlForm.ContainsFocus) PSDRFocusNow = true; // if the form is not forced to stay on top, but its in focus, set true so PSDR doesnt steal focus.
                        }
                        //  else if (SwlForm.ContainsFocus) PSDRAct = true; //
                    }
                    if (IDBOXForm != null) if (IDBOXForm.ContainsFocus) PSDRFocusNow = true;
                    if (TOTBOXForm != null) if (TOTBOXForm.ContainsFocus) PSDRFocusNow = true;
                    if (SpotForm != null)
                    {
                        if (SpotForm.chkAlwaysOnTop.Checked == false) // 
                        {
                            if (SpotForm.ContainsFocus) PSDRFocusNow = true;
                        }
                        //  else if (SpotForm.ContainsFocus) PSDRAct = true; //
                    }
                    if (SpotDecoderForm != null) if (SpotDecoderForm.ContainsFocus) PSDRFocusNow = true;
                    if (ScanForm != null)
                    {
                        if (ScanForm.chkAlwaysOnTop.Checked == false) //
                            if (ScanForm.ContainsFocus) PSDRFocusNow = true;
                    }
                    if (StackForm != null)
                    {
                        if (StackForm.chkAlwaysOnTop.Checked == false) //
                            if (StackForm.ContainsFocus) PSDRFocusNow = true;
                    }
                    if (helpboxForm != null) if (helpboxForm.ContainsFocus) PSDRFocusNow = true;
                    if (helpbox1Form != null) if (helpbox1Form.ContainsFocus) PSDRFocusNow = true;
                    if (cwxForm != null)
                    {
                        if (cwxForm.chkAlwaysOnTop.Checked == false) //
                            if (cwxForm.ContainsFocus) PSDRFocusNow = true;
                    }
                    if (ucbForm != null) if (ucbForm.ContainsFocus) PSDRFocusNow = true;
                    if (xvtrForm != null)
                    {
                        if (xvtrForm.chkAlwaysOnTop1.Checked == false) //
                            if (xvtrForm.ContainsFocus) PSDRFocusNow = true;
                    }
                    if (vuForm != null) if (vuForm.ContainsFocus) PSDRFocusNow = true;
                    if (eqForm != null)
                    {
                        if (eqForm.chkAlwaysOnTop1.Checked == false) //
                            if (eqForm.ContainsFocus) PSDRFocusNow = true;
                    }
                    if (filterRX1Form != null) if (filterRX1Form.ContainsFocus) PSDRFocusNow = true;
                    if (filterRX2Form != null) if (filterRX2Form.ContainsFocus) PSDRFocusNow = true;
                    if (flex5000LLHWForm != null) if (flex5000LLHWForm.ContainsFocus) PSDRFocusNow = true;
                    if (flex5000DebugForm != null) if (flex5000DebugForm.ContainsFocus) PSDRFocusNow = true;
                    if (fwcMixForm != null) if (fwcMixForm.ContainsFocus) PSDRFocusNow = true;
                    if (flex3000MixerForm != null) if (flex3000MixerForm.ContainsFocus) PSDRFocusNow = true;
                    if (flex1500MixerForm != null) if (flex1500MixerForm.ContainsFocus) PSDRFocusNow = true;
                    if (fwcAntForm != null)
                    {
                        if (fwcAntForm.chkAlwaysOnTop1.Checked == false) //
                            if (fwcAntForm.ContainsFocus) PSDRFocusNow = true;
                    }
                    if (flex5000RelayForm != null) if (flex5000RelayForm.ContainsFocus) PSDRFocusNow = true;
                    if (fwcAtuForm != null)
                    {
                        if (fwcAtuForm.chkAlwaysOnTop1.Checked == false) //
                            if (fwcAtuForm.ContainsFocus) PSDRFocusNow = true;
                    }
                    if (flex3000ATUForm != null) if (flex3000ATUForm.ContainsFocus) PSDRFocusNow = true;
                    if (fwcTestForm != null) if (fwcTestForm.ContainsFocus) PSDRFocusNow = true;
                    if (flex5000LPFForm != null) if (flex5000LPFForm.ContainsFocus) PSDRFocusNow = true;
                    if (fwcCalForm != null) if (fwcCalForm.ContainsFocus) PSDRFocusNow = true;
                    if (flex5000ProdTestForm != null) if (flex5000ProdTestForm.ContainsFocus) PSDRFocusNow = true;
                    if (flex5000FinalTestForm != null) if (flex5000FinalTestForm.ContainsFocus) PSDRFocusNow = true;
                    if (flex5000RX2CalForm != null) if (flex5000RX2CalForm.ContainsFocus) PSDRFocusNow = true;
                    if (flex3000TestForm != null) if (flex3000TestForm.ContainsFocus) PSDRFocusNow = true;
                    if (dspTestForm != null) if (dspTestForm.ContainsFocus) PSDRFocusNow = true;
                    if (preSelForm != null) if (preSelForm.ContainsFocus) PSDRFocusNow = true;
                    if (flex1500DebugForm != null) if (flex1500DebugForm.ContainsFocus) PSDRFocusNow = true;
                    if (flex5000VUCalForm != null) if (flex5000VUCalForm.ContainsFocus) PSDRFocusNow = true;
                    if (diversityForm != null) if (diversityForm.ContainsFocus) PSDRFocusNow = true;
                    if (aboutForm != null) if (aboutForm.ContainsFocus) PSDRFocusNow = true;
                    if (hidAntForm != null) if (hidAntForm.ContainsFocus) PSDRFocusNow = true;
                    if (memoryForm != null)
                    {
                        if (memoryForm.chkAlwaysOnTop.Checked == false) //
                            if (memoryForm.ContainsFocus) PSDRFocusNow = true;
                    }
                    if (WaveForm != null)
                    {
                        if (WaveForm.chkAlwaysOnTop.Checked == false) //
                            if (WaveForm.ContainsFocus) PSDRFocusNow = true;
                    }
                    if (PAQualForm != null) if (PAQualForm.ContainsFocus) PSDRFocusNow = true;
                    if (ProdTestForm != null) if (ProdTestForm.ContainsFocus) PSDRFocusNow = true;


                    //.........................................
                    if (PSDRFocusNow == false) // only allow refocus to Console if no sub-form has focus already (or has focus, but "always on top" box checked
                    {



                        //  shownames(); // Debug.WriteLine("Process: {0} ID: {1} Window title: {2}", process.ProcessName, process.Id, process.MainWindowTitle);
                        //    Activate("FlexRadio Systems™  PowerSDR™  v2.8.0.121   [Mods by KE9NS]   FLEX-5000: 1610-2780 : US Extended");
                        //  this.Activate();
                        //   myHandle = AutoIt.AutoItX.WinGetHandle("FlexRadio Systems™  PowerSDR™  v2.8.0.122   [Mods by KE9NS]   FLEX-5000: 1610-2780 : US Extended",""); //= 1253304

                        myHandle = AutoIt.AutoItX.WinGetHandle("FlexRadio Systems™  PowerSDR™");
                        //  Debug.WriteLine("NEED4 FOCUS " + myHandle +" , " + GetForegroundWindow());

                        //  IntPtr activeHandle = GetForegroundWindow();


                        //  if (GetForegroundWindow() != myHandle)
                        // {

                        AutoIt.AutoItX.WinActivate(myHandle);
                        //  }

                        return;

                    } //  if (PSDRFocusNow == false)
                }
            }
        } // Console_MouseEnter

        // ke9ns add:
        private void UdCQCQRepeat_ValueChanged(object sender, EventArgs e)
        {
            //  txtVFOAFreq_LostFocus(this, EventArgs.Empty);
            btnHidden.Focus();

        }

        // ke9ns add
        bool ESCHOVER = false;
        private void ESCToolStripMenuItem_MouseHover(object sender, EventArgs e)
        {

            ESCHOVER = true;

        }

        private void ESCToolStripMenuItem_MouseLeave(object sender, EventArgs e)
        {
            ESCHOVER = false;
        }


        //============================================================================================================
        // ke9ns add: save Continuum data to file 

        public bool CONT_RUN = false;

        // ke9ns add
        private void radDisplayZoom4x_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;
            if ((me.Button == System.Windows.Forms.MouseButtons.Right))
            {
                //ktest
                ptbDisplayZoom.Value = ptbDisplayZoom.Maximum + ptbDisplayZoom.Minimum - (int)(100.0 / 40.0); // ke9ns add: 40x super zoom (slider goes up to x100)
                ptbDisplayZoom_Scroll(this, EventArgs.Empty);
                btnDisplayPanCenter_Click(this, EventArgs.Empty);

            }
            else if ((me.Button == System.Windows.Forms.MouseButtons.Middle)) //.219
            {

                ptbDisplayZoom2.Value = ptbDisplayZoom2.Maximum + ptbDisplayZoom2.Minimum - (int)(100.0 / 4.0);
                ptbDisplayZoom_Scroll(this, EventArgs.Empty);
                btnDisplayPanCenter_Click(this, EventArgs.Empty);

            }


        } // radDisplayZoom4x_MouseDown

        private void lblDisplayZoom_Click(object sender, EventArgs e)
        {

        }
        // ke9ns add
        private void lblDisplayZoom_MouseHover(object sender, EventArgs e)
        {


            double zoom_factor = 1.0 / ((ptbDisplayZoom.Maximum + ptbDisplayZoom.Minimum - ptbDisplayZoom.Value) * 0.01); // ke9ns: 1/(260 - value)*.01 =   LEFT=.3846 <---> RIGHT= 10

            this.toolTip1.SetToolTip(this.lblDisplayZoom1, "LEFT Click:  Toggle between Normal, and Enlarged Signal\nRIGHT Click: Toggle between Normal, and Zoomed in signal (on top)\n\n  Current Zoom Factor: " + zoom_factor);

        }
        // ke9ns add
        private void ptbDisplayZoom_MouseHover(object sender, EventArgs e)
        {
            double zoom_factor = 1.0 / ((ptbDisplayZoom.Maximum + ptbDisplayZoom.Minimum - ptbDisplayZoom.Value) * 0.01); // ke9ns: 1/(260 - value)*.01 =   LEFT=.3846 <---> RIGHT= 10

            this.toolTip1.SetToolTip(this.ptbDisplayZoom, "RX1: LEFT Click = Zoom OUT to see as much Bandwidth as possible (for your Sample Rate 48k = 1500, 96K or 192k for 3000 / 5000a)\n" +
                "RIGHT Click = Zoom IN to see the mininum amount of Bandwidth(to see detail of a signal), use the CENTER slider to center your signal of interest.\n\n" +
                "CHECKBOX: Setup->Display->Hi Res Panafall for maximum resolution detail when ZOOMED IN.\n\n      RX1 Current Zoom Factor: " + zoom_factor);

        }

        private void ptbDisplayZoom2_MouseHover(object sender, EventArgs e) //.219
        {
            double zoom_factor = 1.0 / ((ptbDisplayZoom2.Maximum + ptbDisplayZoom2.Minimum - ptbDisplayZoom2.Value) * 0.01); // ke9ns: 1/(260 - value)*.01 =   LEFT=.3846 <---> RIGHT= 10

            this.toolTip1.SetToolTip(this.ptbDisplayZoom2, "RX2 LEFT Click = Zoom OUT to see as much Bandwidth as possible (for your Sample Rate 48k = 1500, 96K or 192k for 3000 / 5000a)\n" +
                "RIGHT Click = Zoom IN to see the mininum amount of Bandwidth(to see detail of a signal), use the CENTER slider to center your signal of intrest.\n\n" +
                "CHECKBOX: Setup->Display->Hi Res Panafall for maximum resolution detail when ZOOMED IN.\n\n      RX2 Current Zoom Factor: " + zoom_factor);

        }


        // ke9ns add
        private void radDisplayZoom2x_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;
            if ((me.Button == System.Windows.Forms.MouseButtons.Right))
            {
                //ktest
                ptbDisplayZoom.Value = ptbDisplayZoom.Maximum + ptbDisplayZoom.Minimum - (int)(100.0 / 20.0); // ke9ns add: 20x super zoom (slider goes up to x100)
                ptbDisplayZoom_Scroll(this, EventArgs.Empty);
                btnDisplayPanCenter_Click(this, EventArgs.Empty);

            }
            else if ((me.Button == System.Windows.Forms.MouseButtons.Middle)) //.219
            {

                ptbDisplayZoom2.Value = ptbDisplayZoom2.Maximum + ptbDisplayZoom2.Minimum - (int)(100.0 / 2.0);
                ptbDisplayZoom_Scroll(this, EventArgs.Empty);
                btnDisplayPanCenter_Click(this, EventArgs.Empty);

            }
        }
        // ke9ns add
        private void radDisplayZoom05_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;
            if ((me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                ptbDisplayZoom.Value = ptbDisplayZoom.Maximum + ptbDisplayZoom.Minimum; // ke9ns add: 100x super zoom (slider goes up to x100)
                ptbDisplayZoom_Scroll(this, EventArgs.Empty);
                btnDisplayPanCenter_Click(this, EventArgs.Empty);

            }
            else if ((me.Button == System.Windows.Forms.MouseButtons.Middle)) //.219
            {

                ptbDisplayZoom2.Value = ptbDisplayZoom2.Maximum + ptbDisplayZoom2.Minimum - (int)(100.0 / 0.5);
                ptbDisplayZoom_Scroll(this, EventArgs.Empty);
                btnDisplayPanCenter_Click(this, EventArgs.Empty);

            }
        }
        // ke9ns add
        private void radDisplayZoom1x_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;
            if ((me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                ptbDisplayZoom.Value = ptbDisplayZoom.Maximum + ptbDisplayZoom.Minimum - (int)(100.0 / 10.0); // ke9ns add: 10x super zoom (slider goes up to x100)
                ptbDisplayZoom_Scroll(this, EventArgs.Empty);
                btnDisplayPanCenter_Click(this, EventArgs.Empty);

            }
            else if ((me.Button == System.Windows.Forms.MouseButtons.Middle)) //.219
            {

                ptbDisplayZoom2.Value = ptbDisplayZoom2.Maximum + ptbDisplayZoom2.Minimum - (int)(100.0 / 1.0);
                ptbDisplayZoom_Scroll(this, EventArgs.Empty);
                btnDisplayPanCenter_Click(this, EventArgs.Empty);

            }


        }

        // ke9ns add: toggle AGC line across the panadapter screen
        public bool AGCTDIS = false; // ke9ns: true = AGCT green line feature active
        public bool AGCTUPDATE = false; // ke9ns: auto water/pan forces update of AGTC green line

        private void ptbRF_MouseDown(object sender, MouseEventArgs e)
        {
        }

        private void lblRF_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;
            if ((me.Button == System.Windows.Forms.MouseButtons.Right))
            {
                if (AGCTDIS == false) AGCTDIS = true;
                else AGCTDIS = false;

                Debug.WriteLine("AGCTDIS: " + AGCTDIS);
            }
        }

        private void ptbRF_MouseUp(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;
            if ((me.Button == System.Windows.Forms.MouseButtons.Right))
            {
                if (AGCTDIS == false) AGCTDIS = true;
                else AGCTDIS = false;

                Debug.WriteLine("AGCTDIS: " + AGCTDIS);
            }
        }

        //ke9ns add
        private void txtWheelTune_TextChanged(object sender, EventArgs e)
        {
            Debug.WriteLine("TEXTWHEEL TUNE TEXT CHANGED");

            if (initializing == false) // dont update if initializing
            {
                if (setupForm != null)
                {
                    TuneStepIndex = TuneStepLookup(txtWheelTune.Text);                       // if you switch modes then lookup the correct tunestep index
                                                                                             //   setupForm.tune_step_index2 = TuneStepLookup(setupForm.txtWheelTune2.Text);
                                                                                             //   setupForm.tune_step_index3 = TuneStepLookup(setupForm.txtWheelTune3.Text);

                    //  Debug.WriteLine("===TUNESTEP=== " + txtWheelTune.Text + " , "+ setupForm.txtWheelTune4.Text + " , " + setupForm.txtWheelTune9.Text);
                }
            }

            grpVFOBetween.Invalidate();

        } // txtWheelTune_TextChanged

        bool fill = false; // ke9ns add
                           //  bool Map3D = false; // ke9ns add
        int FPS3D = 0; // ke9ns add temporary holder
        private void label6_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((me.Button == System.Windows.Forms.MouseButtons.Right))
            {




            }
        } // label6_mousedown

        // ke9ns add: 3d button
        private void button1_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((me.Button == System.Windows.Forms.MouseButtons.Right))
            {
                if (setupForm == null || setupForm.IsDisposed) setupForm = new Setup(this);


                setupForm.Show();
                setupForm.Focus();
                setupForm.WindowState = FormWindowState.Normal; // ke9ns add

                setupForm.tcSetup.SelectedIndex = 6; // select appearance tab;
                setupForm.tcAppearance.SelectedIndex = 1; // select  tab

            }
            else
            {

                if (setupForm == null || setupForm.IsDisposed) setupForm = new Setup(this);

                if (setupForm.check3DPan.Checked == true) // if 3D was ON, turn off and turn fill back on if was on prior
                {
                    setupForm.check3DPan.Checked = false;
                    this.pictureBox1.Image = global::PowerSDR.Properties.Resources.blue1;

                    if (FPS3D > 0)
                    {
                        setupForm.udDisplayFPS.Value = FPS3D; // restore original value back
                        FPS3D = 0;
                    }

                }
                else // if 3D was OFF,turn ON
                {
                    this.pictureBox1.Image = global::PowerSDR.Properties.Resources.red1;

                    Display.Data3DLineAlpha = setupForm.tbPan3DAlpha.Value;
                    Display.Data3DLineColor = setupForm.clrbtn3DDataLine.Color;

                    setupForm.check3DPan.Checked = true;

                    FPS3D = 0;


                    if (SpotForm == null || SpotForm.IsDisposed)
                    {
                        Debug.WriteLine("SpotControl instance created by Map button");
                        SpotForm = new SpotControl(this);
                    }


                    if (DisplayFPS > 20)
                    {
                        FPS3D = DisplayFPS;
                        setupForm.udDisplayFPS.Value = 20;

                    }


                } // 3D was off, turn ON


            }
        } // button1_MouseDown

        // ke9ns add:
        private void txtMultiText_MouseUp(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                if (MeterMenu == false)
                {

                    MeterMenu = true; // show RX and TX meter menu items
                }
                else
                {
                    MeterMenu = false; // ke9ns add: false = hide RX and TX meter select menus
                }


                //   grpMultimeter.Invalidate();
                //   grpRX2Meter.Invalidate();



                //     Console_Resize(this, e);


            }
        } // txtMultiText_MouseUp

        // ke9ns add:
        private void txtRX2Meter_MouseUp(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                if (MeterMenu == false)
                {
                    MeterMenu = true; // show RX and TX meter menu items
                }
                else
                {
                    MeterMenu = false; // ke9ns add: false = hide RX and TX meter select menus
                }



            }
        } // txtRX2Meter_MouseUp



        // ke9ns add: to paint ring around console
        private void Console_Paint(object sender, PaintEventArgs e)
        {
            // if (FirstDown == true) return;

            if ((setupForm != null))
            {
                if (setupForm.chkBoxConsoleRing.Checked == true)
                {
                    //   e.Graphics.TextRenderingHint = TextRenderingHint.ClearTypeGridFit;
                    //   e.Graphics.CompositingMode = CompositingMode.SourceOver;
                    //   e.Graphics.CompositingQuality = CompositingQuality.HighQuality;
                    e.Graphics.InterpolationMode = InterpolationMode.HighQualityBicubic;
                    e.Graphics.SmoothingMode = SmoothingMode.HighQuality;
                    e.Graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;


                    GraphicsPath gPath = CreatePath(1, 1, this.Width - 2.0f, this.Height - 2.0f, 8, true, true, true, true); //
                                                                                                                             //  Debug.WriteLine("console width " + this.Width + " , " + this.Height);


                    e.Graphics.DrawPath(new Pen(ring_vfo_color, 2.0f), gPath); // ke9ns take color from setup Ring VFO color
                }
            }

        } // Console_Paint


        //==================================================================================================

        bool FirstDown = false; // ke9ns add: true = get initial mouse position 1 time (each time you first click down)
        Stopwatch panelMoveTime = new Stopwatch(); // ke9ns add


        int FirstX = 0;// ke9ns add
        int FirstY = 0;// ke9ns add

        bool MouseMoveSize = false; // ke9ns add: true = move, false = size

        int MouseMoveX = 0;// ke9ns add
        int MouseMoveY = 0;// ke9ns add
        // ke9ns add: to move console around without the titlebar
        private void labelPowerSDR_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                if (setupForm == null || setupForm.IsDisposed)
                    setupForm = new Setup(this);

                setupForm.Show();
                setupForm.Focus();
                setupForm.WindowState = FormWindowState.Normal; // ke9ns add

                setupForm.tcSetup.SelectedIndex = 6; // select appearance tab;
                setupForm.tcAppearance.SelectedIndex = 0; // select  tab

            } // right click
            else
            {
                if (setupForm == null || setupForm.IsDisposed)
                    setupForm = new Setup(this);

                setupForm.Show();
                setupForm.Focus();
                setupForm.WindowState = FormWindowState.Normal; // ke9ns add

                setupForm.tcSetup.SelectedIndex = 6; // select appearance tab;
                setupForm.tcAppearance.SelectedIndex = 0; // select  tab
            }
        } //  labelPowerSDR_MouseDown

        //======================================================================
        private void labelMove_MouseDown(object sender, MouseEventArgs e)
        {
            if (FirstDown == false) // First click DOWN
            {
                FirstDown = true;
                MouseMoveSize = true;
                panelMoveTime.Reset();

                MouseMoveX = FirstX = MousePosition.X;
                MouseMoveY = FirstY = MousePosition.Y;
            }

        }

        // ke9ns add: corner triangle click and move
        private void labelPowerSDR_MouseMove(object sender, MouseEventArgs e)
        {
            if (FirstDown == true)
            {
                panelMoveTime.Restart(); // 0 timer
                MouseMoveX = MousePosition.X;
                MouseMoveY = MousePosition.Y;
            }

        } // labelPowerSDR_MouseMove


        // ke9ns add
        private void labelPowerSDR_MouseUp(object sender, MouseEventArgs e)
        {
            panelMoveTime.Reset();

            if (FirstDown == true)
            {
                FirstDown = false;
                if (MousePosition.Y <= (Screen.PrimaryScreen.WorkingArea.Height))
                {

                    int X = this.Location.X;
                    int Y = this.Location.Y;

                    this.Location = new Point(X - (FirstX - MousePosition.X), Y - (FirstY - MousePosition.Y));

                }

                Console_Resize(this, EventArgs.Empty);
                this.Invalidate();
            }

        }


        //===============================================================

        private void labelSize_MouseDown(object sender, MouseEventArgs e)
        {
            if (FirstDown == false) // First click DOWN
            {
                FirstDown = true;
                panelMoveTime.Reset();
                MouseMoveSize = false;

                MouseMoveX = FirstX = MousePosition.X;
                MouseMoveY = FirstY = MousePosition.Y;
            }


        }
        private void label9_MouseMove(object sender, MouseEventArgs e)
        {
            if (FirstDown == true)
            {
                panelMoveTime.Restart();
                MouseMoveX = MousePosition.X;
                MouseMoveY = MousePosition.Y;

            }
        }

        private void labelSize_MouseUp(object sender, MouseEventArgs e)
        {

            panelMoveTime.Reset();

            if (FirstDown == true)
            {
                FirstDown = false;

                if (MousePosition.Y <= (Screen.PrimaryScreen.WorkingArea.Height))
                {

                    int W = this.Size.Width;
                    int H = this.Size.Height;

                    this.Size = new Size(W - (FirstX - MousePosition.X), H - (FirstY - MousePosition.Y));

                }
                Console_Resize(this, EventArgs.Empty);
                this.Invalidate();
            }
        }



        //================================================================================
        // ke9ns add:MAXIMIZE ICON window button glyphs:unicode
        private void label8_Click(object sender, EventArgs e)
        {
            if (setupForm != null)
            {
                if (setupForm.chkBoxMax.Checked == true)
                {
                    setupForm.chkBoxMax.Checked = false; // set console to NORMAL size (last non-max size)
                }
                else // false
                {
                    setupForm.chkBoxMax.Checked = true; // max size
                }

            }
        }



        // ke9ns add: right click to MINIMIZE to windows tray
        private void labelMax_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                WindowState = FormWindowState.Minimized;
            }

        }

        public List<string> CONT_dbm = new List<string>(); // ke9ns add: create list to hold strings of Continuum data
        public float CONT_BANDPASS = 0.0f;

        // ke9ns add:
        private void Console_MouseMove(object sender, MouseEventArgs e)
        {


            if (setupForm != null)
            {
                if (setupForm.chkBoxTitle.Checked == true)
                {
                    if (FirstDown == true)
                    {
                        panelMoveTime.Restart(); // 0 timer
                        MouseMoveX = MousePosition.X;
                        MouseMoveY = MousePosition.Y;
                    }
                }
            }
        }

        private void Console_MouseUp(object sender, MouseEventArgs e)
        {
            panelMoveTime.Reset();

            if (setupForm != null)
            {
                if (setupForm.chkBoxTitle.Checked == true)
                {
                    if (FirstDown == true)
                    {
                        FirstDown = false;

                        if ((FirstX != MousePosition.X) || (FirstY != MousePosition.Y))
                        {
                            if (MousePosition.Y <= (Screen.PrimaryScreen.WorkingArea.Height))
                            {

                                int X = this.Location.X;
                                int Y = this.Location.Y;

                                this.Location = new Point(X - (FirstX - MousePosition.X), Y - (FirstY - MousePosition.Y));

                            }
                        }

                        if ((FirstX != MousePosition.X) || (FirstY != MousePosition.Y))
                        {
                            Console_Resize(this, EventArgs.Empty);
                            this.Invalidate();
                        }
                    }
                }
            }
        }

        private void Console_MouseDown(object sender, MouseEventArgs e)
        {
            if (setupForm != null)
            {
                if (setupForm.chkBoxTitle.Checked == true)
                {
                    if (FirstDown == false) // First click DOWN
                    {
                        FirstDown = true;
                        MouseMoveSize = true;
                        panelMoveTime.Reset();

                        MouseMoveX = FirstX = MousePosition.X;
                        MouseMoveY = FirstY = MousePosition.Y;
                    }
                }
            }
        }

        // ke9ns add: .169 right click to flip xit -/+ around
        private void chkXIT_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((me.Button == System.Windows.Forms.MouseButtons.Right))
            {
                if (udXIT.Value != 0)
                    udXIT.Value = -udXIT.Value; // ke9ns: alternate -/+
                                                //  Display.XIT = (int)udXIT.Value;




            }

        } //  chkXIT_MouseDown


        // ke9ns add .185
        int XITemp = 0;
        public bool XITFlip
        {
            get
            {
                if (udXIT.Value != 0) return true;
                else return false;
            } // get
            set
            {
                if (chkXIT.Checked == true && udXIT.Value > 0)
                {

                    udXIT.Value = -udXIT.Value; // ke9ns: alternate -/+
                }
                else if (chkXIT.Checked == true && udXIT.Value < 0)
                {
                    chkXIT.Checked = false; // turn OFF

                }
                else if (chkXIT.Checked == false)
                {
                    chkXIT.Checked = true; // turn ON
                    udXIT.Value = -udXIT.Value; // 
                }
            } // set

        } // XITFlip

        private void radModeCWU_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                if (setupForm == null || setupForm.IsDisposed)
                    setupForm = new Setup(this);

                setupForm.Show();
                setupForm.Focus();
                setupForm.WindowState = FormWindowState.Normal; // ke9ns add

                setupForm.tcSetup.SelectedIndex = 0; // select general tab;
                setupForm.tcGeneral.SelectedIndex = 3; // select  filter tab

            }
        }

        private void radModeCWL_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                if (setupForm == null || setupForm.IsDisposed)
                    setupForm = new Setup(this);

                setupForm.Show();
                setupForm.Focus();
                setupForm.WindowState = FormWindowState.Normal; // ke9ns add

                setupForm.tcSetup.SelectedIndex = 0; // select general tab;
                setupForm.tcGeneral.SelectedIndex = 3; // select  filter tab

            }
        }

        private void udFilterLow_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                if (setupForm == null || setupForm.IsDisposed)
                    setupForm = new Setup(this);

                setupForm.Show();
                setupForm.Focus();
                setupForm.WindowState = FormWindowState.Normal; // ke9ns add

                setupForm.tcSetup.SelectedIndex = 0; // select general tab;
                setupForm.tcGeneral.SelectedIndex = 3; // select  filter tab

            }
        }

        private void udFilterHigh_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                if (setupForm == null || setupForm.IsDisposed)
                    setupForm = new Setup(this);

                setupForm.Show();
                setupForm.Focus();
                setupForm.WindowState = FormWindowState.Normal; // ke9ns add

                setupForm.tcSetup.SelectedIndex = 0; // select general tab;
                setupForm.tcGeneral.SelectedIndex = 3; // select  filter tab

            }
        }

        private void udTXFilterHigh_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                if (setupForm == null || setupForm.IsDisposed)
                    setupForm = new Setup(this);

                setupForm.Show();
                setupForm.Focus();
                setupForm.WindowState = FormWindowState.Normal; // ke9ns add

                setupForm.tcSetup.SelectedIndex = 0; // select general tab;
                setupForm.tcGeneral.SelectedIndex = 3; // select  filter tab

            }
        }

        private void udTXFilterLow_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                if (setupForm == null || setupForm.IsDisposed)
                    setupForm = new Setup(this);

                setupForm.Show();
                setupForm.Focus();
                setupForm.WindowState = FormWindowState.Normal; // ke9ns add

                setupForm.tcSetup.SelectedIndex = 0; // select general tab;
                setupForm.tcGeneral.SelectedIndex = 3; // select  filter tab

            }
        }

        private void udRX2FilterLow_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                if (setupForm == null || setupForm.IsDisposed)
                    setupForm = new Setup(this);

                setupForm.Show();
                setupForm.Focus();
                setupForm.WindowState = FormWindowState.Normal; // ke9ns add

                setupForm.tcSetup.SelectedIndex = 0; // select general tab;
                setupForm.tcGeneral.SelectedIndex = 3; // select  filter tab

            }
        }

        private void udRX2FilterHigh_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                if (setupForm == null || setupForm.IsDisposed)
                    setupForm = new Setup(this);

                setupForm.Show();
                setupForm.Focus();
                setupForm.WindowState = FormWindowState.Normal; // ke9ns add

                setupForm.tcSetup.SelectedIndex = 0; // select general tab;
                setupForm.tcGeneral.SelectedIndex = 3; // select  filter tab

            }
        }

        private void radRX2ModeCWU_MouseDown(object sender, MouseEventArgs e)
        {

            MouseEventArgs me = (MouseEventArgs)e;

            if ((me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                if (setupForm == null || setupForm.IsDisposed)
                    setupForm = new Setup(this);

                setupForm.Show();
                setupForm.Focus();
                setupForm.WindowState = FormWindowState.Normal; // ke9ns add

                setupForm.tcSetup.SelectedIndex = 0; // select general tab;
                setupForm.tcGeneral.SelectedIndex = 3; // select  filter tab

            }
        }

        private void radRX2ModeCWL_MouseDown(object sender, MouseEventArgs e)
        {

            MouseEventArgs me = (MouseEventArgs)e;

            if ((me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                if (setupForm == null || setupForm.IsDisposed)
                    setupForm = new Setup(this);

                setupForm.Show();
                setupForm.Focus();
                setupForm.WindowState = FormWindowState.Normal; // ke9ns add

                setupForm.tcSetup.SelectedIndex = 0; // select general tab;
                setupForm.tcGeneral.SelectedIndex = 3; // select  filter tab

            }
        }

        private void chkFM1750_CheckedChanged(object sender, EventArgs e)
        {


        }



        //=======================================================================================
        // ke9ns add .190 quindar Start and End tones option
        //=======================================================================================

        bool quindar_start = false;
        bool quindar_end = false;

        public bool Quindar_Start
        {
            get { return quindar_start; }

            set
            {
                quindar_start = value;

                if (quindar_start == true)
                {
                    Thread t = new Thread(new ThreadStart(QNDR_Start));
                    t.Name = "quindar start tone";
                    t.IsBackground = true;
                    t.Priority = ThreadPriority.Normal;
                    t.Start();
                }

            }

        } // Quindar_Start

        // ke9ns .190 thread
        public bool QuindarStart = false;
        public bool QuindarEnd = false;  // true = start to play end tone, false (wave.cs)= done playing tone 

        bool qndr_mox1 = false;
        bool qndr_pre1 = false;
        bool qndr_release = false; // ke9ns add .190 PollPTT false = keyed with mic,rca,cat,vox, true = unkeyed but not unmoxed

        bool qndr_vac1 = false;
        private void QNDR_Start() // ke9ns: when you first key the radio, the wav plays
        {
            // play quindar_start_tone wav file
            do
            {
                Thread.Sleep(75);

                if ((chkPower.Checked) && (setupForm.checkQuindarToneON.Checked == true) && (chkTUN.Checked != true) &&
                    (rx1_dsp_mode == DSPMode.LSB || rx1_dsp_mode == DSPMode.USB || rx1_dsp_mode == DSPMode.AM || rx1_dsp_mode == DSPMode.SAM || rx1_dsp_mode == DSPMode.FM)) // ke9ns add: only allow play if your in the correct mode and not TUNE
                {

                    if (MOX == false && QuindarEnd == false && QuindarStart == false && qndr_mox1 == false)
                    {
                        if (chkTUN.Checked != true) qndr_mox1 = true;


                        if ((chkMOX.Checked == false) && (checkBoxID.Checked == false) && (ckQuickPlay.Checked == false))
                        {
                            Audio.WavePreamp = Math.Pow(10.0, (int)WaveForm.udPreamp.Value / 20.0); // ke9ns: when the tone finishes set the preamp back to wave
                        }
                    }
                    else
                    {
                        if (chkMOX.Checked == true && qndr_mox1 == true && QuindarEnd == false && QuindarStart == false &&
                            (current_ptt_mode == PTTMode.MIC || current_ptt_mode == PTTMode.X2 || current_ptt_mode == PTTMode.CAT || current_ptt_mode == PTTMode.VOX))
                        {


                            Audio.WavePreamp = Math.Pow(10.0, (int)setupForm.udQuindarTonesVol.Value / 20.0); // convert to scalar
                            qndr_mox1 = false;
                            qndr_pre1 = true;
                            QuindarStart = true;    // let wave: chkQuickPlay_CheckedChanged know you want to play Quindar_tone_start.wav file only in the QuickAudio folder

                            ckQuickPlay.Checked = true;
                        }
                        else if ((qndr_pre1 == true) && (chkMOX.Checked == false) && (checkBoxID.Checked == false) && (ckQuickPlay.Checked == false))
                        {
                            Audio.WavePreamp = Math.Pow(10.0, (int)WaveForm.udPreamp.Value / 20.0);// ke9ns: when the tone finishes set the preamp back to wave
                            qndr_pre1 = false; // ke9ns reset flags for next go-around
                            qndr_mox1 = false;
                        }

                    }

                    if ((qndr_pre1 == true) && (checkBoxID.Checked == false) && (ckQuickPlay.Checked == false) && QuindarEnd == false && QuindarStart == false)
                    {
                        Audio.WavePreamp = Math.Pow(10.0, (int)WaveForm.udPreamp.Value / 20.0); // ke9ns: when the tone finishes set the preamp back to wave
                        qndr_pre1 = false; // reset flags for next go-around
                        qndr_mox1 = false;
                    }

                } // correct mode

            } while (Quindar_Start == true); // end thread when uncheck

        } // QNDR_Start thread

        //-------------------------------------------------------------------------------------------------------------------

        public bool Quindar_End
        {
            get { return quindar_end; }

            set
            {
                quindar_end = value;

                if (quindar_end == true)
                {
                    Thread t = new Thread(new ThreadStart(QNDR_End));
                    t.Name = "quindar End tone";
                    t.IsBackground = true;
                    t.Priority = ThreadPriority.Normal;
                    t.Start();
                }

            }

        } // Quindar_End


        bool qndr_mox = false; // true = you keyed the mic and force a 1 time wav play of the end quindar tone
        bool qndr_pre = false; // true = you will need to put back the orignial wav TX gain 

        PTTMode qndr_mode = PTTMode.NONE; // last device used to key the radio
        bool qndr_end = false;   // ke9ns: true = waiting for you to unkey the mic
        private void QNDR_End()  // ke9ns thread: when you unkey, the radio keys and the wav plays
        {
            // play quindar_End_tone wav file
            do
            {
                Thread.Sleep(75);


                if ((chkPower.Checked) && setupForm.checkQuindarToneON.Checked == true && (chkTUN.Checked != true) &&
                   (rx1_dsp_mode == DSPMode.LSB || rx1_dsp_mode == DSPMode.USB || rx1_dsp_mode == DSPMode.AM || rx1_dsp_mode == DSPMode.SAM || rx1_dsp_mode == DSPMode.FM)) // ke9ns add: check that you in an acceptable mode and supposed to be ON
                {
                    if (chkVAC1.Checked || chkVAC2.Checked) qndr_vac1 = true;


                    if (chkMOX.Checked == true && QuindarEnd == false && QuindarStart == false && qndr_mox == false &&
                        (current_ptt_mode == PTTMode.MIC || current_ptt_mode == PTTMode.X2 || current_ptt_mode == PTTMode.CAT || current_ptt_mode == PTTMode.VOX))  // ke9ns add: check that you are in TX in an accptable PTT mode and not in the middle of a TONE already
                    {
                        qndr_mode = current_ptt_mode; // ke9ns: what was the method of key when you were transmitting
                        qndr_mox = true; // ke9ns: yes you were in TX mode the correct PTT method at the correct time
                        qndr_release = false; // reset flag so PollPTT can check when you release the PTT (without allowing the radio to unkey)
                        qndr_end = true; // flag to let you know your doing an END quindar tone

                        if ((chkMOX.Checked == false) && (checkBoxID.Checked == false) && (ckQuickPlay.Checked == false))
                        {
                            Audio.WavePreamp = Math.Pow(10.0, (int)WaveForm.udPreamp.Value / 20.0); // ke9ns: when the tone finishes set the preamp back to wave

                        }
                    }
                    else
                    {
                        if (qndr_release == true && QuindarEnd == false && QuindarStart == false && qndr_mox == true && qndr_pre == false &&
                        (qndr_mode == PTTMode.MIC || qndr_mode == PTTMode.X2 || qndr_mode == PTTMode.CAT || qndr_mode == PTTMode.VOX))
                        {


                            Audio.WavePreamp = Math.Pow(10.0, (int)setupForm.udQuindarTonesVol.Value / 20.0); // convert to scalar

                            qndr_mox = false; // reset flag to allow this only 1 time
                            qndr_pre = true; // flag to reset preamp when done
                            QuindarEnd = true;     // let wave: chkQuickPlay_CheckedChanged know you want to play Quindar_tone_end.wav file only in the QuickAudio folder
                            checkBoxID.Checked = true; // keep radio keyed
                            ckQuickPlay.Checked = true; // play wav file

                            if (chkVAC1.Checked || chkVAC2.Checked) qndr_vac1 = false;



                        }
                        else if ((qndr_pre == true) && (chkMOX.Checked == false) && (checkBoxID.Checked == false) && (ckQuickPlay.Checked == false))
                        {
                            Audio.WavePreamp = Math.Pow(10.0, (int)WaveForm.udPreamp.Value / 20.0); // ke9ns: when the tone finishes set the preamp back to wave
                            qndr_pre = false; // ke9ns reset flags for next go-around
                            qndr_mox = false;
                            MOX = false;
                            qndr_release = false;
                            qndr_end = false;

                        }
                    }

                    if ((qndr_pre == true) && (chkMOX.Checked == false) && (checkBoxID.Checked == false) && (ckQuickPlay.Checked == false))
                    {
                        Audio.WavePreamp = Math.Pow(10.0, (int)WaveForm.udPreamp.Value / 20.0); // ke9ns: when the tone finishes set the preamp back to wave
                        qndr_pre = false;  // ke9ns reset flags for next go-around
                        qndr_mox = false;
                        MOX = false;
                        qndr_release = false;
                        qndr_end = false;

                    }
                } // check correct DSP mode above

            } while (Quindar_End == true); // end thread when uncheck


        } // QNDR_End thread


        //=======================================================================================
        // ke9ns add .189 FM mode 1750hz tone repeater key option
        //=======================================================================================
        private void chkFM1750_Click(object sender, EventArgs e)
        {
            //  Debug.WriteLine("1750click===== " + chkFM1750.Checked);


            if (chkFM1750.Checked)
            {
                chkFM1750.BackColor = Color.Red;

                chkFMCTCSS.Checked = false;  // ke9ns add .188

                FM1750Timer = false;

                if (FM1750 == false)
                {
                    Thread t = new Thread(new ThreadStart(Thd1750));
                    t.Name = "400msec timer";
                    t.IsBackground = true;
                    t.Priority = ThreadPriority.Normal;
                    t.Start();
                }

            } // 1750 checked true
            else
            {
                chkFM1750.BackColor = Color.Black;

            }


        } // chkFM1750_Click


        // =============================
        // ke9ns thread for 1750hz tone

        bool FM1750 = false;
        bool FM1750Timer = false;
        Stopwatch t7 = new Stopwatch();

        public void Thd1750()
        {
            FM1750 = true;

            do
            {
                if (chkMOX.Checked == true)
                {
                    if (FM1750Timer == false)
                    {
                        t7.Restart();
                        Audio.MOX = true;
                        Audio.SineFreq1 = 1750.0;
                        Audio.SineFreq2 = 1750.0;
                        Audio.two_tone = true;
                        Audio.TXInputSignal = Audio.SignalSource.SINE_TWO_TONE;
                        Audio.SourceScale = 1.0;
                        FM1750Timer = true;
                    }
                    else // below true
                    {

                        if (t7.ElapsedMilliseconds > udFM1750Timer.Value) // .197 was 350
                        {
                            Audio.TXInputSignal = Audio.SignalSource.RADIO;
                            Audio.SineFreq1 = (double)setupForm.udDSPCWPitch.Value;
                            Audio.two_tone = false;

                            chkFM1750.Checked = false; // ke9ns its over

                            t7.Stop();

                        }
                    }



                }
                else // ke9ns: if you unkey before the full time, turn off 1750 but dont kill the thread
                {
                    t7.Stop();

                    Audio.TXInputSignal = Audio.SignalSource.RADIO;
                    Audio.SineFreq1 = (double)setupForm.udDSPCWPitch.Value;
                    Audio.two_tone = false;
                    FM1750Timer = false;

                }



            } while (chkFM1750.Checked == true);

            t7.Stop();

            chkFM1750.BackColor = Color.Black;

            FM1750Timer = false;

            chkFM1750.Checked = false;
            FM1750 = false;

            Audio.TXInputSignal = Audio.SignalSource.RADIO;
            Audio.SineFreq1 = (double)setupForm.udDSPCWPitch.Value;
            Audio.two_tone = false;


        } // Thd1750

        private void buttonVK1_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                if (WaveForm.IsDisposed)
                    WaveForm = new WaveControl(this);
                WaveForm.Show();
                WaveForm.Focus();
                WaveForm.WindowState = FormWindowState.Normal; // ke9ns add




            } // right click
        }

        private void buttonVK2_MouseDown(object sender, MouseEventArgs e)
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((me.Button == System.Windows.Forms.MouseButtons.Right))
            {

                if (WaveForm.IsDisposed)
                    WaveForm = new WaveControl(this);
                WaveForm.Show();
                WaveForm.Focus();
                WaveForm.WindowState = FormWindowState.Normal; // ke9ns add


            } // right click
        }

        public bool VK1CALL = false; // ke9ns add true = wave plays VK1.wav file

        private void buttonVK1_Click(object sender, EventArgs e)
        {
            string filePath = AppDataPath + "QuickAudio\\";

            if (WaveForm.chkQuickAudioFolder.Checked == false) WaveForm.chkQuickAudioFolder.Checked = true;

            if (WaveForm.chkQuickAudioFolder.Checked == true)  // ke9ns add
            {
                if (Directory.Exists(filePath)) // need to see the quickaudio folder
                {
                    if (File.Exists(filePath + "VK1.wav"))
                    {
                        if ((chkPower.Checked)) // ke9ns add allow tx on play directly so you dont need to mox and play
                        {
                            if (WaveForm.QuickPlay == false)
                            {
                                if (chkVAC1.Checked)
                                {
                                    vac1 = 1;
                                    chkVAC1.Checked = false;
                                }

                                VK1CALL = true;      // let wave: chkQuickPlay_CheckedChanged know you want to play CALL.WAV file only
                                checkBoxID.Checked = true;
                                ckQuickPlay.Checked = true;


                                buttonVK1.Image = global::PowerSDR.Properties.Resources.VK1Red;   //  buttonCall.BackColor = Color.Red;

                            }
                            else // turn off
                            {
                                //  buttonCall.BackColor = Color.Blue;

                                WaveForm.QuickPlay = false;
                                chkMOX.Checked = false;     // unkey radio
                                ckQuickPlay.BackColor = SystemColors.Control;//k6jca 1/13/08
                                VK1CALL = false;

                                if (vac1 == 1)
                                {
                                    vac1 = 0;
                                    Thread.Sleep(100);
                                    chkVAC1.Checked = true;
                                }
                                checkBoxID.Checked = false;
                            }

                        } // chkpower

                    } //  if (File.Exists(filePath + "\\CALL.wav"))
                    else
                    {
                        MessageBox.Show(new Form() { TopMost = true }, "Console: Could not Find file VK1.wav in QuickAudio folder");

                    }

                } // if (!Directory.Exists(filePath)) 
                else
                {
                    MessageBox.Show(new Form() { TopMost = true }, "Console: Could not find QuickAudio Folder");
                }

            } //  if (WaveForm.chkQuickAudioFolder.Checked == true) 


        } // buttonVK1

        public bool VK2CALL = false; // ke9ns add true = wave plays VK2.wav file

        private void buttonVK2_Click(object sender, EventArgs e)
        {

            string filePath = AppDataPath + "QuickAudio\\";

            if (WaveForm.chkQuickAudioFolder.Checked == false) WaveForm.chkQuickAudioFolder.Checked = true;

            if (WaveForm.chkQuickAudioFolder.Checked == true)  // ke9ns add
            {
                if (Directory.Exists(filePath)) // need to see the quickaudio folder
                {
                    if (File.Exists(filePath + "VK2.wav"))
                    {
                        if ((chkPower.Checked)) // ke9ns add: allow tx on play directly so you dont need to mox and play
                        {
                            if (WaveForm.QuickPlay == false)
                            {
                                if (chkVAC1.Checked)
                                {
                                    vac1 = 1;
                                    chkVAC1.Checked = false;
                                }

                                VK2CALL = true;      // let wave: chkQuickPlay_CheckedChanged know you want to play VK2.WAV file only
                                checkBoxID.Checked = true;
                                ckQuickPlay.Checked = true;


                                buttonVK2.Image = global::PowerSDR.Properties.Resources.VK2Red;   //  buttonCall.BackColor = Color.Red;

                            }
                            else // turn off
                            {
                                //  buttonCall.BackColor = Color.Blue;

                                WaveForm.QuickPlay = false;
                                chkMOX.Checked = false;     // unkey radio
                                ckQuickPlay.BackColor = SystemColors.Control;//k6jca 1/13/08
                                VK2CALL = false;

                                if (vac1 == 1)
                                {
                                    vac1 = 0;
                                    Thread.Sleep(100);
                                    chkVAC1.Checked = true;
                                }
                                checkBoxID.Checked = false;
                            }

                        } // chkpower

                    } //  if (File.Exists(filePath + "\\CALL.wav"))
                    else
                    {
                        MessageBox.Show(new Form() { TopMost = true }, "Console: Could not Find file VK2.wav in QuickAudio folder");

                    }

                } // if (!Directory.Exists(filePath)) 
                else
                {
                    MessageBox.Show(new Form() { TopMost = true }, "Console: Could not find QuickAudio Folder");
                }

            } //  if (WaveForm.chkQuickAudioFolder.Checked == true) 




        } // buttonvk2

        private void VFODialAA_Paint(object sender, PaintEventArgs e)
        {

            Graphics g1 = e.Graphics; // ke9ns .191 used to improve image quality
            g1.SmoothingMode = SmoothingMode.HighQuality;
            g1.InterpolationMode = InterpolationMode.HighQualityBicubic;
            g1.DrawImage(vfoA, new Rectangle(0, 0, 23, 29));  // rectangle to show bitmap image in

        }

        private void VFODialBB_Paint(object sender, PaintEventArgs e)
        {

            Graphics g1 = e.Graphics; // ke9ns .191 used to improve image quality
            g1.SmoothingMode = SmoothingMode.HighQuality;
            g1.InterpolationMode = InterpolationMode.HighQualityBicubic;
            g1.DrawImage(vfoB, new Rectangle(0, 0, 23, 29));  // rectangle to show bitmap image in

        }


        public bool ROTAFACTOR = false;
        private void VFODialAA_MouseEnter(object sender, EventArgs e)
        {
            ROTAFACTOR = true;
        }

        private void VFODialAA_MouseLeave(object sender, EventArgs e)
        {
            ROTAFACTOR = false;
        }

        // ke9ns add .196
        private void lblTuneStep_Click(object sender, EventArgs e)
        {
            if (snapTNew == false)
            {
                Debug.WriteLine("SNAP TRUE");
                snapTNew = true;

                this.lblTuneStep.ForeColor = System.Drawing.SystemColors.ControlDark;
            }
            else
            {
                Debug.WriteLine("SNAP FALSE");
                snapTNew = false;
                this.lblTuneStep.ForeColor = System.Drawing.SystemColors.ControlLightLight;
            }



        }
        /*
        GEN
        160m  1
        80m
        60m
        40m
        30m
        20m
        17m
        15m
        12m
        10m
        6m   11
        WWV  12
        VU 2m
        VU 70cm
        VHF2
        VHF3
        VHF4
        VHF5
        VHF6
        VHF7
        VHF8
        VHF9
        VHF10
        VHF11
        VHF12
        VHF13
        LMF  27
        120m
        90m
        61m
        49m
        41m
        31m
        25m
        22m
        19m
        16m
        14m
        13m
        11m  40
        */

        private void radBandGEN0RX2_Click(object sender, EventArgs e)
        {
            RX2BandButton = true;
            comboRX2Band.SelectedIndex = 27;

        }
        private void radBandGEN1RX2_Click(object sender, EventArgs e)
        {
            RX2BandButton = true;
            comboRX2Band.SelectedIndex = 28;

        }
        private void radBandGEN2RX2_Click(object sender, EventArgs e)
        {
            RX2BandButton = true;
            comboRX2Band.SelectedIndex = 29;

        }
        private void radBandGEN3RX2_Click(object sender, EventArgs e)
        {
            RX2BandButton = true;
            comboRX2Band.SelectedIndex = 30;

        }
        private void radBandGEN4RX2_Click(object sender, EventArgs e)
        {
            RX2BandButton = true;
            comboRX2Band.SelectedIndex = 31;

        }
        private void radBandGEN5RX2_Click(object sender, EventArgs e)
        {
            RX2BandButton = true;
            comboRX2Band.SelectedIndex = 32;

        }
        private void radBandGEN6RX2_Click(object sender, EventArgs e)
        {
            RX2BandButton = true;
            comboRX2Band.SelectedIndex = 33;
        }
        private void radBandGEN7RX2_Click(object sender, EventArgs e)
        {
            RX2BandButton = true;
            comboRX2Band.SelectedIndex = 34;

        }
        private void radBandGEN8RX2_Click(object sender, EventArgs e)
        {
            RX2BandButton = true;
            comboRX2Band.SelectedIndex = 35;

        }
        private void radBandGEN9RX2_Click(object sender, EventArgs e)
        {
            RX2BandButton = true;
            comboRX2Band.SelectedIndex = 36;

        }
        private void radBandGEN10RX2_Click(object sender, EventArgs e)
        {
            RX2BandButton = true;
            comboRX2Band.SelectedIndex = 37;

        }
        private void radBandGEN11RX2_Click(object sender, EventArgs e)
        {
            RX2BandButton = true;
            comboRX2Band.SelectedIndex = 38;

        }
        private void radBandGEN12RX2_Click(object sender, EventArgs e)
        {
            RX2BandButton = true;
            comboRX2Band.SelectedIndex = 39;

        }
        private void radBandGEN13RX2_Click(object sender, EventArgs e)
        {
            RX2BandButton = true;
            comboRX2Band.SelectedIndex = 40;

        }

        private void radBand2RX2_Click(object sender, EventArgs e)
        {
            RX2BandButton = true;
            comboRX2Band.SelectedIndex = 27; // there currently is no 630m band just LMF
        }

        private void radBand160RX2_Click(object sender, EventArgs e)
        {

            RX2BandButton = true;
            comboRX2Band.SelectedIndex = 1;

        }

        private void radBand80RX2_Click(object sender, EventArgs e)
        {
            RX2BandButton = true;
            comboRX2Band.SelectedIndex = 2;
        }
        private void radBand60RX2_Click(object sender, EventArgs e)
        {
            RX2BandButton = true;
            comboRX2Band.SelectedIndex = 3;
        }
        private void radBand40RX2_Click(object sender, EventArgs e)
        {
            RX2BandButton = true;
            comboRX2Band.SelectedIndex = 4;
        }
        private void radBand30RX2_Click(object sender, EventArgs e)
        {
            RX2BandButton = true;
            comboRX2Band.SelectedIndex = 5;
        }
        private void radBand20RX2_Click(object sender, EventArgs e)
        {
            RX2BandButton = true;
            comboRX2Band.SelectedIndex = 6;
        }
        private void radBand17RX2_Click(object sender, EventArgs e)
        {
            RX2BandButton = true;
            comboRX2Band.SelectedIndex = 7;
        }
        private void radBand15RX2_Click(object sender, EventArgs e)
        {
            RX2BandButton = true;
            comboRX2Band.SelectedIndex = 8;
        }
        private void radBand12RX2_Click(object sender, EventArgs e)
        {
            RX2BandButton = true;
            comboRX2Band.SelectedIndex = 9;
        }
        private void radBand10RX2_Click(object sender, EventArgs e)
        {
            RX2BandButton = true;
            comboRX2Band.SelectedIndex = 10;
        }
        private void radBand6RX2_Click(object sender, EventArgs e)
        {
            RX2BandButton = true;
            comboRX2Band.SelectedIndex = 11;
        }

        private void radBandWWVRX2_Click(object sender, EventArgs e)
        {
            RX2BandButton = true;
            comboRX2Band.SelectedIndex = 12;
        }

        private void radBandVHFRX2_Click(object sender, EventArgs e)
        {
            RX2BandButton = true;
            comboRX2Band.SelectedIndex = 13;
        }
        private void radBandVHF1RX2_Click(object sender, EventArgs e)
        {
            RX2BandButton = true;
            comboRX2Band.SelectedIndex = 14;
        }
        private void radBandVHF2RX2_Click(object sender, EventArgs e)
        {
            RX2BandButton = true;
            comboRX2Band.SelectedIndex = 15;
        }
        private void radBandVHF3RX2_Click(object sender, EventArgs e)
        {
            RX2BandButton = true;
            comboRX2Band.SelectedIndex = 16;
        }
        private void radBandVHF4RX2_Click(object sender, EventArgs e)
        {
            RX2BandButton = true;
            comboRX2Band.SelectedIndex = 17;
        }
        private void radBandVHF5RX2_Click(object sender, EventArgs e)
        {
            RX2BandButton = true;
            comboRX2Band.SelectedIndex = 18;
        }
        private void radBandVHF6RX2_Click(object sender, EventArgs e)
        {
            RX2BandButton = true;
            comboRX2Band.SelectedIndex = 19;
        }
        private void radBandVHF7RX2_Click(object sender, EventArgs e)
        {
            RX2BandButton = true;
            comboRX2Band.SelectedIndex = 20;
        }
        private void radBandVHF8RX2_Click(object sender, EventArgs e)
        {
            RX2BandButton = true;
            comboRX2Band.SelectedIndex = 21;
        }
        private void radBandVHF9RX2_Click(object sender, EventArgs e)
        {
            RX2BandButton = true;
            comboRX2Band.SelectedIndex = 22;
        }
        private void radBandVHF10RX2_Click(object sender, EventArgs e)
        {
            RX2BandButton = true;
            comboRX2Band.SelectedIndex = 23;
        }
        private void radBandVHF11RX2_Click(object sender, EventArgs e)
        {
            RX2BandButton = true;
            comboRX2Band.SelectedIndex = 24;
        }
        private void radBandVHF12RX2_Click(object sender, EventArgs e)
        {
            RX2BandButton = true;
            comboRX2Band.SelectedIndex = 25;
        }
        private void radBandVHF13RX2_Click(object sender, EventArgs e)
        {
            RX2BandButton = true;
            comboRX2Band.SelectedIndex = 26;
        }

        private void panelTSBandStack_MouseUp(object sender, MouseEventArgs e)
        {

        }

        private void buttonAdd_MouseUp(object sender, MouseEventArgs e)
        {

            MouseEventArgs me = (MouseEventArgs)e;

            if ((me.Button == System.Windows.Forms.MouseButtons.Left))
            {
                bool dupfound = false;

                StackForm.updateindex();

                if (band_stacks[StackForm.nnn] < 12) // allow 12 bandstack entries each band
                {

                    for (int ii = 0; ii < band_stacks[StackForm.nnn]; ii++)  // check for freq dups, so dont add if a dup in freq
                    {
                        if (StackForm.freq1[ii] == Math.Round(VFOAFreq, 6))
                        {
                            dupfound = true;

                            buttonAdd.BackColor = Color.Red;
                            break;
                        }

                    }
                    if (dupfound == false)
                    {
                        buttonAdd.BackColor = SystemColors.ButtonFace;

                        DB.AddBandStack(StackForm.band_list[StackForm.nnn], RX1DSPMode.ToString(), RX1Filter.ToString(), Math.Round(VFOAFreq, 6)); // take current band, DSP mode, filter, and freq

                        BandStackUpdate();
                        StackForm.bandstackupdate();

                        StackForm.xxx = band_stacks[StackForm.nnn] - 1; // go to end of list and highlight it

                        textBox1.SelectionStart = (StackForm.xxx * StackForm.BSLength);
                        textBox1.SelectionLength = StackForm.BSLength;
                        StackForm.updateindex();

                    }


                    dupfound = false;
                }

            } //  if (xxx < 12)
            else if ((me.Button == System.Windows.Forms.MouseButtons.Right) && (FWCEEPROM.RX2OK) && chkRX2.Checked)
            {
                bool dupfound = false;
                buttonAdd.BackColor = Color.LightGreen;

                Debug.WriteLine("RX2 RIGHT CLICK");

                StackForm.updateindex2();

                if (band_stacks[StackForm.nnn2] < 12) // allow 12 bandstack entries each band
                {

                    for (int ii = 0; ii < band_stacks[StackForm.nnn2]; ii++)  // check for freq dups, so dont add if a dup in freq
                    {
                        if (StackForm.freq12[ii] == Math.Round(VFOBFreq, 6))
                        {
                            dupfound = true;
                            buttonAdd.BackColor = Color.Red;
                            break;
                        }

                    }
                    if (dupfound == false)
                    {

                        DB.AddBandStack(StackForm.band_list[StackForm.nnn2], RX2DSPMode.ToString(), RX2Filter.ToString(), Math.Round(VFOBFreq, 6)); // take current band, DSP mode, filter, and freq

                        BandStackUpdate();
                        StackForm.bandstackupdate();


                        StackForm.xxx2 = band_stacks[StackForm.nnn2] - 1; // go to end of list and highlight it

                        textBox2.SelectionStart = (StackForm.xxx2 * StackForm.BSLength);
                        textBox2.SelectionLength = StackForm.BSLength;
                        StackForm.updateindex2();

                        buttonAdd.BackColor = SystemColors.ButtonFace;

                    }

                    dupfound = false;
                }

            } //  if (xxx < 12)

        } // buttonAdd_MouseUp  bandstack ADD button

        private void buttonSort_MouseUp(object sender, MouseEventArgs e)
        {

            MouseEventArgs me = (MouseEventArgs)e;

            if ((me.Button == System.Windows.Forms.MouseButtons.Left))
            {

                int index = band_stacks[StackForm.nnn];

                try
                {
                    if (index < 2) return; // nothing to sort


                    // bubble sort
                    for (int d = 0; d < index;)
                    {

                        for (int f = index - 1; f > d; f--)  // check end of list first and work back to front
                        {
                            if (StackForm.freq1[d] > StackForm.freq1[f])
                            {

                                string tempmode = StackForm.mode1[d];
                                string tempfilter = StackForm.filter1[d];
                                double tempfreq = StackForm.freq1[d];


                                StackForm.freq1[d] = StackForm.freq1[f];
                                StackForm.mode1[d] = StackForm.mode1[f];
                                StackForm.filter1[d] = StackForm.filter1[f];

                                StackForm.freq1[f] = tempfreq;
                                StackForm.mode1[f] = tempmode;
                                StackForm.filter1[f] = tempfilter;

                                StackForm.bubble = true;
                            }


                        } // for f

                        if (StackForm.bubble == false) d++;
                        else StackForm.bubble = false;  // reset

                    } // for d

                    for (int g = 0; g < index; g++)  // update database with new sorted bandstack
                    {

                        SortBandStack(g, StackForm.mode1[g], StackForm.filter1[g], StackForm.freq1[g]);     //   DB.SaveBandStack(console.last_band, g, mode1[g], filter1[g], freq1[g]);

                    }

                    BandStackUpdate();  // update the console with the new database sorted bandstack

                    StackForm.bandstackupdate();

                }
                catch (Exception)
                {
                    Debug.WriteLine("Bad location3");

                }
            }
            else if ((me.Button == System.Windows.Forms.MouseButtons.Right) && (FWCEEPROM.RX2OK))
            {

                int index = band_stacks[StackForm.nnn2];

                try
                {
                    if (index < 2) return; // nothing to sort


                    // bubble sort
                    for (int d = 0; d < index;)
                    {

                        for (int f = index - 1; f > d; f--)  // check end of list first and work back to front
                        {
                            if (StackForm.freq12[d] > StackForm.freq12[f])
                            {

                                string tempmode = StackForm.mode12[d];
                                string tempfilter = StackForm.filter12[d];
                                double tempfreq = StackForm.freq12[d];


                                StackForm.freq12[d] = StackForm.freq12[f];
                                StackForm.mode12[d] = StackForm.mode12[f];
                                StackForm.filter12[d] = StackForm.filter12[f];

                                StackForm.freq12[f] = tempfreq;
                                StackForm.mode12[f] = tempmode;
                                StackForm.filter12[f] = tempfilter;

                                StackForm.bubble = true;
                            }


                        } // for f

                        if (StackForm.bubble == false) d++;
                        else StackForm.bubble = false;  // reset

                    } // for d

                    for (int g = 0; g < index; g++)  // update database with new sorted bandstack
                    {

                        SortBandStack2(g, StackForm.mode12[g], StackForm.filter12[g], StackForm.freq12[g]);     //   DB.SaveBandStack(console.last_band, g, mode1[g], filter1[g], freq1[g]);

                    }

                    BandStackUpdate();  // update the console with the new database sorted bandstack

                    StackForm.bandstackupdate(); // both VFOA and B

                }
                catch (Exception)
                {
                    Debug.WriteLine("Bad location3");

                }
            }

        } // buttonsort_MouseUP

        private void buttonDel_MouseUp(object sender, MouseEventArgs e)
        {


            MouseEventArgs me = (MouseEventArgs)e;

            if ((me.Button == System.Windows.Forms.MouseButtons.Left))
            {
                //  StackForm.buttonDel.PerformClick();

                try
                {
                    if (band_stacks[StackForm.nnn] < 3) return;    // dont allow removing all the bandstacks

                    if (StackForm.xxx >= band_stacks[StackForm.nnn]) return;    // if you click past the last index freq, then do nothing.

                    iii = StackForm.xxx;                            // update new position in bandstack for checking if its locked

                    if (StackForm.filter1[StackForm.xxx].Contains("@") == false)      // can only delete an unlocked entry in the bandstack
                    {
                        DialogResult dr = MessageBox.Show(new Form { TopMost = true }, "Are you sure you want to Delete the selected BandStack Entry?",
                                "Delete?",
                                MessageBoxButtons.YesNo,
                                MessageBoxIcon.Question);

                        if (dr == DialogResult.No) return;


                        PurgeBandStack(StackForm.xxx, StackForm.mode1[StackForm.xxx], StackForm.filter1[StackForm.xxx], StackForm.freq1[StackForm.xxx].ToString());

                        BandStackUpdate();
                        StackForm.bandstackupdate();
                        StackForm.updateindex();
                    }
                }
                catch (Exception)
                {
                    Debug.WriteLine("Bad location2");

                }
            }
            else if ((me.Button == System.Windows.Forms.MouseButtons.Right) && (FWCEEPROM.RX2OK))
            {

                try
                {
                    if (band_stacks[StackForm.nnn2] < 3) return;    // dont allow removing all the bandstacks

                    if (StackForm.xxx2 >= band_stacks[StackForm.nnn2]) return;    // if you click past the last index freq, then do nothing.

                    iii = StackForm.xxx2;                            // update new position in bandstack for checking if its locked

                    if (StackForm.filter12[StackForm.xxx].Contains("@") == false)      // can only delete an unlocked entry in the bandstack
                    {
                        DialogResult dr = MessageBox.Show(new Form { TopMost = true }, "Are you sure you want to Delete the selected BandStack Entry?",
                                "Delete?",
                                MessageBoxButtons.YesNo,
                                MessageBoxIcon.Question);

                        if (dr == DialogResult.No) return;


                        PurgeBandStack2(StackForm.xxx2, StackForm.mode12[StackForm.xxx2], StackForm.filter12[StackForm.xxx2], StackForm.freq12[StackForm.xxx2].ToString());

                        BandStackUpdate();
                        StackForm.bandstackupdate();
                        StackForm.updateindex2();
                    }
                }
                catch (Exception)
                {
                    Debug.WriteLine("Bad location22");

                }
            }

        } // buttondel_mouseup

        private void lblAntTX_Click_1(object sender, EventArgs e)
        {
            chkVFOATX.Checked = true; //.213

            //  chkVFOATX_CheckedChanged(this, EventArgs.Empty);

        }

        private void lblAntTX2_Click(object sender, EventArgs e)
        {
            chkVFOBTX.Checked = true; //.213

            //  chkVFOBTX_CheckedChanged(this, EventArgs.Empty);
        }

        private void ptbDisplayZoom2_MouseDown(object sender, MouseEventArgs e) //.219
        {

        } // ptbDisplayZoom2_MouseDown

        private void ptbDisplayZoom2_MouseUp(object sender, MouseEventArgs e)
        {

        }


        // ke9ns: .236 right click now cycles through 2khz, 5khz and wide FM dev modes
        private void radRX2ModeFMN_MouseUp(object sender, MouseEventArgs e) //.236
        {
            MouseEventArgs me = (MouseEventArgs)e;
            if ((me.Button == System.Windows.Forms.MouseButtons.Left)) // set to whatever the PANELFM FM deviation buttons are set to
            {

                if (radFMDeviation2kHz.Checked)
                {
                    lastdeviation = 2500;
                    FMSEQ = 0;
                    FMDeviation_Hz = 2500;
                    radRX2ModeFMN.Text = "2FM";
                    radModeFMN.Text = "2FM";
                    dsp.GetDSPTX(0).TXFMDataMode = false;
                    FMData = false;
                }
                else if (radFMDeviation5kHz.Checked)
                {
                    lastdeviation = 5000;
                    FMSEQ = 1;
                    FMDeviation_Hz = 5000;
                    radRX2ModeFMN.Text = "5FM";
                    radModeFMN.Text = "5FM";
                    dsp.GetDSPTX(0).TXFMDataMode = false;
                    FMData = false;
                }
                else
                {
                    lastdeviation = FMDataDeviation;
                    FMSEQ = 2;
                    radRX2ModeFMN.Text = "WFM";
                    radModeFMN.Text = "WFM";
                    FMDeviation_Hz = FMDataDeviation;
                    FMData = true;
                    FMDeviation10khz(); //.236
                    dsp.GetDSPTX(0).TXFMDataMode = true;
                }

                dsp.GetDSPTX(0).TXFMDeviation = lastdeviation;

            }
            else if ((me.Button == System.Windows.Forms.MouseButtons.Right))
            {
                if (FMSEQ == 0) // switch to 5khz dev
                {
                    radFMDeviation2kHz.Checked = false;
                    radFMDeviation5kHz.Checked = true;

                    lastdeviation = 5000;
                    FMSEQ = 1;
                    FMDeviation_Hz = 5000;
                    radRX2ModeFMN.Text = "5FM";
                    radModeFMN.Text = "5FM";
                    dsp.GetDSPTX(0).TXFMDataMode = false;
                    FMData = false;

                }
                else if (FMSEQ == 1) // switch to WFM
                {
                    radFMDeviation2kHz.Checked = false;
                    radFMDeviation5kHz.Checked = false;

                    lastdeviation = FMDataDeviation;
                    FMSEQ = 2;
                    radRX2ModeFMN.Text = "WFM";
                    radModeFMN.Text = "WFM";
                    FMDeviation_Hz = FMDataDeviation;
                    FMData = true;
                    FMDeviation10khz(); //.236
                    dsp.GetDSPTX(0).TXFMDataMode = true;


                }
                else // switch back to 2khz dev
                {
                    radFMDeviation2kHz.Checked = true;
                    radFMDeviation5kHz.Checked = false;

                    lastdeviation = 2500;

                    FMDeviation_Hz = 2500;
                    radRX2ModeFMN.Text = "2FM";
                    radModeFMN.Text = "2FM";
                    dsp.GetDSPTX(0).TXFMDataMode = false;
                    FMData = false;
                    FMSEQ = 0;
                }
            } // right click 


        } // radRX2ModeFMN_MouseUp

        private void radModeFMN_MouseDown(object sender, MouseEventArgs e) //.236
        {
            MouseEventArgs me = (MouseEventArgs)e;
            if ((me.Button == System.Windows.Forms.MouseButtons.Left)) // set to whatever the PANELFM FM deviation buttons are set to
            {

                if (radFMDeviation2kHz.Checked)
                {
                    lastdeviation = 2500;
                    FMSEQ = 0;
                    FMDeviation_Hz = 2500;
                    radRX2ModeFMN.Text = "2FM";
                    radModeFMN.Text = "2FM";
                    dsp.GetDSPTX(0).TXFMDataMode = false;
                    FMData = false;
                }
                else if (radFMDeviation5kHz.Checked)
                {
                    lastdeviation = 5000;
                    FMSEQ = 1;
                    FMDeviation_Hz = 5000;
                    radRX2ModeFMN.Text = "5FM";
                    radModeFMN.Text = "5FM";
                    dsp.GetDSPTX(0).TXFMDataMode = false;
                    FMData = false;
                }
                else
                {
                    lastdeviation = FMDataDeviation;
                    FMSEQ = 2;
                    radRX2ModeFMN.Text = "WFM";
                    radModeFMN.Text = "WFM";
                    FMDeviation_Hz = FMDataDeviation;
                    FMData = true;
                    FMDeviation10khz(); //.236
                    dsp.GetDSPTX(0).TXFMDataMode = true;
                }

                dsp.GetDSPTX(0).TXFMDeviation = lastdeviation;

            }
            else if ((me.Button == System.Windows.Forms.MouseButtons.Right))
            {
                if (FMSEQ == 0) // switch to 5khz dev
                {
                    radFMDeviation2kHz.Checked = false;
                    radFMDeviation5kHz.Checked = true;

                    lastdeviation = 5000;
                    FMSEQ = 1;
                    FMDeviation_Hz = 5000;
                    radRX2ModeFMN.Text = "5FM";
                    radModeFMN.Text = "5FM";
                    dsp.GetDSPTX(0).TXFMDataMode = false;
                    FMData = false;

                }
                else if (FMSEQ == 1) // switch to WFM
                {
                    radFMDeviation2kHz.Checked = false;
                    radFMDeviation5kHz.Checked = false;

                    lastdeviation = FMDataDeviation;
                    FMSEQ = 2;
                    radRX2ModeFMN.Text = "WFM";
                    radModeFMN.Text = "WFM";
                    FMDeviation_Hz = FMDataDeviation;
                    FMData = true;
                    FMDeviation10khz(); //.236
                    dsp.GetDSPTX(0).TXFMDataMode = true;


                }
                else // switch back to 2khz dev
                {
                    radFMDeviation2kHz.Checked = true;
                    radFMDeviation5kHz.Checked = false;

                    lastdeviation = 2500;

                    FMDeviation_Hz = 2500;
                    radRX2ModeFMN.Text = "2FM";
                    radModeFMN.Text = "2FM";
                    dsp.GetDSPTX(0).TXFMDataMode = false;
                    FMData = false;
                    FMSEQ = 0;
                }
            } // right click 
        }

        private void eSCToolStripMenuItem_MouseUp(object sender, MouseEventArgs e) //.246
        {
            MouseEventArgs me = (MouseEventArgs)e;

            if ((me.Button == System.Windows.Forms.MouseButtons.Right))
            {
                if (current_model == Model.FLEX5000 && FWCEEPROM.RX2OK)  // original
                {
                    btnReset_Click(this, EventArgs.Empty);

                    panelTSRadar.Enabled = true;
                    panelTSRadar.Visible = true;
                }

            }


        } //  eSCToolStripMenuItem_MouseUp




        private Point p2 = new Point(100, 100);
        private double r = 0.0;
        private double angle1 = 0.0;
        private bool mouse_down = false;
        private double locked_r = 0.0f;
        private double locked_angle = 0.0f;
        private Color imageColorTop, imageColorBottom, consoleColorBottom;
        private bool ESCSYNC = false; // .249 true=RX1 and RX2 synced up for ESC (red button face), false=not synced up (black button face)

        private void picRadar_Paint(object sender, PaintEventArgs e) //.246
        {
            Graphics g = e.Graphics;
            int size = Math.Min(picRadar.Width, picRadar.Height);

            string buttonOffPath = Environment.GetFolderPath(Environment.SpecialFolder.CommonApplicationData) +
              "\\FlexRadio Systems\\PowerSDR\\Skins\\" + CurrentSkin + "\\Console\\chkMON-0.png";

            string buttonOnPath = Environment.GetFolderPath(Environment.SpecialFolder.CommonApplicationData) +
                "\\FlexRadio Systems\\PowerSDR\\Skins\\" + CurrentSkin + "\\Console\\chkMON-1.png";

            Bitmap buttonOffImage = new Bitmap(buttonOffPath);
            Bitmap buttonOnImage = new Bitmap(buttonOnPath);


            if (RadarColorUpdate)
            {
                string panadapterBackgroundPath = Environment.GetFolderPath(Environment.SpecialFolder.CommonApplicationData) +
                "\\FlexRadio Systems\\PowerSDR\\Skins\\" + CurrentSkin + "\\Console\\picDisplay.png";

                string consoleBackgroundPath = Environment.GetFolderPath(Environment.SpecialFolder.CommonApplicationData) +
                "\\FlexRadio Systems\\PowerSDR\\Skins\\" + CurrentSkin + "\\Console\\Console.png";


                //   btnEnable.BackgroundImage = buttonOffImage;
                //   btnSync.BackgroundImage = buttonOffImage;

                //    btnReset.BackgroundImage = buttonOffImage;  //w4tme

                //    btnSync.FlatAppearance.BorderColor = imageColorBottom;

                //  btnReset.FlatAppearance.BorderColor = imageColorBottom; //w4tme

                Bitmap panadapterBackground = new Bitmap(panadapterBackgroundPath);
                imageColorTop = panadapterBackground.GetPixel((int)(panadapterBackground.Width - 5), (int)(panadapterBackground.Height - 5));
                imageColorBottom = panadapterBackground.GetPixel((int)(panadapterBackground.Width / 9), (int)(panadapterBackground.Height / 9));


                Bitmap consoleBackground = new Bitmap(consoleBackgroundPath);
                consoleColorBottom = consoleBackground.GetPixel((int)(consoleBackground.Width - 5), (int)(consoleBackground.Height - 5));
                picRadar.BackgroundImage = consoleBackground;
                //this.BackgroundImage = consoleBackground;
                this.BackColor = consoleColorBottom;

                RadarColorUpdate = false;


            } // RadarColorUpdate


            //  Pen pen = new Pen(Color.FromArgb(0, 255, 0)); // green
            Pen pen = new Pen(Color.CadetBlue);

            g.CompositingQuality = CompositingQuality.HighQuality;
            g.InterpolationMode = InterpolationMode.Bicubic;
            g.SmoothingMode = SmoothingMode.AntiAlias;
            g.TextRenderingHint = TextRenderingHint.AntiAlias;

            // draw the background of the radar
            g.FillEllipse(new LinearGradientBrush(new Point((int)(size / 2), 0), new Point((int)(size / 2), size - 1), imageColorTop, imageColorBottom), 0, 0, size - 1, size - 1);


            g.DrawEllipse(pen, 0, 0, size - 1, size - 1);
            // draw the inner ring (60° elevation)
            int interval = size / 3;
            g.DrawEllipse(pen, (size - interval) / 2, (size - interval) / 2, interval, interval);
            // draw the middle ring (30° elevation)
            interval *= 2;
            g.DrawEllipse(pen, (size - interval) / 2, (size - interval) / 2, interval, interval);
            // draw the x and y axis lines
            g.DrawLine(pen, new Point(0, (int)(size / 2)), new Point(size - 1, (int)(size / 2)));
            g.DrawLine(pen, new Point((int)(size / 2), 0), new Point((int)(size / 2), size - 1));


            g.DrawString("0°", ff1, new SolidBrush(Color.LightGray), (int)(size) - 17, (int)(size / 2) - 10); //.247     
            g.DrawString("90°", ff1, new SolidBrush(Color.LightGray), (int)(size / 2) - 10, 3);
            g.DrawString("180°", ff1, new SolidBrush(Color.LightGray), -1, (int)(size / 2) - 10);
            g.DrawString("-90°", ff1, new SolidBrush(Color.LightGray), (int)(size / 2) - 15, (int)(size) - 12);

            g.DrawString("Mag", ff1, new SolidBrush(Color.LightGray), 0, picRadar.Height - 35);

            g.DrawString("Φ rad", ff1, new SolidBrush(Color.LightGray), (int)(size) - 40, picRadar.Height - 35);

            Pen crosshairPen = new Pen(Color.Red, 2);

            g.DrawLine(crosshairPen, p2.X, p2.Y - 16, p2.X, p2.Y - 2);

            g.DrawLine(crosshairPen, p2.X, p2.Y + 16, p2.X, p2.Y + 2);
            g.DrawLine(crosshairPen, p2.X - 2, p2.Y, p2.X - 13, p2.Y);
            g.DrawLine(crosshairPen, p2.X + 2, p2.Y, p2.X + 13, p2.Y);

            g.DrawEllipse(crosshairPen, p2.X - 8, p2.Y - 8, 16, 16);



            if (RX2SpurReduction == false && SpurReduction == false && (VFOAFreq == VFOBFreq) && (RX2DSPMode == RX1DSPMODE) && (RX2FilterHigh == RX1FilterHigh) && (RX2FilterLow == RX1FilterLow) && (RX2PreampMode == RX1PreampMode) && (RX2RF == RF)) //.246
            {

                //  if (VFOSync == false) dsp.GetDSPRX(1, 0).Copy(dsp.GetDSPRX(0, 0));
                //  VFOSync = true;

                btnSync.BackgroundImage = buttonOnImage;
                ESCSYNC = true; // .249
            }
            else
            {
                btnSync.BackgroundImage = buttonOffImage;
                ESCSYNC = false; // .249
            }
            btnBump180.BackgroundImage = buttonOffImage;

        } // picRadar_Paint

        private void btnSync_Click(object sender, EventArgs e) //.246
        {
            VFOSync = true;
            RX2SpurReduction = SpurReduction;
            RX2DSPMode = RX1DSPMode;
            RX2Filter = RX1Filter;
            RX2FilterLow = RX1FilterLow; //.246
            RX2FilterHigh = RX1FilterHigh; //.246

            RX2PreampMode = RX1PreampMode;
            RX2RF = RF;                 //W4TME

            if (RX1AGCMode != AGCMode.CUSTOM && RX1AGCMode != AGCMode.FIXD) RX2AGCMode = RX1AGCMode;    // no custom AGC mode for RX2 causes UHE

            dsp.GetDSPRX(1, 0).Copy(dsp.GetDSPRX(0, 0));

            string buttonOnPath = Environment.GetFolderPath(Environment.SpecialFolder.CommonApplicationData) +
              "\\FlexRadio Systems\\PowerSDR\\Skins\\" + CurrentSkin + "\\Console\\chkMON-1.png";

            Bitmap buttonOnImage = new Bitmap(buttonOnPath);

            Thread.Sleep(100);

            btnSync.BackgroundImage = buttonOnImage;
            ESCSYNC = true; // .249

            picRadar.Invalidate();

        } // btnSync_Click


        public void btnReset_Click(object sender, EventArgs e) //.246
        {
            angle1 = 0.0;
            r = 0.0;
            udR.Value = 0;
            udAngle.Value = 0;
            UpdateDiversity();
            picRadar.Invalidate();
        }

        private void chkBoxRadar_CheckedChanged(object sender, EventArgs e) //.246
        {
            if (checkBoxRadar.Checked)
            {
                if (!RX2Enabled) RX2Enabled = true;
                chkRX2.Checked = true;

            }
            DttSP.SetDiversity(Convert.ToInt16(checkBoxRadar.Checked));

            Thread.Sleep(240);
            chkRX2.Checked = false;
        }

        private void btnEnable_Click(object sender, EventArgs e) //.246
        {

            string buttonOffPath = Environment.GetFolderPath(Environment.SpecialFolder.CommonApplicationData) +
               "\\FlexRadio Systems\\PowerSDR\\Skins\\" + CurrentSkin + "\\Console\\chkMON-0.png";

            string buttonOnPath = Environment.GetFolderPath(Environment.SpecialFolder.CommonApplicationData) +
                "\\FlexRadio Systems\\PowerSDR\\Skins\\" + CurrentSkin + "\\Console\\chkMON-1.png";

            Bitmap buttonOffImage = new Bitmap(buttonOffPath);
            Bitmap buttonOnImage = new Bitmap(buttonOnPath);


            if (checkBoxRadar.Checked == false)
            {
                btnSync_Click(this, EventArgs.Empty);

                checkBoxRadar.Checked = true;

                btnEnable.BackgroundImage = buttonOnImage;
                UpdateDiversity();
                picRadar.Invalidate();
            }
            else
            {
                checkBoxRadar.Checked = false;
                btnEnable.BackgroundImage = buttonOffImage;
                btnSync.BackgroundImage = buttonOffImage;
                ESCSYNC = false; // .249
            }



        } // btnEnable_Click


        private void picRadar_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
        {
            if (!mouse_down) return;

            int W = picRadar.Width;
            int H = picRadar.Height;
            int L = (int)Math.Min(W, H);

            // get coords relative to middle
            int x = e.X - L / 2;
            int y = e.Y - L / 2;

            // change coordinate space form pixels to percentage of half width
            double xf = (double)x / (L / 2);
            double yf = -(double)y / (L / 2);

            double _r = Math.Min(Math.Sqrt(Math.Pow(xf, 2.0) + Math.Pow(yf, 2.0)), 2.0);
            double _angle = Math.Atan2(yf, xf);


            if (mouse_down)
            {
                if (chkLockR.Checked && chkLockAngle.Checked) return;

                if (chkLockR.Checked)
                {
                    p2 = PolarToXY(locked_r, _angle);
                    angle1 = _angle;
                }
                else if (chkLockAngle.Checked)
                {
                    if (_angle > 0 && locked_angle < 0)
                        locked_angle += Math.PI;
                    else if (_angle < 0 && locked_angle > 0)
                        locked_angle -= Math.PI;

                    p2 = PolarToXY(_r, locked_angle);
                    locked_r = _r;
                    r = _r;
                    angle1 = locked_angle;
                }
                else
                {

                    p2 = new Point(e.X, e.Y);
                    locked_r = _r;
                    //Debug.WriteLine("locked_r: " + r.ToString("f4"));
                    locked_angle = _angle;
                    r = _r;
                    angle1 = _angle;

                }
                udR.Value = (decimal)r;
                udAngle.Value = (decimal)angle1;

                UpdateDiversity();

                picRadar.Invalidate();
            }
        } // mousemove
        private Point PolarToXY(double r, double angle)
        {
            int L = (int)Math.Min(picRadar.Width, picRadar.Height);
            return new Point((int)(r * Math.Cos(angle) * L / 2) + L / 2, (int)(r * Math.Sin(angle) * L / 2) + L / 2);
        }

        private void picRadar_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
        {
            mouse_down = true;
            picRadar_MouseMove(sender, e);
        }
        private void udR_ValueChanged(object sender, System.EventArgs e) //.246
        {
            r = (double)udR.Value;

            UpdateDiversity();
        }

        private void udTheta_ValueChanged(object sender, System.EventArgs e) //.246
        {
            angle1 = (double)udAngle.Value;

            UpdateDiversity();
        }

        private void UpdateDiversity() //.246  update.c =  DiversityControl = sdr.c = winmain.c = diversity.scaler  	A = Cscl(Cadd(A,Cmul(B,diversity.scalar)),diversity.gain); // ke9ns: new A = scale signal with diversity.gain = A + (B * diversity.scaler)
        {
            DttSP.SetDiversityScalar((float)((r * 1.5) * Math.Cos(angle1)), (float)((r * 1.5) * Math.Sin(angle1)));

            int L = (int)Math.Min(picRadar.Width, picRadar.Height);


            p2 = new Point((int)(r * L / 2 * Math.Cos(angle1)) + L / 2, -(int)(r * L / 2 * Math.Sin(angle1)) + L / 2);


            picRadar.Invalidate();
        }

        private void picRadar_MouseUp(object sender, MouseEventArgs e) //.246
        {
            mouse_down = false;
        }

        private void panelRX2Mode_MouseClick(object sender, MouseEventArgs e)
        {
            if (FWCEEPROM.RX2OK) picRadar.Invalidate(); //.246
        }

        private void panelRX2Filter_MouseDown(object sender, MouseEventArgs e)
        {
            if (FWCEEPROM.RX2OK) picRadar.Invalidate(); //.246
        }

        private void panelFilter_MouseDown(object sender, MouseEventArgs e)
        {
            if (FWCEEPROM.RX2OK) picRadar.Invalidate(); //.246
        }

        private void chkVFOSync_MouseDown(object sender, MouseEventArgs e)
        {
            if (FWCEEPROM.RX2OK) picRadar.Invalidate(); //.246
        }

        private void panelMode_MouseDown(object sender, MouseEventArgs e)
        {
            if (FWCEEPROM.RX2OK) picRadar.Invalidate(); //.246
        }

        private void comboRX2Band_MouseDown(object sender, MouseEventArgs e)
        {
            if (FWCEEPROM.RX2OK) picRadar.Invalidate(); //.246
        }

        private void btnBump180_Click(object sender, EventArgs e)
        {
            double _angle = angle1;
            _angle += Math.PI;
            if (_angle > 2 * Math.PI) _angle -= 2 * Math.PI;
            angle1 = _angle;
            UpdateDiversity();
            picRadar.Invalidate();
        }

        private void chkLockR_CheckedChanged(object sender, EventArgs e)
        {
            if (chkLockR.Checked)
            {
                udR.Enabled = false;
                locked_r = r;
            }
            else
            {
                udR.Enabled = true;
            }
        }

        private void chkLockAngle_CheckedChanged(object sender, EventArgs e)
        {
            if (chkLockAngle.Checked)
            {
                udAngle.Enabled = false;
                locked_angle = angle1;
            }
            else
            {
                udAngle.Enabled = true;
            }
        }

        public void CONT_Logger_Write()
        {
            // ke9ns store Continuum PLOTS
            string file_nameCONT = AppDataPath + "Continuum" + WaveForm.QAName() + ".csv"; // save data for my mods

            //    Debug.WriteLine("CONTINUUM FILE OPEN TO WRITE: " + CONT_Last + " , " + file_nameCONT);

            FileStream stream3 = new FileStream(file_nameCONT, FileMode.Create); // open   file
                                                                                 //  FileStream stream3 = new FileStream(file_nameCONT, FileMode.Append); // open   file

            BinaryWriter writer3 = new BinaryWriter(stream3);

            int i3 = 0; // 

            writer3.Write("Index , Ant Heading , Local Time, UTC, MJD , dBm peak value in the Panadapter , dBm S-Meter (bandpass)" + Environment.NewLine);

            for (i3 = 0; i3 < CONT_Last; i3++) // 
            {
                writer3.Write(CONT_dbm[i3] + Environment.NewLine);

            } // for loop SLOTS

            writer3.Close();    // close  file
            stream3.Close();   // close stream

            Debug.WriteLine("CONTINUUM FILE CLOSED ");

        } // CONT_Logger_Write()




        //===============================================================================
        // ke9ns add (these 2 functions are called from the scanner routine)
        public void SWR_Logger_Write()
        {
            // ANT
            // RX1: VHF

            /* 
            //=======================================================================
            // Antenna:
               NC = 0,
               ANT1,
               ANT2,
               ANT3,
               RX1IN,
               RX2IN,
               RX1TAP,
               SIG_GEN,
               VHF,
               UHF,  // 9   


                //=======================================================================
                // Bands:

            
               GEN, // 0
               B160M, // 1
               B80M,
               B60M,
               B40M,
               B30M,
               B20M,
               B17M,
               B15M,
               B12M,
               B10M,
               B6M,
               B2M,
               WWV, // 13

               VHF0,
               VHF1,
               VHF2,
               VHF3,
               VHF4,
               VHF5,
               VHF6,
               VHF7,
               VHF8,
               VHF9,
               VHF10,
               VHF11,
               VHF12,
               VHF13, // 27

               BLMF, // 28 ke9ns move down below vhf
               B120M,
               B90M,
               B61M,
               B49M,
               B41M,
               B31M,
               B25M,
               B22M,
               B19M,
               B16M,
               B14M,
               B13M,
               B11M, // 41

              

       */

            // ke9ns store SWR PLOTS
            string file_nameSWR = AppDataPath + "ke9ns_SWR1.dat"; // save data for my mods
                                                                  //  string file_nameSWRcsv = AppDataPath + "ke9ns_SWR2.csv"; // save data for my mods .166


            Debug.WriteLine("KE9NS_SWR FILE OPEN TO WRITE ");

            FileStream stream3 = new FileStream(file_nameSWR, FileMode.Create); // open   file
            BinaryWriter writer3 = new BinaryWriter(stream3);



            int i0 = 0; // 1-5 Test #
            int i1 = 0; // 1-9 Ant #
            int i2 = 0; // 1-41 Band# 
            int i3 = 0; // 1-3000 SWR data Slot


            for (i0 = 1; i0 < 6; i0++) // 5 tests for the Flex-5000 (ANT1 = 1)
            {


                for (i1 = 1; i1 < 10; i1++) // 9 different ant sources for the Flex-5000 (ANT1 = 1)
                {

                    for (i2 = 1; i2 < 42; i2++) // 41 different bands(160m = 1)
                    {


                        for (i3 = 0; i3 < 3000; i3++) // 3000 Slots max per band (1khz = 1 slot)
                        {
                            double temp2 = SWR_READ[i0, i1, i2, i3];


                            if (temp2 == 0)
                            {
                                temp2 = 999.0;
                                writer3.Write(temp2);

                                break;
                            }
                            else
                            {
                                writer3.Write(temp2);

                            }




                        } //3  for loop freq SLOTS

                    } // 2 for loop BANDS
                } //1  for loop ANT
            } // 0for loop TEST#

            writer3.Close();    // close  file
            stream3.Close();   // close stream


            Debug.WriteLine("KE9NS_SWR FILE CLOSED ");

        } // SWR_Logger_Write()


        //========================================================================================================

        public void SWR_Logger_Read()
        {
            Debug.WriteLine("READ SWR database file Start");

            string file_nameSWR = AppDataPath + "ke9ns_SWR1.dat"; // save data for my mods

            FileStream stream3 = new FileStream(file_nameSWR, FileMode.Open); // open ke9ns file
            BinaryReader reader3 = new BinaryReader(stream3);

            int i0 = 0; // 1-5 Test #
            int i1 = 0; // 1-9 Ant #
            int i2 = 0; // 1-41 Band# 
            int i3 = 0; // 1-3000 SWR data Slot

            try
            {
                for (i0 = 1; i0 < 6; i0++) // 5 different TEST runs 
                {
                    for (i1 = 1; i1 < 10; i1++) // 9 different ant sources for the Flex-5000 (ANT1 = 1)
                    {
                        for (i2 = 1; i2 < 42; i2++) // 41 different bands(160m = 1)
                        {
                            for (i3 = 0; i3 < 3000; i3++) // 1000 Slots max per band (1khz = 1 slot)
                            {
                                double temp2 = reader3.ReadDouble();

                                //  Debug.WriteLine("RR> "+ i0 + "," +i1 + "," + i2 + "," + i3 + ", " + temp2);

                                if (temp2 == 999.0) break;
                                SWR_READ[i0, i1, i2, i3] = temp2;



                            } // for loop SLOTS
                        } // for loop BANDS
                    } // for loop ANT
                } // for loop TEST#

                reader3.Close();    // close  file
                stream3.Close();   // close stream

            }
            catch (Exception)
            {
                reader3.Close();    // close  file
                stream3.Close();   // close stream

                MessageBox.Show(new Form { TopMost = true }, "Your SWR Plot file has become corrupted. Will create a new file. ", "SWR Plot FIle",
                                  MessageBoxButtons.OK, MessageBoxIcon.Warning);

                SWR_Logger_Write();
            }



            Debug.WriteLine("READ SWR database file DONE");


        } // SWR_Logger_Read()


        //=====================================
        // ke9ns add (to allow slider in setup to adjust dx map brightness control)
        public int MB2 = 0;
        public int MAPBRIGHT
        {
            get { return MB2; }

            set
            {
                MB2 = value;
            }

        } // MAPBRIGHT

        //=====================================
        // ke9ns add (to allow slider in setup to adjust dx map grayline brightness control) .160
        public int MB3 = 0;
        public int MAPBRIGHT1
        {
            get { return MB2; }

            set
            {
                MB3 = value;
            }

        } // MAPBRIGHT

        //========================================================================================
        // ke9ns add  auto update waterfall level and pandapter level
        public bool autoadjust = false;
        public void AutoWaterPan()
        {

            //  if (setupForm == null || setupForm.IsDisposed)  setupForm = new Setup(this);

            if (setupForm != null)
            {
                if ((setupForm.chkBoxAutoWtrPan.Checked == true)) // && (chkPower.Checked == true))
                {
                    //   Debug.WriteLine("AUTO ADJUST WATERFALL LEVEL");

                    autoadjust = true;
                    Thread t9 = new Thread(new ThreadStart(AutoAdjuster)); // ke9ns start TIME-OUT TIMER HERE
                    t9.Name = "Adjust water and pan levels Thread";
                    t9.IsBackground = true;
                    t9.Priority = ThreadPriority.BelowNormal;
                    t9.Start();
                }
                else
                {
                    autoadjust = false;
                }
            }



        } //AutoWaterPan()

        //=====================================================================
        // kes9n add: thread to force a automatic waterfall and panadapter level adjustment if the noise floor level chnages (check every 2 seconds or band or ant change) RX mode only

        public bool autoadjust1 = false; // true = band change, ant change
        Stopwatch AA = new Stopwatch();

        public void AutoAdjuster()
        {

            AA.Restart(); // timer restart

            do
            {
                if (MOX)
                {
                    AA.Restart(); // dont mess with the 
                }
                else
                {
                    if ((AA.ElapsedMilliseconds > 1000) || ((autoadjust1 == true) && (AA.ElapsedMilliseconds > 500))) // either check for update every 2 seconds or 1/2 sec after a band or ant change.
                    {
                        autoadjust1 = false; // reset flag
                        AGCTUPDATE = true;

                        AA.Restart();
                        if (Display.continuum == 0) // make sure continuum mode is off for this
                        {
                            if (!MOX)  // make sure you not transmitting when you adjust
                            {
                                //   Debug.WriteLine("AUTO WATER/PAN UPDATE NOW");

                                Display.AutoBright = 1; // 1=water, 2 = pan
                                Thread.Sleep(200);
                                Display.AutoBright = 2;
                            }

                        } // if (Display.continuum == 0)
                    }

                }
                Thread.Sleep(100);

            } while (autoadjust == true);

            AA.Stop();


        } // AutoAdjuster() thread

        //==========================================================================================
        // ke9ns add: come here from from SETUP.cs (Update BandText)
        public void Refresh_Tables()
        {

            if (db_exists) // modify bandtext and bandstack for non-US regions
            {
                Debug.WriteLine("Refesh Tables0 ");

                DB.BandTextRefresh = true; // let database know that this is an update not the initial

                DB.BandStackRefresh = setupForm.chkBoxBandStack.Checked; // let database know that its OK to reset and update band stack

                Debug.WriteLine("Refesh Tables " + current_region);

                DB.RefreshTables(current_region); // allow setup.cs to issue an update to the database when bandtext changes

                if (setupForm.chkBoxBandStack.Checked == true)
                {
                    MessageBox.Show(new Form { TopMost = true }, "Band Text and Stack Update to your Database file ", "Band Text and Stack Update",
                               MessageBoxButtons.OK, MessageBoxIcon.Warning);
                }
                else
                {
                    MessageBox.Show(new Form { TopMost = true }, "Band Text Update to your Database file ", "Band Text Update",
                                MessageBoxButtons.OK, MessageBoxIcon.Warning);
                }


            } //  if (db_exists)

            DB.BandStackRefresh = true; // reset back to defaults
            DB.BandTextRefresh = false;

        } //  public void Refresh_Tables()



    } // class console




} // powerSDR